import {
  Bg,
  Bm,
  C,
  De,
  Gm,
  La,
  Nc,
  Oc,
  Rc,
  Vt,
  Yc,
  fo,
  has_default,
  hp,
  ig,
  kg,
  require_dayjs_min,
  tf,
  zm
} from "./chunk-ZZ3TECNR.js";
import {
  xq,
  zq
} from "./chunk-DJ7RRNEK.js";
import {
  Alert,
  AlertDescription,
  AlertIcon,
  Box,
  Button,
  Center,
  Checkbox,
  FormControl,
  FormErrorMessage,
  FormLabel,
  HStack,
  Heading,
  IconButton,
  Image,
  Input,
  Select,
  Spinner,
  Table,
  TableContainer,
  Tbody,
  Td,
  Th,
  Thead,
  Tr
} from "./chunk-YIBNIHBG.js";
import "./chunk-HTHQKSPX.js";
import "./chunk-LMKMSGST.js";
import "./chunk-WVGTWT4U.js";
import "./chunk-JOEXCGTR.js";
import "./chunk-ZYX7IIE4.js";
import {
  Ke,
  N,
  SC,
  SetCache_default,
  Stack_default,
  Symbol_default,
  Uint8Array_default,
  WeakMap_default,
  apply_default,
  arrayFilter_default,
  arrayIncludesWith_default,
  arrayIncludes_default,
  arrayLikeKeys_default,
  arrayMap_default,
  arrayPush_default,
  arraySome_default,
  baseDifference_default,
  baseFindIndex_default,
  baseFlatten_default,
  baseGetAllKeys_default,
  baseGetTag_default,
  baseGet_default,
  baseIndexOf_default,
  baseIsEqual_default,
  baseIsMatch_default,
  baseIsNaN_default,
  baseIsNative_default,
  baseIteratee_default,
  baseKeys_default,
  baseMatchesProperty_default,
  baseMatches_default,
  baseProperty_default,
  baseRest_default,
  baseSlice_default,
  baseTimes_default,
  baseToString_default,
  baseTrim_default,
  baseUnary_default,
  baseUniq_default,
  cacheHas_default,
  castPath_default,
  chunk_default,
  constant_default,
  coreJsData_default,
  debounce_default,
  defineProperty_default,
  differenceWith_default,
  eq_default,
  esm_exports,
  fromPairs_default,
  getAllKeys_default,
  getMatchData_default,
  getSymbols_default,
  getTag_default,
  get_default,
  hasIn_default,
  identity_default,
  isArguments_default,
  isArrayLikeObject_default,
  isArrayLike_default,
  isArray_default,
  isBuffer_default,
  isEqual_default,
  isFunction_default,
  isIndex_default,
  isIterateeCall_default,
  isLength_default,
  isObjectLike_default,
  isObject_default,
  isPrototype_default,
  isSymbol_default,
  isTypedArray_default,
  keys_default,
  last_default,
  mapToArray_default,
  memoize_default,
  nodeUtil_default,
  noop_default,
  now_default,
  overArg_default,
  overRest_default,
  property_default,
  re,
  require_pluralize,
  root_default,
  setToArray_default,
  setToString_default,
  shortOut_default,
  stringToPath_default,
  stubArray_default,
  stubFalse_default,
  toFinite_default,
  toInteger_default,
  toKey_default,
  toNumber_default,
  toString_default,
  trimmedEndIndex_default,
  unionWith_default,
  uniqBy_default,
  unzip_default,
  w,
  zip_default
} from "./chunk-GNLXR2HK.js";
import "./chunk-SCGGGWO5.js";
import "./chunk-GYWC62UC.js";
import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "node_modules/prettier/standalone.js"(exports2, module2) {
    (function(e) {
      if (typeof exports2 == "object" && typeof module2 == "object")
        module2.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var f2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f2.prettier = e();
      }
    })(function() {
      "use strict";
      var xe2 = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
      var pt2 = xe2((r0, pu) => {
        var ir2 = function(e) {
          return e && e.Math == Math && e;
        };
        pu.exports = ir2(typeof globalThis == "object" && globalThis) || ir2(typeof window == "object" && window) || ir2(typeof self == "object" && self) || ir2(typeof global == "object" && global) || function() {
          return this;
        }() || Function("return this")();
      });
      var Dt = xe2((n0, fu) => {
        fu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var yt = xe2((u0, Du) => {
        var Mo = Dt();
        Du.exports = !Mo(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var ar2 = xe2((s0, mu) => {
        var Ro = Dt();
        mu.exports = !Ro(function() {
          var e = (function() {
          }).bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var At = xe2((i0, du) => {
        var $o = ar2(), or2 = Function.prototype.call;
        du.exports = $o ? or2.bind(or2) : function() {
          return or2.apply(or2, arguments);
        };
      });
      var vu = xe2((hu) => {
        "use strict";
        var gu = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu.call({ 1: 2 }, 1);
        hu.f = Vo ? function(r) {
          var t2 = yu(this, r);
          return !!t2 && t2.enumerable;
        } : gu;
      });
      var lr2 = xe2((o0, Cu) => {
        Cu.exports = function(e, r) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
        };
      });
      var mt = xe2((l0, Au) => {
        var Eu = ar2(), Fu = Function.prototype, Wr2 = Fu.call, Wo = Eu && Fu.bind.bind(Wr2, Wr2);
        Au.exports = Eu ? Wo : function(e) {
          return function() {
            return Wr2.apply(e, arguments);
          };
        };
      });
      var Vt2 = xe2((c0, xu) => {
        var Su = mt(), Ho = Su({}.toString), Go = Su("".slice);
        xu.exports = function(e) {
          return Go(Ho(e), 8, -1);
        };
      });
      var Tu = xe2((p0, bu) => {
        var Uo = mt(), Jo = Dt(), zo = Vt2(), Hr2 = Object, Xo = Uo("".split);
        bu.exports = Jo(function() {
          return !Hr2("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return zo(e) == "String" ? Xo(e, "") : Hr2(e);
        } : Hr2;
      });
      var cr2 = xe2((f0, Bu) => {
        Bu.exports = function(e) {
          return e == null;
        };
      });
      var Gr2 = xe2((D0, Nu) => {
        var Ko = cr2(), Yo = TypeError;
        Nu.exports = function(e) {
          if (Ko(e))
            throw Yo("Can't call method on " + e);
          return e;
        };
      });
      var pr2 = xe2((m0, wu) => {
        var Qo = Tu(), Zo = Gr2();
        wu.exports = function(e) {
          return Qo(Zo(e));
        };
      });
      var Jr = xe2((d0, _u) => {
        var Ur2 = typeof document == "object" && document.all, el = typeof Ur2 > "u" && Ur2 !== void 0;
        _u.exports = { all: Ur2, IS_HTMLDDA: el };
      });
      var ot2 = xe2((g0, Iu) => {
        var Pu = Jr(), tl = Pu.all;
        Iu.exports = Pu.IS_HTMLDDA ? function(e) {
          return typeof e == "function" || e === tl;
        } : function(e) {
          return typeof e == "function";
        };
      });
      var St = xe2((y0, Ou) => {
        var ku = ot2(), Lu = Jr(), rl = Lu.all;
        Ou.exports = Lu.IS_HTMLDDA ? function(e) {
          return typeof e == "object" ? e !== null : ku(e) || e === rl;
        } : function(e) {
          return typeof e == "object" ? e !== null : ku(e);
        };
      });
      var Wt = xe2((h0, ju) => {
        var zr2 = pt2(), nl = ot2(), ul = function(e) {
          return nl(e) ? e : void 0;
        };
        ju.exports = function(e, r) {
          return arguments.length < 2 ? ul(zr2[e]) : zr2[e] && zr2[e][r];
        };
      });
      var Xr = xe2((v0, qu) => {
        var sl = mt();
        qu.exports = sl({}.isPrototypeOf);
      });
      var Ru = xe2((C0, Mu) => {
        var il = Wt();
        Mu.exports = il("navigator", "userAgent") || "";
      });
      var Ju = xe2((E0, Uu) => {
        var Gu = pt2(), Kr2 = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu = Wu && Wu.v8, dt, fr2;
        Hu && (dt = Hu.split("."), fr2 = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
        !fr2 && Kr2 && (dt = Kr2.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = Kr2.match(/Chrome\/(\d+)/), dt && (fr2 = +dt[1])));
        Uu.exports = fr2;
      });
      var Yr2 = xe2((F0, Xu) => {
        var zu = Ju(), al = Dt();
        Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
        });
      });
      var Qr2 = xe2((A0, Ku) => {
        var ol = Yr2();
        Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Zr2 = xe2((S0, Yu) => {
        var ll = Wt(), cl = ot2(), pl = Xr(), fl = Qr2(), Dl = Object;
        Yu.exports = fl ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var r = ll("Symbol");
          return cl(r) && pl(r.prototype, Dl(e));
        };
      });
      var Dr2 = xe2((x0, Qu) => {
        var ml = String;
        Qu.exports = function(e) {
          try {
            return ml(e);
          } catch {
            return "Object";
          }
        };
      });
      var Ht = xe2((b0, Zu) => {
        var dl = ot2(), gl = Dr2(), yl = TypeError;
        Zu.exports = function(e) {
          if (dl(e))
            return e;
          throw yl(gl(e) + " is not a function");
        };
      });
      var mr2 = xe2((T0, es) => {
        var hl = Ht(), vl = cr2();
        es.exports = function(e, r) {
          var t2 = e[r];
          return vl(t2) ? void 0 : hl(t2);
        };
      });
      var rs = xe2((B0, ts) => {
        var en = At(), tn = ot2(), rn = St(), Cl = TypeError;
        ts.exports = function(e, r) {
          var t2, s;
          if (r === "string" && tn(t2 = e.toString) && !rn(s = en(t2, e)) || tn(t2 = e.valueOf) && !rn(s = en(t2, e)) || r !== "string" && tn(t2 = e.toString) && !rn(s = en(t2, e)))
            return s;
          throw Cl("Can't convert object to primitive value");
        };
      });
      var us = xe2((N0, ns) => {
        ns.exports = false;
      });
      var dr2 = xe2((w0, is) => {
        var ss = pt2(), El = Object.defineProperty;
        is.exports = function(e, r) {
          try {
            El(ss, e, { value: r, configurable: true, writable: true });
          } catch {
            ss[e] = r;
          }
          return r;
        };
      });
      var gr2 = xe2((_0, os) => {
        var Fl = pt2(), Al = dr2(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
        os.exports = Sl;
      });
      var nn = xe2((P0, cs) => {
        var xl = us(), ls = gr2();
        (cs.exports = function(e, r) {
          return ls[e] || (ls[e] = r !== void 0 ? r : {});
        })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var yr2 = xe2((I0, ps) => {
        var bl = Gr2(), Tl = Object;
        ps.exports = function(e) {
          return Tl(bl(e));
        };
      });
      var Ct = xe2((k0, fs) => {
        var Bl = mt(), Nl = yr2(), wl = Bl({}.hasOwnProperty);
        fs.exports = Object.hasOwn || function(r, t2) {
          return wl(Nl(r), t2);
        };
      });
      var un = xe2((L0, Ds) => {
        var _l = mt(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
        Ds.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl(++Pl + Il, 36);
        };
      });
      var bt = xe2((O0, hs) => {
        var Ll = pt2(), Ol = nn(), ms = Ct(), jl = un(), ds = Yr2(), ys = Qr2(), It = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
        hs.exports = function(e) {
          if (!ms(It, e) || !(ds || typeof It[e] == "string")) {
            var r = "Symbol." + e;
            ds && ms(xt, e) ? It[e] = xt[e] : ys && gs ? It[e] = gs(r) : It[e] = ql(r);
          }
          return It[e];
        };
      });
      var Fs = xe2((j0, Es) => {
        var Ml = At(), vs = St(), Cs = Zr2(), Rl = mr2(), $l = rs(), Vl = bt(), Wl = TypeError, Hl = Vl("toPrimitive");
        Es.exports = function(e, r) {
          if (!vs(e) || Cs(e))
            return e;
          var t2 = Rl(e, Hl), s;
          if (t2) {
            if (r === void 0 && (r = "default"), s = Ml(t2, e, r), !vs(s) || Cs(s))
              return s;
            throw Wl("Can't convert object to primitive value");
          }
          return r === void 0 && (r = "number"), $l(e, r);
        };
      });
      var hr2 = xe2((q0, As) => {
        var Gl = Fs(), Ul = Zr2();
        As.exports = function(e) {
          var r = Gl(e, "string");
          return Ul(r) ? r : r + "";
        };
      });
      var bs = xe2((M0, xs) => {
        var Jl = pt2(), Ss = St(), sn = Jl.document, zl = Ss(sn) && Ss(sn.createElement);
        xs.exports = function(e) {
          return zl ? sn.createElement(e) : {};
        };
      });
      var an = xe2((R0, Ts) => {
        var Xl = yt(), Kl = Dt(), Yl = bs();
        Ts.exports = !Xl && !Kl(function() {
          return Object.defineProperty(Yl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var on = xe2((Ns) => {
        var Ql = yt(), Zl = At(), ec = vu(), tc = lr2(), rc = pr2(), nc = hr2(), uc = Ct(), sc = an(), Bs = Object.getOwnPropertyDescriptor;
        Ns.f = Ql ? Bs : function(r, t2) {
          if (r = rc(r), t2 = nc(t2), sc)
            try {
              return Bs(r, t2);
            } catch {
            }
          if (uc(r, t2))
            return tc(!Zl(ec.f, r, t2), r[t2]);
        };
      });
      var _s = xe2((V0, ws) => {
        var ic = yt(), ac = Dt();
        ws.exports = ic && ac(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Tt = xe2((W0, Ps) => {
        var oc = St(), lc = String, cc = TypeError;
        Ps.exports = function(e) {
          if (oc(e))
            return e;
          throw cc(lc(e) + " is not an object");
        };
      });
      var kt = xe2((ks) => {
        var pc = yt(), fc = an(), Dc = _s(), vr = Tt(), Is = hr2(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn = "configurable", fn = "writable";
        ks.f = pc ? Dc ? function(r, t2, s) {
          if (vr(r), t2 = Is(t2), vr(s), typeof r == "function" && t2 === "prototype" && "value" in s && fn in s && !s[fn]) {
            var a = dc(r, t2);
            a && a[fn] && (r[t2] = s.value, s = { configurable: pn in s ? s[pn] : a[pn], enumerable: cn in s ? s[cn] : a[cn], writable: false });
          }
          return ln(r, t2, s);
        } : ln : function(r, t2, s) {
          if (vr(r), t2 = Is(t2), vr(s), fc)
            try {
              return ln(r, t2, s);
            } catch {
            }
          if ("get" in s || "set" in s)
            throw mc("Accessors not supported");
          return "value" in s && (r[t2] = s.value), r;
        };
      });
      var Dn = xe2((G0, Ls) => {
        var gc = yt(), yc = kt(), hc = lr2();
        Ls.exports = gc ? function(e, r, t2) {
          return yc.f(e, r, hc(1, t2));
        } : function(e, r, t2) {
          return e[r] = t2, e;
        };
      });
      var qs = xe2((U0, js) => {
        var mn = yt(), vc = Ct(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn = vc(Os, "name"), Ec = dn && (function() {
        }).name === "something", Fc = dn && (!mn || mn && Cc(Os, "name").configurable);
        js.exports = { EXISTS: dn, PROPER: Ec, CONFIGURABLE: Fc };
      });
      var yn = xe2((J0, Ms) => {
        var Ac = mt(), Sc = ot2(), gn = gr2(), xc = Ac(Function.toString);
        Sc(gn.inspectSource) || (gn.inspectSource = function(e) {
          return xc(e);
        });
        Ms.exports = gn.inspectSource;
      });
      var Vs = xe2((z0, $s) => {
        var bc = pt2(), Tc = ot2(), Rs = bc.WeakMap;
        $s.exports = Tc(Rs) && /native code/.test(String(Rs));
      });
      var Gs = xe2((X0, Hs) => {
        var Bc = nn(), Nc2 = un(), Ws = Bc("keys");
        Hs.exports = function(e) {
          return Ws[e] || (Ws[e] = Nc2(e));
        };
      });
      var hn = xe2((K0, Us) => {
        Us.exports = {};
      });
      var Ks = xe2((Y0, Xs) => {
        var wc = Vs(), zs = pt2(), _c = St(), Pc = Dn(), vn = Ct(), Cn = gr2(), Ic = Gs(), kc = hn(), Js = "Object already initialized", En = zs.TypeError, Lc = zs.WeakMap, Cr2, Gt, Er2, Oc2 = function(e) {
          return Er2(e) ? Gt(e) : Cr2(e, {});
        }, jc = function(e) {
          return function(r) {
            var t2;
            if (!_c(r) || (t2 = Gt(r)).type !== e)
              throw En("Incompatible receiver, " + e + " required");
            return t2;
          };
        };
        wc || Cn.state ? (gt2 = Cn.state || (Cn.state = new Lc()), gt2.get = gt2.get, gt2.has = gt2.has, gt2.set = gt2.set, Cr2 = function(e, r) {
          if (gt2.has(e))
            throw En(Js);
          return r.facade = e, gt2.set(e, r), r;
        }, Gt = function(e) {
          return gt2.get(e) || {};
        }, Er2 = function(e) {
          return gt2.has(e);
        }) : (Bt = Ic("state"), kc[Bt] = true, Cr2 = function(e, r) {
          if (vn(e, Bt))
            throw En(Js);
          return r.facade = e, Pc(e, Bt, r), r;
        }, Gt = function(e) {
          return vn(e, Bt) ? e[Bt] : {};
        }, Er2 = function(e) {
          return vn(e, Bt);
        });
        var gt2, Bt;
        Xs.exports = { set: Cr2, get: Gt, has: Er2, enforce: Oc2, getterFor: jc };
      });
      var An = xe2((Q0, Qs) => {
        var qc = Dt(), Mc = ot2(), Fr2 = Ct(), Fn = yt(), Rc2 = qs().CONFIGURABLE, $c = yn(), Ys = Ks(), Vc = Ys.enforce, Wc = Ys.get, Ar2 = Object.defineProperty, Hc = Fn && !qc(function() {
          return Ar2(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Gc = String(String).split("String"), Uc = Qs.exports = function(e, r, t2) {
          String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t2 && t2.getter && (r = "get " + r), t2 && t2.setter && (r = "set " + r), (!Fr2(e, "name") || Rc2 && e.name !== r) && (Fn ? Ar2(e, "name", { value: r, configurable: true }) : e.name = r), Hc && t2 && Fr2(t2, "arity") && e.length !== t2.arity && Ar2(e, "length", { value: t2.arity });
          try {
            t2 && Fr2(t2, "constructor") && t2.constructor ? Fn && Ar2(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
          } catch {
          }
          var s = Vc(e);
          return Fr2(s, "source") || (s.source = Gc.join(typeof r == "string" ? r : "")), e;
        };
        Function.prototype.toString = Uc(function() {
          return Mc(this) && Wc(this).source || $c(this);
        }, "toString");
      });
      var ei = xe2((Z0, Zs) => {
        var Jc = ot2(), zc = kt(), Xc = An(), Kc = dr2();
        Zs.exports = function(e, r, t2, s) {
          s || (s = {});
          var a = s.enumerable, n2 = s.name !== void 0 ? s.name : r;
          if (Jc(t2) && Xc(t2, n2, s), s.global)
            a ? e[r] = t2 : Kc(r, t2);
          else {
            try {
              s.unsafe ? e[r] && (a = true) : delete e[r];
            } catch {
            }
            a ? e[r] = t2 : zc.f(e, r, { value: t2, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
          }
          return e;
        };
      });
      var ri = xe2((ey, ti) => {
        var Yc2 = Math.ceil, Qc = Math.floor;
        ti.exports = Math.trunc || function(r) {
          var t2 = +r;
          return (t2 > 0 ? Qc : Yc2)(t2);
        };
      });
      var Sr2 = xe2((ty, ni) => {
        var Zc = ri();
        ni.exports = function(e) {
          var r = +e;
          return r !== r || r === 0 ? 0 : Zc(r);
        };
      });
      var si = xe2((ry, ui) => {
        var ep = Sr2(), tp = Math.max, rp = Math.min;
        ui.exports = function(e, r) {
          var t2 = ep(e);
          return t2 < 0 ? tp(t2 + r, 0) : rp(t2, r);
        };
      });
      var ai = xe2((ny, ii) => {
        var np = Sr2(), up = Math.min;
        ii.exports = function(e) {
          return e > 0 ? up(np(e), 9007199254740991) : 0;
        };
      });
      var Lt = xe2((uy, oi) => {
        var sp = ai();
        oi.exports = function(e) {
          return sp(e.length);
        };
      });
      var pi = xe2((sy, ci) => {
        var ip = pr2(), ap = si(), op = Lt(), li = function(e) {
          return function(r, t2, s) {
            var a = ip(r), n2 = op(a), u = ap(s, n2), i2;
            if (e && t2 != t2) {
              for (; n2 > u; )
                if (i2 = a[u++], i2 != i2)
                  return true;
            } else
              for (; n2 > u; u++)
                if ((e || u in a) && a[u] === t2)
                  return e || u || 0;
            return !e && -1;
          };
        };
        ci.exports = { includes: li(true), indexOf: li(false) };
      });
      var mi = xe2((iy, Di) => {
        var lp = mt(), Sn = Ct(), cp = pr2(), pp = pi().indexOf, fp = hn(), fi = lp([].push);
        Di.exports = function(e, r) {
          var t2 = cp(e), s = 0, a = [], n2;
          for (n2 in t2)
            !Sn(fp, n2) && Sn(t2, n2) && fi(a, n2);
          for (; r.length > s; )
            Sn(t2, n2 = r[s++]) && (~pp(a, n2) || fi(a, n2));
          return a;
        };
      });
      var gi = xe2((ay, di) => {
        di.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var hi = xe2((yi) => {
        var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
        yi.f = Object.getOwnPropertyNames || function(r) {
          return Dp(r, dp);
        };
      });
      var Ci = xe2((vi) => {
        vi.f = Object.getOwnPropertySymbols;
      });
      var Fi = xe2((cy, Ei) => {
        var gp = Wt(), yp = mt(), hp2 = hi(), vp = Ci(), Cp = Tt(), Ep = yp([].concat);
        Ei.exports = gp("Reflect", "ownKeys") || function(r) {
          var t2 = hp2.f(Cp(r)), s = vp.f;
          return s ? Ep(t2, s(r)) : t2;
        };
      });
      var xi = xe2((py, Si) => {
        var Ai = Ct(), Fp = Fi(), Ap = on(), Sp = kt();
        Si.exports = function(e, r, t2) {
          for (var s = Fp(r), a = Sp.f, n2 = Ap.f, u = 0; u < s.length; u++) {
            var i2 = s[u];
            !Ai(e, i2) && !(t2 && Ai(t2, i2)) && a(e, i2, n2(r, i2));
          }
        };
      });
      var Ti = xe2((fy, bi) => {
        var xp = Dt(), bp = ot2(), Tp = /#|\.prototype\./, Ut = function(e, r) {
          var t2 = Np[Bp(e)];
          return t2 == _p ? true : t2 == wp ? false : bp(r) ? xp(r) : !!r;
        }, Bp = Ut.normalize = function(e) {
          return String(e).replace(Tp, ".").toLowerCase();
        }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
        bi.exports = Ut;
      });
      var Jt = xe2((Dy, Bi) => {
        var xn = pt2(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr2(), Op = xi(), jp = Ti();
        Bi.exports = function(e, r) {
          var t2 = e.target, s = e.global, a = e.stat, n2, u, i2, l, p, y;
          if (s ? u = xn : a ? u = xn[t2] || Lp(t2, {}) : u = (xn[t2] || {}).prototype, u)
            for (i2 in r) {
              if (p = r[i2], e.dontCallGetSet ? (y = Pp(u, i2), l = y && y.value) : l = u[i2], n2 = jp(s ? i2 : t2 + (a ? "." : "#") + i2, e.forced), !n2 && l !== void 0) {
                if (typeof p == typeof l)
                  continue;
                Op(p, l);
              }
              (e.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i2, p, e);
            }
        };
      });
      var bn = xe2((my, Ni) => {
        var qp = Vt2();
        Ni.exports = Array.isArray || function(r) {
          return qp(r) == "Array";
        };
      });
      var _i = xe2((dy, wi) => {
        var Mp = TypeError, Rp = 9007199254740991;
        wi.exports = function(e) {
          if (e > Rp)
            throw Mp("Maximum allowed index exceeded");
          return e;
        };
      });
      var Ii = xe2((gy, Pi) => {
        var $p = Vt2(), Vp = mt();
        Pi.exports = function(e) {
          if ($p(e) === "Function")
            return Vp(e);
        };
      });
      var Tn = xe2((yy, Li) => {
        var ki = Ii(), Wp = Ht(), Hp = ar2(), Gp = ki(ki.bind);
        Li.exports = function(e, r) {
          return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function() {
            return e.apply(r, arguments);
          };
        };
      });
      var Bn = xe2((hy, ji) => {
        "use strict";
        var Up = bn(), Jp = Lt(), zp = _i(), Xp = Tn(), Oi = function(e, r, t2, s, a, n2, u, i2) {
          for (var l = a, p = 0, y = u ? Xp(u, i2) : false, h, g2; p < s; )
            p in t2 && (h = y ? y(t2[p], p, r) : t2[p], n2 > 0 && Up(h) ? (g2 = Jp(h), l = Oi(e, r, h, g2, l, n2 - 1) - 1) : (zp(l + 1), e[l] = h), l++), p++;
          return l;
        };
        ji.exports = Oi;
      });
      var Ri = xe2((vy, Mi) => {
        var Kp = bt(), Yp = Kp("toStringTag"), qi = {};
        qi[Yp] = "z";
        Mi.exports = String(qi) === "[object z]";
      });
      var Nn = xe2((Cy, $i) => {
        var Qp = Ri(), Zp = ot2(), xr2 = Vt2(), ef = bt(), tf2 = ef("toStringTag"), rf = Object, nf = xr2(function() {
          return arguments;
        }()) == "Arguments", uf = function(e, r) {
          try {
            return e[r];
          } catch {
          }
        };
        $i.exports = Qp ? xr2 : function(e) {
          var r, t2, s;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t2 = uf(r = rf(e), tf2)) == "string" ? t2 : nf ? xr2(r) : (s = xr2(r)) == "Object" && Zp(r.callee) ? "Arguments" : s;
        };
      });
      var Ji = xe2((Ey, Ui) => {
        var sf = mt(), af = Dt(), Vi = ot2(), of = Nn(), lf = Wt(), cf = yn(), Wi = function() {
        }, pf = [], Hi = lf("Reflect", "construct"), wn = /^\s*(?:class|function)\b/, ff = sf(wn.exec), Df = !wn.exec(Wi), zt = function(r) {
          if (!Vi(r))
            return false;
          try {
            return Hi(Wi, pf, r), true;
          } catch {
            return false;
          }
        }, Gi = function(r) {
          if (!Vi(r))
            return false;
          switch (of(r)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Df || !!ff(wn, cf(r));
          } catch {
            return true;
          }
        };
        Gi.sham = true;
        Ui.exports = !Hi || af(function() {
          var e;
          return zt(zt.call) || !zt(Object) || !zt(function() {
            e = true;
          }) || e;
        }) ? Gi : zt;
      });
      var Yi2 = xe2((Fy, Ki) => {
        var zi = bn(), mf = Ji(), df = St(), gf = bt(), yf = gf("species"), Xi = Array;
        Ki.exports = function(e) {
          var r;
          return zi(e) && (r = e.constructor, mf(r) && (r === Xi || zi(r.prototype)) ? r = void 0 : df(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;
        };
      });
      var _n = xe2((Ay, Qi) => {
        var hf = Yi2();
        Qi.exports = function(e, r) {
          return new (hf(e))(r === 0 ? 0 : r);
        };
      });
      var Zi = xe2(() => {
        "use strict";
        var vf = Jt(), Cf = Bn(), Ef = Ht(), Ff = yr2(), Af = Lt(), Sf = _n();
        vf({ target: "Array", proto: true }, { flatMap: function(r) {
          var t2 = Ff(this), s = Af(t2), a;
          return Ef(r), a = Sf(t2, 0), a.length = Cf(a, t2, t2, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var Pn = xe2((by, ea) => {
        ea.exports = {};
      });
      var ra = xe2((Ty, ta) => {
        var xf = bt(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
        ta.exports = function(e) {
          return e !== void 0 && (bf.Array === e || Bf[Tf] === e);
        };
      });
      var In = xe2((By, ua) => {
        var Nf = Nn(), na = mr2(), wf = cr2(), _f = Pn(), Pf = bt(), If = Pf("iterator");
        ua.exports = function(e) {
          if (!wf(e))
            return na(e, If) || na(e, "@@iterator") || _f[Nf(e)];
        };
      });
      var ia = xe2((Ny, sa) => {
        var kf = At(), Lf = Ht(), Of = Tt(), jf = Dr2(), qf = In(), Mf = TypeError;
        sa.exports = function(e, r) {
          var t2 = arguments.length < 2 ? qf(e) : r;
          if (Lf(t2))
            return Of(kf(t2, e));
          throw Mf(jf(e) + " is not iterable");
        };
      });
      var la = xe2((wy, oa) => {
        var Rf = At(), aa = Tt(), $f = mr2();
        oa.exports = function(e, r, t2) {
          var s, a;
          aa(e);
          try {
            if (s = $f(e, "return"), !s) {
              if (r === "throw")
                throw t2;
              return t2;
            }
            s = Rf(s, e);
          } catch (n2) {
            a = true, s = n2;
          }
          if (r === "throw")
            throw t2;
          if (a)
            throw s;
          return aa(s), t2;
        };
      });
      var ma = xe2((_y, Da) => {
        var Vf = Tn(), Wf = At(), Hf = Tt(), Gf = Dr2(), Uf = ra(), Jf = Lt(), ca = Xr(), zf = ia(), Xf = In(), pa = la(), Kf = TypeError, br2 = function(e, r) {
          this.stopped = e, this.result = r;
        }, fa = br2.prototype;
        Da.exports = function(e, r, t2) {
          var s = t2 && t2.that, a = !!(t2 && t2.AS_ENTRIES), n2 = !!(t2 && t2.IS_RECORD), u = !!(t2 && t2.IS_ITERATOR), i2 = !!(t2 && t2.INTERRUPTED), l = Vf(r, s), p, y, h, g2, c, f2, F2, _ = function(E) {
            return p && pa(p, "normal", E), new br2(true, E);
          }, w2 = function(E) {
            return a ? (Hf(E), i2 ? l(E[0], E[1], _) : l(E[0], E[1])) : i2 ? l(E, _) : l(E);
          };
          if (n2)
            p = e.iterator;
          else if (u)
            p = e;
          else {
            if (y = Xf(e), !y)
              throw Kf(Gf(e) + " is not iterable");
            if (Uf(y)) {
              for (h = 0, g2 = Jf(e); g2 > h; h++)
                if (c = w2(e[h]), c && ca(fa, c))
                  return c;
              return new br2(false);
            }
            p = zf(e, y);
          }
          for (f2 = n2 ? e.next : p.next; !(F2 = Wf(f2, p)).done; ) {
            try {
              c = w2(F2.value);
            } catch (E) {
              pa(p, "throw", E);
            }
            if (typeof c == "object" && c && ca(fa, c))
              return c;
          }
          return new br2(false);
        };
      });
      var ga = xe2((Py, da) => {
        "use strict";
        var Yf = hr2(), Qf = kt(), Zf = lr2();
        da.exports = function(e, r, t2) {
          var s = Yf(r);
          s in e ? Qf.f(e, s, Zf(0, t2)) : e[s] = t2;
        };
      });
      var ya = xe2(() => {
        var eD = Jt(), tD = ma(), rD = ga();
        eD({ target: "Object", stat: true }, { fromEntries: function(r) {
          var t2 = {};
          return tD(r, function(s, a) {
            rD(t2, s, a);
          }, { AS_ENTRIES: true }), t2;
        } });
      });
      var Ca = xe2((Ly, va) => {
        var ha = An(), nD = kt();
        va.exports = function(e, r, t2) {
          return t2.get && ha(t2.get, r, { getter: true }), t2.set && ha(t2.set, r, { setter: true }), nD.f(e, r, t2);
        };
      });
      var Fa = xe2((Oy, Ea) => {
        "use strict";
        var uD = Tt();
        Ea.exports = function() {
          var e = uD(this), r = "";
          return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
        };
      });
      var xa = xe2(() => {
        var sD = pt2(), iD = yt(), aD = Ca(), oD = Fa(), lD = Dt(), Aa = sD.RegExp, Sa = Aa.prototype, cD = iD && lD(function() {
          var e = true;
          try {
            Aa(".", "d");
          } catch {
            e = false;
          }
          var r = {}, t2 = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
            Object.defineProperty(r, l, { get: function() {
              return t2 += p, true;
            } });
          }, n2 = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          e && (n2.hasIndices = "d");
          for (var u in n2)
            a(u, n2[u]);
          var i2 = Object.getOwnPropertyDescriptor(Sa, "flags").get.call(r);
          return i2 !== s || t2 !== s;
        });
        cD && aD(Sa, "flags", { configurable: true, get: oD });
      });
      var ba = xe2(() => {
        var pD = Jt(), kn = pt2();
        pD({ global: true, forced: kn.globalThis !== kn }, { globalThis: kn });
      });
      var Ta = xe2(() => {
        ba();
      });
      var Ba = xe2(() => {
        "use strict";
        var fD = Jt(), DD = Bn(), mD = yr2(), dD = Lt(), gD = Sr2(), yD = _n();
        fD({ target: "Array", proto: true }, { flat: function() {
          var r = arguments.length ? arguments[0] : void 0, t2 = mD(this), s = dD(t2), a = yD(t2, 0);
          return a.length = DD(a, t2, t2, s, 0, r === void 0 ? 1 : gD(r)), a;
        } });
      });
      var e0 = xe2((Uy, jo) => {
        var hD = ["cliName", "cliCategory", "cliDescription"], vD = ["_"], CD = ["languageId"];
        function Hn(e, r) {
          if (e == null)
            return {};
          var t2 = ED(e, r), s, a;
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e);
            for (a = 0; a < n2.length; a++)
              s = n2[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t2[s] = e[s]);
          }
          return t2;
        }
        function ED(e, r) {
          if (e == null)
            return {};
          var t2 = {}, s = Object.keys(e), a, n2;
          for (n2 = 0; n2 < s.length; n2++)
            a = s[n2], !(r.indexOf(a) >= 0) && (t2[a] = e[a]);
          return t2;
        }
        Zi();
        ya();
        xa();
        Ta();
        Ba();
        var FD = Object.create, _r2 = Object.defineProperty, AD = Object.getOwnPropertyDescriptor, Gn = Object.getOwnPropertyNames, SD = Object.getPrototypeOf, xD = Object.prototype.hasOwnProperty, ht = (e, r) => function() {
          return e && (r = (0, e[Gn(e)[0]])(e = 0)), r;
        }, te2 = (e, r) => function() {
          return r || (0, e[Gn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
        }, Kt = (e, r) => {
          for (var t2 in r)
            _r2(e, t2, { get: r[t2], enumerable: true });
        }, Pa = (e, r, t2, s) => {
          if (r && typeof r == "object" || typeof r == "function")
            for (let a of Gn(r))
              !xD.call(e, a) && a !== t2 && _r2(e, a, { get: () => r[a], enumerable: !(s = AD(r, a)) || s.enumerable });
          return e;
        }, bD = (e, r, t2) => (t2 = e != null ? FD(SD(e)) : {}, Pa(r || !e || !e.__esModule ? _r2(t2, "default", { value: e, enumerable: true }) : t2, e)), ft = (e) => Pa(_r2({}, "__esModule", { value: true }), e), wt, ne2 = ht({ "<define:process>"() {
          wt = { env: {}, argv: [] };
        } }), Ia = te2({ "package.json"(e, r) {
          r.exports = { version: "2.8.8" };
        } }), TD = te2({ "node_modules/diff/lib/diff/base.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
          function r() {
          }
          r.prototype = { diff: function(n2, u) {
            var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i2.callback;
            typeof i2 == "function" && (l = i2, i2 = {}), this.options = i2;
            var p = this;
            function y(N2) {
              return l ? (setTimeout(function() {
                l(void 0, N2);
              }, 0), true) : N2;
            }
            n2 = this.castInput(n2), u = this.castInput(u), n2 = this.removeEmpty(this.tokenize(n2)), u = this.removeEmpty(this.tokenize(u));
            var h = u.length, g2 = n2.length, c = 1, f2 = h + g2, F2 = [{ newPos: -1, components: [] }], _ = this.extractCommon(F2[0], u, n2, 0);
            if (F2[0].newPos + 1 >= h && _ + 1 >= g2)
              return y([{ value: this.join(u), count: u.length }]);
            function w2() {
              for (var N2 = -1 * c; N2 <= c; N2 += 2) {
                var x2 = void 0, I = F2[N2 - 1], P = F2[N2 + 1], $ = (P ? P.newPos : 0) - N2;
                I && (F2[N2 - 1] = void 0);
                var D = I && I.newPos + 1 < h, T = P && 0 <= $ && $ < g2;
                if (!D && !T) {
                  F2[N2] = void 0;
                  continue;
                }
                if (!D || T && I.newPos < P.newPos ? (x2 = s(P), p.pushComponent(x2.components, void 0, true)) : (x2 = I, x2.newPos++, p.pushComponent(x2.components, true, void 0)), $ = p.extractCommon(x2, u, n2, N2), x2.newPos + 1 >= h && $ + 1 >= g2)
                  return y(t2(p, x2.components, u, n2, p.useLongestToken));
                F2[N2] = x2;
              }
              c++;
            }
            if (l)
              (function N2() {
                setTimeout(function() {
                  if (c > f2)
                    return l();
                  w2() || N2();
                }, 0);
              })();
            else
              for (; c <= f2; ) {
                var E = w2();
                if (E)
                  return E;
              }
          }, pushComponent: function(n2, u, i2) {
            var l = n2[n2.length - 1];
            l && l.added === u && l.removed === i2 ? n2[n2.length - 1] = { count: l.count + 1, added: u, removed: i2 } : n2.push({ count: 1, added: u, removed: i2 });
          }, extractCommon: function(n2, u, i2, l) {
            for (var p = u.length, y = i2.length, h = n2.newPos, g2 = h - l, c = 0; h + 1 < p && g2 + 1 < y && this.equals(u[h + 1], i2[g2 + 1]); )
              h++, g2++, c++;
            return c && n2.components.push({ count: c }), n2.newPos = h, g2;
          }, equals: function(n2, u) {
            return this.options.comparator ? this.options.comparator(n2, u) : n2 === u || this.options.ignoreCase && n2.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(n2) {
            for (var u = [], i2 = 0; i2 < n2.length; i2++)
              n2[i2] && u.push(n2[i2]);
            return u;
          }, castInput: function(n2) {
            return n2;
          }, tokenize: function(n2) {
            return n2.split("");
          }, join: function(n2) {
            return n2.join("");
          } };
          function t2(a, n2, u, i2, l) {
            for (var p = 0, y = n2.length, h = 0, g2 = 0; p < y; p++) {
              var c = n2[p];
              if (c.removed) {
                if (c.value = a.join(i2.slice(g2, g2 + c.count)), g2 += c.count, p && n2[p - 1].added) {
                  var F2 = n2[p - 1];
                  n2[p - 1] = n2[p], n2[p] = F2;
                }
              } else {
                if (!c.added && l) {
                  var f2 = u.slice(h, h + c.count);
                  f2 = f2.map(function(w2, E) {
                    var N2 = i2[g2 + E];
                    return N2.length > w2.length ? N2 : w2;
                  }), c.value = a.join(f2);
                } else
                  c.value = a.join(u.slice(h, h + c.count));
                h += c.count, c.added || (g2 += c.count);
              }
            }
            var _ = n2[y - 1];
            return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n2[y - 2].value += _.value, n2.pop()), n2;
          }
          function s(a) {
            return { newPos: a.newPos, components: a.components.slice(0) };
          }
        } }), BD = te2({ "node_modules/diff/lib/diff/array.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
          var r = t2(TD());
          function t2(n2) {
            return n2 && n2.__esModule ? n2 : { default: n2 };
          }
          var s = new r.default();
          e.arrayDiff = s, s.tokenize = function(n2) {
            return n2.slice();
          }, s.join = s.removeEmpty = function(n2) {
            return n2;
          };
          function a(n2, u, i2) {
            return s.diff(n2, u, i2);
          }
        } }), Un = te2({ "src/document/doc-builders.js"(e, r) {
          "use strict";
          ne2();
          function t2(C2) {
            return { type: "concat", parts: C2 };
          }
          function s(C2) {
            return { type: "indent", contents: C2 };
          }
          function a(C2, o) {
            return { type: "align", contents: o, n: C2 };
          }
          function n2(C2) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o.id, contents: C2, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
          }
          function u(C2) {
            return a(Number.NEGATIVE_INFINITY, C2);
          }
          function i2(C2) {
            return a({ type: "root" }, C2);
          }
          function l(C2) {
            return a(-1, C2);
          }
          function p(C2, o) {
            return n2(C2[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C2 }));
          }
          function y(C2) {
            return { type: "fill", parts: C2 };
          }
          function h(C2, o) {
            let d2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: C2, flatContents: o, groupId: d2.groupId };
          }
          function g2(C2, o) {
            return { type: "indent-if-break", contents: C2, groupId: o.groupId, negate: o.negate };
          }
          function c(C2) {
            return { type: "line-suffix", contents: C2 };
          }
          var f2 = { type: "line-suffix-boundary" }, F2 = { type: "break-parent" }, _ = { type: "trim" }, w2 = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N2 = { type: "line" }, x2 = { type: "line", soft: true }, I = t2([w2, F2]), P = t2([E, F2]), $ = { type: "cursor", placeholder: Symbol("cursor") };
          function D(C2, o) {
            let d2 = [];
            for (let v2 = 0; v2 < o.length; v2++)
              v2 !== 0 && d2.push(C2), d2.push(o[v2]);
            return t2(d2);
          }
          function T(C2, o, d2) {
            let v2 = C2;
            if (o > 0) {
              for (let S = 0; S < Math.floor(o / d2); ++S)
                v2 = s(v2);
              v2 = a(o % d2, v2), v2 = a(Number.NEGATIVE_INFINITY, v2);
            }
            return v2;
          }
          function m(C2, o) {
            return { type: "label", label: C2, contents: o };
          }
          r.exports = { concat: t2, join: D, line: N2, softline: x2, hardline: I, literalline: P, group: n2, conditionalGroup: p, fill: y, lineSuffix: c, lineSuffixBoundary: f2, cursor: $, breakParent: F2, ifBreak: h, trim: _, indent: s, indentIfBreak: g2, align: a, addAlignmentToDoc: T, markAsRoot: i2, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w2, literallineWithoutBreakParent: E, label: m };
        } }), Jn = te2({ "src/common/end-of-line.js"(e, r) {
          "use strict";
          ne2();
          function t2(u) {
            let i2 = u.indexOf("\r");
            return i2 >= 0 ? u.charAt(i2 + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a(u, i2) {
            let l;
            switch (i2) {
              case `
`:
                l = /\n/g;
                break;
              case "\r":
                l = /\r/g;
                break;
              case `\r
`:
                l = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i2)}.`);
            }
            let p = u.match(l);
            return p ? p.length : 0;
          }
          function n2(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          r.exports = { guessEndOfLine: t2, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n2 };
        } }), lt2 = te2({ "src/utils/get-last.js"(e, r) {
          "use strict";
          ne2();
          var t2 = (s) => s[s.length - 1];
          r.exports = t2;
        } });
        function ND() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r, e ? void 0 : "g");
        }
        var wD = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          ne2();
        } });
        function _D(e) {
          if (typeof e != "string")
            throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
          return e.replace(ND(), "");
        }
        var PD = ht({ "node_modules/strip-ansi/index.js"() {
          ne2(), wD();
        } });
        function ID(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var kD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
          ne2();
        } }), LD = te2({ "node_modules/emoji-regex/index.js"(e, r) {
          "use strict";
          ne2(), r.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ka = {};
        Kt(ka, { default: () => OD });
        function OD(e) {
          if (typeof e != "string" || e.length === 0 || (e = _D(e), e.length === 0))
            return 0;
          e = e.replace((0, La2.default)(), "  ");
          let r = 0;
          for (let t2 = 0; t2 < e.length; t2++) {
            let s = e.codePointAt(t2);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t2++, r += ID(s) ? 2 : 1);
          }
          return r;
        }
        var La2, jD = ht({ "node_modules/string-width/index.js"() {
          ne2(), PD(), kD(), La2 = bD(LD());
        } }), Oa = te2({ "src/utils/get-string-width.js"(e, r) {
          "use strict";
          ne2();
          var t2 = (jD(), ft(ka)).default, s = /[^\x20-\x7F]/;
          function a(n2) {
            return n2 ? s.test(n2) ? t2(n2) : n2.length : 0;
          }
          r.exports = a;
        } }), Yt = te2({ "src/document/doc-utils.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2(), { literalline: s, join: a } = Un(), n2 = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
            if (Array.isArray(o))
              return o;
            if (o.type !== "concat" && o.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return o.parts;
          }, i2 = {};
          function l(o, d2, v2, S) {
            let b = [o];
            for (; b.length > 0; ) {
              let B = b.pop();
              if (B === i2) {
                v2(b.pop());
                continue;
              }
              if (v2 && b.push(B, i2), !d2 || d2(B) !== false)
                if (n2(B) || B.type === "fill") {
                  let k = u(B);
                  for (let M = k.length, R = M - 1; R >= 0; --R)
                    b.push(k[R]);
                } else if (B.type === "if-break")
                  B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
                else if (B.type === "group" && B.expandedStates)
                  if (S)
                    for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M)
                      b.push(B.expandedStates[M]);
                  else
                    b.push(B.contents);
                else
                  B.contents && b.push(B.contents);
            }
          }
          function p(o, d2) {
            let v2 = /* @__PURE__ */ new Map();
            return S(o);
            function S(B) {
              if (v2.has(B))
                return v2.get(B);
              let k = b(B);
              return v2.set(B, k), k;
            }
            function b(B) {
              if (Array.isArray(B))
                return d2(B.map(S));
              if (B.type === "concat" || B.type === "fill") {
                let k = B.parts.map(S);
                return d2(Object.assign(Object.assign({}, B), {}, { parts: k }));
              }
              if (B.type === "if-break") {
                let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                return d2(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
              }
              if (B.type === "group" && B.expandedStates) {
                let k = B.expandedStates.map(S), M = k[0];
                return d2(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
              }
              if (B.contents) {
                let k = S(B.contents);
                return d2(Object.assign(Object.assign({}, B), {}, { contents: k }));
              }
              return d2(B);
            }
          }
          function y(o, d2, v2) {
            let S = v2, b = false;
            function B(k) {
              let M = d2(k);
              if (M !== void 0 && (b = true, S = M), b)
                return false;
            }
            return l(o, B), S;
          }
          function h(o) {
            if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
              return true;
          }
          function g2(o) {
            return y(o, h, false);
          }
          function c(o) {
            if (o.length > 0) {
              let d2 = t2(o);
              !d2.expandedStates && !d2.break && (d2.break = "propagated");
            }
            return null;
          }
          function f2(o) {
            let d2 = /* @__PURE__ */ new Set(), v2 = [];
            function S(B) {
              if (B.type === "break-parent" && c(v2), B.type === "group") {
                if (v2.push(B), d2.has(B))
                  return false;
                d2.add(B);
              }
            }
            function b(B) {
              B.type === "group" && v2.pop().break && c(v2);
            }
            l(o, S, b, true);
          }
          function F2(o) {
            return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
          }
          function _(o) {
            return p(o, F2);
          }
          var w2 = (o, d2) => o && o.type === "line" && o.hard && d2 && d2.type === "break-parent";
          function E(o) {
            if (!o)
              return o;
            if (n2(o) || o.type === "fill") {
              let d2 = u(o);
              for (; d2.length > 1 && w2(...d2.slice(-2)); )
                d2.length -= 2;
              if (d2.length > 0) {
                let v2 = E(t2(d2));
                d2[d2.length - 1] = v2;
              }
              return Array.isArray(o) ? d2 : Object.assign(Object.assign({}, o), {}, { parts: d2 });
            }
            switch (o.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d2 = E(o.contents);
                return Object.assign(Object.assign({}, o), {}, { contents: d2 });
              }
              case "if-break": {
                let d2 = E(o.breakContents), v2 = E(o.flatContents);
                return Object.assign(Object.assign({}, o), {}, { breakContents: d2, flatContents: v2 });
              }
            }
            return o;
          }
          function N2(o) {
            return E(I(o));
          }
          function x2(o) {
            switch (o.type) {
              case "fill":
                if (o.parts.every((v2) => v2 === ""))
                  return "";
                break;
              case "group":
                if (!o.contents && !o.id && !o.break && !o.expandedStates)
                  return "";
                if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                  return o.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o.contents)
                  return "";
                break;
              case "if-break":
                if (!o.flatContents && !o.breakContents)
                  return "";
                break;
            }
            if (!n2(o))
              return o;
            let d2 = [];
            for (let v2 of u(o)) {
              if (!v2)
                continue;
              let [S, ...b] = n2(v2) ? u(v2) : [v2];
              typeof S == "string" && typeof t2(d2) == "string" ? d2[d2.length - 1] += S : d2.push(S), d2.push(...b);
            }
            return d2.length === 0 ? "" : d2.length === 1 ? d2[0] : Array.isArray(o) ? d2 : Object.assign(Object.assign({}, o), {}, { parts: d2 });
          }
          function I(o) {
            return p(o, (d2) => x2(d2));
          }
          function P(o) {
            let d2 = [], v2 = o.filter(Boolean);
            for (; v2.length > 0; ) {
              let S = v2.shift();
              if (S) {
                if (n2(S)) {
                  v2.unshift(...u(S));
                  continue;
                }
                if (d2.length > 0 && typeof t2(d2) == "string" && typeof S == "string") {
                  d2[d2.length - 1] += S;
                  continue;
                }
                d2.push(S);
              }
            }
            return d2;
          }
          function $(o) {
            return p(o, (d2) => Array.isArray(d2) ? P(d2) : d2.parts ? Object.assign(Object.assign({}, d2), {}, { parts: P(d2.parts) }) : d2);
          }
          function D(o) {
            return p(o, (d2) => typeof d2 == "string" && d2.includes(`
`) ? T(d2) : d2);
          }
          function T(o) {
            let d2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(d2, o.split(`
`)).parts;
          }
          function m(o) {
            if (o.type === "line")
              return true;
          }
          function C2(o) {
            return y(o, m, false);
          }
          r.exports = { isConcat: n2, getDocParts: u, willBreak: g2, traverseDoc: l, findInDoc: y, mapDoc: p, propagateBreaks: f2, removeLines: _, stripTrailingHardline: N2, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C2 };
        } }), qD = te2({ "src/document/doc-printer.js"(e, r) {
          "use strict";
          ne2();
          var { convertEndOfLineToChars: t2 } = Jn(), s = lt2(), a = Oa(), { fill: n2, cursor: u, indent: i2 } = Un(), { isConcat: l, getDocParts: p } = Yt(), y, h = 1, g2 = 2;
          function c() {
            return { value: "", length: 0, queue: [] };
          }
          function f2(x2, I) {
            return _(x2, { type: "indent" }, I);
          }
          function F2(x2, I, P) {
            return I === Number.NEGATIVE_INFINITY ? x2.root || c() : I < 0 ? _(x2, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x2), {}, { root: x2 }) : _(x2, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x2;
          }
          function _(x2, I, P) {
            let $ = I.type === "dedent" ? x2.queue.slice(0, -1) : [...x2.queue, I], D = "", T = 0, m = 0, C2 = 0;
            for (let k of $)
              switch (k.type) {
                case "indent":
                  v2(), P.useTabs ? o(1) : d2(P.tabWidth);
                  break;
                case "stringAlign":
                  v2(), D += k.n, T += k.n.length;
                  break;
                case "numberAlign":
                  m += 1, C2 += k.n;
                  break;
                default:
                  throw new Error(`Unexpected type '${k.type}'`);
              }
            return b(), Object.assign(Object.assign({}, x2), {}, { value: D, length: T, queue: $ });
            function o(k) {
              D += "	".repeat(k), T += P.tabWidth * k;
            }
            function d2(k) {
              D += " ".repeat(k), T += k;
            }
            function v2() {
              P.useTabs ? S() : b();
            }
            function S() {
              m > 0 && o(m), B();
            }
            function b() {
              C2 > 0 && d2(C2), B();
            }
            function B() {
              m = 0, C2 = 0;
            }
          }
          function w2(x2) {
            if (x2.length === 0)
              return 0;
            let I = 0;
            for (; x2.length > 0 && typeof s(x2) == "string" && /^[\t ]*$/.test(s(x2)); )
              I += x2.pop().length;
            if (x2.length > 0 && typeof s(x2) == "string") {
              let P = s(x2).replace(/[\t ]*$/, "");
              I += s(x2).length - P.length, x2[x2.length - 1] = P;
            }
            return I;
          }
          function E(x2, I, P, $, D) {
            let T = I.length, m = [x2], C2 = [];
            for (; P >= 0; ) {
              if (m.length === 0) {
                if (T === 0)
                  return true;
                m.push(I[--T]);
                continue;
              }
              let { mode: o, doc: d2 } = m.pop();
              if (typeof d2 == "string")
                C2.push(d2), P -= a(d2);
              else if (l(d2) || d2.type === "fill") {
                let v2 = p(d2);
                for (let S = v2.length - 1; S >= 0; S--)
                  m.push({ mode: o, doc: v2[S] });
              } else
                switch (d2.type) {
                  case "indent":
                  case "align":
                  case "indent-if-break":
                  case "label":
                    m.push({ mode: o, doc: d2.contents });
                    break;
                  case "trim":
                    P += w2(C2);
                    break;
                  case "group": {
                    if (D && d2.break)
                      return false;
                    let v2 = d2.break ? h : o, S = d2.expandedStates && v2 === h ? s(d2.expandedStates) : d2.contents;
                    m.push({ mode: v2, doc: S });
                    break;
                  }
                  case "if-break": {
                    let S = (d2.groupId ? y[d2.groupId] || g2 : o) === h ? d2.breakContents : d2.flatContents;
                    S && m.push({ mode: o, doc: S });
                    break;
                  }
                  case "line":
                    if (o === h || d2.hard)
                      return true;
                    d2.soft || (C2.push(" "), P--);
                    break;
                  case "line-suffix":
                    $ = true;
                    break;
                  case "line-suffix-boundary":
                    if ($)
                      return false;
                    break;
                }
            }
            return false;
          }
          function N2(x2, I) {
            y = {};
            let P = I.printWidth, $ = t2(I.endOfLine), D = 0, T = [{ ind: c(), mode: h, doc: x2 }], m = [], C2 = false, o = [];
            for (; T.length > 0; ) {
              let { ind: v2, mode: S, doc: b } = T.pop();
              if (typeof b == "string") {
                let B = $ !== `
` ? b.replace(/\n/g, $) : b;
                m.push(B), D += a(B);
              } else if (l(b)) {
                let B = p(b);
                for (let k = B.length - 1; k >= 0; k--)
                  T.push({ ind: v2, mode: S, doc: B[k] });
              } else
                switch (b.type) {
                  case "cursor":
                    m.push(u.placeholder);
                    break;
                  case "indent":
                    T.push({ ind: f2(v2, I), mode: S, doc: b.contents });
                    break;
                  case "align":
                    T.push({ ind: F2(v2, b.n, I), mode: S, doc: b.contents });
                    break;
                  case "trim":
                    D -= w2(m);
                    break;
                  case "group":
                    switch (S) {
                      case g2:
                        if (!C2) {
                          T.push({ ind: v2, mode: b.break ? h : g2, doc: b.contents });
                          break;
                        }
                      case h: {
                        C2 = false;
                        let B = { ind: v2, mode: g2, doc: b.contents }, k = P - D, M = o.length > 0;
                        if (!b.break && E(B, T, k, M))
                          T.push(B);
                        else if (b.expandedStates) {
                          let R = s(b.expandedStates);
                          if (b.break) {
                            T.push({ ind: v2, mode: h, doc: R });
                            break;
                          } else
                            for (let q2 = 1; q2 < b.expandedStates.length + 1; q2++)
                              if (q2 >= b.expandedStates.length) {
                                T.push({ ind: v2, mode: h, doc: R });
                                break;
                              } else {
                                let J3 = b.expandedStates[q2], L = { ind: v2, mode: g2, doc: J3 };
                                if (E(L, T, k, M)) {
                                  T.push(L);
                                  break;
                                }
                              }
                        } else
                          T.push({ ind: v2, mode: h, doc: b.contents });
                        break;
                      }
                    }
                    b.id && (y[b.id] = s(T).mode);
                    break;
                  case "fill": {
                    let B = P - D, { parts: k } = b;
                    if (k.length === 0)
                      break;
                    let [M, R] = k, q2 = { ind: v2, mode: g2, doc: M }, J3 = { ind: v2, mode: h, doc: M }, L = E(q2, [], B, o.length > 0, true);
                    if (k.length === 1) {
                      L ? T.push(q2) : T.push(J3);
                      break;
                    }
                    let Q2 = { ind: v2, mode: g2, doc: R }, V = { ind: v2, mode: h, doc: R };
                    if (k.length === 2) {
                      L ? T.push(Q2, q2) : T.push(V, J3);
                      break;
                    }
                    k.splice(0, 2);
                    let j2 = { ind: v2, mode: S, doc: n2(k) }, Y3 = k[0];
                    E({ ind: v2, mode: g2, doc: [M, R, Y3] }, [], B, o.length > 0, true) ? T.push(j2, Q2, q2) : L ? T.push(j2, V, q2) : T.push(j2, V, J3);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let B = b.groupId ? y[b.groupId] : S;
                    if (B === h) {
                      let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i2(b.contents);
                      k && T.push({ ind: v2, mode: S, doc: k });
                    }
                    if (B === g2) {
                      let k = b.type === "if-break" ? b.flatContents : b.negate ? i2(b.contents) : b.contents;
                      k && T.push({ ind: v2, mode: S, doc: k });
                    }
                    break;
                  }
                  case "line-suffix":
                    o.push({ ind: v2, mode: S, doc: b.contents });
                    break;
                  case "line-suffix-boundary":
                    o.length > 0 && T.push({ ind: v2, mode: S, doc: { type: "line", hard: true } });
                    break;
                  case "line":
                    switch (S) {
                      case g2:
                        if (b.hard)
                          C2 = true;
                        else {
                          b.soft || (m.push(" "), D += 1);
                          break;
                        }
                      case h:
                        if (o.length > 0) {
                          T.push({ ind: v2, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                          break;
                        }
                        b.literal ? v2.root ? (m.push($, v2.root.value), D = v2.root.length) : (m.push($), D = 0) : (D -= w2(m), m.push($ + v2.value), D = v2.length);
                        break;
                    }
                    break;
                  case "label":
                    T.push({ ind: v2, mode: S, doc: b.contents });
                    break;
                  default:
                }
              T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
            }
            let d2 = m.indexOf(u.placeholder);
            if (d2 !== -1) {
              let v2 = m.indexOf(u.placeholder, d2 + 1), S = m.slice(0, d2).join(""), b = m.slice(d2 + 1, v2).join(""), B = m.slice(v2 + 1).join("");
              return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
            }
            return { formatted: m.join("") };
          }
          r.exports = { printDocToString: N2 };
        } }), MD = te2({ "src/document/doc-debug.js"(e, r) {
          "use strict";
          ne2();
          var { isConcat: t2, getDocParts: s } = Yt();
          function a(u) {
            if (!u)
              return "";
            if (t2(u)) {
              let i2 = [];
              for (let l of s(u))
                if (t2(l))
                  i2.push(...a(l).parts);
                else {
                  let p = a(l);
                  p !== "" && i2.push(p);
                }
              return { type: "concat", parts: i2 };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
          }
          function n2(u) {
            let i2 = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
            return p(a(u));
            function p(h, g2, c) {
              if (typeof h == "string")
                return JSON.stringify(h);
              if (t2(h)) {
                let f2 = s(h).map(p).filter(Boolean);
                return f2.length === 1 ? f2[0] : `[${f2.join(", ")}]`;
              }
              if (h.type === "line") {
                let f2 = Array.isArray(c) && c[g2 + 1] && c[g2 + 1].type === "break-parent";
                return h.literal ? f2 ? "literalline" : "literallineWithoutBreakParent" : h.hard ? f2 ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
              }
              if (h.type === "break-parent")
                return Array.isArray(c) && c[g2 - 1] && c[g2 - 1].type === "line" && c[g2 - 1].hard ? void 0 : "breakParent";
              if (h.type === "trim")
                return "trim";
              if (h.type === "indent")
                return "indent(" + p(h.contents) + ")";
              if (h.type === "align")
                return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h.contents) + ")" : h.n < 0 ? "dedent(" + p(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + p(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + p(h.contents) + ")";
              if (h.type === "if-break")
                return "ifBreak(" + p(h.breakContents) + (h.flatContents ? ", " + p(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y(h.groupId)} }` : "") + ")";
              if (h.type === "indent-if-break") {
                let f2 = [];
                h.negate && f2.push("negate: true"), h.groupId && f2.push(`groupId: ${y(h.groupId)}`);
                let F2 = f2.length > 0 ? `, { ${f2.join(", ")} }` : "";
                return `indentIfBreak(${p(h.contents)}${F2})`;
              }
              if (h.type === "group") {
                let f2 = [];
                h.break && h.break !== "propagated" && f2.push("shouldBreak: true"), h.id && f2.push(`id: ${y(h.id)}`);
                let F2 = f2.length > 0 ? `, { ${f2.join(", ")} }` : "";
                return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((_) => p(_)).join(",")}]${F2})` : `group(${p(h.contents)}${F2})`;
              }
              if (h.type === "fill")
                return `fill([${h.parts.map((f2) => p(f2)).join(", ")}])`;
              if (h.type === "line-suffix")
                return "lineSuffix(" + p(h.contents) + ")";
              if (h.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (h.type === "label")
                return `label(${JSON.stringify(h.label)}, ${p(h.contents)})`;
              throw new Error("Unknown doc type " + h.type);
            }
            function y(h) {
              if (typeof h != "symbol")
                return JSON.stringify(String(h));
              if (h in i2)
                return i2[h];
              let g2 = String(h).slice(7, -1) || "symbol";
              for (let c = 0; ; c++) {
                let f2 = g2 + (c > 0 ? ` #${c}` : "");
                if (!l.has(f2))
                  return l.add(f2), i2[h] = `Symbol.for(${JSON.stringify(f2)})`;
              }
            }
          }
          r.exports = { printDocToDebug: n2 };
        } }), qe = te2({ "src/document/index.js"(e, r) {
          "use strict";
          ne2(), r.exports = { builders: Un(), printer: qD(), utils: Yt(), debug: MD() };
        } }), ja = {};
        Kt(ja, { default: () => RD });
        function RD(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var $D = ht({ "node_modules/escape-string-regexp/index.js"() {
          ne2();
        } }), qa = te2({ "node_modules/semver/internal/debug.js"(e, r) {
          ne2();
          var t2 = typeof wt == "object" && wt.env && wt.env.NODE_DEBUG && /\bsemver\b/i.test(wt.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, a = new Array(s), n2 = 0; n2 < s; n2++)
              a[n2] = arguments[n2];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          r.exports = t2;
        } }), Ma = te2({ "node_modules/semver/internal/constants.js"(e, r) {
          ne2();
          var t2 = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n2 = 16;
          r.exports = { SEMVER_SPEC_VERSION: t2, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n2 };
        } }), VD = te2({ "node_modules/semver/internal/re.js"(e, r) {
          ne2();
          var { MAX_SAFE_COMPONENT_LENGTH: t2 } = Ma(), s = qa();
          e = r.exports = {};
          var a = e.re = [], n2 = e.src = [], u = e.t = {}, i2 = 0, l = (p, y, h) => {
            let g2 = i2++;
            s(p, g2, y), u[p] = g2, n2[g2] = y, a[g2] = new RegExp(y, h ? "g" : void 0);
          };
          l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n2[u.NUMERICIDENTIFIER]})\\.(${n2[u.NUMERICIDENTIFIER]})\\.(${n2[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n2[u.NUMERICIDENTIFIERLOOSE]})\\.(${n2[u.NUMERICIDENTIFIERLOOSE]})\\.(${n2[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n2[u.NUMERICIDENTIFIER]}|${n2[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n2[u.NUMERICIDENTIFIERLOOSE]}|${n2[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n2[u.PRERELEASEIDENTIFIER]}(?:\\.${n2[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n2[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n2[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n2[u.BUILDIDENTIFIER]}(?:\\.${n2[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n2[u.MAINVERSION]}${n2[u.PRERELEASE]}?${n2[u.BUILD]}?`), l("FULL", `^${n2[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n2[u.MAINVERSIONLOOSE]}${n2[u.PRERELEASELOOSE]}?${n2[u.BUILD]}?`), l("LOOSE", `^${n2[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n2[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n2[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n2[u.XRANGEIDENTIFIER]})(?:\\.(${n2[u.XRANGEIDENTIFIER]})(?:\\.(${n2[u.XRANGEIDENTIFIER]})(?:${n2[u.PRERELEASE]})?${n2[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n2[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n2[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n2[u.XRANGEIDENTIFIERLOOSE]})(?:${n2[u.PRERELEASELOOSE]})?${n2[u.BUILD]}?)?)?`), l("XRANGE", `^${n2[u.GTLT]}\\s*${n2[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n2[u.GTLT]}\\s*${n2[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t2}})(?:\\.(\\d{1,${t2}}))?(?:\\.(\\d{1,${t2}}))?(?:$|[^\\d])`), l("COERCERTL", n2[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n2[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n2[u.LONETILDE]}${n2[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n2[u.LONETILDE]}${n2[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n2[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n2[u.LONECARET]}${n2[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n2[u.LONECARET]}${n2[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n2[u.GTLT]}\\s*(${n2[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n2[u.GTLT]}\\s*(${n2[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n2[u.GTLT]}\\s*(${n2[u.LOOSEPLAIN]}|${n2[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n2[u.XRANGEPLAIN]})\\s+-\\s+(${n2[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n2[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n2[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), WD = te2({ "node_modules/semver/internal/parse-options.js"(e, r) {
          ne2();
          var t2 = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t2.filter((n2) => a[n2]).reduce((n2, u) => (n2[u] = true, n2), {}) : {};
          r.exports = s;
        } }), HD = te2({ "node_modules/semver/internal/identifiers.js"(e, r) {
          ne2();
          var t2 = /^[0-9]+$/, s = (n2, u) => {
            let i2 = t2.test(n2), l = t2.test(u);
            return i2 && l && (n2 = +n2, u = +u), n2 === u ? 0 : i2 && !l ? -1 : l && !i2 ? 1 : n2 < u ? -1 : 1;
          }, a = (n2, u) => s(u, n2);
          r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
        } }), GD = te2({ "node_modules/semver/classes/semver.js"(e, r) {
          ne2();
          var t2 = qa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Ma(), { re: n2, t: u } = VD(), i2 = WD(), { compareIdentifiers: l } = HD(), p = class {
            constructor(y, h) {
              if (h = i2(h), y instanceof p) {
                if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease)
                  return y;
                y = y.version;
              } else if (typeof y != "string")
                throw new TypeError(`Invalid Version: ${y}`);
              if (y.length > s)
                throw new TypeError(`version is longer than ${s} characters`);
              t2("SemVer", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
              let g2 = y.trim().match(h.loose ? n2[u.LOOSE] : n2[u.FULL]);
              if (!g2)
                throw new TypeError(`Invalid Version: ${y}`);
              if (this.raw = y, this.major = +g2[1], this.minor = +g2[2], this.patch = +g2[3], this.major > a || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0)
                throw new TypeError("Invalid patch version");
              g2[4] ? this.prerelease = g2[4].split(".").map((c) => {
                if (/^[0-9]+$/.test(c)) {
                  let f2 = +c;
                  if (f2 >= 0 && f2 < a)
                    return f2;
                }
                return c;
              }) : this.prerelease = [], this.build = g2[5] ? g2[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y) {
              if (t2("SemVer.compare", this.version, this.options, y), !(y instanceof p)) {
                if (typeof y == "string" && y === this.version)
                  return 0;
                y = new p(y, this.options);
              }
              return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
            }
            compareMain(y) {
              return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
            }
            comparePre(y) {
              if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length)
                return -1;
              if (!this.prerelease.length && y.prerelease.length)
                return 1;
              if (!this.prerelease.length && !y.prerelease.length)
                return 0;
              let h = 0;
              do {
                let g2 = this.prerelease[h], c = y.prerelease[h];
                if (t2("prerelease compare", h, g2, c), g2 === void 0 && c === void 0)
                  return 0;
                if (c === void 0)
                  return 1;
                if (g2 === void 0)
                  return -1;
                if (g2 === c)
                  continue;
                return l(g2, c);
              } while (++h);
            }
            compareBuild(y) {
              y instanceof p || (y = new p(y, this.options));
              let h = 0;
              do {
                let g2 = this.build[h], c = y.build[h];
                if (t2("prerelease compare", h, g2, c), g2 === void 0 && c === void 0)
                  return 0;
                if (c === void 0)
                  return 1;
                if (g2 === void 0)
                  return -1;
                if (g2 === c)
                  continue;
                return l(g2, c);
              } while (++h);
            }
            inc(y, h) {
              switch (y) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let g2 = this.prerelease.length;
                    for (; --g2 >= 0; )
                      typeof this.prerelease[g2] == "number" && (this.prerelease[g2]++, g2 = -2);
                    g2 === -1 && this.prerelease.push(0);
                  }
                  h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r.exports = p;
        } }), zn = te2({ "node_modules/semver/functions/compare.js"(e, r) {
          ne2();
          var t2 = GD(), s = (a, n2, u) => new t2(a, u).compare(new t2(n2, u));
          r.exports = s;
        } }), UD = te2({ "node_modules/semver/functions/lt.js"(e, r) {
          ne2();
          var t2 = zn(), s = (a, n2, u) => t2(a, n2, u) < 0;
          r.exports = s;
        } }), JD = te2({ "node_modules/semver/functions/gte.js"(e, r) {
          ne2();
          var t2 = zn(), s = (a, n2, u) => t2(a, n2, u) >= 0;
          r.exports = s;
        } }), zD = te2({ "src/utils/arrayify.js"(e, r) {
          "use strict";
          ne2(), r.exports = (t2, s) => Object.entries(t2).map((a) => {
            let [n2, u] = a;
            return Object.assign({ [s]: n2 }, u);
          });
        } }), XD = te2({ "node_modules/outdent/lib/index.js"(e, r) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t2() {
            for (var E = [], N2 = 0; N2 < arguments.length; N2++)
              E[N2] = arguments[N2];
          }
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          function a() {
            return { add: t2, delete: t2, get: t2, set: t2, has: function(E) {
              return false;
            } };
          }
          var n2 = Object.prototype.hasOwnProperty, u = function(E, N2) {
            return n2.call(E, N2);
          };
          function i2(E, N2) {
            for (var x2 in N2)
              u(N2, x2) && (E[x2] = N2[x2]);
            return E;
          }
          var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function c(E, N2, x2) {
            var I = 0, P = E[0].match(h);
            P && (I = P[1].length);
            var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($, "g");
            N2 && (E = E.slice(1));
            var T = x2.newline, m = x2.trimLeadingNewline, C2 = x2.trimTrailingNewline, o = typeof T == "string", d2 = E.length, v2 = E.map(function(S, b) {
              return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d2 - 1 && C2 && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                return T;
              })), S;
            });
            return v2;
          }
          function f2(E, N2) {
            for (var x2 = "", I = 0, P = E.length; I < P; I++)
              x2 += E[I], I < P - 1 && (x2 += N2[I]);
            return x2;
          }
          function F2(E) {
            return u(E, "raw") && u(E, "length");
          }
          function _(E) {
            var N2 = s(), x2 = s();
            function I($) {
              for (var D = [], T = 1; T < arguments.length; T++)
                D[T - 1] = arguments[T];
              if (F2($)) {
                var m = $, C2 = (D[0] === I || D[0] === w2) && g2.test(m[0]) && y.test(m[1]), o = C2 ? x2 : N2, d2 = o.get(m);
                if (d2 || (d2 = c(m, C2, E), o.set(m, d2)), D.length === 0)
                  return d2[0];
                var v2 = f2(d2, C2 ? D.slice(1) : D);
                return v2;
              } else
                return _(i2(i2({}, E), $ || {}));
            }
            var P = i2(I, { string: function($) {
              return c([$], false, E)[0];
            } });
            return P;
          }
          var w2 = _({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = w2, e.default = w2, typeof r < "u")
            try {
              r.exports = w2, Object.defineProperty(w2, "__esModule", { value: true }), w2.default = w2, w2.outdent = w2;
            } catch {
            }
        } }), KD = te2({ "src/main/core-options.js"(e, r) {
          "use strict";
          ne2();
          var { outdent: t2 } = XD(), s = "Config", a = "Editor", n2 = "Format", u = "Other", i2 = "Output", l = "Global", p = "Special", y = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n2, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i2, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y };
        } }), Xn = te2({ "src/main/support.js"(e, r) {
          "use strict";
          ne2();
          var t2 = { compare: zn(), lt: UD(), gte: JD() }, s = zD(), a = Ia().version, n2 = KD().options;
          function u() {
            let { plugins: l = [], showUnreleased: p = false, showDeprecated: y = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g2 = a.split("-", 1)[0], c = l.flatMap((E) => E.languages || []).filter(F2), f2 = s(Object.assign({}, ...l.map((E) => {
              let { options: N2 } = E;
              return N2;
            }), n2), "name").filter((E) => F2(E) && _(E)).sort((E, N2) => E.name === N2.name ? 0 : E.name < N2.name ? -1 : 1).map(w2).map((E) => {
              E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F2).sort((x2, I) => t2.compare(I.since, x2.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x2) => F2(x2) && _(x2)), E.name === "parser" && i2(E, c, l));
              let N2 = Object.fromEntries(l.filter((x2) => x2.defaultOptions && x2.defaultOptions[E.name] !== void 0).map((x2) => [x2.name, x2.defaultOptions[E.name]]));
              return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N2 });
            });
            return { languages: c, options: f2 };
            function F2(E) {
              return p || !("since" in E) || E.since && t2.gte(g2, E.since);
            }
            function _(E) {
              return y || !("deprecated" in E) || E.deprecated && t2.lt(g2, E.deprecated);
            }
            function w2(E) {
              if (h)
                return E;
              let { cliName: N2, cliCategory: x2, cliDescription: I } = E;
              return Hn(E, hD);
            }
          }
          function i2(l, p, y) {
            let h = new Set(l.choices.map((g2) => g2.value));
            for (let g2 of p)
              if (g2.parsers) {
                for (let c of g2.parsers)
                  if (!h.has(c)) {
                    h.add(c);
                    let f2 = y.find((_) => _.parsers && _.parsers[c]), F2 = g2.name;
                    f2 && f2.name && (F2 += ` (plugin: ${f2.name})`), l.choices.push({ value: c, description: F2 });
                  }
              }
          }
          r.exports = { getSupportInfo: u };
        } }), Kn = te2({ "src/utils/is-non-empty-array.js"(e, r) {
          "use strict";
          ne2();
          function t2(s) {
            return Array.isArray(s) && s.length > 0;
          }
          r.exports = t2;
        } }), Pr = te2({ "src/utils/text/skip.js"(e, r) {
          "use strict";
          ne2();
          function t2(i2) {
            return (l, p, y) => {
              let h = y && y.backwards;
              if (p === false)
                return false;
              let { length: g2 } = l, c = p;
              for (; c >= 0 && c < g2; ) {
                let f2 = l.charAt(c);
                if (i2 instanceof RegExp) {
                  if (!i2.test(f2))
                    return c;
                } else if (!i2.includes(f2))
                  return c;
                h ? c-- : c++;
              }
              return c === -1 || c === g2 ? c : false;
            };
          }
          var s = t2(/\s/), a = t2(" 	"), n2 = t2(",; 	"), u = t2(/[^\n\r]/);
          r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n2, skipEverythingButNewLine: u };
        } }), Ra = te2({ "src/utils/text/skip-inline-comment.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a) {
            if (a === false)
              return false;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (let n2 = a + 2; n2 < s.length; ++n2)
                if (s.charAt(n2) === "*" && s.charAt(n2 + 1) === "/")
                  return n2 + 2;
            }
            return a;
          }
          r.exports = t2;
        } }), $a = te2({ "src/utils/text/skip-trailing-comment.js"(e, r) {
          "use strict";
          ne2();
          var { skipEverythingButNewLine: t2 } = Pr();
          function s(a, n2) {
            return n2 === false ? false : a.charAt(n2) === "/" && a.charAt(n2 + 1) === "/" ? t2(a, n2) : n2;
          }
          r.exports = s;
        } }), Va = te2({ "src/utils/text/skip-newline.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a, n2) {
            let u = n2 && n2.backwards;
            if (a === false)
              return false;
            let i2 = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i2 === `
`)
                return a - 2;
              if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
                return a - 1;
            } else {
              if (i2 === "\r" && s.charAt(a + 1) === `
`)
                return a + 2;
              if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
                return a + 1;
            }
            return a;
          }
          r.exports = t2;
        } }), YD = te2({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Ra(), s = Va(), a = $a(), { skipSpaces: n2 } = Pr();
          function u(i2, l) {
            let p = null, y = l;
            for (; y !== p; )
              p = y, y = n2(i2, y), y = t2(i2, y), y = a(i2, y), y = s(i2, y);
            return y;
          }
          r.exports = u;
        } }), Ue2 = te2({ "src/common/util.js"(e, r) {
          "use strict";
          ne2();
          var { default: t2 } = ($D(), ft(ja)), s = lt2(), { getSupportInfo: a } = Xn(), n2 = Kn(), u = Oa(), { skipWhitespace: i2, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y } = Pr(), h = Ra(), g2 = $a(), c = Va(), f2 = YD(), F2 = (V) => V[V.length - 2];
          function _(V) {
            return (j2, Y3, ie2) => {
              let ee2 = ie2 && ie2.backwards;
              if (Y3 === false)
                return false;
              let { length: ce2 } = j2, W = Y3;
              for (; W >= 0 && W < ce2; ) {
                let K = j2.charAt(W);
                if (V instanceof RegExp) {
                  if (!V.test(K))
                    return W;
                } else if (!V.includes(K))
                  return W;
                ee2 ? W-- : W++;
              }
              return W === -1 || W === ce2 ? W : false;
            };
          }
          function w2(V, j2) {
            let Y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie2 = l(V, Y3.backwards ? j2 - 1 : j2, Y3), ee2 = c(V, ie2, Y3);
            return ie2 !== ee2;
          }
          function E(V, j2, Y3) {
            for (let ie2 = j2; ie2 < Y3; ++ie2)
              if (V.charAt(ie2) === `
`)
                return true;
            return false;
          }
          function N2(V, j2, Y3) {
            let ie2 = Y3(j2) - 1;
            ie2 = l(V, ie2, { backwards: true }), ie2 = c(V, ie2, { backwards: true }), ie2 = l(V, ie2, { backwards: true });
            let ee2 = c(V, ie2, { backwards: true });
            return ie2 !== ee2;
          }
          function x2(V, j2) {
            let Y3 = null, ie2 = j2;
            for (; ie2 !== Y3; )
              Y3 = ie2, ie2 = p(V, ie2), ie2 = h(V, ie2), ie2 = l(V, ie2);
            return ie2 = g2(V, ie2), ie2 = c(V, ie2), ie2 !== false && w2(V, ie2);
          }
          function I(V, j2, Y3) {
            return x2(V, Y3(j2));
          }
          function P(V, j2, Y3) {
            return f2(V, Y3(j2));
          }
          function $(V, j2, Y3) {
            return V.charAt(P(V, j2, Y3));
          }
          function D(V, j2) {
            let Y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l(V, Y3.backwards ? j2 - 1 : j2, Y3) !== j2;
          }
          function T(V, j2) {
            let Y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie2 = 0;
            for (let ee2 = Y3; ee2 < V.length; ++ee2)
              V[ee2] === "	" ? ie2 = ie2 + j2 - ie2 % j2 : ie2++;
            return ie2;
          }
          function m(V, j2) {
            let Y3 = V.lastIndexOf(`
`);
            return Y3 === -1 ? 0 : T(V.slice(Y3 + 1).match(/^[\t ]*/)[0], j2);
          }
          function C2(V, j2) {
            let Y3 = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee2 = j2 === "'" ? ie2 : Y3, ce2 = ee2 === ie2 ? Y3 : ie2, W = ee2;
            if (V.includes(ee2.quote) || V.includes(ce2.quote)) {
              let K = (V.match(ee2.regex) || []).length, de2 = (V.match(ce2.regex) || []).length;
              W = K > de2 ? ce2 : ee2;
            }
            return W;
          }
          function o(V, j2) {
            let Y3 = V.slice(1, -1), ie2 = j2.parser === "json" || j2.parser === "json5" && j2.quoteProps === "preserve" && !j2.singleQuote ? '"' : j2.__isInHtmlAttribute ? "'" : C2(Y3, j2.singleQuote ? "'" : '"').quote;
            return d2(Y3, ie2, !(j2.parser === "css" || j2.parser === "less" || j2.parser === "scss" || j2.__embeddedInHtml));
          }
          function d2(V, j2, Y3) {
            let ie2 = j2 === '"' ? "'" : '"', ee2 = /\\(.)|(["'])/gs, ce2 = V.replace(ee2, (W, K, de2) => K === ie2 ? K : de2 === j2 ? "\\" + de2 : de2 || (Y3 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
            return j2 + ce2 + j2;
          }
          function v2(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function S(V, j2) {
            let Y3 = V.match(new RegExp(`(${t2(j2)})+`, "g"));
            return Y3 === null ? 0 : Y3.reduce((ie2, ee2) => Math.max(ie2, ee2.length / j2.length), 0);
          }
          function b(V, j2) {
            let Y3 = V.match(new RegExp(`(${t2(j2)})+`, "g"));
            if (Y3 === null)
              return 0;
            let ie2 = /* @__PURE__ */ new Map(), ee2 = 0;
            for (let ce2 of Y3) {
              let W = ce2.length / j2.length;
              ie2.set(W, true), W > ee2 && (ee2 = W);
            }
            for (let ce2 = 1; ce2 < ee2; ce2++)
              if (!ie2.get(ce2))
                return ce2;
            return ee2 + 1;
          }
          function B(V, j2) {
            (V.comments || (V.comments = [])).push(j2), j2.printed = false, j2.nodeDescription = Q2(V);
          }
          function k(V, j2) {
            j2.leading = true, j2.trailing = false, B(V, j2);
          }
          function M(V, j2, Y3) {
            j2.leading = false, j2.trailing = false, Y3 && (j2.marker = Y3), B(V, j2);
          }
          function R(V, j2) {
            j2.leading = false, j2.trailing = true, B(V, j2);
          }
          function q2(V, j2) {
            let { languages: Y3 } = a({ plugins: j2.plugins }), ie2 = Y3.find((ee2) => {
              let { name: ce2 } = ee2;
              return ce2.toLowerCase() === V;
            }) || Y3.find((ee2) => {
              let { aliases: ce2 } = ee2;
              return Array.isArray(ce2) && ce2.includes(V);
            }) || Y3.find((ee2) => {
              let { extensions: ce2 } = ee2;
              return Array.isArray(ce2) && ce2.includes(`.${V}`);
            });
            return ie2 && ie2.parsers[0];
          }
          function J3(V) {
            return V && V.type === "front-matter";
          }
          function L(V) {
            let j2 = /* @__PURE__ */ new WeakMap();
            return function(Y3) {
              return j2.has(Y3) || j2.set(Y3, Symbol(V)), j2.get(Y3);
            };
          }
          function Q2(V) {
            let j2 = V.type || V.kind || "(unknown type)", Y3 = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return Y3.length > 20 && (Y3 = Y3.slice(0, 19) + "â¦"), j2 + (Y3 ? " " + Y3 : "");
          }
          r.exports = { inferParserByLanguage: q2, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F2, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f2, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: _, skipWhitespace: i2, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y, skipInlineComment: h, skipTrailingComment: g2, skipNewline: c, isNextLineEmptyAfterIndex: x2, isNextLineEmpty: I, isPreviousLineEmpty: N2, hasNewline: w2, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C2, printString: o, printNumber: v2, makeString: d2, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J3, isNonEmptyArray: n2, createGroupIdMapper: L };
        } }), Wa = {};
        Kt(Wa, { basename: () => za, default: () => Ka, delimiter: () => Mn, dirname: () => Ja, extname: () => Xa, isAbsolute: () => Qn, join: () => Ga, normalize: () => Yn, relative: () => Ua, resolve: () => wr2, sep: () => qn });
        function Ha(e, r) {
          for (var t2 = 0, s = e.length - 1; s >= 0; s--) {
            var a = e[s];
            a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t2++) : t2 && (e.splice(s, 1), t2--);
          }
          if (r)
            for (; t2--; t2)
              e.unshift("..");
          return e;
        }
        function wr2() {
          for (var e = "", r = false, t2 = arguments.length - 1; t2 >= -1 && !r; t2--) {
            var s = t2 >= 0 ? arguments[t2] : "/";
            if (typeof s != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s)
              continue;
            e = s + "/" + e, r = s.charAt(0) === "/";
          }
          return e = Ha(Zn(e.split("/"), function(a) {
            return !!a;
          }), !r).join("/"), (r ? "/" : "") + e || ".";
        }
        function Yn(e) {
          var r = Qn(e), t2 = Ya(e, -1) === "/";
          return e = Ha(Zn(e.split("/"), function(s) {
            return !!s;
          }), !r).join("/"), !e && !r && (e = "."), e && t2 && (e += "/"), (r ? "/" : "") + e;
        }
        function Qn(e) {
          return e.charAt(0) === "/";
        }
        function Ga() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Yn(Zn(e, function(r, t2) {
            if (typeof r != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return r;
          }).join("/"));
        }
        function Ua(e, r) {
          e = wr2(e).substr(1), r = wr2(r).substr(1);
          function t2(p) {
            for (var y = 0; y < p.length && p[y] === ""; y++)
              ;
            for (var h = p.length - 1; h >= 0 && p[h] === ""; h--)
              ;
            return y > h ? [] : p.slice(y, h - y + 1);
          }
          for (var s = t2(e.split("/")), a = t2(r.split("/")), n2 = Math.min(s.length, a.length), u = n2, i2 = 0; i2 < n2; i2++)
            if (s[i2] !== a[i2]) {
              u = i2;
              break;
            }
          for (var l = [], i2 = u; i2 < s.length; i2++)
            l.push("..");
          return l = l.concat(a.slice(u)), l.join("/");
        }
        function Ja(e) {
          var r = Ir2(e), t2 = r[0], s = r[1];
          return !t2 && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t2 + s);
        }
        function za(e, r) {
          var t2 = Ir2(e)[2];
          return r && t2.substr(-1 * r.length) === r && (t2 = t2.substr(0, t2.length - r.length)), t2;
        }
        function Xa(e) {
          return Ir2(e)[3];
        }
        function Zn(e, r) {
          if (e.filter)
            return e.filter(r);
          for (var t2 = [], s = 0; s < e.length; s++)
            r(e[s], s, e) && t2.push(e[s]);
          return t2;
        }
        var Na, Ir2, qn, Mn, Ka, Ya, QD = ht({ "node-modules-polyfills:path"() {
          ne2(), Na = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir2 = function(e) {
            return Na.exec(e).slice(1);
          }, qn = "/", Mn = ":", Ka = { extname: Xa, basename: za, dirname: Ja, sep: qn, delimiter: Mn, relative: Ua, join: Ga, isAbsolute: Qn, normalize: Yn, resolve: wr2 }, Ya = "ab".substr(-1) === "b" ? function(e, r, t2) {
            return e.substr(r, t2);
          } : function(e, r, t2) {
            return r < 0 && (r = e.length + r), e.substr(r, t2);
          };
        } }), ZD = te2({ "node-modules-polyfills-commonjs:path"(e, r) {
          ne2();
          var t2 = (QD(), ft(Wa));
          if (t2 && t2.default) {
            r.exports = t2.default;
            for (let s in t2)
              r.exports[s] = t2[s];
          } else
            t2 && (r.exports = t2);
        } }), Qt = te2({ "src/common/errors.js"(e, r) {
          "use strict";
          ne2();
          var t2 = class extends Error {
          }, s = class extends Error {
          }, a = class extends Error {
          }, n2 = class extends Error {
          };
          r.exports = { ConfigError: t2, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n2 };
        } }), vt = {};
        Kt(vt, { __assign: () => Nr, __asyncDelegator: () => fm, __asyncGenerator: () => pm, __asyncValues: () => Dm, __await: () => Xt, __awaiter: () => sm, __classPrivateFieldGet: () => ym, __classPrivateFieldSet: () => hm, __createBinding: () => am, __decorate: () => rm, __exportStar: () => om, __extends: () => em, __generator: () => im, __importDefault: () => gm, __importStar: () => dm, __makeTemplateObject: () => mm, __metadata: () => um, __param: () => nm, __read: () => Qa, __rest: () => tm, __spread: () => lm, __spreadArrays: () => cm, __values: () => Rn });
        function em(e, r) {
          Br2(e, r);
          function t2() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (t2.prototype = r.prototype, new t2());
        }
        function tm(e, r) {
          var t2 = {};
          for (var s in e)
            Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t2[s] = e[s]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
              r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t2[s[a]] = e[s[a]]);
          return t2;
        }
        function rm(e, r, t2, s) {
          var a = arguments.length, n2 = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t2) : s, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            n2 = Reflect.decorate(e, r, t2, s);
          else
            for (var i2 = e.length - 1; i2 >= 0; i2--)
              (u = e[i2]) && (n2 = (a < 3 ? u(n2) : a > 3 ? u(r, t2, n2) : u(r, t2)) || n2);
          return a > 3 && n2 && Object.defineProperty(r, t2, n2), n2;
        }
        function nm(e, r) {
          return function(t2, s) {
            r(t2, s, e);
          };
        }
        function um(e, r) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e, r);
        }
        function sm(e, r, t2, s) {
          function a(n2) {
            return n2 instanceof t2 ? n2 : new t2(function(u) {
              u(n2);
            });
          }
          return new (t2 || (t2 = Promise))(function(n2, u) {
            function i2(y) {
              try {
                p(s.next(y));
              } catch (h) {
                u(h);
              }
            }
            function l(y) {
              try {
                p(s.throw(y));
              } catch (h) {
                u(h);
              }
            }
            function p(y) {
              y.done ? n2(y.value) : a(y.value).then(i2, l);
            }
            p((s = s.apply(e, r || [])).next());
          });
        }
        function im(e, r) {
          var t2 = { label: 0, sent: function() {
            if (n2[0] & 1)
              throw n2[1];
            return n2[1];
          }, trys: [], ops: [] }, s, a, n2, u;
          return u = { next: i2(0), throw: i2(1), return: i2(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i2(p) {
            return function(y) {
              return l([p, y]);
            };
          }
          function l(p) {
            if (s)
              throw new TypeError("Generator is already executing.");
            for (; t2; )
              try {
                if (s = 1, a && (n2 = p[0] & 2 ? a.return : p[0] ? a.throw || ((n2 = a.return) && n2.call(a), 0) : a.next) && !(n2 = n2.call(a, p[1])).done)
                  return n2;
                switch (a = 0, n2 && (p = [p[0] & 2, n2.value]), p[0]) {
                  case 0:
                  case 1:
                    n2 = p;
                    break;
                  case 4:
                    return t2.label++, { value: p[1], done: false };
                  case 5:
                    t2.label++, a = p[1], p = [0];
                    continue;
                  case 7:
                    p = t2.ops.pop(), t2.trys.pop();
                    continue;
                  default:
                    if (n2 = t2.trys, !(n2 = n2.length > 0 && n2[n2.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                      t2 = 0;
                      continue;
                    }
                    if (p[0] === 3 && (!n2 || p[1] > n2[0] && p[1] < n2[3])) {
                      t2.label = p[1];
                      break;
                    }
                    if (p[0] === 6 && t2.label < n2[1]) {
                      t2.label = n2[1], n2 = p;
                      break;
                    }
                    if (n2 && t2.label < n2[2]) {
                      t2.label = n2[2], t2.ops.push(p);
                      break;
                    }
                    n2[2] && t2.ops.pop(), t2.trys.pop();
                    continue;
                }
                p = r.call(e, t2);
              } catch (y) {
                p = [6, y], a = 0;
              } finally {
                s = n2 = 0;
              }
            if (p[0] & 5)
              throw p[1];
            return { value: p[0] ? p[1] : void 0, done: true };
          }
        }
        function am(e, r, t2, s) {
          s === void 0 && (s = t2), e[s] = r[t2];
        }
        function om(e, r) {
          for (var t2 in e)
            t2 !== "default" && !r.hasOwnProperty(t2) && (r[t2] = e[t2]);
        }
        function Rn(e) {
          var r = typeof Symbol == "function" && Symbol.iterator, t2 = r && e[r], s = 0;
          if (t2)
            return t2.call(e);
          if (e && typeof e.length == "number")
            return { next: function() {
              return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
            } };
          throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function Qa(e, r) {
          var t2 = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t2)
            return e;
          var s = t2.call(e), a, n2 = [], u;
          try {
            for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; )
              n2.push(a.value);
          } catch (i2) {
            u = { error: i2 };
          } finally {
            try {
              a && !a.done && (t2 = s.return) && t2.call(s);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return n2;
        }
        function lm() {
          for (var e = [], r = 0; r < arguments.length; r++)
            e = e.concat(Qa(arguments[r]));
          return e;
        }
        function cm() {
          for (var e = 0, r = 0, t2 = arguments.length; r < t2; r++)
            e += arguments[r].length;
          for (var s = Array(e), a = 0, r = 0; r < t2; r++)
            for (var n2 = arguments[r], u = 0, i2 = n2.length; u < i2; u++, a++)
              s[a] = n2[u];
          return s;
        }
        function Xt(e) {
          return this instanceof Xt ? (this.v = e, this) : new Xt(e);
        }
        function pm(e, r, t2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s = t2.apply(e, r || []), a, n2 = [];
          return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
            return this;
          }, a;
          function u(g2) {
            s[g2] && (a[g2] = function(c) {
              return new Promise(function(f2, F2) {
                n2.push([g2, c, f2, F2]) > 1 || i2(g2, c);
              });
            });
          }
          function i2(g2, c) {
            try {
              l(s[g2](c));
            } catch (f2) {
              h(n2[0][3], f2);
            }
          }
          function l(g2) {
            g2.value instanceof Xt ? Promise.resolve(g2.value.v).then(p, y) : h(n2[0][2], g2);
          }
          function p(g2) {
            i2("next", g2);
          }
          function y(g2) {
            i2("throw", g2);
          }
          function h(g2, c) {
            g2(c), n2.shift(), n2.length && i2(n2[0][0], n2[0][1]);
          }
        }
        function fm(e) {
          var r, t2;
          return r = {}, s("next"), s("throw", function(a) {
            throw a;
          }), s("return"), r[Symbol.iterator] = function() {
            return this;
          }, r;
          function s(a, n2) {
            r[a] = e[a] ? function(u) {
              return (t2 = !t2) ? { value: Xt(e[a](u)), done: a === "return" } : n2 ? n2(u) : u;
            } : n2;
          }
        }
        function Dm(e) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var r = e[Symbol.asyncIterator], t2;
          return r ? r.call(e) : (e = typeof Rn == "function" ? Rn(e) : e[Symbol.iterator](), t2 = {}, s("next"), s("throw"), s("return"), t2[Symbol.asyncIterator] = function() {
            return this;
          }, t2);
          function s(n2) {
            t2[n2] = e[n2] && function(u) {
              return new Promise(function(i2, l) {
                u = e[n2](u), a(i2, l, u.done, u.value);
              });
            };
          }
          function a(n2, u, i2, l) {
            Promise.resolve(l).then(function(p) {
              n2({ value: p, done: i2 });
            }, u);
          }
        }
        function mm(e, r) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
        }
        function dm(e) {
          if (e && e.__esModule)
            return e;
          var r = {};
          if (e != null)
            for (var t2 in e)
              Object.hasOwnProperty.call(e, t2) && (r[t2] = e[t2]);
          return r.default = e, r;
        }
        function gm(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function ym(e, r) {
          if (!r.has(e))
            throw new TypeError("attempted to get private field on non-instance");
          return r.get(e);
        }
        function hm(e, r, t2) {
          if (!r.has(e))
            throw new TypeError("attempted to set private field on non-instance");
          return r.set(e, t2), t2;
        }
        var Br2, Nr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
          ne2(), Br2 = function(e, r) {
            return Br2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, s) {
              t2.__proto__ = s;
            } || function(t2, s) {
              for (var a in s)
                s.hasOwnProperty(a) && (t2[a] = s[a]);
            }, Br2(e, r);
          }, Nr = function() {
            return Nr = Object.assign || function(r) {
              for (var t2, s = 1, a = arguments.length; s < a; s++) {
                t2 = arguments[s];
                for (var n2 in t2)
                  Object.prototype.hasOwnProperty.call(t2, n2) && (r[n2] = t2[n2]);
              }
              return r;
            }, Nr.apply(this, arguments);
          };
        } }), Za = te2({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
            if (r === null || typeof r != "object")
              return JSON.stringify(r);
            if (Array.isArray(r))
              return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
            let t2 = Object.keys(r);
            return t2.length === 0 ? "{}" : `{ ${t2.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
          }, pair: (r) => {
            let { key: t2, value: s } = r;
            return e.apiDescriptor.value({ [t2]: s });
          } };
        } }), vm = te2({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(Za(), e);
        } }), kr2 = te2({ "scripts/build/shims/chalk.cjs"(e, r) {
          "use strict";
          ne2();
          var t2 = (s) => s;
          t2.grey = t2, t2.red = t2, t2.bold = t2, t2.yellow = t2, t2.blue = t2, t2.default = t2, r.exports = t2;
        } }), eo = te2({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2();
          e.commonDeprecatedHandler = (t2, s, a) => {
            let { descriptor: n2 } = a, u = [`${r.default.yellow(typeof t2 == "string" ? n2.key(t2) : n2.pair(t2))} is deprecated`];
            return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n2.key(s) : n2.pair(s))}`), u.join("; ") + ".";
          };
        } }), Cm = te2({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(eo(), e);
        } }), Em = te2({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2();
          e.commonInvalidHandler = (t2, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t2))} value.`, `Expected ${r.default.blue(a.schemas[t2].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
        } }), to = te2({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(Em(), e);
        } }), Fm = te2({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = [], s = [];
          r.exports = function(a, n2) {
            if (a === n2)
              return 0;
            var u = a;
            a.length > n2.length && (a = n2, n2 = u);
            var i2 = a.length, l = n2.length;
            if (i2 === 0)
              return l;
            if (l === 0)
              return i2;
            for (; i2 > 0 && a.charCodeAt(~-i2) === n2.charCodeAt(~-l); )
              i2--, l--;
            if (i2 === 0)
              return l;
            for (var p = 0; p < i2 && a.charCodeAt(p) === n2.charCodeAt(p); )
              p++;
            if (i2 -= p, l -= p, i2 === 0)
              return l;
            for (var y, h, g2, c, f2 = 0, F2 = 0; f2 < i2; )
              s[p + f2] = a.charCodeAt(p + f2), t2[f2] = ++f2;
            for (; F2 < l; )
              for (y = n2.charCodeAt(p + F2), g2 = F2++, h = F2, f2 = 0; f2 < i2; f2++)
                c = y === s[p + f2] ? g2 : g2 + 1, g2 = t2[f2], h = t2[f2] = g2 > h ? c > h ? h + 1 : c : c > g2 ? g2 + 1 : c;
            return h;
          };
        } }), ro = te2({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2(), t2 = Fm();
          e.levenUnknownHandler = (s, a, n2) => {
            let { descriptor: u, logger: i2, schemas: l } = n2, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h) => t2(s, h) < 3);
            y && p.push(`Did you mean ${r.default.blue(u.key(y))}?`), i2.warn(p.join(" "));
          };
        } }), Am = te2({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(ro(), e);
        } }), Sm = te2({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(Cm(), e), r.__exportStar(to(), e), r.__exportStar(Am(), e);
        } }), Ft = te2({ "node_modules/vnopts/lib/schema.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t2(n2, u) {
            let i2 = new n2(u), l = Object.create(i2);
            for (let p of r)
              p in u && (l[p] = a(u[p], i2, s.prototype[p].length));
            return l;
          }
          e.createSchema = t2;
          var s = class {
            constructor(n2) {
              this.name = n2.name;
            }
            static create(n2) {
              return t2(this, n2);
            }
            default(n2) {
            }
            expected(n2) {
              return "nothing";
            }
            validate(n2, u) {
              return false;
            }
            deprecated(n2, u) {
              return false;
            }
            forward(n2, u) {
            }
            redirect(n2, u) {
            }
            overlap(n2, u, i2) {
              return n2;
            }
            preprocess(n2, u) {
              return n2;
            }
            postprocess(n2, u) {
              return n2;
            }
          };
          e.Schema = s;
          function a(n2, u, i2) {
            return typeof n2 == "function" ? function() {
              for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++)
                p[y] = arguments[y];
              return n2(...p.slice(0, i2 - 1), u, ...p.slice(i2 - 1));
            } : () => n2;
          }
        } }), xm = te2({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft(), t2 = class extends r.Schema {
            constructor(s) {
              super(s), this._sourceName = s.sourceName;
            }
            expected(s) {
              return s.schemas[this._sourceName].expected(s);
            }
            validate(s, a) {
              return a.schemas[this._sourceName].validate(s, a);
            }
            redirect(s, a) {
              return this._sourceName;
            }
          };
          e.AliasSchema = t2;
        } }), bm = te2({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft(), t2 = class extends r.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e.AnySchema = t2;
        } }), Tm = te2({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt)), t2 = Ft(), s = class extends t2.Schema {
            constructor(n2) {
              var { valueSchema: u, name: i2 = u.name } = n2, l = r.__rest(n2, ["valueSchema", "name"]);
              super(Object.assign({}, l, { name: i2 })), this._valueSchema = u;
            }
            expected(n2) {
              return `an array of ${this._valueSchema.expected(n2)}`;
            }
            validate(n2, u) {
              if (!Array.isArray(n2))
                return false;
              let i2 = [];
              for (let l of n2) {
                let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                p !== true && i2.push(p.value);
              }
              return i2.length === 0 ? true : { value: i2 };
            }
            deprecated(n2, u) {
              let i2 = [];
              for (let l of n2) {
                let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                p !== false && i2.push(...p.map((y) => {
                  let { value: h } = y;
                  return { value: [h] };
                }));
              }
              return i2;
            }
            forward(n2, u) {
              let i2 = [];
              for (let l of n2) {
                let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                i2.push(...p.map(a));
              }
              return i2;
            }
            redirect(n2, u) {
              let i2 = [], l = [];
              for (let p of n2) {
                let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                "remain" in y && i2.push(y.remain), l.push(...y.redirect.map(a));
              }
              return i2.length === 0 ? { redirect: l } : { redirect: l, remain: i2 };
            }
            overlap(n2, u) {
              return n2.concat(u);
            }
          };
          e.ArraySchema = s;
          function a(n2) {
            let { from: u, to: i2 } = n2;
            return { from: [u], to: i2 };
          }
        } }), Bm2 = te2({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft(), t2 = class extends r.Schema {
            expected() {
              return "true or false";
            }
            validate(s) {
              return typeof s == "boolean";
            }
          };
          e.BooleanSchema = t2;
        } }), eu = te2({ "node_modules/vnopts/lib/utils.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          function r(c, f2) {
            let F2 = /* @__PURE__ */ Object.create(null);
            for (let _ of c) {
              let w2 = _[f2];
              if (F2[w2])
                throw new Error(`Duplicate ${f2} ${JSON.stringify(w2)}`);
              F2[w2] = _;
            }
            return F2;
          }
          e.recordFromArray = r;
          function t2(c, f2) {
            let F2 = /* @__PURE__ */ new Map();
            for (let _ of c) {
              let w2 = _[f2];
              if (F2.has(w2))
                throw new Error(`Duplicate ${f2} ${JSON.stringify(w2)}`);
              F2.set(w2, _);
            }
            return F2;
          }
          e.mapFromArray = t2;
          function s() {
            let c = /* @__PURE__ */ Object.create(null);
            return (f2) => {
              let F2 = JSON.stringify(f2);
              return c[F2] ? true : (c[F2] = true, false);
            };
          }
          e.createAutoChecklist = s;
          function a(c, f2) {
            let F2 = [], _ = [];
            for (let w2 of c)
              f2(w2) ? F2.push(w2) : _.push(w2);
            return [F2, _];
          }
          e.partition = a;
          function n2(c) {
            return c === Math.floor(c);
          }
          e.isInt = n2;
          function u(c, f2) {
            if (c === f2)
              return 0;
            let F2 = typeof c, _ = typeof f2, w2 = ["undefined", "object", "boolean", "number", "string"];
            return F2 !== _ ? w2.indexOf(F2) - w2.indexOf(_) : F2 !== "string" ? Number(c) - Number(f2) : c.localeCompare(f2);
          }
          e.comparePrimitive = u;
          function i2(c) {
            return c === void 0 ? {} : c;
          }
          e.normalizeDefaultResult = i2;
          function l(c, f2) {
            return c === true ? true : c === false ? { value: f2 } : c;
          }
          e.normalizeValidateResult = l;
          function p(c, f2) {
            let F2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return c === false ? false : c === true ? F2 ? true : [{ value: f2 }] : "value" in c ? [c] : c.length === 0 ? false : c;
          }
          e.normalizeDeprecatedResult = p;
          function y(c, f2) {
            return typeof c == "string" || "key" in c ? { from: f2, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f2, to: c.to };
          }
          e.normalizeTransferResult = y;
          function h(c, f2) {
            return c === void 0 ? [] : Array.isArray(c) ? c.map((F2) => y(F2, f2)) : [y(c, f2)];
          }
          e.normalizeForwardResult = h;
          function g2(c, f2) {
            let F2 = h(typeof c == "object" && "redirect" in c ? c.redirect : c, f2);
            return F2.length === 0 ? { remain: f2, redirect: F2 } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: F2 } : { redirect: F2 };
          }
          e.normalizeRedirectResult = g2;
        } }), Nm = te2({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft(), t2 = eu(), s = class extends r.Schema {
            constructor(a) {
              super(a), this._choices = t2.mapFromArray(a.choices.map((n2) => n2 && typeof n2 == "object" ? n2 : { value: n2 }), "value");
            }
            expected(a) {
              let { descriptor: n2 } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t2.comparePrimitive).map(n2.value), i2 = u.slice(0, -2), l = u.slice(-2);
              return i2.concat(l.join(" or ")).join(", ");
            }
            validate(a) {
              return this._choices.has(a);
            }
            deprecated(a) {
              let n2 = this._choices.get(a);
              return n2 && n2.deprecated ? { value: a } : false;
            }
            forward(a) {
              let n2 = this._choices.get(a);
              return n2 ? n2.forward : void 0;
            }
            redirect(a) {
              let n2 = this._choices.get(a);
              return n2 ? n2.redirect : void 0;
            }
          };
          e.ChoiceSchema = s;
        } }), no = te2({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft(), t2 = class extends r.Schema {
            expected() {
              return "a number";
            }
            validate(s, a) {
              return typeof s == "number";
            }
          };
          e.NumberSchema = t2;
        } }), wm = te2({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = eu(), t2 = no(), s = class extends t2.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a, n2) {
              return n2.normalizeValidateResult(super.validate(a, n2), a) === true && r.isInt(a);
            }
          };
          e.IntegerSchema = s;
        } }), _m = te2({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft(), t2 = class extends r.Schema {
            expected() {
              return "a string";
            }
            validate(s) {
              return typeof s == "string";
            }
          };
          e.StringSchema = t2;
        } }), Pm = te2({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(xm(), e), r.__exportStar(bm(), e), r.__exportStar(Tm(), e), r.__exportStar(Bm2(), e), r.__exportStar(Nm(), e), r.__exportStar(wm(), e), r.__exportStar(no(), e), r.__exportStar(_m(), e);
        } }), Im = te2({ "node_modules/vnopts/lib/defaults.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Za(), t2 = eo(), s = to(), a = ro();
          e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t2.commonDeprecatedHandler;
        } }), km = te2({ "node_modules/vnopts/lib/normalize.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Im(), t2 = eu();
          e.normalize = (a, n2, u) => new s(n2, u).normalize(a);
          var s = class {
            constructor(a, n2) {
              let { logger: u = console, descriptor: i2 = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: y = r.defaultDeprecatedHandler } = n2 || {};
              this._utils = { descriptor: i2, logger: u || { warn: () => {
              } }, schemas: t2.recordFromArray(a, "name"), normalizeDefaultResult: t2.normalizeDefaultResult, normalizeDeprecatedResult: t2.normalizeDeprecatedResult, normalizeForwardResult: t2.normalizeForwardResult, normalizeRedirectResult: t2.normalizeRedirectResult, normalizeValidateResult: t2.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t2.createAutoChecklist();
            }
            normalize(a) {
              let n2 = {}, u = [a], i2 = () => {
                for (; u.length !== 0; ) {
                  let l = u.shift(), p = this._applyNormalization(l, n2);
                  u.push(...p);
                }
              };
              i2();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                if (!(l in n2)) {
                  let y = t2.normalizeDefaultResult(p.default(this._utils));
                  "value" in y && u.push({ [l]: y.value });
                }
              }
              i2();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                l in n2 && (n2[l] = p.postprocess(n2[l], this._utils));
              }
              return n2;
            }
            _applyNormalization(a, n2) {
              let u = [], [i2, l] = t2.partition(Object.keys(a), (p) => p in this._utils.schemas);
              for (let p of i2) {
                let y = this._utils.schemas[p], h = y.preprocess(a[p], this._utils), g2 = t2.normalizeValidateResult(y.validate(h, this._utils), h);
                if (g2 !== true) {
                  let { value: w2 } = g2, E = this._invalidHandler(p, w2, this._utils);
                  throw typeof E == "string" ? new Error(E) : E;
                }
                let c = (w2) => {
                  let { from: E, to: N2 } = w2;
                  u.push(typeof N2 == "string" ? { [N2]: E } : { [N2.key]: N2.value });
                }, f2 = (w2) => {
                  let { value: E, redirectTo: N2 } = w2, x2 = t2.normalizeDeprecatedResult(y.deprecated(E, this._utils), h, true);
                  if (x2 !== false)
                    if (x2 === true)
                      this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N2, this._utils));
                    else
                      for (let { value: I } of x2) {
                        let P = { key: p, value: I };
                        if (!this._hasDeprecationWarned(P)) {
                          let $ = typeof N2 == "string" ? { key: N2, value: I } : N2;
                          this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                        }
                      }
                };
                t2.normalizeForwardResult(y.forward(h, this._utils), h).forEach(c);
                let _ = t2.normalizeRedirectResult(y.redirect(h, this._utils), h);
                if (_.redirect.forEach(c), "remain" in _) {
                  let w2 = _.remain;
                  n2[p] = p in n2 ? y.overlap(n2[p], w2, this._utils) : w2, f2({ value: w2 });
                }
                for (let { from: w2, to: E } of _.redirect)
                  f2({ value: w2, redirectTo: E });
              }
              for (let p of l) {
                let y = a[p], h = this._unknownHandler(p, y, this._utils);
                if (h)
                  for (let g2 of Object.keys(h)) {
                    let c = { [g2]: h[g2] };
                    g2 in this._utils.schemas ? u.push(c) : Object.assign(n2, c);
                  }
              }
              return u;
            }
          };
          e.Normalizer = s;
        } }), Lm = te2({ "node_modules/vnopts/lib/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et(), ft(vt));
          r.__exportStar(vm(), e), r.__exportStar(Sm(), e), r.__exportStar(Pm(), e), r.__exportStar(km(), e), r.__exportStar(Ft(), e);
        } }), Om = te2({ "src/main/options-normalizer.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Lm(), s = lt2(), a = { key: (g2) => g2.length === 1 ? `-${g2}` : `--${g2}`, value: (g2) => t2.apiDescriptor.value(g2), pair: (g2) => {
            let { key: c, value: f2 } = g2;
            return f2 === false ? `--no-${c}` : f2 === true ? a.key(c) : f2 === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f2}`;
          } }, n2 = (g2) => {
            let { colorsModule: c, levenshteinDistance: f2 } = g2;
            return class extends t2.ChoiceSchema {
              constructor(_) {
                let { name: w2, flags: E } = _;
                super({ name: w2, choices: E }), this._flags = [...E].sort();
              }
              preprocess(_, w2) {
                if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                  let E = this._flags.find((N2) => f2(N2, _) < 3);
                  if (E)
                    return w2.logger.warn([`Unknown flag ${c.yellow(w2.descriptor.value(_))},`, `did you mean ${c.blue(w2.descriptor.value(E))}?`].join(" ")), E;
                }
                return _;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i2(g2, c) {
            let { logger: f2 = false, isCLI: F2 = false, passThrough: _ = false, colorsModule: w2 = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N2 = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C2) => {
              let o = C2.schemas, { _: d2 } = o, v2 = Hn(o, vD);
              return t2.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C2), {}, { schemas: v2 }));
            }, x2 = F2 ? a : t2.apiDescriptor, I = l(c, { isCLI: F2, colorsModule: w2, levenshteinDistance: E }), P = new t2.Normalizer(I, { logger: f2, unknown: N2, descriptor: x2 }), $ = f2 !== false;
            $ && u && (P._hasDeprecationWarned = u);
            let D = P.normalize(g2);
            return $ && (u = P._hasDeprecationWarned), F2 && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
          }
          function l(g2, c) {
            let { isCLI: f2, colorsModule: F2, levenshteinDistance: _ } = c, w2 = [];
            f2 && w2.push(t2.AnySchema.create({ name: "_" }));
            for (let E of g2)
              w2.push(p(E, { isCLI: f2, optionInfos: g2, colorsModule: F2, levenshteinDistance: _ })), E.alias && f2 && w2.push(t2.AliasSchema.create({ name: E.alias, sourceName: E.name }));
            return w2;
          }
          function p(g2, c) {
            let { isCLI: f2, optionInfos: F2, colorsModule: _, levenshteinDistance: w2 } = c, { name: E } = g2;
            if (E === "plugin-search-dir" || E === "pluginSearchDirs")
              return t2.AnySchema.create({ name: E, preprocess(P) {
                return P === false || (P = Array.isArray(P) ? P : [P]), P;
              }, validate(P) {
                return P === false ? true : P.every(($) => typeof $ == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let N2 = { name: E }, x2, I = {};
            switch (g2.type) {
              case "int":
                x2 = t2.IntegerSchema, f2 && (N2.preprocess = Number);
                break;
              case "string":
                x2 = t2.StringSchema;
                break;
              case "choice":
                x2 = t2.ChoiceSchema, N2.choices = g2.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g2.name, value: P.redirect } } }) : P);
                break;
              case "boolean":
                x2 = t2.BooleanSchema;
                break;
              case "flag":
                x2 = n2({ colorsModule: _, levenshteinDistance: w2 }), N2.flags = F2.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                break;
              case "path":
                x2 = t2.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g2.type}`);
            }
            if (g2.exception ? N2.validate = (P, $, D) => g2.exception(P) || $.validate(P, D) : N2.validate = (P, $, D) => P === void 0 || $.validate(P, D), g2.redirect && (I.redirect = (P) => P ? { to: { key: g2.redirect.option, value: g2.redirect.value } } : void 0), g2.deprecated && (I.deprecated = true), f2 && !g2.array) {
              let P = N2.preprocess || (($) => $);
              N2.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);
            }
            return g2.array ? t2.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f2 ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x2.create(N2) })) : x2.create(Object.assign(Object.assign({}, N2), I));
          }
          function y(g2, c, f2) {
            return i2(g2, c, f2);
          }
          function h(g2, c, f2) {
            return i2(g2, c, Object.assign({ isCLI: true }, f2));
          }
          r.exports = { normalizeApiOptions: y, normalizeCliOptions: h };
        } }), ut = te2({ "src/language-js/loc.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Kn();
          function s(l) {
            var p, y;
            let h = l.range ? l.range[0] : l.start, g2 = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;
            return t2(g2) ? Math.min(s(g2[0]), h) : h;
          }
          function a(l) {
            return l.range ? l.range[1] : l.end;
          }
          function n2(l, p) {
            let y = s(l);
            return Number.isInteger(y) && y === s(p);
          }
          function u(l, p) {
            let y = a(l);
            return Number.isInteger(y) && y === a(p);
          }
          function i2(l, p) {
            return n2(l, p) && u(l, p);
          }
          r.exports = { locStart: s, locEnd: a, hasSameLocStart: n2, hasSameLoc: i2 };
        } }), jm = te2({ "src/main/load-parser.js"(e, r) {
          ne2(), r.exports = () => {
          };
        } }), qm = te2({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
          "use strict";
          ne2();
          var t2 = kr2(), s = { shouldHighlight: () => false, getChalk: () => t2 };
          r.exports = s;
        } }), Mm = te2({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i2;
          var r = qm(), t2 = false;
          function s(l) {
            return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
          }
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function n2(l, p, y) {
            let h = Object.assign({ column: 0, line: -1 }, l.start), g2 = Object.assign({}, h, l.end), { linesAbove: c = 2, linesBelow: f2 = 3 } = y || {}, F2 = h.line, _ = h.column, w2 = g2.line, E = g2.column, N2 = Math.max(F2 - (c + 1), 0), x2 = Math.min(p.length, w2 + f2);
            F2 === -1 && (N2 = 0), w2 === -1 && (x2 = p.length);
            let I = w2 - F2, P = {};
            if (I)
              for (let $ = 0; $ <= I; $++) {
                let D = $ + F2;
                if (!_)
                  P[D] = true;
                else if ($ === 0) {
                  let T = p[D - 1].length;
                  P[D] = [_, T - _ + 1];
                } else if ($ === I)
                  P[D] = [0, E];
                else {
                  let T = p[D - $].length;
                  P[D] = [0, T];
                }
              }
            else
              _ === E ? _ ? P[F2] = [_, 0] : P[F2] = true : P[F2] = [_, E - _];
            return { start: N2, end: x2, markerLines: P };
          }
          function u(l, p) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y), g2 = (0, r.getChalk)(y), c = s(g2), f2 = ($, D) => h ? $(D) : D, F2 = l.split(a), { start: _, end: w2, markerLines: E } = n2(p, F2, y), N2 = p.start && typeof p.start.column == "number", x2 = String(w2).length, P = (h ? (0, r.default)(l, y) : l).split(a, w2).slice(_, w2).map(($, D) => {
              let T = _ + 1 + D, C2 = ` ${` ${T}`.slice(-x2)} |`, o = E[T], d2 = !E[T + 1];
              if (o) {
                let v2 = "";
                if (Array.isArray(o)) {
                  let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                  v2 = [`
 `, f2(c.gutter, C2.replace(/\d/g, " ")), " ", S, f2(c.marker, "^").repeat(b)].join(""), d2 && y.message && (v2 += " " + f2(c.message, y.message));
                }
                return [f2(c.marker, ">"), f2(c.gutter, C2), $.length > 0 ? ` ${$}` : "", v2].join("");
              } else
                return ` ${f2(c.gutter, C2)}${$.length > 0 ? ` ${$}` : ""}`;
            }).join(`
`);
            return y.message && !N2 && (P = `${" ".repeat(x2 + 1)}${y.message}
${P}`), h ? g2.reset(P) : P;
          }
          function i2(l, p, y) {
            let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t2) {
              t2 = true;
              let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (wt.emitWarning)
                wt.emitWarning(c, "DeprecationWarning");
              else {
                let f2 = new Error(c);
                f2.name = "DeprecationWarning", console.warn(new Error(c));
              }
            }
            return y = Math.max(y, 0), u(l, { start: { column: y, line: p } }, h);
          }
        } }), tu = te2({ "src/main/parser.js"(e, r) {
          "use strict";
          ne2();
          var { ConfigError: t2 } = Qt(), s = ut(), a = jm(), { locStart: n2, locEnd: u } = s, i2 = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
          function p(g2) {
            let c = {};
            for (let f2 of g2.plugins)
              if (f2.parsers)
                for (let F2 of i2(f2.parsers))
                  Object.defineProperty(c, F2, l(f2.parsers, F2));
            return c;
          }
          function y(g2) {
            let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g2);
            if (typeof g2.parser == "function")
              return { parse: g2.parser, astFormat: "estree", locStart: n2, locEnd: u };
            if (typeof g2.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(c, g2.parser))
                return c[g2.parser];
              throw new t2(`Couldn't resolve parser "${g2.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          function h(g2, c) {
            let f2 = p(c), F2 = Object.defineProperties({}, Object.fromEntries(Object.keys(f2).map((w2) => [w2, { enumerable: true, get() {
              return f2[w2].parse;
            } }]))), _ = y(c, f2);
            try {
              return _.preprocess && (g2 = _.preprocess(g2, c)), { text: g2, ast: _.parse(g2, F2, c) };
            } catch (w2) {
              let { loc: E } = w2;
              if (E) {
                let { codeFrameColumns: N2 } = Mm();
                throw w2.codeFrame = N2(g2, E, { highlightCode: true }), w2.message += `
` + w2.codeFrame, w2;
              }
              throw w2;
            }
          }
          r.exports = { parse: h, resolveParser: y };
        } }), uo = te2({ "src/main/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = ZD(), { UndefinedParserError: s } = Qt(), { getSupportInfo: a } = Xn(), n2 = Om(), { resolveParser: u } = tu(), i2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l(h) {
            let g2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, h), f2 = a({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, F2 = Object.assign(Object.assign({}, i2), Object.fromEntries(f2.filter((x2) => x2.default !== void 0).map((x2) => [x2.name, x2.default])));
            if (!c.parser) {
              if (!c.filepath)
                (g2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
              else if (c.parser = y(c.filepath, c.plugins), !c.parser)
                throw new s(`No parser could be inferred for file: ${c.filepath}`);
            }
            let _ = u(n2.normalizeApiOptions(c, [f2.find((x2) => x2.name === "parser")], { passThrough: true, logger: false }));
            c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
            let w2 = p(c);
            c.printer = w2.printers[c.astFormat];
            let E = Object.fromEntries(f2.filter((x2) => x2.pluginDefaults && x2.pluginDefaults[w2.name] !== void 0).map((x2) => [x2.name, x2.pluginDefaults[w2.name]])), N2 = Object.assign(Object.assign({}, F2), E);
            for (let [x2, I] of Object.entries(N2))
              (c[x2] === null || c[x2] === void 0) && (c[x2] = I);
            return c.parser === "json" && (c.trailingComma = "none"), n2.normalizeApiOptions(c, f2, Object.assign({ passThrough: Object.keys(i2) }, g2));
          }
          function p(h) {
            let { astFormat: g2 } = h;
            if (!g2)
              throw new Error("getPlugin() requires astFormat to be set");
            let c = h.plugins.find((f2) => f2.printers && f2.printers[g2]);
            if (!c)
              throw new Error(`Couldn't find plugin for AST format "${g2}"`);
            return c;
          }
          function y(h, g2) {
            let c = t2.basename(h).toLowerCase(), F2 = a({ plugins: g2 }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w2) => c.endsWith(w2)) || _.filenames && _.filenames.some((w2) => w2.toLowerCase() === c));
            return F2 && F2.parsers[0];
          }
          r.exports = { normalize: l, hiddenDefaults: i2, inferParser: y };
        } }), Rm = te2({ "src/main/massage-ast.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a, n2) {
            if (Array.isArray(s))
              return s.map((p) => t2(p, a, n2)).filter(Boolean);
            if (!s || typeof s != "object")
              return s;
            let u = a.printer.massageAstNode, i2;
            u && u.ignoredProperties ? i2 = u.ignoredProperties : i2 = /* @__PURE__ */ new Set();
            let l = {};
            for (let [p, y] of Object.entries(s))
              !i2.has(p) && typeof y != "function" && (l[p] = t2(y, a, s));
            if (u) {
              let p = u(s, l, n2);
              if (p === null)
                return;
              if (p)
                return p;
            }
            return l;
          }
          r.exports = t2;
        } }), Zt = te2({ "scripts/build/shims/assert.cjs"(e, r) {
          "use strict";
          ne2();
          var t2 = () => {
          };
          t2.ok = t2, t2.strictEqual = t2, r.exports = t2;
        } }), et = te2({ "src/main/comments.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Zt(), { builders: { line: s, hardline: a, breakParent: n2, indent: u, lineSuffix: i2, join: l, cursor: p } } = qe(), { hasNewline: y, skipNewline: h, skipSpaces: g2, isPreviousLineEmpty: c, addLeadingComment: f2, addDanglingComment: F2, addTrailingComment: _ } = Ue2(), w2 = /* @__PURE__ */ new WeakMap();
          function E(k, M, R) {
            if (!k)
              return;
            let { printer: q2, locStart: J3, locEnd: L } = M;
            if (R) {
              if (q2.canAttachComment && q2.canAttachComment(k)) {
                let V;
                for (V = R.length - 1; V >= 0 && !(J3(R[V]) <= J3(k) && L(R[V]) <= L(k)); --V)
                  ;
                R.splice(V + 1, 0, k);
                return;
              }
            } else if (w2.has(k))
              return w2.get(k);
            let Q2 = q2.getCommentChildNodes && q2.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
              let [j2] = V;
              return j2 !== "enclosingNode" && j2 !== "precedingNode" && j2 !== "followingNode" && j2 !== "tokens" && j2 !== "comments" && j2 !== "parent";
            }).map((V) => {
              let [, j2] = V;
              return j2;
            });
            if (Q2) {
              R || (R = [], w2.set(k, R));
              for (let V of Q2)
                E(V, M, R);
              return R;
            }
          }
          function N2(k, M, R, q2) {
            let { locStart: J3, locEnd: L } = R, Q2 = J3(M), V = L(M), j2 = E(k, R), Y3, ie2, ee2 = 0, ce2 = j2.length;
            for (; ee2 < ce2; ) {
              let W = ee2 + ce2 >> 1, K = j2[W], de2 = J3(K), ue2 = L(K);
              if (de2 <= Q2 && V <= ue2)
                return N2(K, M, R, K);
              if (ue2 <= Q2) {
                Y3 = K, ee2 = W + 1;
                continue;
              }
              if (V <= de2) {
                ie2 = K, ce2 = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q2 && q2.type === "TemplateLiteral") {
              let { quasis: W } = q2, K = C2(W, M, R);
              Y3 && C2(W, Y3, R) !== K && (Y3 = null), ie2 && C2(W, ie2, R) !== K && (ie2 = null);
            }
            return { enclosingNode: q2, precedingNode: Y3, followingNode: ie2 };
          }
          var x2 = () => false;
          function I(k, M, R, q2) {
            if (!Array.isArray(k))
              return;
            let J3 = [], { locStart: L, locEnd: Q2, printer: { handleComments: V = {} } } = q2, { avoidAstMutation: j2, ownLine: Y3 = x2, endOfLine: ie2 = x2, remaining: ee2 = x2 } = V, ce2 = k.map((W, K) => Object.assign(Object.assign({}, N2(M, W, q2)), {}, { comment: W, text: R, options: q2, ast: M, isLastComment: k.length - 1 === K }));
            for (let [W, K] of ce2.entries()) {
              let { comment: de2, precedingNode: ue2, enclosingNode: Fe2, followingNode: z, text: U2, options: Z, ast: se, isLastComment: fe2 } = K;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L(de2) - L(se) <= 0) {
                  f2(se, de2);
                  continue;
                }
                if (Q2(de2) - Q2(se) >= 0) {
                  _(se, de2);
                  continue;
                }
              }
              let ge;
              if (j2 ? ge = [K] : (de2.enclosingNode = Fe2, de2.precedingNode = ue2, de2.followingNode = z, ge = [de2, U2, Z, se, fe2]), $(U2, Z, ce2, W))
                de2.placement = "ownLine", Y3(...ge) || (z ? f2(z, de2) : ue2 ? _(ue2, de2) : F2(Fe2 || se, de2));
              else if (D(U2, Z, ce2, W))
                de2.placement = "endOfLine", ie2(...ge) || (ue2 ? _(ue2, de2) : z ? f2(z, de2) : F2(Fe2 || se, de2));
              else if (de2.placement = "remaining", !ee2(...ge))
                if (ue2 && z) {
                  let he = J3.length;
                  he > 0 && J3[he - 1].followingNode !== z && T(J3, U2, Z), J3.push(K);
                } else
                  ue2 ? _(ue2, de2) : z ? f2(z, de2) : F2(Fe2 || se, de2);
            }
            if (T(J3, R, q2), !j2)
              for (let W of k)
                delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
          function $(k, M, R, q2) {
            let { comment: J3, precedingNode: L } = R[q2], { locStart: Q2, locEnd: V } = M, j2 = Q2(J3);
            if (L)
              for (let Y3 = q2 - 1; Y3 >= 0; Y3--) {
                let { comment: ie2, precedingNode: ee2 } = R[Y3];
                if (ee2 !== L || !P(k.slice(V(ie2), j2)))
                  break;
                j2 = Q2(ie2);
              }
            return y(k, j2, { backwards: true });
          }
          function D(k, M, R, q2) {
            let { comment: J3, followingNode: L } = R[q2], { locStart: Q2, locEnd: V } = M, j2 = V(J3);
            if (L)
              for (let Y3 = q2 + 1; Y3 < R.length; Y3++) {
                let { comment: ie2, followingNode: ee2 } = R[Y3];
                if (ee2 !== L || !P(k.slice(j2, Q2(ie2))))
                  break;
                j2 = V(ie2);
              }
            return y(k, j2);
          }
          function T(k, M, R) {
            let q2 = k.length;
            if (q2 === 0)
              return;
            let { precedingNode: J3, followingNode: L, enclosingNode: Q2 } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q2) || /^[\s(]*$/, j2 = R.locStart(L), Y3;
            for (Y3 = q2; Y3 > 0; --Y3) {
              let { comment: ie2, precedingNode: ee2, followingNode: ce2 } = k[Y3 - 1];
              t2.strictEqual(ee2, J3), t2.strictEqual(ce2, L);
              let W = M.slice(R.locEnd(ie2), j2);
              if (V.test(W))
                j2 = R.locStart(ie2);
              else
                break;
            }
            for (let [ie2, { comment: ee2 }] of k.entries())
              ie2 < Y3 ? _(J3, ee2) : f2(L, ee2);
            for (let ie2 of [J3, L])
              ie2.comments && ie2.comments.length > 1 && ie2.comments.sort((ee2, ce2) => R.locStart(ee2) - R.locStart(ce2));
            k.length = 0;
          }
          function m(k, M) {
            let R = k.getValue();
            return R.printed = true, M.printer.printComment(k, M);
          }
          function C2(k, M, R) {
            let q2 = R.locStart(M) - 1;
            for (let J3 = 1; J3 < k.length; ++J3)
              if (q2 < R.locStart(k[J3]))
                return J3 - 1;
            return 0;
          }
          function o(k, M) {
            let R = k.getValue(), q2 = [m(k, M)], { printer: J3, originalText: L, locStart: Q2, locEnd: V } = M;
            if (J3.isBlockComment && J3.isBlockComment(R)) {
              let ie2 = y(L, V(R)) ? y(L, Q2(R), { backwards: true }) ? a : s : " ";
              q2.push(ie2);
            } else
              q2.push(a);
            let Y3 = h(L, g2(L, V(R)));
            return Y3 !== false && y(L, Y3) && q2.push(a), q2;
          }
          function d2(k, M) {
            let R = k.getValue(), q2 = m(k, M), { printer: J3, originalText: L, locStart: Q2 } = M, V = J3.isBlockComment && J3.isBlockComment(R);
            if (y(L, Q2(R), { backwards: true })) {
              let Y3 = c(L, R, Q2);
              return i2([a, Y3 ? a : "", q2]);
            }
            let j2 = [" ", q2];
            return V || (j2 = [i2(j2), n2]), j2;
          }
          function v2(k, M, R, q2) {
            let J3 = [], L = k.getValue();
            return !L || !L.comments || (k.each(() => {
              let Q2 = k.getValue();
              !Q2.leading && !Q2.trailing && (!q2 || q2(Q2)) && J3.push(m(k, M));
            }, "comments"), J3.length === 0) ? "" : R ? l(a, J3) : u([a, l(a, J3)]);
          }
          function S(k, M, R) {
            let q2 = k.getValue();
            if (!q2)
              return {};
            let J3 = q2.comments || [];
            R && (J3 = J3.filter((j2) => !R.has(j2)));
            let L = q2 === M.cursorNode;
            if (J3.length === 0) {
              let j2 = L ? p : "";
              return { leading: j2, trailing: j2 };
            }
            let Q2 = [], V = [];
            return k.each(() => {
              let j2 = k.getValue();
              if (R && R.has(j2))
                return;
              let { leading: Y3, trailing: ie2 } = j2;
              Y3 ? Q2.push(o(k, M)) : ie2 && V.push(d2(k, M));
            }, "comments"), L && (Q2.unshift(p), V.push(p)), { leading: Q2, trailing: V };
          }
          function b(k, M, R, q2) {
            let { leading: J3, trailing: L } = S(k, R, q2);
            return !J3 && !L ? M : [J3, M, L];
          }
          function B(k) {
            if (k)
              for (let M of k) {
                if (!M.printed)
                  throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                delete M.printed;
              }
          }
          r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v2, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
        } }), $m = te2({ "src/common/ast-path.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2();
          function s(u, i2) {
            let l = a(u.stack, i2);
            return l === -1 ? null : u.stack[l];
          }
          function a(u, i2) {
            for (let l = u.length - 1; l >= 0; l -= 2) {
              let p = u[l];
              if (p && !Array.isArray(p) && --i2 < 0)
                return l;
            }
            return -1;
          }
          var n2 = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i2 } = u;
              return i2 > 1 ? u[i2 - 2] : null;
            }
            getValue() {
              return t2(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u + 1);
            }
            call(u) {
              let { stack: i2 } = this, { length: l } = i2, p = t2(i2);
              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g2 = 1; g2 < y; g2++)
                h[g2 - 1] = arguments[g2];
              for (let f2 of h)
                p = p[f2], i2.push(f2, p);
              let c = u(this);
              return i2.length = l, c;
            }
            callParent(u) {
              let i2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i2 + 1), p = this.stack.splice(l + 1), y = u(this);
              return this.stack.push(...p), y;
            }
            each(u) {
              let { stack: i2 } = this, { length: l } = i2, p = t2(i2);
              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g2 = 1; g2 < y; g2++)
                h[g2 - 1] = arguments[g2];
              for (let c of h)
                p = p[c], i2.push(c, p);
              for (let c = 0; c < p.length; ++c)
                i2.push(c, p[c]), u(this, c, p), i2.length -= 2;
              i2.length = l;
            }
            map(u) {
              let i2 = [];
              for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                p[y - 1] = arguments[y];
              return this.each((h, g2, c) => {
                i2[g2] = u(h, g2, c);
              }, ...p), i2;
            }
            try(u) {
              let { stack: i2 } = this, l = [...i2];
              try {
                return u();
              } finally {
                i2.length = 0, i2.push(...l);
              }
            }
            match() {
              let u = this.stack.length - 1, i2 = null, l = this.stack[u--];
              for (var p = arguments.length, y = new Array(p), h = 0; h < p; h++)
                y[h] = arguments[h];
              for (let g2 of y) {
                if (l === void 0)
                  return false;
                let c = null;
                if (typeof i2 == "number" && (c = i2, i2 = this.stack[u--], l = this.stack[u--]), g2 && !g2(l, i2, c))
                  return false;
                i2 = this.stack[u--], l = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i2 = this.stack.length - 1, l = null, p = this.stack[i2--];
              for (; p; ) {
                let y = null;
                if (typeof l == "number" && (y = l, l = this.stack[i2--], p = this.stack[i2--]), l !== null && u(p, l, y))
                  return p;
                l = this.stack[i2--], p = this.stack[i2--];
              }
            }
          };
          r.exports = n2;
        } }), Vm = te2({ "src/main/multiparser.js"(e, r) {
          "use strict";
          ne2();
          var { utils: { stripTrailingHardline: t2 } } = qe(), { normalize: s } = uo(), a = et();
          function n2(i2, l, p, y) {
            if (p.printer.embed && p.embeddedLanguageFormatting === "auto")
              return p.printer.embed(i2, l, (h, g2, c) => u(h, g2, p, y, c), p);
          }
          function u(i2, l, p, y) {
            let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g2 = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i2 }), { passThrough: true }), c = tu().parse(i2, g2), { ast: f2 } = c;
            i2 = c.text;
            let F2 = f2.comments;
            delete f2.comments, a.attach(F2, f2, i2, g2), g2[Symbol.for("comments")] = F2 || [], g2[Symbol.for("tokens")] = f2.tokens || [];
            let _ = y(f2, g2);
            return a.ensureAllCommentsPrinted(F2), h ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t2(_) : _;
          }
          r.exports = { printSubtree: n2 };
        } }), Wm = te2({ "src/main/ast-to-doc.js"(e, r) {
          "use strict";
          ne2();
          var t2 = $m(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n2 } } = qe(), { printComments: u } = et(), i2 = Vm();
          function l(h, g2) {
            let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f2 } = g2;
            f2.preprocess && (h = f2.preprocess(h, g2));
            let F2 = /* @__PURE__ */ new Map(), _ = new t2(h), w2 = E();
            return c > 0 && (w2 = a([s, w2], c, g2.tabWidth)), n2(w2), w2;
            function E(x2, I) {
              return x2 === void 0 || x2 === _ ? N2(I) : Array.isArray(x2) ? _.call(() => N2(I), ...x2) : _.call(() => N2(I), x2);
            }
            function N2(x2) {
              let I = _.getValue(), P = I && typeof I == "object" && x2 === void 0;
              if (P && F2.has(I))
                return F2.get(I);
              let $ = y(_, g2, E, x2);
              return P && F2.set(I, $), $;
            }
          }
          function p(h, g2) {
            let { originalText: c, [Symbol.for("comments")]: f2, locStart: F2, locEnd: _ } = g2, w2 = F2(h), E = _(h), N2 = /* @__PURE__ */ new Set();
            for (let x2 of f2)
              F2(x2) >= w2 && _(x2) <= E && (x2.printed = true, N2.add(x2));
            return { doc: c.slice(w2, E), printedComments: N2 };
          }
          function y(h, g2, c, f2) {
            let F2 = h.getValue(), { printer: _ } = g2, w2, E;
            if (_.hasPrettierIgnore && _.hasPrettierIgnore(h))
              ({ doc: w2, printedComments: E } = p(F2, g2));
            else {
              if (F2)
                try {
                  w2 = i2.printSubtree(h, c, g2, l);
                } catch (N2) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw N2;
                }
              w2 || (w2 = _.print(h, g2, c, f2));
            }
            return (!_.willPrintOwnComments || !_.willPrintOwnComments(h, g2)) && (w2 = u(h, w2, g2, E)), w2;
          }
          r.exports = l;
        } }), Hm = te2({ "src/main/range-util.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Zt(), s = et(), a = (f2) => {
            let { parser: F2 } = f2;
            return F2 === "json" || F2 === "json5" || F2 === "json-stringify";
          };
          function n2(f2, F2) {
            let _ = [f2.node, ...f2.parentNodes], w2 = /* @__PURE__ */ new Set([F2.node, ...F2.parentNodes]);
            return _.find((E) => y.has(E.type) && w2.has(E));
          }
          function u(f2) {
            let F2 = f2.length - 1;
            for (; ; ) {
              let _ = f2[F2];
              if (_ && (_.type === "Program" || _.type === "File"))
                F2--;
              else
                break;
            }
            return f2.slice(0, F2 + 1);
          }
          function i2(f2, F2, _) {
            let { locStart: w2, locEnd: E } = _, N2 = f2.node, x2 = F2.node;
            if (N2 === x2)
              return { startNode: N2, endNode: x2 };
            let I = w2(f2.node);
            for (let $ of u(F2.parentNodes))
              if (w2($) >= I)
                x2 = $;
              else
                break;
            let P = E(F2.node);
            for (let $ of u(f2.parentNodes)) {
              if (E($) <= P)
                N2 = $;
              else
                break;
              if (N2 === x2)
                break;
            }
            return { startNode: N2, endNode: x2 };
          }
          function l(f2, F2, _, w2) {
            let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N2 = arguments.length > 5 ? arguments[5] : void 0, { locStart: x2, locEnd: I } = _, P = x2(f2), $ = I(f2);
            if (!(F2 > $ || F2 < P || N2 === "rangeEnd" && F2 === P || N2 === "rangeStart" && F2 === $)) {
              for (let D of s.getSortedChildNodes(f2, _)) {
                let T = l(D, F2, _, w2, [f2, ...E], N2);
                if (T)
                  return T;
              }
              if (!w2 || w2(f2, E[0]))
                return { node: f2, parentNodes: E };
            }
          }
          function p(f2, F2) {
            return F2 !== "DeclareExportDeclaration" && f2 !== "TypeParameterDeclaration" && (f2 === "Directive" || f2 === "TypeAlias" || f2 === "TSExportAssignment" || f2.startsWith("Declare") || f2.startsWith("TSDeclare") || f2.endsWith("Statement") || f2.endsWith("Declaration"));
          }
          var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g2(f2, F2, _) {
            if (!F2)
              return false;
            switch (f2.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return p(F2.type, _ && _.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y.has(F2.type);
              case "graphql":
                return h.has(F2.kind);
              case "vue":
                return F2.tag !== "root";
            }
            return false;
          }
          function c(f2, F2, _) {
            let { rangeStart: w2, rangeEnd: E, locStart: N2, locEnd: x2 } = F2;
            t2.ok(E > w2);
            let I = f2.slice(w2, E).search(/\S/), P = I === -1;
            if (!P)
              for (w2 += I; E > w2 && !/\S/.test(f2[E - 1]); --E)
                ;
            let $ = l(_, w2, F2, (C2, o) => g2(F2, C2, o), [], "rangeStart"), D = P ? $ : l(_, E, F2, (C2) => g2(F2, C2), [], "rangeEnd");
            if (!$ || !D)
              return { rangeStart: 0, rangeEnd: 0 };
            let T, m;
            if (a(F2)) {
              let C2 = n2($, D);
              T = C2, m = C2;
            } else
              ({ startNode: T, endNode: m } = i2($, D, F2));
            return { rangeStart: Math.min(N2(T), N2(m)), rangeEnd: Math.max(x2(T), x2(m)) };
          }
          r.exports = { calculateRange: c, findNodeAtOffset: l };
        } }), Gm2 = te2({ "src/main/core.js"(e, r) {
          "use strict";
          ne2();
          var { diffArrays: t2 } = BD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n2 } = Ue2(), { guessEndOfLine: u, convertEndOfLineToChars: i2, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn(), y = uo().normalize, h = Rm(), g2 = et(), c = tu(), f2 = Wm(), F2 = Hm(), _ = "\uFEFF", w2 = Symbol("cursor");
          function E(m, C2, o) {
            let d2 = C2.comments;
            return d2 && (delete C2.comments, g2.attach(d2, C2, m, o)), o[Symbol.for("comments")] = d2 || [], o[Symbol.for("tokens")] = C2.tokens || [], o.originalText = m, d2;
          }
          function N2(m, C2) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m || m.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d2, text: v2 } = c.parse(m, C2);
            if (C2.cursorOffset >= 0) {
              let k = F2.findNodeAtOffset(d2, C2.cursorOffset, C2);
              k && k.node && (C2.cursorNode = k.node);
            }
            let S = E(v2, d2, C2), b = f2(d2, C2, o), B = s(b, C2);
            if (g2.ensureAllCommentsPrinted(S), o > 0) {
              let k = B.formatted.trim();
              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i2(C2.endOfLine);
            }
            if (C2.cursorOffset >= 0) {
              let k, M, R, q2, J3;
              if (C2.cursorNode && B.cursorNodeText ? (k = C2.locStart(C2.cursorNode), M = v2.slice(k, C2.locEnd(C2.cursorNode)), R = C2.cursorOffset - k, q2 = B.cursorNodeStart, J3 = B.cursorNodeText) : (k = 0, M = v2, R = C2.cursorOffset, q2 = 0, J3 = B.formatted), M === J3)
                return { formatted: B.formatted, cursorOffset: q2 + R, comments: S };
              let L = [...M];
              L.splice(R, 0, w2);
              let Q2 = [...J3], V = t2(L, Q2), j2 = q2;
              for (let Y3 of V)
                if (Y3.removed) {
                  if (Y3.value.includes(w2))
                    break;
                } else
                  j2 += Y3.count;
              return { formatted: B.formatted, cursorOffset: j2, comments: S };
            }
            return { formatted: B.formatted, cursorOffset: -1, comments: S };
          }
          function x2(m, C2) {
            let { ast: o, text: d2 } = c.parse(m, C2), { rangeStart: v2, rangeEnd: S } = F2.calculateRange(d2, C2, o), b = d2.slice(v2, S), B = Math.min(v2, d2.lastIndexOf(`
`, v2) + 1), k = d2.slice(B, v2).match(/^\s*/)[0], M = n2(k, C2.tabWidth), R = N2(b, Object.assign(Object.assign({}, C2), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C2.cursorOffset > v2 && C2.cursorOffset <= S ? C2.cursorOffset - v2 : -1, endOfLine: "lf" }), M), q2 = R.formatted.trimEnd(), { cursorOffset: J3 } = C2;
            J3 > S ? J3 += q2.length - b.length : R.cursorOffset >= 0 && (J3 = R.cursorOffset + v2);
            let L = d2.slice(0, v2) + q2 + d2.slice(S);
            if (C2.endOfLine !== "lf") {
              let Q2 = i2(C2.endOfLine);
              J3 >= 0 && Q2 === `\r
` && (J3 += l(L.slice(0, J3), `
`)), L = L.replace(/\n/g, Q2);
            }
            return { formatted: L, cursorOffset: J3, comments: R.comments };
          }
          function I(m, C2, o) {
            return typeof C2 != "number" || Number.isNaN(C2) || C2 < 0 || C2 > m.length ? o : C2;
          }
          function P(m, C2) {
            let { cursorOffset: o, rangeStart: d2, rangeEnd: v2 } = C2;
            return o = I(m, o, -1), d2 = I(m, d2, 0), v2 = I(m, v2, m.length), Object.assign(Object.assign({}, C2), {}, { cursorOffset: o, rangeStart: d2, rangeEnd: v2 });
          }
          function $(m, C2) {
            let { cursorOffset: o, rangeStart: d2, rangeEnd: v2, endOfLine: S } = P(m, C2), b = m.charAt(0) === _;
            if (b && (m = m.slice(1), o--, d2--, v2--), S === "auto" && (S = u(m)), m.includes("\r")) {
              let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
              o -= B(o), d2 -= B(d2), v2 -= B(v2), m = p(m);
            }
            return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C2), {}, { cursorOffset: o, rangeStart: d2, rangeEnd: v2, endOfLine: S })) };
          }
          function D(m, C2) {
            let o = c.resolveParser(C2);
            return !o.hasPragma || o.hasPragma(m);
          }
          function T(m, C2) {
            let { hasBOM: o, text: d2, options: v2 } = $(m, y(C2));
            if (v2.rangeStart >= v2.rangeEnd && d2 !== "" || v2.requirePragma && !D(d2, v2))
              return { formatted: m, cursorOffset: C2.cursorOffset, comments: [] };
            let S;
            return v2.rangeStart > 0 || v2.rangeEnd < d2.length ? S = x2(d2, v2) : (!v2.requirePragma && v2.insertPragma && v2.printer.insertPragma && !D(d2, v2) && (d2 = v2.printer.insertPragma(d2)), S = N2(d2, v2)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
          }
          r.exports = { formatWithCursor: T, parse(m, C2, o) {
            let { text: d2, options: v2 } = $(m, y(C2)), S = c.parse(d2, v2);
            return o && (S.ast = h(S.ast, v2)), S;
          }, formatAST(m, C2) {
            C2 = y(C2);
            let o = f2(m, C2);
            return s(o, C2);
          }, formatDoc(m, C2) {
            return T(a(m), Object.assign(Object.assign({}, C2), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m, C2) {
            C2 = y(C2);
            let { ast: o, text: d2 } = c.parse(m, C2);
            return E(d2, o, C2), f2(o, C2);
          }, printDocToString(m, C2) {
            return s(m, y(C2));
          } };
        } }), Um = te2({ "src/common/util-shared.js"(e, r) {
          "use strict";
          ne2();
          var { getMaxContinuousCount: t2, getStringWidth: s, getAlignmentSize: a, getIndentSize: n2, skip: u, skipWhitespace: i2, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g2, skipTrailingComment: c, hasNewline: f2, hasNewlineInRange: F2, hasSpaces: _, isNextLineEmpty: w2, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N2, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D } = Ue2();
          r.exports = { getMaxContinuousCount: t2, getStringWidth: s, getAlignmentSize: a, getIndentSize: n2, skip: u, skipWhitespace: i2, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g2, skipTrailingComment: c, hasNewline: f2, hasNewlineInRange: F2, hasSpaces: _, isNextLineEmpty: w2, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N2, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D };
        } }), _t = te2({ "src/utils/create-language.js"(e, r) {
          "use strict";
          ne2(), r.exports = function(t2, s) {
            let { languageId: a } = t2, n2 = Hn(t2, CD);
            return Object.assign(Object.assign({ linguistLanguageId: a }, n2), s(t2));
          };
        } }), Jm = te2({ "node_modules/esutils/lib/ast.js"(e, r) {
          ne2(), function() {
            "use strict";
            function t2(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function n2(l) {
              return a(l) || l != null && l.type === "FunctionDeclaration";
            }
            function u(l) {
              switch (l.type) {
                case "IfStatement":
                  return l.alternate != null ? l.alternate : l.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l.body;
              }
              return null;
            }
            function i2(l) {
              var p;
              if (l.type !== "IfStatement" || l.alternate == null)
                return false;
              p = l.consequent;
              do {
                if (p.type === "IfStatement" && p.alternate == null)
                  return true;
                p = u(p);
              } while (p);
              return false;
            }
            r.exports = { isExpression: t2, isStatement: a, isIterationStatement: s, isSourceElement: n2, isProblematicIfStatement: i2, trailingStatement: u };
          }();
        } }), so = te2({ "node_modules/esutils/lib/code.js"(e, r) {
          ne2(), function() {
            "use strict";
            var t2, s, a, n2, u, i2;
            s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l(E) {
              return 48 <= E && E <= 57;
            }
            function p(E) {
              return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
            }
            function y(E) {
              return E >= 48 && E <= 55;
            }
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h(E) {
              return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;
            }
            function g2(E) {
              return E === 10 || E === 13 || E === 8232 || E === 8233;
            }
            function c(E) {
              if (E <= 65535)
                return String.fromCharCode(E);
              var N2 = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x2 = String.fromCharCode((E - 65536) % 1024 + 56320);
              return N2 + x2;
            }
            for (n2 = new Array(128), i2 = 0; i2 < 128; ++i2)
              n2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 === 36 || i2 === 95;
            for (u = new Array(128), i2 = 0; i2 < 128; ++i2)
              u[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 36 || i2 === 95;
            function f2(E) {
              return E < 128 ? n2[E] : s.NonAsciiIdentifierStart.test(c(E));
            }
            function F2(E) {
              return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));
            }
            function _(E) {
              return E < 128 ? n2[E] : t2.NonAsciiIdentifierStart.test(c(E));
            }
            function w2(E) {
              return E < 128 ? u[E] : t2.NonAsciiIdentifierPart.test(c(E));
            }
            r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y, isWhiteSpace: h, isLineTerminator: g2, isIdentifierStartES5: f2, isIdentifierPartES5: F2, isIdentifierStartES6: _, isIdentifierPartES6: w2 };
          }();
        } }), zm2 = te2({ "node_modules/esutils/lib/keyword.js"(e, r) {
          ne2(), function() {
            "use strict";
            var t2 = so();
            function s(f2) {
              switch (f2) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a(f2, F2) {
              return !F2 && f2 === "yield" ? false : n2(f2, F2);
            }
            function n2(f2, F2) {
              if (F2 && s(f2))
                return true;
              switch (f2.length) {
                case 2:
                  return f2 === "if" || f2 === "in" || f2 === "do";
                case 3:
                  return f2 === "var" || f2 === "for" || f2 === "new" || f2 === "try";
                case 4:
                  return f2 === "this" || f2 === "else" || f2 === "case" || f2 === "void" || f2 === "with" || f2 === "enum";
                case 5:
                  return f2 === "while" || f2 === "break" || f2 === "catch" || f2 === "throw" || f2 === "const" || f2 === "yield" || f2 === "class" || f2 === "super";
                case 6:
                  return f2 === "return" || f2 === "typeof" || f2 === "delete" || f2 === "switch" || f2 === "export" || f2 === "import";
                case 7:
                  return f2 === "default" || f2 === "finally" || f2 === "extends";
                case 8:
                  return f2 === "function" || f2 === "continue" || f2 === "debugger";
                case 10:
                  return f2 === "instanceof";
                default:
                  return false;
              }
            }
            function u(f2, F2) {
              return f2 === "null" || f2 === "true" || f2 === "false" || a(f2, F2);
            }
            function i2(f2, F2) {
              return f2 === "null" || f2 === "true" || f2 === "false" || n2(f2, F2);
            }
            function l(f2) {
              return f2 === "eval" || f2 === "arguments";
            }
            function p(f2) {
              var F2, _, w2;
              if (f2.length === 0 || (w2 = f2.charCodeAt(0), !t2.isIdentifierStartES5(w2)))
                return false;
              for (F2 = 1, _ = f2.length; F2 < _; ++F2)
                if (w2 = f2.charCodeAt(F2), !t2.isIdentifierPartES5(w2))
                  return false;
              return true;
            }
            function y(f2, F2) {
              return (f2 - 55296) * 1024 + (F2 - 56320) + 65536;
            }
            function h(f2) {
              var F2, _, w2, E, N2;
              if (f2.length === 0)
                return false;
              for (N2 = t2.isIdentifierStartES6, F2 = 0, _ = f2.length; F2 < _; ++F2) {
                if (w2 = f2.charCodeAt(F2), 55296 <= w2 && w2 <= 56319) {
                  if (++F2, F2 >= _ || (E = f2.charCodeAt(F2), !(56320 <= E && E <= 57343)))
                    return false;
                  w2 = y(w2, E);
                }
                if (!N2(w2))
                  return false;
                N2 = t2.isIdentifierPartES6;
              }
              return true;
            }
            function g2(f2, F2) {
              return p(f2) && !u(f2, F2);
            }
            function c(f2, F2) {
              return h(f2) && !i2(f2, F2);
            }
            r.exports = { isKeywordES5: a, isKeywordES6: n2, isReservedWordES5: u, isReservedWordES6: i2, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h, isIdentifierES5: g2, isIdentifierES6: c };
          }();
        } }), Xm = te2({ "node_modules/esutils/lib/utils.js"(e) {
          ne2(), function() {
            "use strict";
            e.ast = Jm(), e.code = so(), e.keyword = zm2();
          }();
        } }), Pt = te2({ "src/language-js/utils/is-block-comment.js"(e, r) {
          "use strict";
          ne2();
          var t2 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t2.has(a == null ? void 0 : a.type);
          r.exports = s;
        } }), Km = te2({ "src/language-js/utils/is-node-matches.js"(e, r) {
          "use strict";
          ne2();
          function t2(a, n2) {
            let u = n2.split(".");
            for (let i2 = u.length - 1; i2 >= 0; i2--) {
              let l = u[i2];
              if (i2 === 0)
                return a.type === "Identifier" && a.name === l;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
                return false;
              a = a.object;
            }
          }
          function s(a, n2) {
            return n2.some((u) => t2(a, u));
          }
          r.exports = s;
        } }), Ke3 = te2({ "src/language-js/utils/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Xm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n2, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i2, getStringWidth: l } = Ue2(), { locStart: p, locEnd: y, hasSameLocStart: h } = ut(), g2 = Pt(), c = Km(), f2 = "(?:(?=.)\\s)", F2 = new RegExp(`^${f2}*:`), _ = new RegExp(`^${f2}*::`);
          function w2(O2) {
            var me2, _e;
            return ((me2 = O2.extra) === null || me2 === void 0 ? void 0 : me2.parenthesized) && g2((_e = O2.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F2.test(O2.trailingComments[0].value);
          }
          function E(O2) {
            let me2 = O2 == null ? void 0 : O2[0];
            return g2(me2) && _.test(me2.value);
          }
          function N2(O2, me2) {
            if (!O2 || typeof O2 != "object")
              return false;
            if (Array.isArray(O2))
              return O2.some((He2) => N2(He2, me2));
            let _e = me2(O2);
            return typeof _e == "boolean" ? _e : Object.values(O2).some((He2) => N2(He2, me2));
          }
          function x2(O2) {
            return O2.type === "AssignmentExpression" || O2.type === "BinaryExpression" || O2.type === "LogicalExpression" || O2.type === "NGPipeExpression" || O2.type === "ConditionalExpression" || de2(O2) || ue2(O2) || O2.type === "SequenceExpression" || O2.type === "TaggedTemplateExpression" || O2.type === "BindExpression" || O2.type === "UpdateExpression" && !O2.prefix || st2(O2) || O2.type === "TSNonNullExpression";
          }
          function I(O2) {
            var me2, _e, He2, Ge2, it, Qe2;
            return O2.expressions ? O2.expressions[0] : (me2 = (_e = (He2 = (Ge2 = (it = (Qe2 = O2.left) !== null && Qe2 !== void 0 ? Qe2 : O2.test) !== null && it !== void 0 ? it : O2.callee) !== null && Ge2 !== void 0 ? Ge2 : O2.object) !== null && He2 !== void 0 ? He2 : O2.tag) !== null && _e !== void 0 ? _e : O2.argument) !== null && me2 !== void 0 ? me2 : O2.expression;
          }
          function P(O2, me2) {
            if (me2.expressions)
              return ["expressions", 0];
            if (me2.left)
              return ["left"];
            if (me2.test)
              return ["test"];
            if (me2.object)
              return ["object"];
            if (me2.callee)
              return ["callee"];
            if (me2.tag)
              return ["tag"];
            if (me2.argument)
              return ["argument"];
            if (me2.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function $(O2) {
            return O2 = new Set(O2), (me2) => O2.has(me2 == null ? void 0 : me2.type);
          }
          var D = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m(O2) {
            let me2 = O2.getParentNode();
            return O2.getName() === "declaration" && T(me2) ? me2 : null;
          }
          var C2 = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o(O2) {
            return O2.type === "NumericLiteral" || O2.type === "Literal" && typeof O2.value == "number";
          }
          function d2(O2) {
            return O2.type === "UnaryExpression" && (O2.operator === "+" || O2.operator === "-") && o(O2.argument);
          }
          function v2(O2) {
            return O2.type === "StringLiteral" || O2.type === "Literal" && typeof O2.value == "string";
          }
          var S = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
          function B(O2) {
            return O2.type === "FunctionExpression" || O2.type === "ArrowFunctionExpression" && O2.body.type === "BlockStatement";
          }
          function k(O2) {
            return de2(O2) && O2.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O2.callee.name);
          }
          var M = $(["JSXElement", "JSXFragment"]);
          function R(O2, me2) {
            if (O2.parentParser !== "markdown" && O2.parentParser !== "mdx")
              return false;
            let _e = me2.getNode();
            if (!_e.expression || !M(_e.expression))
              return false;
            let He2 = me2.getParentNode();
            return He2.type === "Program" && He2.body.length === 1;
          }
          function q2(O2) {
            return O2.kind === "get" || O2.kind === "set";
          }
          function J3(O2) {
            return q2(O2) || h(O2, O2.value);
          }
          function L(O2) {
            return (O2.type === "ObjectTypeProperty" || O2.type === "ObjectTypeInternalSlot") && O2.value.type === "FunctionTypeAnnotation" && !O2.static && !J3(O2);
          }
          function Q2(O2) {
            return (O2.type === "TypeAnnotation" || O2.type === "TSTypeAnnotation") && O2.typeAnnotation.type === "FunctionTypeAnnotation" && !O2.static && !h(O2, O2.typeAnnotation);
          }
          var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function j2(O2) {
            return ue2(O2) || O2.type === "BindExpression" && Boolean(O2.object);
          }
          var Y3 = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ie2(O2) {
            return O2 ? !!((O2.type === "GenericTypeAnnotation" || O2.type === "TSTypeReference") && !O2.typeParameters || Y3.has(O2.type)) : false;
          }
          function ee2(O2) {
            let me2 = /^(?:before|after)(?:Each|All)$/;
            return O2.callee.type === "Identifier" && me2.test(O2.callee.name) && O2.arguments.length === 1;
          }
          var ce2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O2) {
            return c(O2, ce2);
          }
          function K(O2, me2) {
            if (O2.type !== "CallExpression")
              return false;
            if (O2.arguments.length === 1) {
              if (k(O2) && me2 && K(me2))
                return b(O2.arguments[0]);
              if (ee2(O2))
                return k(O2.arguments[0]);
            } else if ((O2.arguments.length === 2 || O2.arguments.length === 3) && (O2.arguments[0].type === "TemplateLiteral" || v2(O2.arguments[0])) && W(O2.callee))
              return O2.arguments[2] && !o(O2.arguments[2]) ? false : (O2.arguments.length === 2 ? b(O2.arguments[1]) : B(O2.arguments[1]) && ve(O2.arguments[1]).length <= 1) || k(O2.arguments[1]);
            return false;
          }
          var de2 = $(["CallExpression", "OptionalCallExpression"]), ue2 = $(["MemberExpression", "OptionalMemberExpression"]);
          function Fe2(O2) {
            let me2 = "expressions";
            O2.type === "TSTemplateLiteralType" && (me2 = "types");
            let _e = O2[me2];
            return _e.length === 0 ? false : _e.every((He2) => {
              if (Me2(He2))
                return false;
              if (He2.type === "Identifier" || He2.type === "ThisExpression")
                return true;
              if (ue2(He2)) {
                let Ge2 = He2;
                for (; ue2(Ge2); )
                  if (Ge2.property.type !== "Identifier" && Ge2.property.type !== "Literal" && Ge2.property.type !== "StringLiteral" && Ge2.property.type !== "NumericLiteral" || (Ge2 = Ge2.object, Me2(Ge2)))
                    return false;
                return Ge2.type === "Identifier" || Ge2.type === "ThisExpression";
              }
              return false;
            });
          }
          function z(O2, me2) {
            return O2 === "+" || O2 === "-" ? O2 + me2 : me2;
          }
          function U2(O2, me2) {
            let _e = p(me2), He2 = n2(O2, y(me2));
            return He2 !== false && O2.slice(_e, _e + 2) === "/*" && O2.slice(He2, He2 + 2) === "*/";
          }
          function Z(O2, me2) {
            return M(me2) ? Oe2(me2) : Me2(me2, Te2.Leading, (_e) => a(O2, y(_e)));
          }
          function se(O2, me2) {
            return me2.parser !== "json" && v2(O2.key) && oe2(O2.key).slice(1, -1) === O2.key.value && (t2(O2.key.value) && !(me2.parser === "babel-ts" && O2.type === "ClassProperty" || me2.parser === "typescript" && O2.type === "PropertyDefinition") || fe2(O2.key.value) && String(Number(O2.key.value)) === O2.key.value && (me2.parser === "babel" || me2.parser === "acorn" || me2.parser === "espree" || me2.parser === "meriyah" || me2.parser === "__babel_estree"));
          }
          function fe2(O2) {
            return /^(?:\d+|\d+\.\d+)$/.test(O2);
          }
          function ge(O2, me2) {
            let _e = /^[fx]?(?:describe|it|test)$/;
            return me2.type === "TaggedTemplateExpression" && me2.quasi === O2 && me2.tag.type === "MemberExpression" && me2.tag.property.type === "Identifier" && me2.tag.property.name === "each" && (me2.tag.object.type === "Identifier" && _e.test(me2.tag.object.name) || me2.tag.object.type === "MemberExpression" && me2.tag.object.property.type === "Identifier" && (me2.tag.object.property.name === "only" || me2.tag.object.property.name === "skip") && me2.tag.object.object.type === "Identifier" && _e.test(me2.tag.object.object.name));
          }
          function he(O2) {
            return O2.quasis.some((me2) => me2.value.raw.includes(`
`));
          }
          function we2(O2, me2) {
            return (O2.type === "TemplateLiteral" && he(O2) || O2.type === "TaggedTemplateExpression" && he(O2.quasi)) && !a(me2, p(O2), { backwards: true });
          }
          function ke2(O2) {
            if (!Me2(O2))
              return false;
            let me2 = s(ae(O2, Te2.Dangling));
            return me2 && !g2(me2);
          }
          function Re2(O2) {
            if (O2.length <= 1)
              return false;
            let me2 = 0;
            for (let _e of O2)
              if (b(_e)) {
                if (me2 += 1, me2 > 1)
                  return true;
              } else if (de2(_e)) {
                for (let He2 of _e.arguments)
                  if (b(He2))
                    return true;
              }
            return false;
          }
          function Ne2(O2) {
            let me2 = O2.getValue(), _e = O2.getParentNode();
            return de2(me2) && de2(_e) && _e.callee === me2 && me2.arguments.length > _e.arguments.length && _e.arguments.length > 0;
          }
          function Pe2(O2, me2) {
            if (me2 >= 2)
              return false;
            let _e = (Qe2) => Pe2(Qe2, me2 + 1), He2 = O2.type === "Literal" && "regex" in O2 && O2.regex.pattern || O2.type === "RegExpLiteral" && O2.pattern;
            if (He2 && l(He2) > 5)
              return false;
            if (O2.type === "Literal" || O2.type === "BigIntLiteral" || O2.type === "DecimalLiteral" || O2.type === "BooleanLiteral" || O2.type === "NullLiteral" || O2.type === "NumericLiteral" || O2.type === "RegExpLiteral" || O2.type === "StringLiteral" || O2.type === "Identifier" || O2.type === "ThisExpression" || O2.type === "Super" || O2.type === "PrivateName" || O2.type === "PrivateIdentifier" || O2.type === "ArgumentPlaceholder" || O2.type === "Import")
              return true;
            if (O2.type === "TemplateLiteral")
              return O2.quasis.every((Qe2) => !Qe2.value.raw.includes(`
`)) && O2.expressions.every(_e);
            if (O2.type === "ObjectExpression")
              return O2.properties.every((Qe2) => !Qe2.computed && (Qe2.shorthand || Qe2.value && _e(Qe2.value)));
            if (O2.type === "ArrayExpression")
              return O2.elements.every((Qe2) => Qe2 === null || _e(Qe2));
            if (tt(O2))
              return (O2.type === "ImportExpression" || Pe2(O2.callee, me2)) && Ye2(O2).every(_e);
            if (ue2(O2))
              return Pe2(O2.object, me2) && Pe2(O2.property, me2);
            let Ge2 = { "!": true, "-": true, "+": true, "~": true };
            if (O2.type === "UnaryExpression" && Ge2[O2.operator])
              return Pe2(O2.argument, me2);
            let it = { "++": true, "--": true };
            return O2.type === "UpdateExpression" && it[O2.operator] ? Pe2(O2.argument, me2) : O2.type === "TSNonNullExpression" ? Pe2(O2.expression, me2) : false;
          }
          function oe2(O2) {
            var me2, _e;
            return (me2 = (_e = O2.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me2 !== void 0 ? me2 : O2.raw;
          }
          function H(O2) {
            return O2;
          }
          function pe2(O2) {
            return O2.filepath && /\.tsx$/i.test(O2.filepath);
          }
          function X2(O2) {
            let me2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O2.trailingComma === "es5" && me2 === "es5" || O2.trailingComma === "all" && (me2 === "all" || me2 === "es5");
          }
          function le(O2, me2) {
            switch (O2.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
              case "NGPipeExpression":
                return le(O2.left, me2);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return le(O2.object, me2);
              case "TaggedTemplateExpression":
                return O2.tag.type === "FunctionExpression" ? false : le(O2.tag, me2);
              case "CallExpression":
              case "OptionalCallExpression":
                return O2.callee.type === "FunctionExpression" ? false : le(O2.callee, me2);
              case "ConditionalExpression":
                return le(O2.test, me2);
              case "UpdateExpression":
                return !O2.prefix && le(O2.argument, me2);
              case "BindExpression":
                return O2.object && le(O2.object, me2);
              case "SequenceExpression":
                return le(O2.expressions[0], me2);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return le(O2.expression, me2);
              default:
                return me2(O2);
            }
          }
          var Ae2 = { "==": true, "!=": true, "===": true, "!==": true }, Ee2 = { "*": true, "/": true, "%": true }, De3 = { ">>": true, ">>>": true, "<<": true };
          function A2(O2, me2) {
            return !(re2(me2) !== re2(O2) || O2 === "**" || Ae2[O2] && Ae2[me2] || me2 === "%" && Ee2[O2] || O2 === "%" && Ee2[me2] || me2 !== O2 && Ee2[me2] && Ee2[O2] || De3[O2] && De3[me2]);
          }
          var G2 = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O2, me2) => O2.map((_e) => [_e, me2])));
          function re2(O2) {
            return G2.get(O2);
          }
          function ye(O2) {
            return Boolean(De3[O2]) || O2 === "|" || O2 === "^" || O2 === "&";
          }
          function Ce2(O2) {
            var me2;
            if (O2.rest)
              return true;
            let _e = ve(O2);
            return ((me2 = s(_e)) === null || me2 === void 0 ? void 0 : me2.type) === "RestElement";
          }
          var Be2 = /* @__PURE__ */ new WeakMap();
          function ve(O2) {
            if (Be2.has(O2))
              return Be2.get(O2);
            let me2 = [];
            return O2.this && me2.push(O2.this), Array.isArray(O2.parameters) ? me2.push(...O2.parameters) : Array.isArray(O2.params) && me2.push(...O2.params), O2.rest && me2.push(O2.rest), Be2.set(O2, me2), me2;
          }
          function ze(O2, me2) {
            let _e = O2.getValue(), He2 = 0, Ge2 = (it) => me2(it, He2++);
            _e.this && O2.call(Ge2, "this"), Array.isArray(_e.parameters) ? O2.each(Ge2, "parameters") : Array.isArray(_e.params) && O2.each(Ge2, "params"), _e.rest && O2.call(Ge2, "rest");
          }
          var be2 = /* @__PURE__ */ new WeakMap();
          function Ye2(O2) {
            if (be2.has(O2))
              return be2.get(O2);
            let me2 = O2.arguments;
            return O2.type === "ImportExpression" && (me2 = [O2.source], O2.attributes && me2.push(O2.attributes)), be2.set(O2, me2), me2;
          }
          function Se2(O2, me2) {
            let _e = O2.getValue();
            _e.type === "ImportExpression" ? (O2.call((He2) => me2(He2, 0), "source"), _e.attributes && O2.call((He2) => me2(He2, 1), "attributes")) : O2.each(me2, "arguments");
          }
          function Ie2(O2) {
            return O2.value.trim() === "prettier-ignore" && !O2.unignore;
          }
          function Oe2(O2) {
            return O2 && (O2.prettierIgnore || Me2(O2, Te2.PrettierIgnore));
          }
          function Je2(O2) {
            let me2 = O2.getValue();
            return Oe2(me2);
          }
          var Te2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je2 = (O2, me2) => {
            if (typeof O2 == "function" && (me2 = O2, O2 = 0), O2 || me2)
              return (_e, He2, Ge2) => !(O2 & Te2.Leading && !_e.leading || O2 & Te2.Trailing && !_e.trailing || O2 & Te2.Dangling && (_e.leading || _e.trailing) || O2 & Te2.Block && !g2(_e) || O2 & Te2.Line && !D(_e) || O2 & Te2.First && He2 !== 0 || O2 & Te2.Last && He2 !== Ge2.length - 1 || O2 & Te2.PrettierIgnore && !Ie2(_e) || me2 && !me2(_e));
          };
          function Me2(O2, me2, _e) {
            if (!u(O2 == null ? void 0 : O2.comments))
              return false;
            let He2 = je2(me2, _e);
            return He2 ? O2.comments.some(He2) : true;
          }
          function ae(O2, me2, _e) {
            if (!Array.isArray(O2 == null ? void 0 : O2.comments))
              return [];
            let He2 = je2(me2, _e);
            return He2 ? O2.comments.filter(He2) : O2.comments;
          }
          var nt = (O2, me2) => {
            let { originalText: _e } = me2;
            return i2(_e, y(O2));
          };
          function tt(O2) {
            return de2(O2) || O2.type === "NewExpression" || O2.type === "ImportExpression";
          }
          function Ve2(O2) {
            return O2 && (O2.type === "ObjectProperty" || O2.type === "Property" && !O2.method && O2.kind === "init");
          }
          function We2(O2) {
            return Boolean(O2.__isUsingHackPipeline);
          }
          var Xe2 = Symbol("ifWithoutBlockAndSameLineComment");
          function st2(O2) {
            return O2.type === "TSAsExpression" || O2.type === "TSSatisfiesExpression";
          }
          r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye2, iterateCallArgumentsPath: Se2, hasRestParameter: Ce2, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w2, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x2, hasNode: N2, hasIgnoreComment: Je2, hasNodeIgnoreComment: Oe2, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We2, isLineComment: D, isPrettierIgnoreComment: Ie2, isCallExpression: de2, isMemberExpression: ue2, isExportDeclaration: T, isFlowAnnotationComment: U2, isFunctionCompositionArgs: Re2, isFunctionNotation: J3, isFunctionOrArrowExpression: b, isGetterOrSetter: q2, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C2, isLongCurriedCallExpression: Ne2, isSimpleCallArgument: Pe2, isMemberish: j2, isNumericLiteral: o, isSignedNumericLiteral: d2, isObjectProperty: Ve2, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie2, isSimpleNumber: fe2, isSimpleTemplateLiteral: Fe2, isStringLiteral: v2, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we2, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe2, isTypeAnnotationAFunction: Q2, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke2, rawText: oe2, shouldPrintComma: X2, isBitwiseOperator: ye, shouldFlatten: A2, startsWithNoLookaheadToken: le, getPrecedence: re2, hasComment: Me2, getComments: ae, CommentCheckFlags: Te2, markerForIfWithoutBlockAndSameLineComment: Xe2, isTSTypeExpression: st2 };
        } }), jt = te2({ "src/language-js/print/template-literal.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2(), { getStringWidth: s, getIndentSize: a } = Ue2(), { builders: { join: n2, hardline: u, softline: i2, group: l, indent: p, align: y, lineSuffixBoundary: h, addAlignmentToDoc: g2 }, printer: { printDocToString: c }, utils: { mapDoc: f2 } } = qe(), { isBinaryish: F2, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w2, hasComment: E, isMemberExpression: N2, isTSTypeExpression: x2 } = Ke3();
          function I(C2, o, d2) {
            let v2 = C2.getValue();
            if (v2.type === "TemplateLiteral" && _(v2, C2.getParentNode())) {
              let R = P(C2, d2, o);
              if (R)
                return R;
            }
            let b = "expressions";
            v2.type === "TSTemplateLiteralType" && (b = "types");
            let B = [], k = C2.map(o, b), M = w2(v2);
            return M && (k = k.map((R) => c(R, Object.assign(Object.assign({}, d2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h, "`"), C2.each((R) => {
              let q2 = R.getName();
              if (B.push(o()), q2 < k.length) {
                let { tabWidth: J3 } = d2, L = R.getValue(), Q2 = a(L.value.raw, J3), V = k[q2];
                if (!M) {
                  let Y3 = v2[b][q2];
                  (E(Y3) || N2(Y3) || Y3.type === "ConditionalExpression" || Y3.type === "SequenceExpression" || x2(Y3) || F2(Y3)) && (V = [p([i2, V]), i2]);
                }
                let j2 = Q2 === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g2(V, Q2, J3);
                B.push(l(["${", j2, h, "}"]));
              }
            }, "quasis"), B.push("`"), B;
          }
          function P(C2, o, d2) {
            let v2 = C2.getNode(), S = v2.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (S.length > 1 || S.some((b) => b.length > 0)) {
              o.__inJestEach = true;
              let b = C2.map(d2, "expressions");
              o.__inJestEach = false;
              let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
              for (let L = 1; L < v2.quasis.length; L++) {
                let Q2 = t2(M), V = k[L - 1];
                Q2.cells.push(V), V.includes(`
`) && (Q2.hasLineBreak = true), v2.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
              }
              let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q2 = Array.from({ length: R }).fill(0), J3 = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
              for (let { cells: L } of J3.filter((Q2) => !Q2.hasLineBreak))
                for (let [Q2, V] of L.entries())
                  q2[Q2] = Math.max(q2[Q2], s(V));
              return B.push(h, "`", p([u, n2(u, J3.map((L) => n2(" | ", L.cells.map((Q2, V) => L.hasLineBreak ? Q2 : Q2 + " ".repeat(q2[V] - s(Q2))))))]), u, "`"), B;
            }
          }
          function $(C2, o) {
            let d2 = C2.getValue(), v2 = o();
            return E(d2) && (v2 = l([p([i2, v2]), i2])), ["${", v2, h, "}"];
          }
          function D(C2, o) {
            return C2.map((d2) => $(d2, o), "expressions");
          }
          function T(C2, o) {
            return f2(C2, (d2) => typeof d2 == "string" ? o ? d2.replace(/(\\*)`/g, "$1$1\\`") : m(d2) : d2);
          }
          function m(C2) {
            return C2.replace(/([\\`]|\${)/g, "\\$1");
          }
          r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
        } }), Ym = te2({ "src/language-js/embed/markdown.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { indent: t2, softline: s, literalline: a, dedentToRoot: n2 } } = qe(), { escapeTemplateCharacters: u } = jt();
          function i2(p, y, h) {
            let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w2, E) => "\\".repeat(E.length / 2) + "`"), f2 = l(c), F2 = f2 !== "";
            F2 && (c = c.replace(new RegExp(`^${f2}`, "gm"), ""));
            let _ = u(h(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", F2 ? t2([s, _]) : [a, n2(_)], s, "`"];
          }
          function l(p) {
            let y = p.match(/^([^\S\n]*)\S/m);
            return y === null ? "" : y[1];
          }
          r.exports = i2;
        } }), Qm = te2({ "src/language-js/embed/css.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2 } = Ue2(), { builders: { indent: s, hardline: a, softline: n2 }, utils: { mapDoc: u, replaceEndOfLine: i2, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = jt();
          function y(c, f2, F2) {
            let _ = c.getValue(), w2 = _.quasis.map((P) => P.value.raw), E = 0, N2 = w2.reduce((P, $, D) => D === 0 ? $ : P + "@prettier-placeholder-" + E++ + "-id" + $, ""), x2 = F2(N2, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c, f2);
            return h(x2, _, I);
          }
          function h(c, f2, F2) {
            if (f2.quasis.length === 1 && !f2.quasis[0].value.raw.trim())
              return "``";
            let w2 = g2(c, F2);
            if (!w2)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, w2]), n2, "`"];
          }
          function g2(c, f2) {
            if (!t2(f2))
              return c;
            let F2 = 0, _ = u(l(c), (w2) => typeof w2 != "string" || !w2.includes("@prettier-placeholder") ? w2 : w2.split(/@prettier-placeholder-(\d+)-id/).map((E, N2) => N2 % 2 === 0 ? i2(E) : (F2++, f2[E])));
            return f2.length === F2 ? _ : null;
          }
          r.exports = y;
        } }), Zm = te2({ "src/language-js/embed/graphql.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { indent: t2, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n2, printTemplateExpressions: u } = jt();
          function i2(p, y, h) {
            let g2 = p.getValue(), c = g2.quasis.length;
            if (c === 1 && g2.quasis[0].value.raw.trim() === "")
              return "``";
            let f2 = u(p, y), F2 = [];
            for (let _ = 0; _ < c; _++) {
              let w2 = g2.quasis[_], E = _ === 0, N2 = _ === c - 1, x2 = w2.value.cooked, I = x2.split(`
`), P = I.length, $ = f2[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
              if (!N2 && /#[^\n\r]*$/.test(I[P - 1]))
                return null;
              let C2 = null;
              m ? C2 = l(I) : C2 = h(x2, { parser: "graphql" }, { stripTrailingHardline: true }), C2 ? (C2 = n2(C2, false), !E && D && F2.push(""), F2.push(C2), !N2 && T && F2.push("")) : !E && !N2 && D && F2.push(""), $ && F2.push($);
            }
            return ["`", t2([a, s(a, F2)]), a, "`"];
          }
          function l(p) {
            let y = [], h = false, g2 = p.map((c) => c.trim());
            for (let [c, f2] of g2.entries())
              f2 !== "" && (g2[c - 1] === "" && h ? y.push([a, f2]) : y.push(f2), h = true);
            return y.length === 0 ? null : s(a, y);
          }
          r.exports = i2;
        } }), ed = te2({ "src/language-js/embed/html.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { indent: t2, line: s, hardline: a, group: n2 }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i2, uncookTemplateElementValue: l } = jt(), p = 0;
          function y(h, g2, c, f2, F2) {
            let { parser: _ } = F2, w2 = h.getValue(), E = p;
            p = p + 1 >>> 0;
            let N2 = (d2) => `PRETTIER_HTML_PLACEHOLDER_${d2}_${E}_IN_JS`, x2 = w2.quasis.map((d2, v2, S) => v2 === S.length - 1 ? d2.value.cooked : d2.value.cooked + N2(v2)).join(""), I = i2(h, g2);
            if (I.length === 0 && x2.trim().length === 0)
              return "``";
            let P = new RegExp(N2("(\\d+)"), "g"), $ = 0, D = c(x2, { parser: _, __onHtmlRoot(d2) {
              $ = d2.children.length;
            } }, { stripTrailingHardline: true }), T = u(D, (d2) => {
              if (typeof d2 != "string")
                return d2;
              let v2 = [], S = d2.split(P);
              for (let b = 0; b < S.length; b++) {
                let B = S[b];
                if (b % 2 === 0) {
                  B && (B = l(B), f2.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v2.push(B));
                  continue;
                }
                let k = Number(B);
                v2.push(I[k]);
              }
              return v2;
            }), m = /^\s/.test(x2) ? " " : "", C2 = /\s$/.test(x2) ? " " : "", o = f2.htmlWhitespaceSensitivity === "ignore" ? a : m && C2 ? s : null;
            return n2(o ? ["`", t2([o, n2(T)]), o, "`"] : ["`", m, $ > 1 ? t2(n2(T)) : n2(T), C2, "`"]);
          }
          r.exports = y;
        } }), td = te2({ "src/language-js/embed.js"(e, r) {
          "use strict";
          ne2();
          var { hasComment: t2, CommentCheckFlags: s, isObjectProperty: a } = Ke3(), n2 = Ym(), u = Qm(), i2 = Zm(), l = ed();
          function p(D) {
            if (g2(D) || _(D) || w2(D) || c(D))
              return "css";
            if (x2(D))
              return "graphql";
            if (P(D))
              return "html";
            if (f2(D))
              return "angular";
            if (h(D))
              return "markdown";
          }
          function y(D, T, m, C2) {
            let o = D.getValue();
            if (o.type !== "TemplateLiteral" || $(o))
              return;
            let d2 = p(D);
            if (d2) {
              if (d2 === "markdown")
                return n2(D, T, m);
              if (d2 === "css")
                return u(D, T, m);
              if (d2 === "graphql")
                return i2(D, T, m);
              if (d2 === "html" || d2 === "angular")
                return l(D, T, m, C2, { parser: d2 });
            }
          }
          function h(D) {
            let T = D.getValue(), m = D.getParentNode();
            return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
          }
          function g2(D) {
            let T = D.getValue(), m = D.getParentNode(), C2 = D.getParentNode(1);
            return C2 && T.quasis && m.type === "JSXExpressionContainer" && C2.type === "JSXElement" && C2.openingElement.name.name === "style" && C2.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
          }
          function c(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F2);
          }
          function f2(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F2);
          }
          var F2 = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
          function _(D) {
            let T = D.getParentNode();
            if (!T || T.type !== "TaggedTemplateExpression")
              return false;
            let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
            switch (m.type) {
              case "MemberExpression":
                return E(m.object) || N2(m);
              case "CallExpression":
                return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N2(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
              case "Identifier":
                return m.name === "css";
              default:
                return false;
            }
          }
          function w2(D) {
            let T = D.getParentNode(), m = D.getParentNode(1);
            return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
          }
          function E(D) {
            return D.type === "Identifier" && D.name === "styled";
          }
          function N2(D) {
            return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
          }
          function x2(D) {
            let T = D.getValue(), m = D.getParentNode();
            return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
          }
          function I(D, T) {
            return t2(D, s.Block | s.Leading, (m) => {
              let { value: C2 } = m;
              return C2 === ` ${T} `;
            });
          }
          function P(D) {
            return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
          }
          function $(D) {
            let { quasis: T } = D;
            return T.some((m) => {
              let { value: { cooked: C2 } } = m;
              return C2 === null;
            });
          }
          r.exports = y;
        } }), rd = te2({ "src/language-js/clean.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
            for (let i2 of u.quasis)
              delete i2.value;
          };
          function n2(u, i2, l) {
            if (u.type === "Program" && delete i2.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i2.value && (i2.value = i2.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i2.bigint && (i2.bigint = i2.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i2.value = Number(i2.value)), u.type === "Literal" && i2.decimal && (i2.decimal = Number(i2.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
              return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i2.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx"))
              for (let { type: h, expression: g2 } of i2.children)
                h === "JSXExpressionContainer" && g2.type === "TemplateLiteral" && a(g2);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i2.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i2.value.value = i2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let p = u.expression || u.callee;
            if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
              let h = u.expression.arguments[0].properties;
              for (let [g2, c] of i2.expression.arguments[0].properties.entries())
                switch (h[g2].key.name) {
                  case "styles":
                    c.value.type === "ArrayExpression" && a(c.value.elements[0]);
                    break;
                  case "template":
                    c.value.type === "TemplateLiteral" && a(c.value);
                    break;
                }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i2.quasi), u.type === "TemplateLiteral") {
              var y;
              (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g2) => t2(g2) && ["GraphQL", "HTML"].some((c) => g2.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i2);
            }
            if (u.type === "InterpreterDirective" && (i2.value = i2.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
              return i2.types[0];
          }
          n2.ignoredProperties = s, r.exports = n2;
        } }), io = {};
        Kt(io, { EOL: () => Wn, arch: () => nd, cpus: () => Do, default: () => vo, endianness: () => ao, freemem: () => po, getNetworkInterfaces: () => ho, hostname: () => oo, loadavg: () => lo, networkInterfaces: () => yo, platform: () => ud, release: () => go, tmpDir: () => $n, tmpdir: () => Vn, totalmem: () => fo2, type: () => mo, uptime: () => co });
        function ao() {
          if (typeof Tr3 > "u") {
            var e = new ArrayBuffer(2), r = new Uint8Array(e), t2 = new Uint16Array(e);
            if (r[0] = 1, r[1] = 2, t2[0] === 258)
              Tr3 = "BE";
            else if (t2[0] === 513)
              Tr3 = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Tr3;
        }
        function oo() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function lo() {
          return [];
        }
        function co() {
          return 0;
        }
        function po() {
          return Number.MAX_VALUE;
        }
        function fo2() {
          return Number.MAX_VALUE;
        }
        function Do() {
          return [];
        }
        function mo() {
          return "Browser";
        }
        function go() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function yo() {
        }
        function ho() {
        }
        function nd() {
          return "javascript";
        }
        function ud() {
          return "browser";
        }
        function $n() {
          return "/tmp";
        }
        var Tr3, Vn, Wn, vo, sd = ht({ "node-modules-polyfills:os"() {
          ne2(), Vn = $n, Wn = `
`, vo = { EOL: Wn, tmpdir: Vn, tmpDir: $n, networkInterfaces: yo, getNetworkInterfaces: ho, release: go, type: mo, cpus: Do, totalmem: fo2, freemem: po, uptime: co, loadavg: lo, hostname: oo, endianness: ao };
        } }), id = te2({ "node-modules-polyfills-commonjs:os"(e, r) {
          ne2();
          var t2 = (sd(), ft(io));
          if (t2 && t2.default) {
            r.exports = t2.default;
            for (let s in t2)
              r.exports[s] = t2[s];
          } else
            t2 && (r.exports = t2);
        } }), ad = te2({ "node_modules/detect-newline/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = (s) => {
            if (typeof s != "string")
              throw new TypeError("Expected a string");
            let a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0)
              return;
            let n2 = a.filter((i2) => i2 === `\r
`).length, u = a.length - n2;
            return n2 > u ? `\r
` : `
`;
          };
          r.exports = t2, r.exports.graceful = (s) => typeof s == "string" && t2(s) || `
`;
        } }), od = te2({ "node_modules/jest-docblock/build/index.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = F2, e.parseWithComments = _, e.print = w2, e.strip = f2;
          function r() {
            let N2 = id();
            return r = function() {
              return N2;
            }, N2;
          }
          function t2() {
            let N2 = s(ad());
            return t2 = function() {
              return N2;
            }, N2;
          }
          function s(N2) {
            return N2 && N2.__esModule ? N2 : { default: N2 };
          }
          var a = /\*\/$/, n2 = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i2 = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g2 = [];
          function c(N2) {
            let x2 = N2.match(u);
            return x2 ? x2[0].trimLeft() : "";
          }
          function f2(N2) {
            let x2 = N2.match(u);
            return x2 && x2[0] ? N2.substring(x2[0].length) : N2;
          }
          function F2(N2) {
            return _(N2).pragmas;
          }
          function _(N2) {
            let x2 = (0, t2().default)(N2) || r().EOL;
            N2 = N2.replace(n2, "").replace(a, "").replace(h, "$1");
            let I = "";
            for (; I !== N2; )
              I = N2, N2 = N2.replace(p, `${x2}$1 $2${x2}`);
            N2 = N2.replace(l, "").trimRight();
            let P = /* @__PURE__ */ Object.create(null), $ = N2.replace(y, "").replace(l, "").trimRight(), D;
            for (; D = y.exec(N2); ) {
              let T = D[2].replace(i2, "");
              typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g2.concat(P[D[1]], T) : P[D[1]] = T;
            }
            return { comments: $, pragmas: P };
          }
          function w2(N2) {
            let { comments: x2 = "", pragmas: I = {} } = N2, P = (0, t2().default)(x2) || r().EOL, $ = "/**", D = " *", T = " */", m = Object.keys(I), C2 = m.map((d2) => E(d2, I[d2])).reduce((d2, v2) => d2.concat(v2), []).map((d2) => `${D} ${d2}${P}`).join("");
            if (!x2) {
              if (m.length === 0)
                return "";
              if (m.length === 1 && !Array.isArray(I[m[0]])) {
                let d2 = I[m[0]];
                return `${$} ${E(m[0], d2)[0]}${T}`;
              }
            }
            let o = x2.split(P).map((d2) => `${D} ${d2}`).join(P) + P;
            return $ + P + (x2 ? o : "") + (x2 && m.length ? D + P : "") + C2 + T;
          }
          function E(N2, x2) {
            return g2.concat(x2).map((I) => `@${N2} ${I}`.trim());
          }
        } }), ld = te2({ "src/language-js/utils/get-shebang.js"(e, r) {
          "use strict";
          ne2();
          function t2(s) {
            if (!s.startsWith("#!"))
              return "";
            let a = s.indexOf(`
`);
            return a === -1 ? s : s.slice(0, a);
          }
          r.exports = t2;
        } }), Co = te2({ "src/language-js/pragma.js"(e, r) {
          "use strict";
          ne2();
          var { parseWithComments: t2, strip: s, extract: a, print: n2 } = od(), { normalizeEndOfLine: u } = Jn(), i2 = ld();
          function l(h) {
            let g2 = i2(h);
            g2 && (h = h.slice(g2.length + 1));
            let c = a(h), { pragmas: f2, comments: F2 } = t2(c);
            return { shebang: g2, text: h, pragmas: f2, comments: F2 };
          }
          function p(h) {
            let g2 = Object.keys(l(h).pragmas);
            return g2.includes("prettier") || g2.includes("format");
          }
          function y(h) {
            let { shebang: g2, text: c, pragmas: f2, comments: F2 } = l(h), _ = s(c), w2 = n2({ pragmas: Object.assign({ format: "" }, f2), comments: F2.trimStart() });
            return (g2 ? `${g2}
` : "") + u(w2) + (_.startsWith(`
`) ? `
` : `

`) + _;
          }
          r.exports = { hasPragma: p, insertPragma: y };
        } }), cd = te2({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Pt();
          function s(a) {
            return t2(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
          }
          r.exports = s;
        } }), Eo = te2({ "src/language-js/comments.js"(e, r) {
          "use strict";
          ne2();
          var { getLast: t2, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n2, hasNewlineInRange: u, addLeadingComment: i2, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h } = Ue2(), { getFunctionParameters: g2, isPrettierIgnoreComment: c, isJsxNode: f2, hasFlowShorthandAnnotationComment: F2, hasFlowAnnotationComment: _, hasIgnoreComment: w2, isCallLikeExpression: E, getCallArguments: N2, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke3(), { locStart: C2, locEnd: o } = ut(), d2 = Pt(), v2 = cd();
          function S(De3) {
            return [H, Fe2, Q2, q2, J3, L, ie2, he, se, ge, we2, ke2, ce2, z, U2].some((A2) => A2(De3));
          }
          function b(De3) {
            return [R, Fe2, V, we2, q2, J3, L, ie2, z, Z, fe2, ge, Pe2, U2, X2].some((A2) => A2(De3));
          }
          function B(De3) {
            return [H, q2, J3, j2, ue2, ce2, ge, de2, K, pe2, U2, oe2].some((A2) => A2(De3));
          }
          function k(De3, A2) {
            let G2 = (De3.body || De3.properties).find((re2) => {
              let { type: ye } = re2;
              return ye !== "EmptyStatement";
            });
            G2 ? i2(G2, A2) : p(De3, A2);
          }
          function M(De3, A2) {
            De3.type === "BlockStatement" ? k(De3, A2) : i2(De3, A2);
          }
          function R(De3) {
            let { comment: A2, followingNode: G2 } = De3;
            return G2 && v2(A2) ? (i2(G2, A2), true) : false;
          }
          function q2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye, text: Ce2 } = De3;
            if ((re2 == null ? void 0 : re2.type) !== "IfStatement" || !ye)
              return false;
            if (n2(Ce2, A2, o) === ")")
              return l(G2, A2), true;
            if (G2 === re2.consequent && ye === re2.alternate) {
              if (G2.type === "BlockStatement")
                l(G2, A2);
              else {
                let ve = A2.type === "SingleLine" || A2.loc.start.line === A2.loc.end.line, ze = A2.loc.start.line === G2.loc.start.line;
                ve && ze ? p(G2, A2, m) : p(re2, A2);
              }
              return true;
            }
            return ye.type === "BlockStatement" ? (k(ye, A2), true) : ye.type === "IfStatement" ? (M(ye.consequent, A2), true) : re2.consequent === ye ? (i2(ye, A2), true) : false;
          }
          function J3(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye, text: Ce2 } = De3;
            return (re2 == null ? void 0 : re2.type) !== "WhileStatement" || !ye ? false : n2(Ce2, A2, o) === ")" ? (l(G2, A2), true) : ye.type === "BlockStatement" ? (k(ye, A2), true) : re2.body === ye ? (i2(ye, A2), true) : false;
          }
          function L(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye } = De3;
            return (re2 == null ? void 0 : re2.type) !== "TryStatement" && (re2 == null ? void 0 : re2.type) !== "CatchClause" || !ye ? false : re2.type === "CatchClause" && G2 ? (l(G2, A2), true) : ye.type === "BlockStatement" ? (k(ye, A2), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A2), true) : ye.type === "CatchClause" ? (M(ye.body, A2), true) : false;
          }
          function Q2(De3) {
            let { comment: A2, enclosingNode: G2, followingNode: re2 } = De3;
            return I(G2) && (re2 == null ? void 0 : re2.type) === "Identifier" ? (i2(G2, A2), true) : false;
          }
          function V(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye, text: Ce2 } = De3, Be2 = G2 && !u(Ce2, o(G2), C2(A2));
            return (!G2 || !Be2) && ((re2 == null ? void 0 : re2.type) === "ConditionalExpression" || (re2 == null ? void 0 : re2.type) === "TSConditionalType") && ye ? (i2(ye, A2), true) : false;
          }
          function j2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2 } = De3;
            return P(re2) && re2.shorthand && re2.key === G2 && re2.value.type === "AssignmentPattern" ? (l(re2.value.left, A2), true) : false;
          }
          var Y3 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function ie2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye } = De3;
            if (Y3.has(re2 == null ? void 0 : re2.type)) {
              if (h(re2.decorators) && !(ye && ye.type === "Decorator"))
                return l(t2(re2.decorators), A2), true;
              if (re2.body && ye === re2.body)
                return k(re2.body, A2), true;
              if (ye) {
                if (re2.superClass && ye === re2.superClass && G2 && (G2 === re2.id || G2 === re2.typeParameters))
                  return l(G2, A2), true;
                for (let Ce2 of ["implements", "extends", "mixins"])
                  if (re2[Ce2] && ye === re2[Ce2][0])
                    return G2 && (G2 === re2.id || G2 === re2.typeParameters || G2 === re2.superClass) ? l(G2, A2) : p(re2, A2, Ce2), true;
              }
            }
            return false;
          }
          var ee2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
          function ce2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, text: ye } = De3;
            return re2 && G2 && n2(ye, A2, o) === "(" && (re2.type === "Property" || re2.type === "TSDeclareMethod" || re2.type === "TSAbstractMethodDefinition") && G2.type === "Identifier" && re2.key === G2 && n2(ye, G2, o) !== ":" || (G2 == null ? void 0 : G2.type) === "Decorator" && ee2.has(re2 == null ? void 0 : re2.type) ? (l(G2, A2), true) : false;
          }
          var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function K(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, text: ye } = De3;
            return n2(ye, A2, o) !== "(" ? false : G2 && W.has(re2 == null ? void 0 : re2.type) ? (l(G2, A2), true) : false;
          }
          function de2(De3) {
            let { comment: A2, enclosingNode: G2, text: re2 } = De3;
            if ((G2 == null ? void 0 : G2.type) !== "ArrowFunctionExpression")
              return false;
            let ye = y(re2, A2, o);
            return ye !== false && re2.slice(ye, ye + 2) === "=>" ? (p(G2, A2), true) : false;
          }
          function ue2(De3) {
            let { comment: A2, enclosingNode: G2, text: re2 } = De3;
            return n2(re2, A2, o) !== ")" ? false : G2 && (le(G2) && g2(G2).length === 0 || E(G2) && N2(G2).length === 0) ? (p(G2, A2), true) : ((G2 == null ? void 0 : G2.type) === "MethodDefinition" || (G2 == null ? void 0 : G2.type) === "TSAbstractMethodDefinition") && g2(G2.value).length === 0 ? (p(G2.value, A2), true) : false;
          }
          function Fe2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye, text: Ce2 } = De3;
            if ((G2 == null ? void 0 : G2.type) === "FunctionTypeParam" && (re2 == null ? void 0 : re2.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G2 == null ? void 0 : G2.type) === "Identifier" || (G2 == null ? void 0 : G2.type) === "AssignmentPattern") && re2 && le(re2) && n2(Ce2, A2, o) === ")")
              return l(G2, A2), true;
            if ((re2 == null ? void 0 : re2.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
              let Be2 = (() => {
                let ve = g2(re2);
                if (ve.length > 0)
                  return a(Ce2, o(t2(ve)));
                let ze = a(Ce2, o(re2.id));
                return ze !== false && a(Ce2, ze + 1);
              })();
              if (C2(A2) > Be2)
                return k(ye, A2), true;
            }
            return false;
          }
          function z(De3) {
            let { comment: A2, enclosingNode: G2 } = De3;
            return (G2 == null ? void 0 : G2.type) === "LabeledStatement" ? (i2(G2, A2), true) : false;
          }
          function U2(De3) {
            let { comment: A2, enclosingNode: G2 } = De3;
            return ((G2 == null ? void 0 : G2.type) === "ContinueStatement" || (G2 == null ? void 0 : G2.type) === "BreakStatement") && !G2.label ? (l(G2, A2), true) : false;
          }
          function Z(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2 } = De3;
            return x2(re2) && G2 && re2.callee === G2 && re2.arguments.length > 0 ? (i2(re2.arguments[0], A2), true) : false;
          }
          function se(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye } = De3;
            return (re2 == null ? void 0 : re2.type) === "UnionTypeAnnotation" || (re2 == null ? void 0 : re2.type) === "TSUnionType" ? (c(A2) && (ye.prettierIgnore = true, A2.unignore = true), G2 ? (l(G2, A2), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c(A2) && (ye.types[0].prettierIgnore = true, A2.unignore = true), false);
          }
          function fe2(De3) {
            let { comment: A2, enclosingNode: G2 } = De3;
            return P(G2) ? (i2(G2, A2), true) : false;
          }
          function ge(De3) {
            let { comment: A2, enclosingNode: G2, followingNode: re2, ast: ye, isLastComment: Ce2 } = De3;
            return ye && ye.body && ye.body.length === 0 ? (Ce2 ? p(ye, A2) : i2(ye, A2), true) : (G2 == null ? void 0 : G2.type) === "Program" && (G2 == null ? void 0 : G2.body.length) === 0 && !h(G2.directives) ? (Ce2 ? p(G2, A2) : i2(G2, A2), true) : (re2 == null ? void 0 : re2.type) === "Program" && (re2 == null ? void 0 : re2.body.length) === 0 && (G2 == null ? void 0 : G2.type) === "ModuleExpression" ? (p(re2, A2), true) : false;
          }
          function he(De3) {
            let { comment: A2, enclosingNode: G2 } = De3;
            return (G2 == null ? void 0 : G2.type) === "ForInStatement" || (G2 == null ? void 0 : G2.type) === "ForOfStatement" ? (i2(G2, A2), true) : false;
          }
          function we2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, text: ye } = De3;
            if ((re2 == null ? void 0 : re2.type) === "ImportSpecifier" || (re2 == null ? void 0 : re2.type) === "ExportSpecifier")
              return i2(re2, A2), true;
            let Ce2 = (G2 == null ? void 0 : G2.type) === "ImportSpecifier" && (re2 == null ? void 0 : re2.type) === "ImportDeclaration", Be2 = (G2 == null ? void 0 : G2.type) === "ExportSpecifier" && (re2 == null ? void 0 : re2.type) === "ExportNamedDeclaration";
            return (Ce2 || Be2) && s(ye, o(A2)) ? (l(G2, A2), true) : false;
          }
          function ke2(De3) {
            let { comment: A2, enclosingNode: G2 } = De3;
            return (G2 == null ? void 0 : G2.type) === "AssignmentPattern" ? (i2(G2, A2), true) : false;
          }
          var Re2 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne2 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function Pe2(De3) {
            let { comment: A2, enclosingNode: G2, followingNode: re2 } = De3;
            return Re2.has(G2 == null ? void 0 : G2.type) && re2 && (Ne2.has(re2.type) || d2(A2)) ? (i2(re2, A2), true) : false;
          }
          function oe2(De3) {
            let { comment: A2, enclosingNode: G2, followingNode: re2, text: ye } = De3;
            return !re2 && ((G2 == null ? void 0 : G2.type) === "TSMethodSignature" || (G2 == null ? void 0 : G2.type) === "TSDeclareFunction" || (G2 == null ? void 0 : G2.type) === "TSAbstractMethodDefinition") && n2(ye, A2, o) === ";" ? (l(G2, A2), true) : false;
          }
          function H(De3) {
            let { comment: A2, enclosingNode: G2, followingNode: re2 } = De3;
            if (c(A2) && (G2 == null ? void 0 : G2.type) === "TSMappedType" && (re2 == null ? void 0 : re2.type) === "TSTypeParameter" && re2.constraint)
              return G2.prettierIgnore = true, A2.unignore = true, true;
          }
          function pe2(De3) {
            let { comment: A2, precedingNode: G2, enclosingNode: re2, followingNode: ye } = De3;
            return (re2 == null ? void 0 : re2.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i2(ye.name, A2), true) : (G2 == null ? void 0 : G2.type) === "TSTypeParameter" && G2.constraint ? (l(G2.constraint, A2), true) : false;
          }
          function X2(De3) {
            let { comment: A2, enclosingNode: G2, followingNode: re2 } = De3;
            return !G2 || G2.type !== "SwitchCase" || G2.test || !re2 || re2 !== G2.consequent[0] ? false : (re2.type === "BlockStatement" && $(A2) ? k(re2, A2) : p(G2, A2), true);
          }
          function le(De3) {
            return De3.type === "ArrowFunctionExpression" || De3.type === "FunctionExpression" || De3.type === "FunctionDeclaration" || De3.type === "ObjectMethod" || De3.type === "ClassMethod" || De3.type === "TSDeclareFunction" || De3.type === "TSCallSignatureDeclaration" || De3.type === "TSConstructSignatureDeclaration" || De3.type === "TSMethodSignature" || De3.type === "TSConstructorType" || De3.type === "TSFunctionType" || De3.type === "TSDeclareMethod";
          }
          function Ae2(De3, A2) {
            if ((A2.parser === "typescript" || A2.parser === "flow" || A2.parser === "acorn" || A2.parser === "espree" || A2.parser === "meriyah" || A2.parser === "__babel_estree") && De3.type === "MethodDefinition" && De3.value && De3.value.type === "FunctionExpression" && g2(De3.value).length === 0 && !De3.value.returnType && !h(De3.value.typeParameters) && De3.value.body)
              return [...De3.decorators || [], De3.key, De3.value.body];
          }
          function Ee2(De3) {
            let A2 = De3.getValue(), G2 = De3.getParentNode(), re2 = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
            return (A2 && (f2(A2) || F2(A2) || x2(G2) && re2(A2)) || G2 && (G2.type === "JSXSpreadAttribute" || G2.type === "JSXSpreadChild" || G2.type === "UnionTypeAnnotation" || G2.type === "TSUnionType" || (G2.type === "ClassDeclaration" || G2.type === "ClassExpression") && G2.superClass === A2)) && (!w2(De3) || G2.type === "UnionTypeAnnotation" || G2.type === "TSUnionType");
          }
          r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae2, willPrintOwnComments: Ee2 };
        } }), qt = te2({ "src/language-js/needs-parens.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2(), s = Kn(), { getFunctionParameters: a, getLeftSidePathName: n2, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i2, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y, shouldFlatten: h, getPrecedence: g2, isCallExpression: c, isMemberExpression: f2, isObjectProperty: F2, isTSTypeExpression: _ } = Ke3();
          function w2(D, T) {
            let m = D.getParentNode();
            if (!m)
              return false;
            let C2 = D.getName(), o = D.getNode();
            if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D))
              return true;
            if (E(o))
              return false;
            if (T.parser !== "flow" && u(D.getValue()))
              return true;
            if (o.type === "Identifier") {
              if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C2 === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement")
                return true;
              if (o.name === "let") {
                var d2;
                let S = (d2 = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d2 === void 0 ? void 0 : d2.left;
                if (S && y(S, (b) => b === o))
                  return true;
              }
              if (C2 === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                if (b && y(b, (B) => B === o))
                  return true;
              }
              return false;
            }
            if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
              var v2;
              let S = (v2 = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v2 === void 0 ? void 0 : v2.expression;
              if (S && y(S, (b) => b === o))
                return true;
            }
            switch (m.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (C2 === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return $(D, T) || o.type === "SequenceExpression";
              case "Decorator": {
                if (C2 === "expression") {
                  if (f2(o) && o.computed)
                    return true;
                  let S = false, b = false, B = o;
                  for (; B; )
                    switch (B.type) {
                      case "MemberExpression":
                        b = true, B = B.object;
                        break;
                      case "CallExpression":
                        if (b || S)
                          return T.parser !== "typescript";
                        S = true, B = B.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return T.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ArrowFunctionExpression": {
                if (C2 === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression"))
                  return true;
                break;
              }
            }
            switch (o.type) {
              case "UpdateExpression":
                if (m.type === "UnaryExpression")
                  return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
              case "UnaryExpression":
                switch (m.type) {
                  case "UnaryExpression":
                    return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C2 === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C2 === "callee";
                  case "BinaryExpression":
                    return C2 === "left" && m.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m.type === "UpdateExpression" || o.operator === "in" && N2(D))
                  return true;
                if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                  let S = D.getParentNode(1);
                  if (S.type === "BinaryExpression" && S.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !_(o);
                  case "ConditionalExpression":
                    return _(o);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return C2 === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return C2 === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C2 === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return C2 === "left" && (o.type === "TSTypeAssertion" || _(o));
                  case "LogicalExpression":
                    if (o.type === "LogicalExpression")
                      return m.operator !== o.operator;
                  case "BinaryExpression": {
                    let { operator: S, type: b } = o;
                    if (!S && b !== "TSTypeAssertion")
                      return true;
                    let B = g2(S), k = m.operator, M = g2(k);
                    return M > B || C2 === "right" && M === B || M === B && !h(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return C2 !== "expression";
                  case "ArrowFunctionExpression":
                    return C2 !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C2 === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C2 === "callee";
                  case "ConditionalExpression":
                    return C2 === "test";
                  case "BinaryExpression":
                    return !(!o.argument && m.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
              case "TSFunctionType":
              case "TSConstructorType":
                if (C2 === "extendsType" && m.type === "TSConditionalType") {
                  if (o.type === "TSConditionalType")
                    return true;
                  let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                  if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
                    return true;
                }
                if (C2 === "checkType" && m.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                  return true;
              case "TSInferType":
                if (o.type === "TSInferType" && m.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C2 === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
              case "TSTypeQuery":
                return C2 === "objectType" && m.type === "TSIndexedAccessType" || C2 === "elementType" && m.type === "TSArrayType";
              case "TypeofTypeAnnotation":
                return C2 === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C2 === "elementType" && m.type === "ArrayTypeAnnotation";
              case "ArrayTypeAnnotation":
                return m.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C2 === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || C2 === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C2 === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return C2 === "objectType" && m.type === "IndexedAccessType";
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                  let S = D.getParentNode(1);
                  return S.type === "Program" || S.type === "BlockStatement";
                }
                return C2 === "object" && m.type === "MemberExpression" && typeof o.value == "number";
              case "AssignmentExpression": {
                let S = D.getParentNode(1);
                return C2 === "body" && m.type === "ArrowFunctionExpression" ? true : C2 === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C2 === "init" || C2 === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C2 === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C2 === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C2 === "callee";
                  case "ConditionalExpression":
                    return C2 === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C2 === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C2 === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m.type) {
                  case "BinaryExpression":
                    return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C2 === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C2 === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return C2 === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s(o.decorators))
                  return true;
                switch (m.type) {
                  case "NewExpression":
                    return C2 === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let S = D.getParentNode(1);
                if (C2 === "object" && m.type === "MemberExpression" || C2 === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (C2 === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                  let S = o;
                  for (; S; )
                    switch (S.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        S = S.object;
                        break;
                      case "TaggedTemplateExpression":
                        S = S.tag;
                        break;
                      case "TSNonNullExpression":
                        S = S.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return C2 === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C2 === "object" && f2(m);
              case "NGPipeExpression":
                return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C2] === o || C2 === "right" && m.type === "NGPipeExpression" || C2 === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return C2 === "callee" || C2 === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !F2(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
              case "TypeAnnotation":
                return C2 === "returnType" && m.type === "ArrowFunctionExpression" && x2(o);
            }
            return false;
          }
          function E(D) {
            return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
          }
          function N2(D) {
            let T = 0, m = D.getValue();
            for (; m; ) {
              let C2 = D.getParentNode(T++);
              if (C2 && C2.type === "ForStatement" && C2.init === m)
                return true;
              m = C2;
            }
            return false;
          }
          function x2(D) {
            return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function I(D) {
            switch (D.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function P(D) {
            let T = D.getValue(), m = D.getParentNode(), C2 = D.getName();
            switch (m.type) {
              case "NGPipeExpression":
                if (typeof C2 == "number" && m.arguments[C2] === T && m.arguments.length - 1 === C2)
                  return D.callParent(P);
                break;
              case "ObjectProperty":
                if (C2 === "value") {
                  let o = D.getParentNode(1);
                  return t2(o.properties) === m;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (C2 === "right")
                  return D.callParent(P);
                break;
              case "ConditionalExpression":
                if (C2 === "alternate")
                  return D.callParent(P);
                break;
              case "UnaryExpression":
                if (m.prefix)
                  return D.callParent(P);
                break;
            }
            return false;
          }
          function $(D, T) {
            let m = D.getValue(), C2 = D.getParentNode();
            return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C2.type === "ExportDefaultDeclaration" || !w2(D, T) : !i2(m) || C2.type !== "ExportDefaultDeclaration" && w2(D, T) ? false : D.call((o) => $(o, T), ...n2(D, m));
          }
          r.exports = w2;
        } }), Fo = te2({ "src/language-js/print-preprocess.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
              default:
                return s;
            }
          }
          r.exports = t2;
        } }), pd = te2({ "src/language-js/print/html-binding.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { join: t2, line: s, group: a, softline: n2, indent: u } } = qe();
          function i2(p, y, h) {
            let g2 = p.getValue();
            if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g2, y), g2.type === "File") {
              if (y.__isVueForBindingLeft)
                return p.call((c) => {
                  let f2 = t2([",", s], c.map(h, "params")), { params: F2 } = c.getValue();
                  return F2.length === 1 ? f2 : ["(", u([n2, a(f2)]), n2, ")"];
                }, "program", "body", 0);
              if (y.__isVueBindings)
                return p.call((c) => t2([",", s], c.map(h, "params")), "program", "body", 0);
            }
          }
          function l(p) {
            switch (p.type) {
              case "MemberExpression":
                switch (p.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l(p.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i2 };
        } }), ru = te2({ "src/language-js/print/binaryish.js"(e, r) {
          "use strict";
          ne2();
          var { printComments: t2 } = et(), { getLast: s } = Ue2(), { builders: { join: a, line: n2, softline: u, group: i2, indent: l, align: p, indentIfBreak: y }, utils: { cleanDoc: h, getDocParts: g2, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f2, isBinaryish: F2, isJsxNode: _, shouldFlatten: w2, hasComment: E, CommentCheckFlags: N2, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke3(), D = 0;
          function T(o, d2, v2) {
            let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $(d2) && S.operator === "|>", R = m(o, v2, d2, false, k);
            if (k)
              return R;
            if (M)
              return i2(R);
            if (x2(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed)
              return i2([l([u, ...R]), u]);
            let q2 = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d2.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x2(B) || b.type === "TemplateLiteral", J3 = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F2(S.left) && w2(S.operator, S.left.operator);
            if (q2 || C2(S) && !L || !C2(S) && J3)
              return i2(R);
            if (R.length === 0)
              return "";
            let Q2 = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j2 = R.slice(0, V === -1 ? 1 : V + 1), Y3 = R.slice(j2.length, Q2 ? -1 : void 0), ie2 = Symbol("logicalChain-" + ++D), ee2 = i2([...j2, l(Y3)], { id: ie2 });
            if (!Q2)
              return ee2;
            let ce2 = s(R);
            return i2([ee2, y(ce2, { groupId: ie2 })]);
          }
          function m(o, d2, v2, S, b) {
            let B = o.getValue();
            if (!F2(B))
              return [i2(d2())];
            let k = [];
            w2(B.operator, B.left.operator) ? k = o.call((Y3) => m(Y3, d2, v2, true, b), "left") : k.push(i2(d2("left")));
            let M = C2(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v2.parser === "__vue_expression") && !f2(v2.originalText, B.right), q2 = B.type === "NGPipeExpression" ? "|" : B.operator, J3 = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i2(l([n2, ": ", a([n2, ": "], o.map(d2, "arguments").map((Y3) => p(2, i2(Y3))))])) : "", L;
            if (M)
              L = [q2, " ", d2("right"), J3];
            else {
              let ie2 = $(v2) && q2 === "|>" ? o.call((ee2) => m(ee2, d2, v2, true, b), "right") : d2("right");
              L = [R ? n2 : "", q2, R ? " " : n2, ie2, J3];
            }
            let Q2 = o.getParentNode(), V = E(B.left, N2.Trailing | N2.Line), j2 = V || !(b && B.type === "LogicalExpression") && Q2.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
            if (k.push(R ? "" : " ", j2 ? i2(L, { shouldBreak: V }) : L), S && E(B)) {
              let Y3 = h(t2(o, k, v2));
              return c(Y3) || Y3.type === "fill" ? g2(Y3) : [Y3];
            }
            return k;
          }
          function C2(o) {
            return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
          }
          r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C2 };
        } }), fd = te2({ "src/language-js/print/angular.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { join: t2, line: s, group: a } } = qe(), { hasNode: n2, hasComment: u, getComments: i2 } = Ke3(), { printBinaryishExpression: l } = ru();
          function p(g2, c, f2) {
            let F2 = g2.getValue();
            if (F2.type.startsWith("NG"))
              switch (F2.type) {
                case "NGRoot":
                  return [f2("node"), u(F2.node) ? " //" + i2(F2.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return l(g2, c, f2);
                case "NGChainedExpression":
                  return a(t2([";", s], g2.map((_) => h(_) ? f2() : ["(", f2(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [F2.prefix, ": ", F2.value.trim()];
                case "NGMicrosyntax":
                  return g2.map((_, w2) => [w2 === 0 ? "" : y(_.getValue(), w2, F2) ? " " : [";", s], f2()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F2.name) ? F2.name : JSON.stringify(F2.name);
                case "NGMicrosyntaxExpression":
                  return [f2("expression"), F2.alias === null ? "" : [" as ", f2("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let _ = g2.getName(), w2 = g2.getParentNode(), E = y(F2, _, w2) || (_ === 1 && (F2.key.name === "then" || F2.key.name === "else") || _ === 2 && F2.key.name === "else" && w2.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w2.body[_ - 1].key.name === "then") && w2.body[0].type === "NGMicrosyntaxExpression";
                  return [f2("key"), E ? " " : ": ", f2("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", f2("key"), F2.value === null ? "" : [" = ", f2("value")]];
                case "NGMicrosyntaxAs":
                  return [f2("key"), " as ", f2("alias")];
                default:
                  throw new Error(`Unknown Angular node type: ${JSON.stringify(F2.type)}.`);
              }
          }
          function y(g2, c, f2) {
            return g2.type === "NGMicrosyntaxKeyedExpression" && g2.key.name === "of" && c === 1 && f2.body[0].type === "NGMicrosyntaxLet" && f2.body[0].value === null;
          }
          function h(g2) {
            return n2(g2.getValue(), (c) => {
              switch (c.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          r.exports = { printAngular: p };
        } }), Dd = te2({ "src/language-js/print/jsx.js"(e, r) {
          "use strict";
          ne2();
          var { printComments: t2, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n2, hardline: u, softline: i2, group: l, indent: p, conditionalGroup: y, fill: h, ifBreak: g2, lineSuffixBoundary: c, join: f2 }, utils: { willBreak: F2 } } = qe(), { getLast: _, getPreferredQuote: w2 } = Ue2(), { isJsxNode: E, rawText: N2, isCallExpression: x2, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke3(), m = qt(), { willPrintOwnComments: C2 } = Eo(), o = (U2) => U2 === "" || U2 === n2 || U2 === u || U2 === i2;
          function d2(U2, Z, se) {
            let fe2 = U2.getValue();
            if (fe2.type === "JSXElement" && de2(fe2))
              return [se("openingElement"), se("closingElement")];
            let ge = fe2.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe2.type === "JSXElement" ? se("closingElement") : se("closingFragment");
            if (fe2.children.length === 1 && fe2.children[0].type === "JSXExpressionContainer" && (fe2.children[0].expression.type === "TemplateLiteral" || fe2.children[0].expression.type === "TaggedTemplateExpression"))
              return [ge, ...U2.map(se, "children"), he];
            fe2.children = fe2.children.map((A2) => Fe2(A2) ? { type: "JSXText", value: " ", raw: " " } : A2);
            let we2 = fe2.children.some(E), ke2 = fe2.children.filter((A2) => A2.type === "JSXExpressionContainer").length > 1, Re2 = fe2.type === "JSXElement" && fe2.openingElement.attributes.length > 1, Ne2 = F2(ge) || we2 || Re2 || ke2, Pe2 = U2.getParentNode().rootMarker === "mdx", oe2 = Z.singleQuote ? "{' '}" : '{" "}', H = Pe2 ? " " : g2([oe2, i2], " "), pe2 = fe2.openingElement && fe2.openingElement.name && fe2.openingElement.name.name === "fbt", X2 = v2(U2, Z, se, H, pe2), le = fe2.children.some((A2) => ue2(A2));
            for (let A2 = X2.length - 2; A2 >= 0; A2--) {
              let G2 = X2[A2] === "" && X2[A2 + 1] === "", re2 = X2[A2] === u && X2[A2 + 1] === "" && X2[A2 + 2] === u, ye = (X2[A2] === i2 || X2[A2] === u) && X2[A2 + 1] === "" && X2[A2 + 2] === H, Ce2 = X2[A2] === H && X2[A2 + 1] === "" && (X2[A2 + 2] === i2 || X2[A2 + 2] === u), Be2 = X2[A2] === H && X2[A2 + 1] === "" && X2[A2 + 2] === H, ve = X2[A2] === i2 && X2[A2 + 1] === "" && X2[A2 + 2] === u || X2[A2] === u && X2[A2 + 1] === "" && X2[A2 + 2] === i2;
              re2 && le || G2 || ye || Be2 || ve ? X2.splice(A2, 2) : Ce2 && X2.splice(A2 + 1, 2);
            }
            for (; X2.length > 0 && o(_(X2)); )
              X2.pop();
            for (; X2.length > 1 && o(X2[0]) && o(X2[1]); )
              X2.shift(), X2.shift();
            let Ae2 = [];
            for (let [A2, G2] of X2.entries()) {
              if (G2 === H) {
                if (A2 === 1 && X2[A2 - 1] === "") {
                  if (X2.length === 2) {
                    Ae2.push(oe2);
                    continue;
                  }
                  Ae2.push([oe2, u]);
                  continue;
                } else if (A2 === X2.length - 1) {
                  Ae2.push(oe2);
                  continue;
                } else if (X2[A2 - 1] === "" && X2[A2 - 2] === u) {
                  Ae2.push(oe2);
                  continue;
                }
              }
              Ae2.push(G2), F2(G2) && (Ne2 = true);
            }
            let Ee2 = le ? h(Ae2) : l(Ae2, { shouldBreak: true });
            if (Pe2)
              return Ee2;
            let De3 = l([ge, p([u, Ee2]), u, he]);
            return Ne2 ? De3 : y([l([ge, ...X2, he]), De3]);
          }
          function v2(U2, Z, se, fe2, ge) {
            let he = [];
            return U2.each((we2, ke2, Re2) => {
              let Ne2 = we2.getValue();
              if (Ne2.type === "JSXText") {
                let Pe2 = N2(Ne2);
                if (ue2(Ne2)) {
                  let oe2 = Pe2.split(ce2);
                  if (oe2[0] === "") {
                    if (he.push(""), oe2.shift(), /\n/.test(oe2[0])) {
                      let pe2 = Re2[ke2 + 1];
                      he.push(b(ge, oe2[1], Ne2, pe2));
                    } else
                      he.push(fe2);
                    oe2.shift();
                  }
                  let H;
                  if (_(oe2) === "" && (oe2.pop(), H = oe2.pop()), oe2.length === 0)
                    return;
                  for (let [pe2, X2] of oe2.entries())
                    pe2 % 2 === 1 ? he.push(n2) : he.push(X2);
                  if (H !== void 0)
                    if (/\n/.test(H)) {
                      let pe2 = Re2[ke2 + 1];
                      he.push(b(ge, _(he), Ne2, pe2));
                    } else
                      he.push(fe2);
                  else {
                    let pe2 = Re2[ke2 + 1];
                    he.push(S(ge, _(he), Ne2, pe2));
                  }
                } else
                  /\n/.test(Pe2) ? Pe2.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe2);
              } else {
                let Pe2 = se();
                he.push(Pe2);
                let oe2 = Re2[ke2 + 1];
                if (oe2 && ue2(oe2)) {
                  let pe2 = K(N2(oe2)).split(ce2)[0];
                  he.push(S(ge, pe2, Ne2, oe2));
                } else
                  he.push(u);
              }
            }, "children"), he;
          }
          function S(U2, Z, se, fe2) {
            return U2 ? "" : se.type === "JSXElement" && !se.closingElement || fe2 && fe2.type === "JSXElement" && !fe2.closingElement ? Z.length === 1 ? i2 : u : i2;
          }
          function b(U2, Z, se, fe2) {
            return U2 ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe2 && fe2.type === "JSXElement" && !fe2.closingElement ? u : i2 : u;
          }
          function B(U2, Z, se) {
            let fe2 = U2.getParentNode();
            if (!fe2 || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe2.type])
              return Z;
            let he = U2.match(void 0, (ke2) => ke2.type === "ArrowFunctionExpression", x2, (ke2) => ke2.type === "JSXExpressionContainer"), we2 = m(U2, se);
            return l([we2 ? "" : g2("("), p([i2, Z]), i2, we2 ? "" : g2(")")], { shouldBreak: he });
          }
          function k(U2, Z, se) {
            let fe2 = U2.getValue(), ge = [];
            if (ge.push(se("name")), fe2.value) {
              let he;
              if (I(fe2.value)) {
                let ke2 = N2(fe2.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re2, quote: Ne2, regex: Pe2 } = w2(ke2, Z.jsxSingleQuote ? "'" : '"');
                ke2 = ke2.replace(Pe2, Re2);
                let { leading: oe2, trailing: H } = U2.call(() => a(U2, Z), "value");
                he = [oe2, Ne2, ke2, Ne2, H];
              } else
                he = se("value");
              ge.push("=", he);
            }
            return ge;
          }
          function M(U2, Z, se) {
            let fe2 = U2.getValue(), ge = (he, we2) => he.type === "JSXEmptyExpression" || !$(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x2(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we2) && (he.type === "ConditionalExpression" || P(he)));
            return ge(fe2.expression, U2.getParentNode(0)) ? l(["{", se("expression"), c, "}"]) : l(["{", p([i2, se("expression")]), i2, c, "}"]);
          }
          function R(U2, Z, se) {
            let fe2 = U2.getValue(), ge = fe2.name && $(fe2.name) || fe2.typeParameters && $(fe2.typeParameters);
            if (fe2.selfClosing && fe2.attributes.length === 0 && !ge)
              return ["<", se("name"), se("typeParameters"), " />"];
            if (fe2.attributes && fe2.attributes.length === 1 && fe2.attributes[0].value && I(fe2.attributes[0].value) && !fe2.attributes[0].value.value.includes(`
`) && !ge && !$(fe2.attributes[0]))
              return l(["<", se("name"), se("typeParameters"), " ", ...U2.map(se, "attributes"), fe2.selfClosing ? " />" : ">"]);
            let he = fe2.attributes && fe2.attributes.some((ke2) => ke2.value && I(ke2.value) && ke2.value.value.includes(`
`)), we2 = Z.singleAttributePerLine && fe2.attributes.length > 1 ? u : n2;
            return l(["<", se("name"), se("typeParameters"), p(U2.map(() => [we2, se()], "attributes")), ...q2(fe2, Z, ge)], { shouldBreak: he });
          }
          function q2(U2, Z, se) {
            return U2.selfClosing ? [n2, "/>"] : J3(U2, Z, se) ? [">"] : [i2, ">"];
          }
          function J3(U2, Z, se) {
            let fe2 = U2.attributes.length > 0 && $(_(U2.attributes), D.Trailing);
            return U2.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U2.attributes.length > 0) && !fe2;
          }
          function L(U2, Z, se) {
            let fe2 = U2.getValue(), ge = [];
            ge.push("</");
            let he = se("name");
            return $(fe2.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe2.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
          }
          function Q2(U2, Z) {
            let se = U2.getValue(), fe2 = $(se), ge = $(se, D.Line), he = se.type === "JSXOpeningFragment";
            return [he ? "<" : "</", p([ge ? u : fe2 && !he ? " " : "", s(U2, Z, true)]), ge ? u : "", ">"];
          }
          function V(U2, Z, se) {
            let fe2 = t2(U2, d2(U2, Z, se), Z);
            return B(U2, fe2, Z);
          }
          function j2(U2, Z) {
            let se = U2.getValue(), fe2 = $(se, D.Line);
            return [s(U2, Z, !fe2), fe2 ? u : ""];
          }
          function Y3(U2, Z, se) {
            let fe2 = U2.getValue();
            return ["{", U2.call((ge) => {
              let he = ["...", se()], we2 = ge.getValue();
              return !$(we2) || !C2(ge) ? he : [p([i2, t2(ge, he, Z)]), i2];
            }, fe2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function ie2(U2, Z, se) {
            let fe2 = U2.getValue();
            if (fe2.type.startsWith("JSX"))
              switch (fe2.type) {
                case "JSXAttribute":
                  return k(U2, Z, se);
                case "JSXIdentifier":
                  return String(fe2.name);
                case "JSXNamespacedName":
                  return f2(":", [se("namespace"), se("name")]);
                case "JSXMemberExpression":
                  return f2(".", [se("object"), se("property")]);
                case "JSXSpreadAttribute":
                  return Y3(U2, Z, se);
                case "JSXSpreadChild":
                  return Y3(U2, Z, se);
                case "JSXExpressionContainer":
                  return M(U2, Z, se);
                case "JSXFragment":
                case "JSXElement":
                  return V(U2, Z, se);
                case "JSXOpeningElement":
                  return R(U2, Z, se);
                case "JSXClosingElement":
                  return L(U2, Z, se);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return Q2(U2, Z);
                case "JSXEmptyExpression":
                  return j2(U2, Z);
                case "JSXText":
                  throw new Error("JSXText should be handled by JSXElement");
                default:
                  throw new Error(`Unknown JSX node type: ${JSON.stringify(fe2.type)}.`);
              }
          }
          var ee2 = ` 
\r	`, ce2 = new RegExp("([" + ee2 + "]+)"), W = new RegExp("[^" + ee2 + "]"), K = (U2) => U2.replace(new RegExp("(?:^" + ce2.source + "|" + ce2.source + "$)"), "");
          function de2(U2) {
            if (U2.children.length === 0)
              return true;
            if (U2.children.length > 1)
              return false;
            let Z = U2.children[0];
            return Z.type === "JSXText" && !ue2(Z);
          }
          function ue2(U2) {
            return U2.type === "JSXText" && (W.test(N2(U2)) || !/\n/.test(N2(U2)));
          }
          function Fe2(U2) {
            return U2.type === "JSXExpressionContainer" && I(U2.expression) && U2.expression.value === " " && !$(U2.expression);
          }
          function z(U2) {
            let Z = U2.getValue(), se = U2.getParentNode();
            if (!se || !Z || !E(Z) || !E(se))
              return false;
            let fe2 = se.children.indexOf(Z), ge = null;
            for (let he = fe2; he > 0; he--) {
              let we2 = se.children[he - 1];
              if (!(we2.type === "JSXText" && !ue2(we2))) {
                ge = we2;
                break;
              }
            }
            return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
          }
          r.exports = { hasJsxIgnoreComment: z, printJsx: ie2 };
        } }), ct = te2({ "src/language-js/print/misc.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2 } = Ue2(), { builders: { indent: s, join: a, line: n2 } } = qe(), { isFlowAnnotationComment: u } = Ke3();
          function i2(_) {
            let w2 = _.getValue();
            return !w2.optional || w2.type === "Identifier" && w2 === _.getParentNode().key ? "" : w2.type === "OptionalCallExpression" || w2.type === "OptionalMemberExpression" && w2.computed ? "?." : "?";
          }
          function l(_) {
            return _.getValue().definite || _.match(void 0, (w2, E) => E === "id" && w2.type === "VariableDeclarator" && w2.definite) ? "!" : "";
          }
          function p(_, w2, E) {
            let N2 = _.getValue();
            return N2.typeArguments ? E("typeArguments") : N2.typeParameters ? E("typeParameters") : "";
          }
          function y(_, w2, E) {
            let N2 = _.getValue();
            if (!N2.typeAnnotation)
              return "";
            let x2 = _.getParentNode(), I = x2.type === "DeclareFunction" && x2.id === N2;
            return u(w2.originalText, N2.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
          }
          function h(_, w2, E) {
            return ["::", E("callee")];
          }
          function g2(_, w2, E) {
            let N2 = _.getValue();
            return t2(N2.modifiers) ? [a(" ", _.map(E, "modifiers")), " "] : "";
          }
          function c(_, w2, E) {
            return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w2] : s([n2, w2]);
          }
          function f2(_, w2, E) {
            return ["...", E("argument"), y(_, w2, E)];
          }
          function F2(_, w2) {
            let E = _.slice(1, -1);
            if (E.includes('"') || E.includes("'"))
              return _;
            let N2 = w2.singleQuote ? "'" : '"';
            return N2 + E + N2;
          }
          r.exports = { printOptionalToken: i2, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h, printTypeScriptModifiers: g2, printTypeAnnotation: y, printRestSpread: f2, adjustClause: c, printDirective: F2 };
        } }), er2 = te2({ "src/language-js/print/array.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { builders: { line: s, softline: a, hardline: n2, group: u, indent: i2, ifBreak: l, fill: p } } = qe(), { getLast: y, hasNewline: h } = Ue2(), { shouldPrintComma: g2, hasComment: c, CommentCheckFlags: f2, isNextLineEmpty: F2, isNumericLiteral: _, isSignedNumericLiteral: w2 } = Ke3(), { locStart: E } = ut(), { printOptionalToken: N2, printTypeAnnotation: x2 } = ct();
          function I(T, m, C2) {
            let o = T.getValue(), d2 = [], v2 = o.type === "TupleExpression" ? "#[" : "[", S = "]";
            if (o.elements.length === 0)
              c(o, f2.Dangling) ? d2.push(u([v2, t2(T, m), a, S])) : d2.push(v2, S);
            else {
              let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q2, V) => {
                let j2 = L && L.type;
                if (j2 !== "ArrayExpression" && j2 !== "ObjectExpression")
                  return false;
                let Y3 = V[Q2 + 1];
                if (Y3 && j2 !== Y3.type)
                  return false;
                let ie2 = j2 === "ArrayExpression" ? "elements" : "properties";
                return L[ie2] && L[ie2].length > 1;
              }), q2 = P(o, m), J3 = B ? k ? "," : g2(m) ? q2 ? l(",", "", { groupId: M }) : l(",") : "" : "";
              d2.push(u([v2, i2([a, q2 ? D(T, m, C2, J3) : [$(T, m, "elements", C2), J3], t2(T, m, true)]), a, S], { shouldBreak: R, id: M }));
            }
            return d2.push(N2(T), x2(T, m, C2)), d2;
          }
          function P(T, m) {
            return T.elements.length > 1 && T.elements.every((C2) => C2 && (_(C2) || w2(C2) && !c(C2.argument)) && !c(C2, f2.Trailing | f2.Line, (o) => !h(m.originalText, E(o), { backwards: true })));
          }
          function $(T, m, C2, o) {
            let d2 = [], v2 = [];
            return T.each((S) => {
              d2.push(v2, u(o())), v2 = [",", s], S.getValue() && F2(S.getValue(), m) && v2.push(a);
            }, C2), d2;
          }
          function D(T, m, C2, o) {
            let d2 = [];
            return T.each((v2, S, b) => {
              let B = S === b.length - 1;
              d2.push([C2(), B ? o : ","]), B || d2.push(F2(v2.getValue(), m) ? [n2, n2] : c(b[S + 1], f2.Leading | f2.Line) ? n2 : s);
            }, "elements"), p(d2);
          }
          r.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
        } }), Ao = te2({ "src/language-js/print/call-arguments.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { getLast: s, getPenultimate: a } = Ue2(), { getFunctionParameters: n2, hasComment: u, CommentCheckFlags: i2, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y, shouldPrintComma: h, getCallArguments: g2, iterateCallArgumentsPath: c, isNextLineEmpty: f2, isCallExpression: F2, isStringLiteral: _, isObjectProperty: w2, isTSTypeExpression: E } = Ke3(), { builders: { line: N2, hardline: x2, softline: I, group: P, indent: $, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C2 } } = qe(), { ArgExpansionBailout: o } = Qt(), { isConciselyPrintedArray: d2 } = er2();
          function v2(q2, J3, L) {
            let Q2 = q2.getValue(), V = Q2.type === "ImportExpression", j2 = g2(Q2);
            if (j2.length === 0)
              return ["(", t2(q2, J3, true), ")"];
            if (k(j2))
              return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
            let Y3 = false, ie2 = false, ee2 = j2.length - 1, ce2 = [];
            c(q2, (z, U2) => {
              let Z = z.getNode(), se = [L()];
              U2 === ee2 || (f2(Z, J3) ? (U2 === 0 && (ie2 = true), Y3 = true, se.push(",", x2, x2)) : se.push(",", N2)), ce2.push(se);
            });
            let W = !(V || Q2.callee && Q2.callee.type === "Import") && h(J3, "all") ? "," : "";
            function K() {
              return P(["(", $([N2, ...ce2]), W, N2, ")"], { shouldBreak: true });
            }
            if (Y3 || q2.getParentNode().type !== "Decorator" && l(j2))
              return K();
            let de2 = B(j2), ue2 = b(j2, J3);
            if (de2 || ue2) {
              if (de2 ? ce2.slice(1).some(C2) : ce2.slice(0, -1).some(C2))
                return K();
              let z = [];
              try {
                q2.try(() => {
                  c(q2, (U2, Z) => {
                    de2 && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce2.length > 1 ? "," : "", ie2 ? x2 : N2, ie2 ? x2 : ""], ...ce2.slice(1)]), ue2 && Z === ee2 && (z = [...ce2.slice(0, -1), L([], { expandLastArg: true })]);
                  });
                });
              } catch (U2) {
                if (U2 instanceof o)
                  return K();
                throw U2;
              }
              return [ce2.some(C2) ? m : "", D([["(", ...z, ")"], de2 ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce2.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
            }
            let Fe2 = ["(", $([I, ...ce2]), T(W), I, ")"];
            return y(q2) ? Fe2 : P(Fe2, { shouldBreak: ce2.some(C2) || Y3 });
          }
          function S(q2) {
            let J3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q2.type === "ObjectExpression" && (q2.properties.length > 0 || u(q2)) || q2.type === "ArrayExpression" && (q2.elements.length > 0 || u(q2)) || q2.type === "TSTypeAssertion" && S(q2.expression) || E(q2) && S(q2.expression) || q2.type === "FunctionExpression" || q2.type === "ArrowFunctionExpression" && (!q2.returnType || !q2.returnType.typeAnnotation || q2.returnType.typeAnnotation.type !== "TSTypeReference" || M(q2.body)) && (q2.body.type === "BlockStatement" || q2.body.type === "ArrowFunctionExpression" && S(q2.body, true) || q2.body.type === "ObjectExpression" || q2.body.type === "ArrayExpression" || !J3 && (F2(q2.body) || q2.body.type === "ConditionalExpression") || p(q2.body)) || q2.type === "DoExpression" || q2.type === "ModuleExpression";
          }
          function b(q2, J3) {
            let L = s(q2), Q2 = a(q2);
            return !u(L, i2.Leading) && !u(L, i2.Trailing) && S(L) && (!Q2 || Q2.type !== L.type) && (q2.length !== 2 || Q2.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q2.length > 1 && L.type === "ArrayExpression" && d2(L, J3));
          }
          function B(q2) {
            if (q2.length !== 2)
              return false;
            let [J3, L] = q2;
            return J3.type === "ModuleExpression" && R(L) ? true : !u(J3) && (J3.type === "FunctionExpression" || J3.type === "ArrowFunctionExpression" && J3.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
          }
          function k(q2) {
            return q2.length === 2 && q2[0].type === "ArrowFunctionExpression" && n2(q2[0]).length === 0 && q2[0].body.type === "BlockStatement" && q2[1].type === "ArrayExpression" && !q2.some((J3) => u(J3));
          }
          function M(q2) {
            return q2.type === "BlockStatement" && (q2.body.some((J3) => J3.type !== "EmptyStatement") || u(q2, i2.Dangling));
          }
          function R(q2) {
            return q2.type === "ObjectExpression" && q2.properties.length === 1 && w2(q2.properties[0]) && q2.properties[0].key.type === "Identifier" && q2.properties[0].key.name === "type" && _(q2.properties[0].value) && q2.properties[0].value.value === "module";
          }
          r.exports = v2;
        } }), So = te2({ "src/language-js/print/member.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { softline: t2, group: s, indent: a, label: n2 } } = qe(), { isNumericLiteral: u, isMemberExpression: i2, isCallExpression: l } = Ke3(), { printOptionalToken: p } = ct();
          function y(g2, c, f2) {
            let F2 = g2.getValue(), _ = g2.getParentNode(), w2, E = 0;
            do
              w2 = g2.getParentNode(E), E++;
            while (w2 && (i2(w2) || w2.type === "TSNonNullExpression"));
            let N2 = f2("object"), x2 = h(g2, c, f2), I = w2 && (w2.type === "NewExpression" || w2.type === "BindExpression" || w2.type === "AssignmentExpression" && w2.left.type !== "Identifier") || F2.computed || F2.object.type === "Identifier" && F2.property.type === "Identifier" && !i2(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F2.object) && F2.object.arguments.length > 0 || F2.object.type === "TSNonNullExpression" && l(F2.object.expression) && F2.object.expression.arguments.length > 0 || N2.label === "member-chain");
            return n2(N2.label === "member-chain" ? "member-chain" : "member", [N2, I ? x2 : s(a([t2, x2]))]);
          }
          function h(g2, c, f2) {
            let F2 = f2("property"), _ = g2.getValue(), w2 = p(g2);
            return _.computed ? !_.property || u(_.property) ? [w2, "[", F2, "]"] : s([w2, "[", a([t2, F2]), t2, "]"]) : [w2, ".", F2];
          }
          r.exports = { printMemberExpression: y, printMemberLookup: h };
        } }), md = te2({ "src/language-js/print/member-chain.js"(e, r) {
          "use strict";
          ne2();
          var { printComments: t2 } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n2 } = Ue2(), u = qt(), { isCallExpression: i2, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y, isMemberish: h, isNumericLiteral: g2, isSimpleCallArgument: c, hasComment: f2, CommentCheckFlags: F2, isNextLineEmpty: _ } = Ke3(), { locEnd: w2 } = ut(), { builders: { join: E, hardline: N2, group: x2, indent: I, conditionalGroup: P, breakParent: $, label: D }, utils: { willBreak: T } } = qe(), m = Ao(), { printMemberLookup: C2 } = So(), { printOptionalToken: o, printFunctionTypeParameters: d2, printBindExpressionCallee: v2 } = ct();
          function S(b, B, k) {
            let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q2 = [];
            function J3(Ne2) {
              let { originalText: Pe2 } = B, oe2 = n2(Pe2, Ne2, w2);
              return Pe2.charAt(oe2) === ")" ? oe2 !== false && a(Pe2, oe2 + 1) : _(Ne2, B);
            }
            function L(Ne2) {
              let Pe2 = Ne2.getValue();
              i2(Pe2) && (h(Pe2.callee) || i2(Pe2.callee)) ? (q2.unshift({ node: Pe2, printed: [t2(Ne2, [o(Ne2), d2(Ne2, B, k), m(Ne2, B, k)], B), J3(Pe2) ? N2 : ""] }), Ne2.call((oe2) => L(oe2), "callee")) : h(Pe2) ? (q2.unshift({ node: Pe2, needsParens: u(Ne2, B), printed: t2(Ne2, l(Pe2) ? C2(Ne2, B, k) : v2(Ne2, B, k), B) }), Ne2.call((oe2) => L(oe2), "object")) : Pe2.type === "TSNonNullExpression" ? (q2.unshift({ node: Pe2, printed: t2(Ne2, "!", B) }), Ne2.call((oe2) => L(oe2), "expression")) : q2.unshift({ node: Pe2, printed: k() });
            }
            let Q2 = b.getValue();
            q2.unshift({ node: Q2, printed: [o(b), d2(b, B, k), m(b, B, k)] }), Q2.callee && b.call((Ne2) => L(Ne2), "callee");
            let V = [], j2 = [q2[0]], Y3 = 1;
            for (; Y3 < q2.length && (q2[Y3].node.type === "TSNonNullExpression" || i2(q2[Y3].node) || l(q2[Y3].node) && q2[Y3].node.computed && g2(q2[Y3].node.property)); ++Y3)
              j2.push(q2[Y3]);
            if (!i2(q2[0].node))
              for (; Y3 + 1 < q2.length && (h(q2[Y3].node) && h(q2[Y3 + 1].node)); ++Y3)
                j2.push(q2[Y3]);
            V.push(j2), j2 = [];
            let ie2 = false;
            for (; Y3 < q2.length; ++Y3) {
              if (ie2 && h(q2[Y3].node)) {
                if (q2[Y3].node.computed && g2(q2[Y3].node.property)) {
                  j2.push(q2[Y3]);
                  continue;
                }
                V.push(j2), j2 = [], ie2 = false;
              }
              (i2(q2[Y3].node) || q2[Y3].node.type === "ImportExpression") && (ie2 = true), j2.push(q2[Y3]), f2(q2[Y3].node, F2.Trailing) && (V.push(j2), j2 = [], ie2 = false);
            }
            j2.length > 0 && V.push(j2);
            function ee2(Ne2) {
              return /^[A-Z]|^[$_]+$/.test(Ne2);
            }
            function ce2(Ne2) {
              return Ne2.length <= B.tabWidth;
            }
            function W(Ne2) {
              let Pe2 = Ne2[1].length > 0 && Ne2[1][0].node.computed;
              if (Ne2[0].length === 1) {
                let H = Ne2[0][0].node;
                return H.type === "ThisExpression" || H.type === "Identifier" && (ee2(H.name) || R && ce2(H.name) || Pe2);
              }
              let oe2 = s(Ne2[0]).node;
              return l(oe2) && oe2.property.type === "Identifier" && (ee2(oe2.property.name) || Pe2);
            }
            let K = V.length >= 2 && !f2(V[1][0].node) && W(V);
            function de2(Ne2) {
              let Pe2 = Ne2.map((oe2) => oe2.printed);
              return Ne2.length > 0 && s(Ne2).needsParens ? ["(", ...Pe2, ")"] : Pe2;
            }
            function ue2(Ne2) {
              return Ne2.length === 0 ? "" : I(x2([N2, E(N2, Ne2.map(de2))]));
            }
            let Fe2 = V.map(de2), z = Fe2, U2 = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne2) => f2(Ne2.node, F2.Leading)) || Z.slice(0, -1).some((Ne2) => f2(Ne2.node, F2.Trailing)) || V[U2] && f2(V[U2][0].node, F2.Leading);
            if (V.length <= U2 && !se)
              return y(b) ? z : x2(z);
            let fe2 = s(V[K ? 1 : 0]).node, ge = !i2(fe2) && J3(fe2), he = [de2(V[0]), K ? V.slice(1, 2).map(de2) : "", ge ? N2 : "", ue2(V.slice(K ? 2 : 1))], we2 = q2.map((Ne2) => {
              let { node: Pe2 } = Ne2;
              return Pe2;
            }).filter(i2);
            function ke2() {
              let Ne2 = s(s(V)).node, Pe2 = s(Fe2);
              return i2(Ne2) && T(Pe2) && we2.slice(0, -1).some((oe2) => oe2.arguments.some(p));
            }
            let Re2;
            return se || we2.length > 2 && we2.some((Ne2) => !Ne2.arguments.every((Pe2) => c(Pe2, 0))) || Fe2.slice(0, -1).some(T) || ke2() ? Re2 = x2(he) : Re2 = [T(z) || ge ? $ : "", P([z, he])], D("member-chain", Re2);
          }
          r.exports = S;
        } }), xo = te2({ "src/language-js/print/call-expression.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { join: t2, group: s } } = qe(), a = qt(), { getCallArguments: n2, hasFlowAnnotationComment: u, isCallExpression: i2, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y, isTestCall: h, iterateCallArgumentsPath: g2 } = Ke3(), c = md(), f2 = Ao(), { printOptionalToken: F2, printFunctionTypeParameters: _ } = ct();
          function w2(N2, x2, I) {
            let P = N2.getValue(), $ = N2.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F2(N2), C2 = n2(P);
            if (C2.length > 0 && (!T && !D && E(P, $) || C2.length === 1 && y(C2[0], x2.originalText) || !D && h(P, $))) {
              let v2 = [];
              return g2(N2, () => {
                v2.push(I());
              }), [D ? "new " : "", I("callee"), m, _(N2, x2, I), "(", t2(", ", v2), ")"];
            }
            let o = (x2.parser === "babel" || x2.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
            if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N2.call((v2) => a(v2, x2), "callee"))
              return c(N2, x2, I);
            let d2 = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N2, x2, I), f2(N2, x2, I)];
            return T || i2(P.callee) ? s(d2) : d2;
          }
          function E(N2, x2) {
            if (N2.callee.type !== "Identifier")
              return false;
            if (N2.callee.name === "require")
              return true;
            if (N2.callee.name === "define") {
              let I = n2(N2);
              return x2.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          r.exports = { printCallExpression: w2 };
        } }), tr2 = te2({ "src/language-js/print/assignment.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2, getStringWidth: s } = Ue2(), { builders: { line: a, group: n2, indent: u, indentIfBreak: i2, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y, canBreak: h } } = qe(), { hasLeadingOwnLineComment: g2, isBinaryish: c, isStringLiteral: f2, isLiteral: F2, isNumericLiteral: _, isCallExpression: w2, isMemberExpression: E, getCallArguments: N2, rawText: x2, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke3(), { shouldInlineLogicalExpression: D } = ru(), { printCallExpression: T } = xo();
          function m(W, K, de2, ue2, Fe2, z) {
            let U2 = d2(W, K, de2, ue2, z), Z = de2(z, { assignmentLayout: U2 });
            switch (U2) {
              case "break-after-operator":
                return n2([n2(ue2), Fe2, n2(u([a, Z]))]);
              case "never-break-after-operator":
                return n2([n2(ue2), Fe2, " ", Z]);
              case "fluid": {
                let se = Symbol("assignment");
                return n2([n2(ue2), Fe2, n2(u(a), { id: se }), l, i2(Z, { groupId: se })]);
              }
              case "break-lhs":
                return n2([ue2, Fe2, " ", n2(Z)]);
              case "chain":
                return [n2(ue2), Fe2, a, Z];
              case "chain-tail":
                return [n2(ue2), Fe2, u([a, Z])];
              case "chain-tail-arrow-chain":
                return [n2(ue2), Fe2, Z];
              case "only-left":
                return ue2;
            }
          }
          function C2(W, K, de2) {
            let ue2 = W.getValue();
            return m(W, K, de2, de2("left"), [" ", ue2.operator], "right");
          }
          function o(W, K, de2) {
            return m(W, K, de2, de2("id"), " =", "init");
          }
          function d2(W, K, de2, ue2, Fe2) {
            let z = W.getValue(), U2 = z[Fe2];
            if (!U2)
              return "only-left";
            let Z = !b(U2);
            if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration"))
              return Z ? U2.type === "ArrowFunctionExpression" && U2.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b(U2.right) || g2(K.originalText, U2))
              return "break-after-operator";
            if (U2.type === "CallExpression" && U2.callee.name === "require" || K.parser === "json5" || K.parser === "json")
              return "never-break-after-operator";
            if (S(z) || k(z) || q2(z) || J3(z) && h(ue2))
              return "break-lhs";
            let ge = ie2(z, ue2, K);
            return W.call(() => v2(W, K, de2, ge), Fe2) ? "break-after-operator" : ge || U2.type === "TemplateLiteral" || U2.type === "TaggedTemplateExpression" || U2.type === "BooleanLiteral" || _(U2) || U2.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function v2(W, K, de2, ue2) {
            let Fe2 = W.getValue();
            if (c(Fe2) && !D(Fe2))
              return true;
            switch (Fe2.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Fe2;
                return c(Z) && !D(Z);
              }
              case "ClassExpression":
                return t2(Fe2.decorators);
            }
            if (ue2)
              return false;
            let z = Fe2, U2 = [];
            for (; ; )
              if (z.type === "UnaryExpression")
                z = z.argument, U2.push("argument");
              else if (z.type === "TSNonNullExpression")
                z = z.expression, U2.push("expression");
              else
                break;
            return !!(f2(z) || W.call(() => V(W, K, de2), ...U2));
          }
          function S(W) {
            if (B(W)) {
              let K = W.left || W.id;
              return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de2) => $(de2) && (!de2.shorthand || de2.value && de2.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function b(W) {
            return W.type === "AssignmentExpression";
          }
          function B(W) {
            return b(W) || W.type === "VariableDeclarator";
          }
          function k(W) {
            let K = M(W);
            if (t2(K)) {
              let de2 = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (K.length > 1 && K.some((ue2) => ue2[de2] || ue2.default))
                return true;
            }
            return false;
          }
          function M(W) {
            return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function R(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function q2(W) {
            if (W.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: K } = W.id;
            if (!K || !K.typeAnnotation)
              return false;
            let de2 = L(K.typeAnnotation);
            return t2(de2) && de2.length > 1 && de2.some((ue2) => t2(L(ue2)) || ue2.type === "TSConditionalType");
          }
          function J3(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function L(W) {
            return Q2(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Q2(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function V(W, K, de2) {
            let ue2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe2 = W.getValue(), z = () => V(W, K, de2, true);
            if (Fe2.type === "TSNonNullExpression")
              return W.call(z, "expression");
            if (w2(Fe2)) {
              if (T(W, K, de2).label === "member-chain")
                return false;
              let Z = N2(Fe2);
              return !(Z.length === 0 || Z.length === 1 && Y3(Z[0], K)) || ee2(Fe2, de2) ? false : W.call(z, "callee");
            }
            return E(Fe2) ? W.call(z, "object") : ue2 && (Fe2.type === "Identifier" || Fe2.type === "ThisExpression");
          }
          var j2 = 0.25;
          function Y3(W, K) {
            let { printWidth: de2 } = K;
            if (I(W))
              return false;
            let ue2 = de2 * j2;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue2 || P(W) && !I(W.argument))
              return true;
            let Fe2 = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return Fe2 ? Fe2.length <= ue2 : f2(W) ? x2(W).length <= ue2 : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue2 && !W.quasis[0].value.raw.includes(`
`) : F2(W);
          }
          function ie2(W, K, de2) {
            if (!$(W))
              return false;
            K = p(K);
            let ue2 = 3;
            return typeof K == "string" && s(K) < de2.tabWidth + ue2;
          }
          function ee2(W, K) {
            let de2 = ce2(W);
            if (t2(de2)) {
              if (de2.length > 1)
                return true;
              if (de2.length === 1) {
                let Fe2 = de2[0];
                if (Fe2.type === "TSUnionType" || Fe2.type === "UnionTypeAnnotation" || Fe2.type === "TSIntersectionType" || Fe2.type === "IntersectionTypeAnnotation" || Fe2.type === "TSTypeLiteral" || Fe2.type === "ObjectTypeAnnotation")
                  return true;
              }
              let ue2 = W.typeParameters ? "typeParameters" : "typeArguments";
              if (y(K(ue2)))
                return true;
            }
            return false;
          }
          function ce2(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          r.exports = { printVariableDeclarator: o, printAssignmentExpression: C2, printAssignment: m, isArrowFunctionVariableDeclarator: J3 };
        } }), Lr = te2({ "src/language-js/print/function-parameters.js"(e, r) {
          "use strict";
          ne2();
          var { getNextNonSpaceNonCommentCharacter: t2 } = Ue2(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n2, softline: u, group: i2, indent: l, ifBreak: p }, utils: { removeLines: y, willBreak: h } } = qe(), { getFunctionParameters: g2, iterateFunctionParametersPath: c, isSimpleType: f2, isTestCall: F2, isTypeAnnotationAFunction: _, isObjectType: w2, isObjectTypePropertyAFunction: E, hasRestParameter: N2, shouldPrintComma: x2, hasComment: I, isNextLineEmpty: P } = Ke3(), { locEnd: $ } = ut(), { ArgExpansionBailout: D } = Qt(), { printFunctionTypeParameters: T } = ct();
          function m(v2, S, b, B, k) {
            let M = v2.getValue(), R = g2(M), q2 = k ? T(v2, b, S) : "";
            if (R.length === 0)
              return [q2, "(", s(v2, b, true, (ie2) => t2(b.originalText, ie2, $) === ")"), ")"];
            let J3 = v2.getParentNode(), L = F2(J3), Q2 = C2(M), V = [];
            if (c(v2, (ie2, ee2) => {
              let ce2 = ee2 === R.length - 1;
              ce2 && M.rest && V.push("..."), V.push(S()), !ce2 && (V.push(","), L || Q2 ? V.push(" ") : P(R[ee2], b) ? V.push(n2, n2) : V.push(a));
            }), B) {
              if (h(q2) || h(V))
                throw new D();
              return i2([y(q2), "(", y(V), ")"]);
            }
            let j2 = R.every((ie2) => !ie2.decorators);
            return Q2 && j2 ? [q2, "(", ...V, ")"] : L ? [q2, "(", ...V, ")"] : (E(J3) || _(J3) || J3.type === "TypeAlias" || J3.type === "UnionTypeAnnotation" || J3.type === "TSUnionType" || J3.type === "IntersectionTypeAnnotation" || J3.type === "FunctionTypeAnnotation" && J3.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f2(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q2, "(", l([u, ...V]), p(!N2(M) && x2(b, "all") ? "," : ""), u, ")"];
          }
          function C2(v2) {
            if (!v2)
              return false;
            let S = g2(v2);
            if (S.length !== 1)
              return false;
            let [b] = S;
            return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w2(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w2(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
          }
          function o(v2) {
            let S;
            return v2.returnType ? (S = v2.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v2.typeAnnotation && (S = v2.typeAnnotation), S;
          }
          function d2(v2, S) {
            let b = o(v2);
            if (!b)
              return false;
            let B = v2.typeParameters && v2.typeParameters.params;
            if (B) {
              if (B.length > 1)
                return false;
              if (B.length === 1) {
                let k = B[0];
                if (k.constraint || k.default)
                  return false;
              }
            }
            return g2(v2).length === 1 && (w2(b) || h(S));
          }
          r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C2, shouldGroupFunctionParameters: d2 };
        } }), Or2 = te2({ "src/language-js/print/type-annotation.js"(e, r) {
          "use strict";
          ne2();
          var { printComments: t2, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue2(), { builders: { group: n2, join: u, line: i2, softline: l, indent: p, align: y, ifBreak: h } } = qe(), g2 = qt(), { locStart: c } = ut(), { isSimpleType: f2, isObjectType: F2, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w2, shouldPrintComma: E } = Ke3(), { printAssignment: N2 } = tr2(), { printFunctionParameters: x2, shouldGroupFunctionParameters: I } = Lr(), { printArrayItems: P } = er2();
          function $(b) {
            if (f2(b) || F2(b))
              return true;
            if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
              let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
              if (b.types.length - 1 === B && k)
                return true;
            }
            return false;
          }
          function D(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q2 = [];
            return q2.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q2.push(": ", k("supertype")), R.impltype && q2.push(" = ", k("impltype")), q2.push(M), q2;
          }
          function T(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q2 = [];
            R.declare && q2.push("declare "), q2.push("type ", k("id"), k("typeParameters"));
            let J3 = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [N2(b, B, k, q2, " =", J3), M];
          }
          function m(b, B, k) {
            let M = b.getValue(), R = b.map(k, "types"), q2 = [], J3 = false;
            for (let L = 0; L < R.length; ++L)
              L === 0 ? q2.push(R[L]) : F2(M.types[L - 1]) && F2(M.types[L]) ? q2.push([" & ", J3 ? p(R[L]) : R[L]]) : !F2(M.types[L - 1]) && !F2(M.types[L]) ? q2.push(p([" &", i2, R[L]])) : (L > 1 && (J3 = true), q2.push(" & ", L > 1 ? p(R[L]) : R[L]));
            return n2(q2);
          }
          function C2(b, B, k) {
            let M = b.getValue(), R = b.getParentNode(), q2 = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J3 = $(M), L = b.map((j2) => {
              let Y3 = k();
              return J3 || (Y3 = y(2, Y3)), t2(j2, Y3, B);
            }, "types");
            if (J3)
              return u(" | ", L);
            let Q2 = q2 && !_(B.originalText, M), V = [h([Q2 ? i2 : "", "| "]), u([i2, "| "], L)];
            return g2(b, B) ? n2([p(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n2([p([h(["(", l]), V]), l, h(")")]) : n2(q2 ? p(V) : V);
          }
          function o(b, B, k) {
            let M = b.getValue(), R = [], q2 = b.getParentNode(0), J3 = b.getParentNode(1), L = b.getParentNode(2), Q2 = M.type === "TSFunctionType" || !((q2.type === "ObjectTypeProperty" || q2.type === "ObjectTypeInternalSlot") && !q2.variance && !q2.optional && c(q2) === c(M) || q2.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q2 && (q2.type === "TypeAnnotation" || q2.type === "TSTypeAnnotation"), j2 = V && Q2 && (q2.type === "TypeAnnotation" || q2.type === "TSTypeAnnotation") && J3.type === "ArrowFunctionExpression";
            w2(q2) && (Q2 = true, V = true), j2 && R.push("(");
            let Y3 = x2(b, k, B, false, true), ie2 = M.returnType || M.predicate || M.typeAnnotation ? [Q2 ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee2 = I(M, ie2);
            return R.push(ee2 ? n2(Y3) : Y3), ie2 && R.push(ie2), j2 && R.push(")"), n2(R);
          }
          function d2(b, B, k) {
            let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q2 = M[R], J3 = a(q2), L = J3 ? l : "";
            return n2(["[", p([L, P(b, B, R, k)]), h(J3 && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
          }
          function v2(b, B, k) {
            let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
            return [k("objectType"), R, k("indexType"), "]"];
          }
          function S(b, B, k) {
            let M = b.getValue();
            return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
          }
          r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C2, printFunctionType: o, printTupleType: d2, printIndexedAccessType: v2, shouldHugType: $, printJSDocType: S };
        } }), jr2 = te2({ "src/language-js/print/type-parameters.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { builders: { join: s, line: a, hardline: n2, softline: u, group: i2, indent: l, ifBreak: p } } = qe(), { isTestCall: y, hasComment: h, CommentCheckFlags: g2, isTSXFile: c, shouldPrintComma: f2, getFunctionParameters: F2, isObjectType: _, getTypeScriptMappedTypeModifier: w2 } = Ke3(), { createGroupIdMapper: E } = Ue2(), { shouldHugType: N2 } = Or2(), { isArrowFunctionVariableDeclarator: x2 } = tr2(), I = E("typeParameters");
          function P(T, m, C2, o) {
            let d2 = T.getValue();
            if (!d2[o])
              return "";
            if (!Array.isArray(d2[o]))
              return C2(o);
            let v2 = T.getNode(2), S = v2 && y(v2), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x2);
            if (d2[o].length === 0 || !b && (S || d2[o].length === 1 && (d2[o][0].type === "NullableTypeAnnotation" || N2(d2[o][0]))))
              return ["<", s(", ", T.map(C2, o)), $(T, m), ">"];
            let k = d2.type === "TSTypeParameterInstantiation" ? "" : F2(d2).length === 1 && c(m) && !d2[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f2(m, "all") ? p(",") : "";
            return i2(["<", l([u, s([",", a], T.map(C2, o))]), k, u, ">"], { id: I(d2) });
          }
          function $(T, m) {
            let C2 = T.getValue();
            if (!h(C2, g2.Dangling))
              return "";
            let o = !h(C2, g2.Line), d2 = t2(T, m, o);
            return o ? d2 : [d2, n2];
          }
          function D(T, m, C2) {
            let o = T.getValue(), d2 = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v2 = T.getParentNode();
            return v2.type === "TSMappedType" ? (v2.readonly && d2.push(w2(v2.readonly, "readonly"), " "), d2.push("[", C2("name")), o.constraint && d2.push(" in ", C2("constraint")), v2.nameType && d2.push(" as ", T.callParent(() => C2("nameType"))), d2.push("]"), d2) : (o.variance && d2.push(C2("variance")), o.in && d2.push("in "), o.out && d2.push("out "), d2.push(C2("name")), o.bound && d2.push(": ", C2("bound")), o.constraint && d2.push(" extends ", C2("constraint")), o.default && d2.push(" = ", C2("default")), d2);
          }
          r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
        } }), rr2 = te2({ "src/language-js/print/property.js"(e, r) {
          "use strict";
          ne2();
          var { printComments: t2 } = et(), { printString: s, printNumber: a } = Ue2(), { isNumericLiteral: n2, isSimpleNumber: u, isStringLiteral: i2, isStringPropSafeToUnquote: l, rawText: p } = Ke3(), { printAssignment: y } = tr2(), h = /* @__PURE__ */ new WeakMap();
          function g2(f2, F2, _) {
            let w2 = f2.getNode();
            if (w2.computed)
              return ["[", _("key"), "]"];
            let E = f2.getParentNode(), { key: N2 } = w2;
            if (F2.quoteProps === "consistent" && !h.has(E)) {
              let x2 = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i2(I.key) && !l(I, F2));
              h.set(E, x2);
            }
            if ((N2.type === "Identifier" || n2(N2) && u(a(p(N2))) && String(N2.value) === a(p(N2)) && !(F2.parser === "typescript" || F2.parser === "babel-ts")) && (F2.parser === "json" || F2.quoteProps === "consistent" && h.get(E))) {
              let x2 = s(JSON.stringify(N2.type === "Identifier" ? N2.name : N2.value.toString()), F2);
              return f2.call((I) => t2(I, x2, F2), "key");
            }
            return l(w2, F2) && (F2.quoteProps === "as-needed" || F2.quoteProps === "consistent" && !h.get(E)) ? f2.call((x2) => t2(x2, /^\d/.test(N2.value) ? a(N2.value) : N2.value, F2), "key") : _("key");
          }
          function c(f2, F2, _) {
            return f2.getValue().shorthand ? _("value") : y(f2, F2, _, g2(f2, F2, _), ":", "value");
          }
          r.exports = { printProperty: c, printPropertyKey: g2 };
        } }), qr2 = te2({ "src/language-js/print/function.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Zt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n2 = lt2(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue2(), { builders: { line: i2, softline: l, group: p, indent: y, ifBreak: h, hardline: g2, join: c, indentIfBreak: f2 }, utils: { removeLines: F2, willBreak: _ } } = qe(), { ArgExpansionBailout: w2 } = Qt(), { getFunctionParameters: E, hasLeadingOwnLineComment: N2, isFlowAnnotationComment: x2, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C2, getComments: o, CommentCheckFlags: d2, isCallLikeExpression: v2, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke3(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q2 } = Lr(), { printPropertyKey: J3 } = rr2(), { printFunctionTypeParameters: L } = ct();
          function Q2(U2, Z, se, fe2) {
            let ge = U2.getValue(), he = false;
            if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe2 && fe2.expandLastArg) {
              let Pe2 = U2.getParentNode();
              S(Pe2) && b(Pe2).length > 1 && (he = true);
            }
            let we2 = [];
            ge.type === "TSDeclareFunction" && ge.declare && we2.push("declare "), ge.async && we2.push("async "), ge.generator ? we2.push("function* ") : we2.push("function "), ge.id && we2.push(Z("id"));
            let ke2 = R(U2, Z, se, he), Re2 = K(U2, Z, se), Ne2 = q2(ge, Re2);
            return we2.push(L(U2, se, Z), p([Ne2 ? p(ke2) : ke2, Re2]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we2.push(";"), we2;
          }
          function V(U2, Z, se) {
            let fe2 = U2.getNode(), { kind: ge } = fe2, he = fe2.value || fe2, we2 = [];
            return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we2.push("async ") : (t2.ok(ge === "get" || ge === "set"), we2.push(ge, " ")), he.generator && we2.push("*"), we2.push(J3(U2, Z, se), fe2.optional || fe2.key.optional ? "?" : ""), fe2 === he ? we2.push(j2(U2, Z, se)) : he.type === "FunctionExpression" ? we2.push(U2.call((ke2) => j2(ke2, Z, se), "value")) : we2.push(se("value")), we2;
          }
          function j2(U2, Z, se) {
            let fe2 = U2.getNode(), ge = R(U2, se, Z), he = K(U2, se, Z), we2 = q2(fe2, he), ke2 = [L(U2, Z, se), p([we2 ? p(ge) : ge, he])];
            return fe2.body ? ke2.push(" ", se("body")) : ke2.push(Z.semi ? ";" : ""), ke2;
          }
          function Y3(U2, Z, se, fe2) {
            let ge = U2.getValue(), he = [];
            if (ge.async && he.push("async "), W(U2, Z))
              he.push(se(["params", 0]));
            else {
              let ke2 = fe2 && (fe2.expandLastArg || fe2.expandFirstArg), Re2 = K(U2, se, Z);
              if (ke2) {
                if (_(Re2))
                  throw new w2();
                Re2 = p(F2(Re2));
              }
              he.push(p([R(U2, se, Z, ke2, true), Re2]));
            }
            let we2 = s(U2, Z, true, (ke2) => {
              let Re2 = u(Z.originalText, ke2, M);
              return Re2 !== false && Z.originalText.slice(Re2, Re2 + 2) === "=>";
            });
            return we2 && he.push(" ", we2), he;
          }
          function ie2(U2, Z, se, fe2, ge, he) {
            let we2 = U2.getName(), ke2 = U2.getParentNode(), Re2 = v2(ke2) && we2 === "callee", Ne2 = Boolean(Z && Z.assignmentLayout), Pe2 = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe2 = Re2 && Pe2 || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
            return he.body.type === "SequenceExpression" && (ge = p(["(", y([l, ge]), l, ")"])), p([p(y([Re2 || Ne2 ? l : "", p(c([" =>", i2], se), { shouldBreak: fe2 })]), { id: H, shouldBreak: oe2 }), " =>", f2(Pe2 ? y([i2, ge]) : [" ", ge], { groupId: H }), Re2 ? h(l, "", { groupId: H }) : ""]);
          }
          function ee2(U2, Z, se, fe2) {
            let ge = U2.getValue(), he = [], we2 = [], ke2 = false;
            if (function H() {
              let pe2 = Y3(U2, Z, se, fe2);
              if (he.length === 0)
                he.push(pe2);
              else {
                let { leading: X2, trailing: le } = a(U2, Z);
                he.push([X2, pe2]), we2.unshift(le);
              }
              ke2 = ke2 || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X2) => X2.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe2 && fe2.expandLastArg ? we2.unshift(se("body", fe2)) : (ge = ge.body, U2.call(H, "body"));
            }(), he.length > 1)
              return ie2(U2, fe2, he, ke2, we2, ge);
            let Re2 = he;
            if (Re2.push(" =>"), !N2(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
              return p([...Re2, " ", we2]);
            if (ge.body.type === "SequenceExpression")
              return p([...Re2, p([" (", y([l, we2]), l, ")"])]);
            let Ne2 = (fe2 && fe2.expandLastArg || U2.getParentNode().type === "JSXExpressionContainer") && !C2(ge), Pe2 = fe2 && fe2.expandLastArg && $(Z, "all"), oe2 = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
            return p([...Re2, p([y([i2, oe2 ? h("", "(") : "", we2, oe2 ? h("", ")") : ""]), Ne2 ? [h(Pe2 ? "," : ""), l] : ""])]);
          }
          function ce2(U2) {
            let Z = E(U2);
            return Z.length === 1 && !U2.typeParameters && !C2(U2, d2.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C2(Z[0]) && !Z[0].optional && !U2.predicate && !U2.returnType;
          }
          function W(U2, Z) {
            if (Z.arrowParens === "always")
              return false;
            if (Z.arrowParens === "avoid") {
              let se = U2.getValue();
              return ce2(se);
            }
            return false;
          }
          function K(U2, Z, se) {
            let fe2 = U2.getValue(), ge = Z("returnType");
            if (fe2.returnType && x2(se.originalText, fe2.returnType))
              return [" /*: ", ge, " */"];
            let he = [ge];
            return fe2.returnType && fe2.returnType.typeAnnotation && he.unshift(": "), fe2.predicate && he.push(fe2.returnType ? " " : ": ", Z("predicate")), he;
          }
          function de2(U2, Z, se) {
            let fe2 = U2.getValue(), ge = Z.semi ? ";" : "", he = [];
            fe2.argument && (z(Z, fe2.argument) ? he.push([" (", y([g2, se("argument")]), g2, ")"]) : T(fe2.argument) || fe2.argument.type === "SequenceExpression" ? he.push(p([h(" (", " "), y([l, se("argument")]), l, h(")")])) : he.push(" ", se("argument")));
            let we2 = o(fe2), ke2 = n2(we2), Re2 = ke2 && m(ke2);
            return Re2 && he.push(ge), C2(fe2, d2.Dangling) && he.push(" ", s(U2, Z, true)), Re2 || he.push(ge), he;
          }
          function ue2(U2, Z, se) {
            return ["return", de2(U2, Z, se)];
          }
          function Fe2(U2, Z, se) {
            return ["throw", de2(U2, Z, se)];
          }
          function z(U2, Z) {
            if (N2(U2.originalText, Z))
              return true;
            if (B(Z)) {
              let se = Z, fe2;
              for (; fe2 = k(se); )
                if (se = fe2, N2(U2.originalText, se))
                  return true;
            }
            return false;
          }
          r.exports = { printFunction: Q2, printArrowFunction: ee2, printMethod: V, printReturnStatement: ue2, printThrowStatement: Fe2, printMethodInternal: j2, shouldPrintParamsWithoutParens: W };
        } }), nu = te2({ "src/language-js/print/decorators.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2, hasNewline: s } = Ue2(), { builders: { line: a, hardline: n2, join: u, breakParent: i2, group: l } } = qe(), { locStart: p, locEnd: y } = ut(), { getParentExportDeclaration: h } = Ke3();
          function g2(w2, E, N2) {
            let x2 = w2.getValue();
            return l([u(a, w2.map(N2, "decorators")), F2(x2, E) ? n2 : a]);
          }
          function c(w2, E, N2) {
            return [u(n2, w2.map(N2, "declaration", "decorators")), n2];
          }
          function f2(w2, E, N2) {
            let x2 = w2.getValue(), { decorators: I } = x2;
            if (!t2(I) || _(w2.getParentNode()))
              return;
            let P = x2.type === "ClassExpression" || x2.type === "ClassDeclaration" || F2(x2, E);
            return [h(w2) ? n2 : P ? i2 : "", u(a, w2.map(N2, "decorators")), a];
          }
          function F2(w2, E) {
            return w2.decorators.some((N2) => s(E.originalText, y(N2)));
          }
          function _(w2) {
            if (w2.type !== "ExportDefaultDeclaration" && w2.type !== "ExportNamedDeclaration" && w2.type !== "DeclareExportDeclaration")
              return false;
            let E = w2.declaration && w2.declaration.decorators;
            return t2(E) && p(w2) === p(E[0]);
          }
          r.exports = { printDecorators: f2, printClassMemberDecorators: g2, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
        } }), nr2 = te2({ "src/language-js/print/class.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2, createGroupIdMapper: s } = Ue2(), { printComments: a, printDanglingComments: n2 } = et(), { builders: { join: u, line: i2, hardline: l, softline: p, group: y, indent: h, ifBreak: g2 } } = qe(), { hasComment: c, CommentCheckFlags: f2 } = Ke3(), { getTypeParametersGroupId: F2 } = jr2(), { printMethod: _ } = qr2(), { printOptionalToken: w2, printTypeAnnotation: E, printDefiniteToken: N2 } = ct(), { printPropertyKey: x2 } = rr2(), { printAssignment: I } = tr2(), { printClassMemberDecorators: P } = nu();
          function $(b, B, k) {
            let M = b.getValue(), R = [];
            M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
            let q2 = M.id && c(M.id, f2.Trailing) || M.typeParameters && c(M.typeParameters, f2.Trailing) || M.superClass && c(M.superClass) || t2(M.extends) || t2(M.mixins) || t2(M.implements), J3 = [], L = [];
            if (M.id && J3.push(" ", k("id")), J3.push(k("typeParameters")), M.superClass) {
              let Q2 = [d2(b, B, k), k("superTypeParameters")], V = b.call((j2) => ["extends ", a(j2, Q2, B)], "superClass");
              q2 ? L.push(i2, y(V)) : L.push(" ", V);
            } else
              L.push(o(b, B, k, "extends"));
            if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q2) {
              let Q2;
              C2(M) ? Q2 = [...J3, h(L)] : Q2 = h([...J3, L]), R.push(y(Q2, { id: D(M) }));
            } else
              R.push(...J3, ...L);
            return R.push(" ", k("body")), R;
          }
          var D = s("heritageGroup");
          function T(b) {
            return g2(l, "", { groupId: D(b) });
          }
          function m(b) {
            return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
          }
          function C2(b) {
            return b.typeParameters && !c(b.typeParameters, f2.Trailing | f2.Line) && !m(b);
          }
          function o(b, B, k, M) {
            let R = b.getValue();
            if (!t2(R[M]))
              return "";
            let q2 = n2(b, B, true, (J3) => {
              let { marker: L } = J3;
              return L === M;
            });
            return [C2(R) ? g2(" ", i2, { groupId: F2(R.typeParameters) }) : i2, q2, q2 && l, M, y(h([i2, u([",", i2], b.map(k, M))]))];
          }
          function d2(b, B, k) {
            let M = k("superClass");
            return b.getParentNode().type === "AssignmentExpression" ? y(g2(["(", h([p, M]), p, ")"], M)) : M;
          }
          function v2(b, B, k) {
            let M = b.getValue(), R = [];
            return t2(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
          }
          function S(b, B, k) {
            let M = b.getValue(), R = [], q2 = B.semi ? ";" : "";
            return t2(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x2(b, B, k), w2(b), N2(b), E(b, B, k)), [I(b, B, k, R, " =", "value"), q2];
          }
          r.exports = { printClass: $, printClassMethod: v2, printClassProperty: S, printHardlineAfterHeritage: T };
        } }), bo = te2({ "src/language-js/print/interface.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2 } = Ue2(), { builders: { join: s, line: a, group: n2, indent: u, ifBreak: i2 } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: y } = Ke3(), { getTypeParametersGroupId: h } = jr2(), { printTypeScriptModifiers: g2 } = ct();
          function c(f2, F2, _) {
            let w2 = f2.getValue(), E = [];
            w2.declare && E.push("declare "), w2.type === "TSInterfaceDeclaration" && E.push(w2.abstract ? "abstract " : "", g2(f2, F2, _)), E.push("interface");
            let N2 = [], x2 = [];
            w2.type !== "InterfaceTypeAnnotation" && N2.push(" ", _("id"), _("typeParameters"));
            let I = w2.typeParameters && !l(w2.typeParameters, y.Trailing | y.Line);
            return t2(w2.extends) && x2.push(I ? i2(" ", a, { groupId: h(w2.typeParameters) }) : a, "extends ", (w2.extends.length === 1 ? p : u)(s([",", a], f2.map(_, "extends")))), w2.id && l(w2.id, y.Trailing) || t2(w2.extends) ? I ? E.push(n2([...N2, u(x2)])) : E.push(n2(u([...N2, ...x2]))) : E.push(...N2, ...x2), E.push(" ", _("body")), n2(E);
          }
          r.exports = { printInterface: c };
        } }), To = te2({ "src/language-js/print/module.js"(e, r) {
          "use strict";
          ne2();
          var { isNonEmptyArray: t2 } = Ue2(), { builders: { softline: s, group: a, indent: n2, join: u, line: i2, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: y } = et(), { hasComment: h, CommentCheckFlags: g2, shouldPrintComma: c, needsHardlineAfterDanglingComment: f2, isStringLiteral: F2, rawText: _ } = Ke3(), { locStart: w2, hasSameLoc: E } = ut(), { hasDecoratorsBeforeExport: N2, printDecoratorsBeforeExport: x2 } = nu();
          function I(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q2 } = k;
            return R.push("import"), q2 && q2 !== "value" && R.push(" ", q2), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;
          }
          function P(S, b, B) {
            let k = S.getValue(), M = [];
            N2(k) && M.push(x2(S, b, B));
            let { type: R, exportKind: q2, declaration: J3 } = k;
            return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), h(k, g2.Dangling) && (M.push(" ", y(S, b, true)), f2(k) && M.push(p)), J3 ? M.push(" ", B("declaration")) : M.push(q2 === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
          }
          function $(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q2, exported: J3 } = k;
            return R.push("export"), q2 === "type" && R.push(" type"), R.push(" *"), J3 && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
          }
          function D(S, b) {
            if (!b.semi)
              return false;
            let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
            if (!k)
              return true;
            let { type: R } = k;
            return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
          }
          function T(S, b, B) {
            let k = S.getValue();
            if (!k.source)
              return "";
            let M = [];
            return C2(k, b) || M.push(" from"), M.push(" ", B("source")), M;
          }
          function m(S, b, B) {
            let k = S.getValue();
            if (C2(k, b))
              return "";
            let M = [" "];
            if (t2(k.specifiers)) {
              let R = [], q2 = [];
              S.each(() => {
                let J3 = S.getValue().type;
                if (J3 === "ExportNamespaceSpecifier" || J3 === "ExportDefaultSpecifier" || J3 === "ImportNamespaceSpecifier" || J3 === "ImportDefaultSpecifier")
                  R.push(B());
                else if (J3 === "ExportSpecifier" || J3 === "ImportSpecifier")
                  q2.push(B());
                else
                  throw new Error(`Unknown specifier type ${JSON.stringify(J3)}`);
              }, "specifiers"), M.push(u(", ", R)), q2.length > 0 && (R.length > 0 && M.push(", "), q2.length > 1 || R.length > 0 || k.specifiers.some((L) => h(L)) ? M.push(a(["{", n2([b.bracketSpacing ? i2 : s, u([",", i2], q2)]), l(c(b) ? "," : ""), b.bracketSpacing ? i2 : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q2, b.bracketSpacing ? " " : "", "}"]));
            } else
              M.push("{}");
            return M;
          }
          function C2(S, b) {
            let { type: B, importKind: k, source: M, specifiers: R } = S;
            return B !== "ImportDeclaration" || t2(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w2(S), w2(M)));
          }
          function o(S, b, B) {
            let k = S.getNode();
            return t2(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
          }
          function d2(S, b, B) {
            let k = S.getNode(), { type: M } = k, R = [], q2 = M === "ImportSpecifier" ? k.importKind : k.exportKind;
            q2 && q2 !== "value" && R.push(q2, " ");
            let J3 = M.startsWith("Import"), L = J3 ? "imported" : "local", Q2 = J3 ? "local" : "exported", V = k[L], j2 = k[Q2], Y3 = "", ie2 = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y3 = "*" : V && (Y3 = B(L)), j2 && !v2(k) && (ie2 = B(Q2)), R.push(Y3, Y3 && ie2 ? " as " : "", ie2), R;
          }
          function v2(S) {
            if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
              return false;
            let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
            if (b.type !== B.type || !E(b, B))
              return false;
            if (F2(b))
              return b.value === B.value && _(b) === _(B);
            switch (b.type) {
              case "Identifier":
                return b.name === B.name;
              default:
                return false;
            }
          }
          r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d2 };
        } }), uu = te2({ "src/language-js/print/object.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { builders: { line: s, softline: a, group: n2, indent: u, ifBreak: i2, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: y, hasNewline: h, isNonEmptyArray: g2 } = Ue2(), { shouldPrintComma: c, hasComment: f2, getComments: F2, CommentCheckFlags: _, isNextLineEmpty: w2 } = Ke3(), { locStart: E, locEnd: N2 } = ut(), { printOptionalToken: x2, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Lr(), { shouldHugType: $ } = Or2(), { printHardlineAfterHeritage: D } = nr2();
          function T(m, C2, o) {
            let d2 = C2.semi ? ";" : "", v2 = m.getValue(), S;
            v2.type === "TSTypeLiteral" ? S = "members" : v2.type === "TSInterfaceBody" ? S = "body" : S = "properties";
            let b = v2.type === "ObjectTypeAnnotation", B = [S];
            b && B.push("indexers", "callProperties", "internalSlots");
            let k = B.map((W) => v2[W][0]).sort((W, K) => E(W) - E(K))[0], M = m.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q2 = v2.type === "TSInterfaceBody" || R || v2.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v2.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v2.type !== "ObjectPattern" && k && y(C2.originalText, E(v2), E(k)), J3 = R ? ";" : v2.type === "TSInterfaceBody" || v2.type === "TSTypeLiteral" ? i2(d2, ";") : ",", L = v2.type === "RecordExpression" ? "#{" : v2.exact ? "{|" : "{", Q2 = v2.exact ? "|}" : "}", V = [];
            for (let W of B)
              m.each((K) => {
                let de2 = K.getValue();
                V.push({ node: de2, printed: o(), loc: E(de2) });
              }, W);
            B.length > 1 && V.sort((W, K) => W.loc - K.loc);
            let j2 = [], Y3 = V.map((W) => {
              let K = [...j2, n2(W.printed)];
              return j2 = [J3, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f2(W.node, _.PrettierIgnore) && j2.shift(), w2(W.node, C2) && j2.push(l), K;
            });
            if (v2.inexact) {
              let W;
              if (f2(v2, _.Dangling)) {
                let K = f2(v2, _.Line);
                W = [t2(m, C2, true), K || h(C2.originalText, N2(p(F2(v2)))) ? l : s, "..."];
              } else
                W = ["..."];
              Y3.push([...j2, ...W]);
            }
            let ie2 = p(v2[S]), ee2 = !(v2.inexact || ie2 && ie2.type === "RestElement" || ie2 && (ie2.type === "TSPropertySignature" || ie2.type === "TSCallSignatureDeclaration" || ie2.type === "TSMethodSignature" || ie2.type === "TSConstructSignatureDeclaration") && f2(ie2, _.PrettierIgnore)), ce2;
            if (Y3.length === 0) {
              if (!f2(v2, _.Dangling))
                return [L, Q2, I(m, C2, o)];
              ce2 = n2([L, t2(m, C2), a, Q2, x2(m), I(m, C2, o)]);
            } else
              ce2 = [R && g2(v2.properties) ? D(M) : "", L, u([C2.bracketSpacing ? s : a, ...Y3]), i2(ee2 && (J3 !== "," || c(C2)) ? J3 : ""), C2.bracketSpacing ? s : a, Q2, x2(m), I(m, C2, o)];
            return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de2) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de2 === 0) || m.match($, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de2) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de2 === 0) || !q2 && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce2 : n2(ce2, { shouldBreak: q2 });
          }
          r.exports = { printObject: T };
        } }), dd = te2({ "src/language-js/print/flow.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Zt(), { printDanglingComments: s } = et(), { printString: a, printNumber: n2 } = Ue2(), { builders: { hardline: u, softline: i2, group: l, indent: p } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h, isGetterOrSetter: g2, rawText: c, shouldPrintComma: f2 } = Ke3(), { locStart: F2, locEnd: _ } = ut(), { replaceTextEndOfLine: w2 } = Yt(), { printClass: E } = nr2(), { printOpaqueType: N2, printTypeAlias: x2, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: D, printIndexedAccessType: T } = Or2(), { printInterface: m } = bo(), { printTypeParameter: C2, printTypeParameters: o } = jr2(), { printExportDeclaration: d2, printExportAllDeclaration: v2 } = To(), { printArrayItems: S } = er2(), { printObject: b } = uu(), { printPropertyKey: B } = rr2(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
          function q2(L, Q2, V) {
            let j2 = L.getValue(), Y3 = Q2.semi ? ";" : "", ie2 = [];
            switch (j2.type) {
              case "DeclareClass":
                return J3(L, E(L, Q2, V));
              case "DeclareFunction":
                return J3(L, ["function ", V("id"), j2.predicate ? " " : "", V("predicate"), Y3]);
              case "DeclareModule":
                return J3(L, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J3(L, ["module.exports", ": ", V("typeAnnotation"), Y3]);
              case "DeclareVariable":
                return J3(L, ["var ", V("id"), Y3]);
              case "DeclareOpaqueType":
                return J3(L, N2(L, Q2, V));
              case "DeclareInterface":
                return J3(L, m(L, Q2, V));
              case "DeclareTypeAlias":
                return J3(L, x2(L, Q2, V));
              case "DeclareExportDeclaration":
                return J3(L, d2(L, Q2, V));
              case "DeclareExportAllDeclaration":
                return J3(L, v2(L, Q2, V));
              case "OpaqueType":
                return N2(L, Q2, V);
              case "TypeAlias":
                return x2(L, Q2, V);
              case "IntersectionTypeAnnotation":
                return I(L, Q2, V);
              case "UnionTypeAnnotation":
                return P(L, Q2, V);
              case "FunctionTypeAnnotation":
                return $(L, Q2, V);
              case "TupleTypeAnnotation":
                return D(L, Q2, V);
              case "GenericTypeAnnotation":
                return [V("id"), o(L, Q2, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return T(L, Q2, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return C2(L, Q2, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(j2.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (j2.type === "EnumSymbolBody" || j2.explicitType) {
                  let ee2 = null;
                  switch (j2.type) {
                    case "EnumBooleanBody":
                      ee2 = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee2 = "number";
                      break;
                    case "EnumStringBody":
                      ee2 = "string";
                      break;
                    case "EnumSymbolBody":
                      ee2 = "symbol";
                      break;
                  }
                  ie2.push("of ", ee2, " ");
                }
                if (j2.members.length === 0 && !j2.hasUnknownMembers)
                  ie2.push(l(["{", s(L, Q2), i2, "}"]));
                else {
                  let ee2 = j2.members.length > 0 ? [u, S(L, Q2, "members", V), j2.hasUnknownMembers || f2(Q2) ? "," : ""] : [];
                  ie2.push(l(["{", p([...ee2, ...j2.hasUnknownMembers ? [u, "..."] : []]), s(L, Q2, true), u, "}"]));
                }
                return ie2;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof j2.init == "object" ? V("init") : String(j2.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let ee2 = j2.name ? V("name") : L.getParentNode().this === j2 ? "this" : "";
                return [ee2, k(L), ee2 ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m(L, Q2, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: ee2 } = j2;
                return t2.ok(ee2 === "plus" || ee2 === "minus"), ee2 === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return j2.static && ie2.push("static "), ie2.push(V("value")), ie2;
              case "ObjectTypeIndexer":
                return [j2.static ? "static " : "", j2.variance ? V("variance") : "", "[", V("id"), j2.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let ee2 = "";
                return j2.proto ? ee2 = "proto " : j2.static && (ee2 = "static "), [ee2, g2(j2) ? j2.kind + " " : "", j2.variance ? V("variance") : "", B(L, Q2, V), k(L), h(j2) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b(L, Q2, V);
              case "ObjectTypeInternalSlot":
                return [j2.static ? "static " : "", "[[", V("id"), "]]", k(L), j2.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return R(L, Q2, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return w2(a(c(j2), Q2));
              case "NumberLiteralTypeAnnotation":
                t2.strictEqual(typeof j2.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return j2.extra ? n2(j2.extra.raw) : n2(j2.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), M(L, Q2, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee2 = o(L, Q2, V, "params");
                if (Q2.parser === "flow") {
                  let ce2 = F2(j2), W = _(j2), K = Q2.originalText.lastIndexOf("/*", ce2), de2 = Q2.originalText.indexOf("*/", W);
                  if (K !== -1 && de2 !== -1) {
                    let ue2 = Q2.originalText.slice(K + 2, de2).trim();
                    if (ue2.startsWith("::") && !ue2.includes("/*") && !ue2.includes("*/"))
                      return ["/*:: ", ee2, " */"];
                  }
                }
                return ee2;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(j2.type));
            }
          }
          function J3(L, Q2) {
            let V = y(L);
            return V ? (t2.strictEqual(V.type, "DeclareExportDeclaration"), Q2) : ["declare ", Q2];
          }
          r.exports = { printFlow: q2 };
        } }), gd = te2({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
          "use strict";
          ne2();
          function t2(s) {
            let { type: a } = s;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          r.exports = t2;
        } }), Bo = te2({ "src/language-js/print/ternary.js"(e, r) {
          "use strict";
          ne2();
          var { hasNewlineInRange: t2 } = Ue2(), { isJsxNode: s, getComments: a, isCallExpression: n2, isMemberExpression: u, isTSTypeExpression: i2 } = Ke3(), { locStart: l, locEnd: p } = ut(), y = Pt(), { builders: { line: h, softline: g2, group: c, indent: f2, align: F2, ifBreak: _, dedent: w2, breakParent: E } } = qe();
          function N2(D) {
            let T = [D];
            for (let m = 0; m < T.length; m++) {
              let C2 = T[m];
              for (let o of ["test", "consequent", "alternate"]) {
                let d2 = C2[o];
                if (s(d2))
                  return true;
                d2.type === "ConditionalExpression" && T.push(d2);
              }
            }
            return false;
          }
          function x2(D, T, m) {
            let C2 = D.getValue(), o = C2.type === "ConditionalExpression", d2 = o ? "alternate" : "falseType", v2 = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
            return v2.type === C2.type && v2[d2] === C2 ? F2(2, S) : S;
          }
          var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P(D) {
            let T = D.getValue();
            if (T.type !== "ConditionalExpression")
              return false;
            let m, C2 = T;
            for (let o = 0; !m; o++) {
              let d2 = D.getParentNode(o);
              if (n2(d2) && d2.callee === C2 || u(d2) && d2.object === C2 || d2.type === "TSNonNullExpression" && d2.expression === C2) {
                C2 = d2;
                continue;
              }
              d2.type === "NewExpression" && d2.callee === C2 || i2(d2) && d2.expression === C2 ? (m = D.getParentNode(o + 1), C2 = d2) : m = d2;
            }
            return C2 === T ? false : m[I.get(m.type)] === C2;
          }
          function $(D, T, m) {
            let C2 = D.getValue(), o = C2.type === "ConditionalExpression", d2 = o ? "consequent" : "trueType", v2 = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C2[d2], B = C2[v2], k = [], M = false, R = D.getParentNode(), q2 = R.type === C2.type && S.some((ue2) => R[ue2] === C2), J3 = R.type === C2.type && !q2, L, Q2, V = 0;
            do
              Q2 = L || C2, L = D.getParentNode(V), V++;
            while (L && L.type === C2.type && S.every((ue2) => L[ue2] !== Q2));
            let j2 = L || R, Y3 = Q2;
            if (o && (s(C2[S[0]]) || s(b) || s(B) || N2(Y3))) {
              M = true, J3 = true;
              let ue2 = (z) => [_("("), f2([g2, z]), g2, _(")")], Fe2 = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
              k.push(" ? ", Fe2(b) ? m(d2) : ue2(m(d2)), " : ", B.type === C2.type || Fe2(B) ? m(v2) : ue2(m(v2)));
            } else {
              let ue2 = [h, "? ", b.type === C2.type ? _("", "(") : "", F2(2, m(d2)), b.type === C2.type ? _("", ")") : "", h, ": ", B.type === C2.type ? m(v2) : F2(2, m(v2))];
              k.push(R.type !== C2.type || R[v2] === C2 || q2 ? ue2 : T.useTabs ? w2(f2(ue2)) : F2(Math.max(0, T.tabWidth - 2), ue2));
            }
            let ee2 = [...S.map((ue2) => a(C2[ue2])), a(b), a(B)].flat().some((ue2) => y(ue2) && t2(T.originalText, l(ue2), p(ue2))), ce2 = (ue2) => R === j2 ? c(ue2, { shouldBreak: ee2 }) : ee2 ? [ue2, E] : ue2, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C2) && !R.computed, K = P(D), de2 = ce2([x2(D, T, m), J3 ? k : f2(k), o && W && !K ? g2 : ""]);
            return q2 || K ? c([f2([g2, de2]), g2]) : de2;
          }
          r.exports = { printTernary: $ };
        } }), No = te2({ "src/language-js/print/statement.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { hardline: t2 } } = qe(), s = qt(), { getLeftSidePathName: a, hasNakedLeftSide: n2, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i2, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y } = Ke3(), { shouldPrintParamsWithoutParens: h } = qr2();
          function g2(x2, I, P, $) {
            let D = x2.getValue(), T = [], m = D.type === "ClassBody", C2 = c(D[$]);
            return x2.each((o, d2, v2) => {
              let S = o.getValue();
              if (S.type === "EmptyStatement")
                return;
              let b = P();
              !I.semi && !m && !i2(I, o) && f2(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && E(S) && N2(S, v2[d2 + 1]) && T.push(";"), S !== C2 && (T.push(t2), y(S, I) && T.push(t2));
            }, $), T;
          }
          function c(x2) {
            for (let I = x2.length - 1; I >= 0; I--) {
              let P = x2[I];
              if (P.type !== "EmptyStatement")
                return P;
            }
          }
          function f2(x2, I) {
            return x2.getNode().type !== "ExpressionStatement" ? false : x2.call(($) => F2($, I), "expression");
          }
          function F2(x2, I) {
            let P = x2.getValue();
            switch (P.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h(x2, I))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: $, operator: D } = P;
                if ($ && (D === "+" || D === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!P.object)
                  return true;
                break;
              }
              case "Literal": {
                if (P.regex)
                  return true;
                break;
              }
              default:
                if (u(P))
                  return true;
            }
            return s(x2, I) ? true : n2(P) ? x2.call(($) => F2($, I), ...a(x2, P)) : false;
          }
          function _(x2, I, P) {
            return g2(x2, I, P, "body");
          }
          function w2(x2, I, P) {
            return g2(x2, I, P, "consequent");
          }
          var E = (x2) => {
            let { type: I } = x2;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
          };
          function N2(x2, I) {
            let { type: P, name: $ } = x2.key;
            if (!x2.computed && P === "Identifier" && ($ === "static" || $ === "get" || $ === "set" || $ === "accessor") && !x2.value && !x2.typeAnnotation)
              return true;
            if (!I || I.static || I.accessibility)
              return false;
            if (!I.computed) {
              let D = I.key && I.key.name;
              if (D === "in" || D === "instanceof")
                return true;
            }
            if (E(I) && I.variance && !I.static && !I.declare)
              return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                  return false;
                let T = I.value ? I.value.generator : I.generator;
                return !!(I.computed || T);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          r.exports = { printBody: _, printSwitchCaseConsequent: w2 };
        } }), wo = te2({ "src/language-js/print/block.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { isNonEmptyArray: s } = Ue2(), { builders: { hardline: a, indent: n2 } } = qe(), { hasComment: u, CommentCheckFlags: i2, isNextLineEmpty: l } = Ke3(), { printHardlineAfterHeritage: p } = nr2(), { printBody: y } = No();
          function h(c, f2, F2) {
            let _ = c.getValue(), w2 = [];
            if (_.type === "StaticBlock" && w2.push("static "), _.type === "ClassBody" && s(_.body)) {
              let N2 = c.getParentNode();
              w2.push(p(N2));
            }
            w2.push("{");
            let E = g2(c, f2, F2);
            if (E)
              w2.push(n2([a, E]), a);
            else {
              let N2 = c.getParentNode(), x2 = c.getParentNode(1);
              N2.type === "ArrowFunctionExpression" || N2.type === "FunctionExpression" || N2.type === "FunctionDeclaration" || N2.type === "ObjectMethod" || N2.type === "ClassMethod" || N2.type === "ClassPrivateMethod" || N2.type === "ForStatement" || N2.type === "WhileStatement" || N2.type === "DoWhileStatement" || N2.type === "DoExpression" || N2.type === "CatchClause" && !x2.finalizer || N2.type === "TSModuleDeclaration" || N2.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w2.push(a);
            }
            return w2.push("}"), w2;
          }
          function g2(c, f2, F2) {
            let _ = c.getValue(), w2 = s(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N2 = u(_, i2.Dangling);
            if (!w2 && !E && !N2)
              return "";
            let x2 = [];
            if (w2 && c.each((I, P, $) => {
              x2.push(F2()), (P < $.length - 1 || E || N2) && (x2.push(a), l(I.getValue(), f2) && x2.push(a));
            }, "directives"), E && x2.push(y(c, f2, F2)), N2 && x2.push(t2(c, f2, true)), _.type === "Program") {
              let I = c.getParentNode();
              (!I || I.type !== "ModuleExpression") && x2.push(a);
            }
            return x2;
          }
          r.exports = { printBlock: h, printBlockBody: g2 };
        } }), yd = te2({ "src/language-js/print/typescript.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { hasNewlineInRange: s } = Ue2(), { builders: { join: a, line: n2, hardline: u, softline: i2, group: l, indent: p, conditionalGroup: y, ifBreak: h } } = qe(), { isStringLiteral: g2, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f2, isCallExpression: F2, isMemberExpression: _ } = Ke3(), w2 = gd(), { locStart: E, locEnd: N2 } = ut(), { printOptionalToken: x2, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Bo(), { printFunctionParameters: $, shouldGroupFunctionParameters: D } = Lr(), { printTemplateLiteral: T } = jt(), { printArrayItems: m } = er2(), { printObject: C2 } = uu(), { printClassProperty: o, printClassMethod: d2 } = nr2(), { printTypeParameter: v2, printTypeParameters: S } = jr2(), { printPropertyKey: b } = rr2(), { printFunction: B, printMethodInternal: k } = qr2(), { printInterface: M } = bo(), { printBlock: R } = wo(), { printTypeAlias: q2, printIntersectionType: J3, printUnionType: L, printFunctionType: Q2, printTupleType: V, printIndexedAccessType: j2, printJSDocType: Y3 } = Or2();
          function ie2(ee2, ce2, W) {
            let K = ee2.getValue();
            if (!K.type.startsWith("TS"))
              return;
            if (w2(K))
              return K.type.slice(2, -7).toLowerCase();
            let de2 = ce2.semi ? ";" : "", ue2 = [];
            switch (K.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Fe2 = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i2, W("typeAnnotation")]), i2, ">"]), U2 = [h("("), p([i2, W("expression")]), i2, h(")")];
                return Fe2 ? y([[z, W("expression")], [z, l(U2, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
              }
              case "TSDeclareFunction":
                return B(ee2, W, ce2);
              case "TSExportAssignment":
                return ["export = ", W("expression"), de2];
              case "TSModuleBlock":
                return R(ee2, ce2, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return C2(ee2, ce2, W);
              case "TSTypeAliasDeclaration":
                return q2(ee2, ce2, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d2(ee2, ce2, W);
              case "TSAbstractAccessorProperty":
              case "TSAbstractPropertyDefinition":
                return o(ee2, ce2, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ue2.push(W("expression")), K.typeParameters && ue2.push(W("typeParameters")), ue2;
              case "TSTemplateLiteralType":
                return T(ee2, W, ce2);
              case "TSNamedTupleMember":
                return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(ee2, ce2, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return S(ee2, ce2, W, "params");
              case "TSTypeParameter":
                return v2(ee2, ce2, W);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Fe2 = K.type === "TSAsExpression" ? "as" : "satisfies";
                ue2.push(W("expression"), ` ${Fe2} `, W("typeAnnotation"));
                let z = ee2.getParentNode();
                return F2(z) && z.callee === K || _(z) && z.object === K ? l([p([i2, ...ue2]), i2]) : ue2;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return K.readonly && ue2.push("readonly "), ue2.push(b(ee2, ce2, W), x2(ee2)), K.typeAnnotation && ue2.push(": ", W("typeAnnotation")), K.initializer && ue2.push(" = ", W("initializer")), ue2;
              case "TSParameterProperty":
                return K.accessibility && ue2.push(K.accessibility + " "), K.export && ue2.push("export "), K.static && ue2.push("static "), K.override && ue2.push("override "), K.readonly && ue2.push("readonly "), ue2.push(W("parameter")), ue2;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let Fe2 = ee2.getParentNode(), z = K.parameters.length > 1 ? h(f2(ce2) ? "," : "") : "", U2 = l([p([i2, a([", ", i2], ee2.map(W, "parameters"))]), z, i2]);
                return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U2 : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe2.type === "ClassBody" ? de2 : ""];
              }
              case "TSTypePredicate":
                return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee2, ce2, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return j2(ee2, ce2, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (K.type === "TSConstructorType" && K.abstract && ue2.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue2.push("new "), ue2.push(l($(ee2, W, ce2, false, true))), K.returnType || K.typeAnnotation) {
                  let Fe2 = K.type === "TSConstructorType";
                  ue2.push(Fe2 ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return ue2;
              }
              case "TSTypeOperator":
                return [K.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let Fe2 = s(ce2.originalText, E(K), N2(K));
                return l(["{", p([ce2.bracketSpacing ? n2 : i2, W("typeParameter"), K.optional ? c(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h(de2)]), t2(ee2, ce2, true), ce2.bracketSpacing ? n2 : i2, "}"], { shouldBreak: Fe2 });
              }
              case "TSMethodSignature": {
                let Fe2 = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                ue2.push(K.accessibility ? [K.accessibility, " "] : "", Fe2, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x2(ee2));
                let z = $(ee2, W, ce2, false, true), U2 = K.returnType ? "returnType" : "typeAnnotation", Z = K[U2], se = Z ? W(U2) : "", fe2 = D(K, se);
                return ue2.push(fe2 ? l(z) : z), Z && ue2.push(": ", l(se)), l(ue2);
              }
              case "TSNamespaceExportDeclaration":
                return ue2.push("export as namespace ", W("id")), ce2.semi && ue2.push(";"), l(ue2);
              case "TSEnumDeclaration":
                return K.declare && ue2.push("declare "), K.modifiers && ue2.push(I(ee2, ce2, W)), K.const && ue2.push("const "), ue2.push("enum ", W("id"), " "), K.members.length === 0 ? ue2.push(l(["{", t2(ee2, ce2), i2, "}"])) : ue2.push(l(["{", p([u, m(ee2, ce2, "members", W), f2(ce2, "es5") ? "," : ""]), t2(ee2, ce2, true), u, "}"])), ue2;
              case "TSEnumMember":
                return K.computed ? ue2.push("[", W("id"), "]") : ue2.push(W("id")), K.initializer && ue2.push(" = ", W("initializer")), ue2;
              case "TSImportEqualsDeclaration":
                return K.isExport && ue2.push("export "), ue2.push("import "), K.importKind && K.importKind !== "value" && ue2.push(K.importKind, " "), ue2.push(W("id"), " = ", W("moduleReference")), ce2.semi && ue2.push(";"), l(ue2);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let Fe2 = ee2.getParentNode(), z = g2(K.id), U2 = Fe2.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                if (U2)
                  ue2.push(".");
                else {
                  K.declare && ue2.push("declare "), ue2.push(I(ee2, ce2, W));
                  let se = ce2.originalText.slice(E(K), E(K.id));
                  K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue2.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                }
                return ue2.push(W("id")), Z ? ue2.push(W("body")) : K.body ? ue2.push(" ", l(W("body"))) : ue2.push(de2), ue2;
              }
              case "TSConditionalType":
                return P(ee2, ce2, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return J3(ee2, ce2, W);
              case "TSUnionType":
                return L(ee2, ce2, W);
              case "TSFunctionType":
                return Q2(ee2, ce2, W);
              case "TSTupleType":
                return V(ee2, ce2, W);
              case "TSTypeReference":
                return [W("typeName"), S(ee2, ce2, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k(ee2, ce2, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Y3(ee2, W, "?");
              case "TSJSDocNonNullableType":
                return Y3(ee2, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
            }
          }
          r.exports = { printTypescript: ie2 };
        } }), hd = te2({ "src/language-js/print/comment.js"(e, r) {
          "use strict";
          ne2();
          var { hasNewline: t2 } = Ue2(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n2 } } = qe(), { isLineComment: u } = Ke3(), { locStart: i2, locEnd: l } = ut(), p = Pt();
          function y(c, f2) {
            let F2 = c.getValue();
            if (u(F2))
              return f2.originalText.slice(i2(F2), l(F2)).trimEnd();
            if (p(F2)) {
              if (h(F2)) {
                let E = g2(F2);
                return F2.trailing && !t2(f2.originalText, i2(F2), { backwards: true }) ? [a, E] : E;
              }
              let _ = l(F2), w2 = f2.originalText.slice(_ - 3, _) === "*-/";
              return ["/*", n2(F2.value), w2 ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(F2));
          }
          function h(c) {
            let f2 = `*${c.value}*`.split(`
`);
            return f2.length > 1 && f2.every((F2) => F2.trim()[0] === "*");
          }
          function g2(c) {
            let f2 = c.value.split(`
`);
            return ["/*", s(a, f2.map((F2, _) => _ === 0 ? F2.trimEnd() : " " + (_ < f2.length - 1 ? F2.trim() : F2.trimStart()))), "*/"];
          }
          r.exports = { printComment: y };
        } }), vd = te2({ "src/language-js/print/literal.js"(e, r) {
          "use strict";
          ne2();
          var { printString: t2, printNumber: s } = Ue2(), { replaceTextEndOfLine: a } = Yt(), { printDirective: n2 } = ct();
          function u(y, h) {
            let g2 = y.getNode();
            switch (g2.type) {
              case "RegExpLiteral":
                return p(g2);
              case "BigIntLiteral":
                return l(g2.bigint || g2.extra.raw);
              case "NumericLiteral":
                return s(g2.extra.raw);
              case "StringLiteral":
                return a(t2(g2.extra.raw, h));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(g2.value);
              case "DecimalLiteral":
                return s(g2.value) + "m";
              case "Literal": {
                if (g2.regex)
                  return p(g2.regex);
                if (g2.bigint)
                  return l(g2.raw);
                if (g2.decimal)
                  return s(g2.decimal) + "m";
                let { value: c } = g2;
                return typeof c == "number" ? s(g2.raw) : typeof c == "string" ? i2(y) ? n2(g2.raw, h) : a(t2(g2.raw, h)) : String(c);
              }
            }
          }
          function i2(y) {
            if (y.getName() !== "expression")
              return;
            let h = y.getParentNode();
            return h.type === "ExpressionStatement" && h.directive;
          }
          function l(y) {
            return y.toLowerCase();
          }
          function p(y) {
            let { pattern: h, flags: g2 } = y;
            return g2 = [...g2].sort().join(""), `/${h}/${g2}`;
          }
          r.exports = { printLiteral: u };
        } }), Cd = te2({ "src/language-js/printer-estree.js"(e, r) {
          "use strict";
          ne2();
          var { printDanglingComments: t2 } = et(), { hasNewline: s } = Ue2(), { builders: { join: a, line: n2, hardline: u, softline: i2, group: l, indent: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = td(), g2 = rd(), { insertPragma: c } = Co(), f2 = Eo(), F2 = qt(), _ = Fo(), { hasFlowShorthandAnnotationComment: w2, hasComment: E, CommentCheckFlags: N2, isTheOnlyJsxElementInMarkdown: x2, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C2 } = Ke3(), { locStart: o, locEnd: d2 } = ut(), v2 = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd(), { printAngular: B } = fd(), { printJsx: k, hasJsxIgnoreComment: M } = Dd(), { printFlow: R } = dd(), { printTypescript: q2 } = yd(), { printOptionalToken: J3, printBindExpressionCallee: L, printTypeAnnotation: Q2, adjustClause: V, printRestSpread: j2, printDefiniteToken: Y3, printDirective: ie2 } = ct(), { printImportDeclaration: ee2, printExportDeclaration: ce2, printExportAllDeclaration: W, printModuleSpecifier: K } = To(), { printTernary: de2 } = Bo(), { printTemplateLiteral: ue2 } = jt(), { printArray: Fe2 } = er2(), { printObject: z } = uu(), { printClass: U2, printClassMethod: Z, printClassProperty: se } = nr2(), { printProperty: fe2 } = rr2(), { printFunction: ge, printArrowFunction: he, printMethod: we2, printReturnStatement: ke2, printThrowStatement: Re2 } = qr2(), { printCallExpression: Ne2 } = xo(), { printVariableDeclarator: Pe2, printAssignmentExpression: oe2 } = tr2(), { printBinaryishExpression: H } = ru(), { printSwitchCaseConsequent: pe2 } = No(), { printMemberExpression: X2 } = So(), { printBlock: le, printBlockBody: Ae2 } = wo(), { printComment: Ee2 } = hd(), { printLiteral: De3 } = vd(), { printDecorators: A2 } = nu();
          function G2(Ce2, Be2, ve, ze) {
            let be2 = re2(Ce2, Be2, ve, ze);
            if (!be2)
              return "";
            let Ye2 = Ce2.getValue(), { type: Se2 } = Ye2;
            if (Se2 === "ClassMethod" || Se2 === "ClassPrivateMethod" || Se2 === "ClassProperty" || Se2 === "ClassAccessorProperty" || Se2 === "AccessorProperty" || Se2 === "TSAbstractAccessorProperty" || Se2 === "PropertyDefinition" || Se2 === "TSAbstractPropertyDefinition" || Se2 === "ClassPrivateProperty" || Se2 === "MethodDefinition" || Se2 === "TSAbstractMethodDefinition" || Se2 === "TSDeclareMethod")
              return be2;
            let Ie2 = [be2], Oe2 = A2(Ce2, Be2, ve), Je2 = Ye2.type === "ClassExpression" && Oe2;
            if (Oe2 && (Ie2 = [...Oe2, be2], !Je2))
              return l(Ie2);
            if (!F2(Ce2, Be2))
              return ze && ze.needsSemi && Ie2.unshift(";"), Ie2.length === 1 && Ie2[0] === be2 ? be2 : Ie2;
            if (Je2 && (Ie2 = [p([n2, ...Ie2])]), Ie2.unshift("("), ze && ze.needsSemi && Ie2.unshift(";"), w2(Ye2)) {
              let [je2] = Ye2.trailingComments;
              Ie2.push(" /*", je2.value.trimStart(), "*/"), je2.printed = true;
            }
            return Je2 && Ie2.push(n2), Ie2.push(")"), Ie2;
          }
          function re2(Ce2, Be2, ve, ze) {
            let be2 = Ce2.getValue(), Ye2 = Be2.semi ? ";" : "";
            if (!be2)
              return "";
            if (typeof be2 == "string")
              return be2;
            for (let Ie2 of [De3, S, B, k, R, q2]) {
              let Oe2 = Ie2(Ce2, Be2, ve);
              if (typeof Oe2 < "u")
                return Oe2;
            }
            let Se2 = [];
            switch (be2.type) {
              case "JsExpressionRoot":
                return ve("node");
              case "JsonRoot":
                return [ve("node"), u];
              case "File":
                return be2.program && be2.program.interpreter && Se2.push(ve(["program", "interpreter"])), Se2.push(ve("program")), Se2;
              case "Program":
                return Ae2(Ce2, Be2, ve);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (Be2.parser === "__vue_event_binding" || Be2.parser === "__vue_ts_event_binding") {
                  let Oe2 = Ce2.getParentNode();
                  if (Oe2.type === "Program" && Oe2.body.length === 1 && Oe2.body[0] === be2)
                    return [ve("expression"), b(be2.expression) ? ";" : ""];
                }
                let Ie2 = t2(Ce2, Be2, true, (Oe2) => {
                  let { marker: Je2 } = Oe2;
                  return Je2 === C2;
                });
                return [ve("expression"), x2(Be2, Ce2) ? "" : Ye2, Ie2 ? [" ", Ie2] : ""];
              }
              case "ParenthesizedExpression":
                return !E(be2.expression) && (be2.expression.type === "ObjectExpression" || be2.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i2, ve("expression")]), i2, ")"]);
              case "AssignmentExpression":
                return oe2(Ce2, Be2, ve);
              case "VariableDeclarator":
                return Pe2(Ce2, Be2, ve);
              case "BinaryExpression":
              case "LogicalExpression":
                return H(Ce2, Be2, ve);
              case "AssignmentPattern":
                return [ve("left"), " = ", ve("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return X2(Ce2, Be2, ve);
              case "MetaProperty":
                return [ve("meta"), ".", ve("property")];
              case "BindExpression":
                return be2.object && Se2.push(ve("object")), Se2.push(l(p([i2, L(Ce2, Be2, ve)]))), Se2;
              case "Identifier":
                return [be2.name, J3(Ce2), Y3(Ce2), Q2(Ce2, Be2, ve)];
              case "V8IntrinsicIdentifier":
                return ["%", be2.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return j2(Ce2, Be2, ve);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge(Ce2, ve, Be2, ze);
              case "ArrowFunctionExpression":
                return he(Ce2, Be2, ve, ze);
              case "YieldExpression":
                return Se2.push("yield"), be2.delegate && Se2.push("*"), be2.argument && Se2.push(" ", ve("argument")), Se2;
              case "AwaitExpression": {
                if (Se2.push("await"), be2.argument) {
                  Se2.push(" ", ve("argument"));
                  let Ie2 = Ce2.getParentNode();
                  if (T(Ie2) && Ie2.callee === be2 || m(Ie2) && Ie2.object === be2) {
                    Se2 = [p([i2, ...Se2]), i2];
                    let Oe2 = Ce2.findAncestor((Je2) => Je2.type === "AwaitExpression" || Je2.type === "BlockStatement");
                    if (!Oe2 || Oe2.type !== "AwaitExpression")
                      return l(Se2);
                  }
                }
                return Se2;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return ce2(Ce2, Be2, ve);
              case "ExportAllDeclaration":
                return W(Ce2, Be2, ve);
              case "ImportDeclaration":
                return ee2(Ce2, Be2, ve);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return K(Ce2, Be2, ve);
              case "ImportAttribute":
                return [ve("key"), ": ", ve("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return le(Ce2, Be2, ve);
              case "ThrowStatement":
                return Re2(Ce2, Be2, ve);
              case "ReturnStatement":
                return ke2(Ce2, Be2, ve);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return Ne2(Ce2, Be2, ve);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Ce2, Be2, ve);
              case "ObjectProperty":
              case "Property":
                return be2.method || be2.kind === "get" || be2.kind === "set" ? we2(Ce2, Be2, ve) : fe2(Ce2, Be2, ve);
              case "ObjectMethod":
                return we2(Ce2, Be2, ve);
              case "Decorator":
                return ["@", ve("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Fe2(Ce2, Be2, ve);
              case "SequenceExpression": {
                let Ie2 = Ce2.getParentNode(0);
                if (Ie2.type === "ExpressionStatement" || Ie2.type === "ForStatement") {
                  let Oe2 = [];
                  return Ce2.each((Je2, Te2) => {
                    Te2 === 0 ? Oe2.push(ve()) : Oe2.push(",", p([n2, ve()]));
                  }, "expressions"), l(Oe2);
                }
                return l(a([",", n2], Ce2.map(ve, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [ve("value"), Ye2];
              case "DirectiveLiteral":
                return ie2(be2.extra.raw, Be2);
              case "UnaryExpression":
                return Se2.push(be2.operator), /[a-z]$/.test(be2.operator) && Se2.push(" "), E(be2.argument) ? Se2.push(l(["(", p([i2, ve("argument")]), i2, ")"])) : Se2.push(ve("argument")), Se2;
              case "UpdateExpression":
                return Se2.push(ve("argument"), be2.operator), be2.prefix && Se2.reverse(), Se2;
              case "ConditionalExpression":
                return de2(Ce2, Be2, ve);
              case "VariableDeclaration": {
                let Ie2 = Ce2.map(ve, "declarations"), Oe2 = Ce2.getParentNode(), Je2 = Oe2.type === "ForStatement" || Oe2.type === "ForInStatement" || Oe2.type === "ForOfStatement", Te2 = be2.declarations.some((Me2) => Me2.init), je2;
                return Ie2.length === 1 && !E(be2.declarations[0]) ? je2 = Ie2[0] : Ie2.length > 0 && (je2 = p(Ie2[0])), Se2 = [be2.declare ? "declare " : "", be2.kind, je2 ? [" ", je2] : "", p(Ie2.slice(1).map((Me2) => [",", Te2 && !Je2 ? u : n2, Me2]))], Je2 && Oe2.body !== be2 || Se2.push(Ye2), l(Se2);
              }
              case "WithStatement":
                return l(["with (", ve("object"), ")", V(be2.body, ve("body"))]);
              case "IfStatement": {
                let Ie2 = V(be2.consequent, ve("consequent")), Oe2 = l(["if (", l([p([i2, ve("test")]), i2]), ")", Ie2]);
                if (Se2.push(Oe2), be2.alternate) {
                  let Je2 = E(be2.consequent, N2.Trailing | N2.Line) || $(be2), Te2 = be2.consequent.type === "BlockStatement" && !Je2;
                  Se2.push(Te2 ? " " : u), E(be2, N2.Dangling) && Se2.push(t2(Ce2, Be2, true), Je2 ? u : " "), Se2.push("else", l(V(be2.alternate, ve("alternate"), be2.alternate.type === "IfStatement")));
                }
                return Se2;
              }
              case "ForStatement": {
                let Ie2 = V(be2.body, ve("body")), Oe2 = t2(Ce2, Be2, true), Je2 = Oe2 ? [Oe2, i2] : "";
                return !be2.init && !be2.test && !be2.update ? [Je2, l(["for (;;)", Ie2])] : [Je2, l(["for (", l([p([i2, ve("init"), ";", n2, ve("test"), ";", n2, ve("update")]), i2]), ")", Ie2])];
              }
              case "WhileStatement":
                return l(["while (", l([p([i2, ve("test")]), i2]), ")", V(be2.body, ve("body"))]);
              case "ForInStatement":
                return l(["for (", ve("left"), " in ", ve("right"), ")", V(be2.body, ve("body"))]);
              case "ForOfStatement":
                return l(["for", be2.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be2.body, ve("body"))]);
              case "DoWhileStatement": {
                let Ie2 = V(be2.body, ve("body"));
                return Se2 = [l(["do", Ie2])], be2.body.type === "BlockStatement" ? Se2.push(" ") : Se2.push(u), Se2.push("while (", l([p([i2, ve("test")]), i2]), ")", Ye2), Se2;
              }
              case "DoExpression":
                return [be2.async ? "async " : "", "do ", ve("body")];
              case "BreakStatement":
                return Se2.push("break"), be2.label && Se2.push(" ", ve("label")), Se2.push(Ye2), Se2;
              case "ContinueStatement":
                return Se2.push("continue"), be2.label && Se2.push(" ", ve("label")), Se2.push(Ye2), Se2;
              case "LabeledStatement":
                return be2.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
              case "TryStatement":
                return ["try ", ve("block"), be2.handler ? [" ", ve("handler")] : "", be2.finalizer ? [" finally ", ve("finalizer")] : ""];
              case "CatchClause":
                if (be2.param) {
                  let Ie2 = E(be2.param, (Je2) => !v2(Je2) || Je2.leading && s(Be2.originalText, d2(Je2)) || Je2.trailing && s(Be2.originalText, o(Je2), { backwards: true })), Oe2 = ve("param");
                  return ["catch ", Ie2 ? ["(", p([i2, Oe2]), i2, ") "] : ["(", Oe2, ") "], ve("body")];
                }
                return ["catch ", ve("body")];
              case "SwitchStatement":
                return [l(["switch (", p([i2, ve("discriminant")]), i2, ")"]), " {", be2.cases.length > 0 ? p([u, a(u, Ce2.map((Ie2, Oe2, Je2) => {
                  let Te2 = Ie2.getValue();
                  return [ve(), Oe2 !== Je2.length - 1 && P(Te2, Be2) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                be2.test ? Se2.push("case ", ve("test"), ":") : Se2.push("default:"), E(be2, N2.Dangling) && Se2.push(" ", t2(Ce2, Be2, true));
                let Ie2 = be2.consequent.filter((Oe2) => Oe2.type !== "EmptyStatement");
                if (Ie2.length > 0) {
                  let Oe2 = pe2(Ce2, Be2, ve);
                  Se2.push(Ie2.length === 1 && Ie2[0].type === "BlockStatement" ? [" ", Oe2] : p([u, Oe2]));
                }
                return Se2;
              }
              case "DebuggerStatement":
                return ["debugger", Ye2];
              case "ClassDeclaration":
              case "ClassExpression":
                return U2(Ce2, Be2, ve);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Ce2, Be2, ve);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
              case "AccessorProperty":
                return se(Ce2, Be2, ve);
              case "TemplateElement":
                return y(be2.value.raw);
              case "TemplateLiteral":
                return ue2(Ce2, ve, Be2);
              case "TaggedTemplateExpression":
                return [ve("tag"), ve("typeParameters"), ve("quasi")];
              case "PrivateIdentifier":
                return ["#", ve("name")];
              case "PrivateName":
                return ["#", ve("id")];
              case "InterpreterDirective":
                return Se2.push("#!", be2.value, u), P(be2, Be2) && Se2.push(u), Se2;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                Se2.push("module {");
                let Ie2 = ve("body");
                return Ie2 && Se2.push(p([u, Ie2]), u), Se2.push("}"), Se2;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(be2.type));
            }
          }
          function ye(Ce2) {
            return Ce2.type && !v2(Ce2) && !I(Ce2) && Ce2.type !== "EmptyStatement" && Ce2.type !== "TemplateElement" && Ce2.type !== "Import" && Ce2.type !== "TSEmptyBodyFunctionExpression";
          }
          r.exports = { preprocess: _, print: G2, embed: h, insertPragma: c, massageAstNode: g2, hasPrettierIgnore(Ce2) {
            return D(Ce2) || M(Ce2);
          }, willPrintOwnComments: f2.willPrintOwnComments, canAttachComment: ye, printComment: Ee2, isBlockComment: v2, handleComments: { avoidAstMutation: true, ownLine: f2.handleOwnLineComment, endOfLine: f2.handleEndOfLineComment, remaining: f2.handleRemainingComment }, getCommentChildNodes: f2.getCommentChildNodes };
        } }), Ed = te2({ "src/language-js/printer-estree-json.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { hardline: t2, indent: s, join: a } } = qe(), n2 = Fo();
          function u(y, h, g2) {
            let c = y.getValue();
            switch (c.type) {
              case "JsonRoot":
                return [g2("node"), t2];
              case "ArrayExpression": {
                if (c.elements.length === 0)
                  return "[]";
                let f2 = y.map(() => y.getValue() === null ? "null" : g2(), "elements");
                return ["[", s([t2, a([",", t2], f2)]), t2, "]"];
              }
              case "ObjectExpression":
                return c.properties.length === 0 ? "{}" : ["{", s([t2, a([",", t2], y.map(g2, "properties"))]), t2, "}"];
              case "ObjectProperty":
                return [g2("key"), ": ", g2("value")];
              case "UnaryExpression":
                return [c.operator === "+" ? "" : c.operator, g2("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return c.value ? "true" : "false";
              case "StringLiteral":
                return JSON.stringify(c.value);
              case "NumericLiteral":
                return i2(y) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
              case "Identifier":
                return i2(y) ? JSON.stringify(c.name) : c.name;
              case "TemplateLiteral":
                return g2(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(c.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(c.type));
            }
          }
          function i2(y) {
            return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
          }
          var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function p(y, h) {
            let { type: g2 } = y;
            if (g2 === "ObjectProperty") {
              let { key: c } = y;
              c.type === "Identifier" ? h.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (h.key = { type: "StringLiteral", value: String(c.value) });
              return;
            }
            if (g2 === "UnaryExpression" && y.operator === "+")
              return h.argument;
            if (g2 === "ArrayExpression") {
              for (let [c, f2] of y.elements.entries())
                f2 === null && h.elements.splice(c, 0, { type: "NullLiteral" });
              return;
            }
            if (g2 === "TemplateLiteral")
              return { type: "StringLiteral", value: y.quasis[0].value.cooked };
          }
          p.ignoredProperties = l, r.exports = { preprocess: n2, print: u, massageAstNode: p };
        } }), Mt = te2({ "src/common/common-options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = "Common";
          r.exports = { bracketSpacing: { since: "0.0.0", category: t2, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t2, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t2, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t2, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t2, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Fd = te2({ "src/language-js/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Mt(), s = "JavaScript";
          r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t2.bracketSameLine, bracketSpacing: t2.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t2.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t2.singleAttributePerLine };
        } }), Ad = te2({ "src/language-js/parse/parsers.js"() {
          ne2();
        } }), Ln = te2({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
          r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Sd = te2({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
          r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), xd = te2({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
          r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), wa = te2({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
          r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), bd = te2({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
          r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), Td2 = te2({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
          r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), Bd = te2({ "src/language-js/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = Cd(), a = Ed(), n2 = Fd(), u = Ad(), i2 = [t2(Ln(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t2(Ln(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t2(Ln(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t2(Sd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t2(xd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t2(wa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t2(wa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y) => y !== ".jsonl") })), t2(bd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t2(Td2(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
          r.exports = { languages: i2, options: n2, printers: l, parsers: u };
        } }), Nd = te2({ "src/language-css/clean.js"(e, r) {
          "use strict";
          ne2();
          var { isFrontMatterNode: t2 } = Ue2(), s = lt2(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function n2(i2, l, p) {
            if (t2(i2) && i2.lang === "yaml" && delete l.value, i2.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i2 || t2(p.nodes[0]) && p.nodes[1] === i2) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i2.text)) || p.type === "css-root" && s(p.nodes) === i2))
              return null;
            if (i2.type === "value-root" && delete l.text, (i2.type === "media-query" || i2.type === "media-query-list" || i2.type === "media-feature-expression") && delete l.value, i2.type === "css-rule" && delete l.params, i2.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i2.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i2.type === "value-word" && (i2.isColor && i2.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i2.type === "media-feature" || i2.type === "selector-root-invalid" || i2.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i2.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i2.type === "css-atrule" || i2.type === "css-import") && (l.name = l.name.toLowerCase()), i2.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i2.type === "media-feature" || i2.type === "media-keyword" || i2.type === "media-type" || i2.type === "media-unknown" || i2.type === "media-url" || i2.type === "media-value" || i2.type === "selector-attribute" || i2.type === "selector-string" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "value-string") && l.value && (l.value = u(l.value)), i2.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i2.type === "media-value" || i2.type === "media-type" || i2.type === "value-number" || i2.type === "selector-root-invalid" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g2) => {
              let c = Number(h);
              return Number.isNaN(c) ? y : c + g2.toLowerCase();
            })), i2.type === "selector-tag") {
              let y = i2.value.toLowerCase();
              ["from", "to"].includes(y) && (l.value = y);
            }
            if (i2.type === "css-atrule" && i2.name.toLowerCase() === "supports" && delete l.value, i2.type === "selector-unknown" && delete l.value, i2.type === "value-comma_group") {
              let y = i2.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
              y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
            if (i2.type === "value-comma_group" && i2.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]")))
              return { type: "value-atword", value: i2.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
          }
          n2.ignoredProperties = a;
          function u(i2) {
            return i2.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          r.exports = n2;
        } }), su = te2({ "src/utils/front-matter/print.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { hardline: t2, markAsRoot: s } } = qe();
          function a(n2, u) {
            if (n2.lang === "yaml") {
              let i2 = n2.value.trim(), l = i2 ? u(i2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s([n2.startDelimiter, t2, l, l ? t2 : "", n2.endDelimiter]);
            }
          }
          r.exports = a;
        } }), wd = te2({ "src/language-css/embed.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { hardline: t2 } } = qe(), s = su();
          function a(n2, u, i2) {
            let l = n2.getValue();
            if (l.type === "front-matter") {
              let p = s(l, i2);
              return p ? [p, t2] : "";
            }
          }
          r.exports = a;
        } }), _o = te2({ "src/utils/front-matter/parse.js"(e, r) {
          "use strict";
          ne2();
          var t2 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            let n2 = a.match(t2);
            if (!n2)
              return { content: a };
            let { startDelimiter: u, language: i2, value: l = "", endDelimiter: p } = n2.groups, y = i2.trim() || "yaml";
            if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p)
              return { content: a };
            let [h] = n2;
            return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a.slice(h.length) };
          }
          r.exports = s;
        } }), _d = te2({ "src/language-css/pragma.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Co(), s = _o();
          function a(u) {
            return t2.hasPragma(s(u).content);
          }
          function n2(u) {
            let { frontMatter: i2, content: l } = s(u);
            return (i2 ? i2.raw + `

` : "") + t2.insertPragma(l);
          }
          r.exports = { hasPragma: a, insertPragma: n2 };
        } }), Pd = te2({ "src/language-css/utils/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(z, U2) {
            let Z = Array.isArray(U2) ? U2 : [U2], se = -1, fe2;
            for (; fe2 = z.getParentNode(++se); )
              if (Z.includes(fe2.type))
                return se;
            return -1;
          }
          function a(z, U2) {
            let Z = s(z, U2);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          function n2(z) {
            var U2;
            let Z = a(z, "css-decl");
            return Z == null || (U2 = Z.prop) === null || U2 === void 0 ? void 0 : U2.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i2(z) {
            return u.has(z.toLowerCase());
          }
          function l(z, U2) {
            let Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U2.toLowerCase());
          }
          function p(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          function y(z, U2) {
            var Z;
            let se = a(z, "value-func");
            return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U2;
          }
          function h(z) {
            var U2;
            let Z = a(z, "css-rule"), se = Z == null || (U2 = Z.raws) === null || U2 === void 0 ? void 0 : U2.selector;
            return se && (se.startsWith(":import") || se.startsWith(":export"));
          }
          function g2(z, U2) {
            let Z = Array.isArray(U2) ? U2 : [U2], se = a(z, "css-atrule");
            return se && Z.includes(se.name.toLowerCase());
          }
          function c(z) {
            let U2 = z.getValue(), Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && U2.groups[0].value === "url" && U2.groups.length === 2;
          }
          function f2(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          function F2(z, U2) {
            var Z;
            let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return se && se.indexOf(U2) === se.length - 1;
          }
          function _(z) {
            let { selector: U2 } = z;
            return U2 ? typeof U2 == "string" && /^@.+:.*$/.test(U2) || U2.value && /^@.+:.*$/.test(U2.value) : false;
          }
          function w2(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          function E(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          function N2(z) {
            return z.type === "value-word" && z.value === "in";
          }
          function x2(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          function I(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          function P(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          function $(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          function D(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          function T(z) {
            return x2(z) || I(z) || P(z) || $(z) || D(z);
          }
          function m(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          function C2(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          function o(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          function d2(z) {
            var U2;
            return ((U2 = z.raws) === null || U2 === void 0 ? void 0 : U2.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          function v2(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          function S(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          function b(z, U2) {
            return z.value === "$$" && z.type === "value-func" && (U2 == null ? void 0 : U2.type) === "value-word" && !U2.raws.before;
          }
          function B(z) {
            var U2, Z;
            return ((U2 = z.value) === null || U2 === void 0 ? void 0 : U2.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          function k(z) {
            var U2, Z, se;
            return ((U2 = z.value) === null || U2 === void 0 || (Z = U2.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          function M(z) {
            var U2;
            return ((U2 = z.raws) === null || U2 === void 0 ? void 0 : U2.before) === "";
          }
          function R(z) {
            var U2, Z;
            return z.type === "value-comma_group" && ((U2 = z.groups) === null || U2 === void 0 || (Z = U2[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          function q2(z) {
            var U2;
            return z.type === "value-paren_group" && ((U2 = z.groups) === null || U2 === void 0 ? void 0 : U2[0]) && R(z.groups[0]);
          }
          function J3(z) {
            var U2;
            let Z = z.getValue();
            if (Z.groups.length === 0)
              return false;
            let se = z.getParentNode(1);
            if (!q2(Z) && !(se && q2(se)))
              return false;
            let fe2 = a(z, "css-decl");
            return !!(fe2 != null && (U2 = fe2.prop) !== null && U2 !== void 0 && U2.startsWith("$") || q2(se) || se.type === "value-func");
          }
          function L(z) {
            return z.type === "value-comment" && z.inline;
          }
          function Q2(z) {
            return z.type === "value-word" && z.value === "#";
          }
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          function j2(z) {
            return z.type === "value-word" && z.value === "}";
          }
          function Y3(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          function ie2(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          function ee2(z, U2) {
            if (!R(U2))
              return false;
            let { groups: Z } = U2, se = Z.indexOf(z);
            return se === -1 ? false : ie2(Z[se + 1]);
          }
          function ce2(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          function W(z) {
            return z.type !== "value-func" ? false : t2.has(z.value.toLowerCase());
          }
          function K(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          function de2(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          function ue2(z, U2) {
            var Z, se;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe2) => fe2.type !== "value-comma_group"))
              return false;
            if (U2.type === "value-comma_group") {
              let fe2 = U2.groups.indexOf(z) - 1, ge = U2.groups[fe2];
              if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                return true;
            }
            return false;
          }
          function Fe2(z) {
            var U2, Z;
            return z.type === "value-paren_group" && ((U2 = z.open) === null || U2 === void 0 ? void 0 : U2.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n2, maybeToLowerCase: p, insideValueFunctionNode: y, insideICSSRuleNode: h, insideAtRuleNode: g2, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i2, isLastNode: F2, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C2, isEqualityOperatorNode: m, isMultiplicationNode: x2, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N2, isForKeywordNode: w2, isURLFunctionNode: f2, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d2, isTemplatePlaceholderNode: v2, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q2, isKeyInValuePairNode: ee2, isSCSSMapItemNode: J3, isInlineValueCommentNode: L, isHashNode: Q2, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j2, isWordNode: Y3, isColonNode: ie2, isMediaAndSupportsKeywords: ce2, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de2, isConfigurationNode: ue2, isParenGroupNode: Fe2 };
        } }), Id = te2({ "src/utils/line-column-to-index.js"(e, r) {
          "use strict";
          ne2(), r.exports = function(t2, s) {
            let a = 0;
            for (let n2 = 0; n2 < t2.line - 1; ++n2)
              a = s.indexOf(`
`, a) + 1;
            return a + t2.column;
          };
        } }), kd = te2({ "src/language-css/loc.js"(e, r) {
          "use strict";
          ne2();
          var { skipEverythingButNewLine: t2 } = Pr(), s = lt2(), a = Id();
          function n2(c, f2) {
            return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f2) - 1 : null;
          }
          function u(c, f2) {
            if (c.type === "css-comment" && c.inline)
              return t2(f2, c.source.startOffset);
            let F2 = c.nodes && s(c.nodes);
            return F2 && c.source && !c.source.end && (c = F2), c.source && c.source.end ? a(c.source.end, f2) : null;
          }
          function i2(c, f2) {
            c.source && (c.source.startOffset = n2(c, f2), c.source.endOffset = u(c, f2));
            for (let F2 in c) {
              let _ = c[F2];
              F2 === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i2(_, f2));
            }
          }
          function l(c, f2, F2) {
            c.source && (c.source.startOffset = n2(c, F2) + f2, c.source.endOffset = u(c, F2) + f2);
            for (let _ in c) {
              let w2 = c[_];
              _ === "source" || !w2 || typeof w2 != "object" || l(w2, f2, F2);
            }
          }
          function p(c) {
            let f2 = c.source.startOffset;
            return typeof c.prop == "string" && (f2 += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f2 += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f2 += c.raws.between.length), f2;
          }
          function y(c) {
            let f2 = "initial", F2 = "initial", _, w2 = false, E = [];
            for (let N2 = 0; N2 < c.length; N2++) {
              let x2 = c[N2];
              switch (f2) {
                case "initial":
                  if (x2 === "'") {
                    f2 = "single-quotes";
                    continue;
                  }
                  if (x2 === '"') {
                    f2 = "double-quotes";
                    continue;
                  }
                  if ((x2 === "u" || x2 === "U") && c.slice(N2, N2 + 4).toLowerCase() === "url(") {
                    f2 = "url", N2 += 3;
                    continue;
                  }
                  if (x2 === "*" && c[N2 - 1] === "/") {
                    f2 = "comment-block";
                    continue;
                  }
                  if (x2 === "/" && c[N2 - 1] === "/") {
                    f2 = "comment-inline", _ = N2 - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (x2 === "'" && c[N2 - 1] !== "\\" && (f2 = F2, F2 = "initial"), x2 === `
` || x2 === "\r")
                    return c;
                  continue;
                case "double-quotes":
                  if (x2 === '"' && c[N2 - 1] !== "\\" && (f2 = F2, F2 = "initial"), x2 === `
` || x2 === "\r")
                    return c;
                  continue;
                case "url":
                  if (x2 === ")" && (f2 = "initial"), x2 === `
` || x2 === "\r")
                    return c;
                  if (x2 === "'") {
                    f2 = "single-quotes", F2 = "url";
                    continue;
                  }
                  if (x2 === '"') {
                    f2 = "double-quotes", F2 = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  x2 === "/" && c[N2 - 1] === "*" && (f2 = "initial");
                  continue;
                case "comment-inline":
                  (x2 === '"' || x2 === "'" || x2 === "*") && (w2 = true), (x2 === `
` || x2 === "\r") && (w2 && E.push([_, N2]), f2 = "initial", w2 = false);
                  continue;
              }
            }
            for (let [N2, x2] of E)
              c = c.slice(0, N2) + c.slice(N2, x2).replace(/["'*]/g, " ") + c.slice(x2);
            return c;
          }
          function h(c) {
            return c.source.startOffset;
          }
          function g2(c) {
            return c.source.endOffset;
          }
          r.exports = { locStart: h, locEnd: g2, calculateLoc: i2, replaceQuotesInInlineComments: y };
        } }), Ld = te2({ "src/language-css/utils/is-less-parser.js"(e, r) {
          "use strict";
          ne2();
          function t2(s) {
            return s.parser === "css" || s.parser === "less";
          }
          r.exports = t2;
        } }), Od = te2({ "src/language-css/utils/is-scss.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          r.exports = t2;
        } }), jd = te2({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
          r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), qd = te2({ "src/language-css/utils/print-unit.js"(e, r) {
          "use strict";
          ne2();
          var t2 = jd();
          function s(a) {
            let n2 = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t2, n2) ? t2[n2] : a;
          }
          r.exports = s;
        } }), Md = te2({ "src/language-css/printer-postcss.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2(), { printNumber: s, printString: a, hasNewline: n2, isFrontMatterNode: u, isNextLineEmpty: i2, isNonEmptyArray: l } = Ue2(), { builders: { join: p, line: y, hardline: h, softline: g2, group: c, fill: f2, indent: F2, dedent: _, ifBreak: w2, breakParent: E }, utils: { removeLines: N2, getDocParts: x2 } } = qe(), I = Nd(), P = wd(), { insertPragma: $ } = _d(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C2, insideICSSRuleNode: o, insideAtRuleNode: d2, insideURLFunctionInImportAtRuleNode: v2, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q2, isMultiplicationNode: J3, isDivisionNode: L, isAdditionNode: Q2, isSubtractionNode: V, isMathOperatorNode: j2, isEachKeywordNode: Y3, isForKeywordNode: ie2, isURLFunctionNode: ee2, isIfElseKeywordNode: ce2, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de2, isKeyValuePairNode: ue2, isKeyInValuePairNode: Fe2, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U2, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe2, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we2, isRightCurlyBraceNode: ke2, isWordNode: Re2, isColonNode: Ne2, isMediaAndSupportsKeywords: Pe2, isColorAdjusterFuncNode: oe2, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe2, isConfigurationNode: X2, isParenGroupNode: le } = Pd(), { locStart: Ae2, locEnd: Ee2 } = kd(), De3 = Ld(), A2 = Od(), G2 = qd();
          function re2(Te2) {
            return Te2.trailingComma === "es5" || Te2.trailingComma === "all";
          }
          function ye(Te2, je2, Me2) {
            let ae = Te2.getValue();
            if (!ae)
              return "";
            if (typeof ae == "string")
              return ae;
            switch (ae.type) {
              case "front-matter":
                return [ae.raw, h];
              case "css-root": {
                let Ve2 = Ce2(Te2, je2, Me2), We2 = ae.raws.after.trim();
                return We2.startsWith(";") && (We2 = We2.slice(1).trim()), [Ve2, We2 ? ` ${We2}` : "", x2(Ve2).length > 0 ? h : ""];
              }
              case "css-comment": {
                let Ve2 = ae.inline || ae.raws.inline, We2 = je2.originalText.slice(Ae2(ae), Ee2(ae));
                return Ve2 ? We2.trimEnd() : We2;
              }
              case "css-rule":
                return [Me2("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F2([h, Ce2(Te2, je2, Me2)]) : "", h, "}", M(ae) ? ";" : ""] : ";"];
              case "css-decl": {
                let Ve2 = Te2.getParentNode(), { between: We2 } = ae.raws, Xe2 = We2.trim(), st2 = Xe2 === ":", O2 = W(ae) ? N2(Me2("value")) : Me2("value");
                return !st2 && H(Xe2) && (O2 = F2([h, _(O2)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve2.type === "css-atrule" && Ve2.variable || o(Te2) ? ae.prop : m(ae.prop), Xe2.startsWith("//") ? " " : "", Xe2, ae.extend ? "" : " ", De3(je2) && ae.extend && ae.selector ? ["extend(", Me2("selector"), ")"] : "", O2, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F2([g2, Ce2(Te2, je2, Me2)]), g2, "}"] : Z(ae) && !Ve2.raws.semicolon && je2.originalText[Ee2(ae) - 1] !== ";" ? "" : je2.__isHTMLStyleAttribute && B(Te2, ae) ? w2(";") : ";"];
              }
              case "css-atrule": {
                let Ve2 = Te2.getParentNode(), We2 = U2(ae) && !Ve2.raws.semicolon && je2.originalText[Ee2(ae) - 1] !== ";";
                if (De3(je2)) {
                  if (ae.mixin)
                    return [Me2("selector"), ae.important ? " !important" : "", We2 ? "" : ";"];
                  if (ae.function)
                    return [ae.name, Me2("params"), We2 ? "" : ";"];
                  if (ae.variable)
                    return ["@", ae.name, ": ", ae.value ? Me2("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F2([ae.nodes.length > 0 ? g2 : "", Ce2(Te2, je2, Me2)]), g2, "}"] : "", We2 ? "" : ";"];
                }
                return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U2(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h, h] : /^\s*\n/.test(ae.raws.afterName) ? h : " " : " ", Me2("params")] : "", ae.selector ? F2([" ", Me2("selector")]) : "", ae.value ? c([" ", Me2("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F2([ae.nodes.length > 0 ? g2 : "", Ce2(Te2, je2, Me2)]), g2, "}"] : We2 ? "" : ";"];
              }
              case "media-query-list": {
                let Ve2 = [];
                return Te2.each((We2) => {
                  let Xe2 = We2.getValue();
                  Xe2.type === "media-query" && Xe2.value === "" || Ve2.push(Me2());
                }, "nodes"), c(F2(p(y, Ve2)));
              }
              case "media-query":
                return [p(" ", Te2.map(Me2, "nodes")), B(Te2, ae) ? "" : ","];
              case "media-type":
                return Oe2(Se2(ae.value, je2));
              case "media-feature-expression":
                return ae.nodes ? ["(", ...Te2.map(Me2, "nodes"), ")"] : ae.value;
              case "media-feature":
                return m(Se2(ae.value.replace(/ +/g, " "), je2));
              case "media-colon":
                return [ae.value, " "];
              case "media-value":
                return Oe2(Se2(ae.value, je2));
              case "media-keyword":
                return Se2(ae.value, je2);
              case "media-url":
                return Se2(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je2);
              case "media-unknown":
                return ae.value;
              case "selector-root":
                return c([d2(Te2, "custom-selector") ? [D(Te2, "css-atrule").customSelector, y] : "", p([",", d2(Te2, ["extend", "custom-selector", "nest"]) ? y : h], Te2.map(Me2, "nodes"))]);
              case "selector-selector":
                return c(F2(Te2.map(Me2, "nodes")));
              case "selector-comment":
                return ae.value;
              case "selector-string":
                return Se2(ae.value, je2);
              case "selector-tag": {
                let Ve2 = Te2.getParentNode(), We2 = Ve2 && Ve2.nodes.indexOf(ae), Xe2 = We2 && Ve2.nodes[We2 - 1];
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe2.type === "selector-nesting" ? ae.value : Oe2(S(Te2, ae.value) ? ae.value.toLowerCase() : ae.value)];
              }
              case "selector-id":
                return ["#", ae.value];
              case "selector-class":
                return [".", Oe2(Se2(ae.value, je2))];
              case "selector-attribute": {
                var nt;
                return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie2(Se2(ae.value.trim(), je2), je2) : "", ae.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                  let Xe2 = Te2.getParentNode();
                  return [Xe2.type === "selector-selector" && Xe2.nodes[0] === ae ? "" : y, ae.value, B(Te2, ae) ? "" : " "];
                }
                let Ve2 = ae.value.trim().startsWith("(") ? y : "", We2 = Oe2(Se2(ae.value.trim(), je2)) || y;
                return [Ve2, We2];
              }
              case "selector-universal":
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
              case "selector-pseudo":
                return [m(ae.value), l(ae.nodes) ? c(["(", F2([g2, p([",", y], Te2.map(Me2, "nodes"))]), g2, ")"]) : ""];
              case "selector-nesting":
                return ae.value;
              case "selector-unknown": {
                let Ve2 = D(Te2, "css-rule");
                if (Ve2 && Ve2.isSCSSNesterProperty)
                  return Oe2(Se2(m(ae.value), je2));
                let We2 = Te2.getParentNode();
                if (We2.raws && We2.raws.selector) {
                  let st2 = Ae2(We2), O2 = st2 + We2.raws.selector.length;
                  return je2.originalText.slice(st2, O2).trim();
                }
                let Xe2 = Te2.getParentNode(1);
                if (We2.type === "value-paren_group" && Xe2 && Xe2.type === "value-func" && Xe2.value === "selector") {
                  let st2 = Ee2(We2.open) + 1, O2 = Ae2(We2.close), me2 = je2.originalText.slice(st2, O2).trim();
                  return H(me2) ? [E, me2] : me2;
                }
                return ae.value;
              }
              case "value-value":
              case "value-root":
                return Me2("group");
              case "value-comment":
                return je2.originalText.slice(Ae2(ae), Ee2(ae));
              case "value-comma_group": {
                let Ve2 = Te2.getParentNode(), We2 = Te2.getParentNode(1), Xe2 = T(Te2), st2 = Xe2 && Ve2.type === "value-value" && (Xe2 === "grid" || Xe2.startsWith("grid-template")), O2 = D(Te2, "css-atrule"), me2 = O2 && k(O2), _e = ae.groups.some((at3) => ge(at3)), He2 = Te2.map(Me2, "groups"), Ge2 = [], it = C2(Te2, "url"), Qe2 = false, rt = false;
                for (let at3 = 0; at3 < ae.groups.length; ++at3) {
                  var tt;
                  Ge2.push(He2[at3]);
                  let Ze2 = ae.groups[at3 - 1], Le2 = ae.groups[at3], $e2 = ae.groups[at3 + 1], sr2 = ae.groups[at3 + 2];
                  if (it) {
                    ($e2 && Q2($e2) || Q2(Le2)) && Ge2.push(" ");
                    continue;
                  }
                  if (d2(Te2, "forward") && Le2.type === "value-word" && Le2.value && Ze2 !== void 0 && Ze2.type === "value-word" && Ze2.value === "as" && $e2.type === "value-operator" && $e2.value === "*" || !$e2 || Le2.type === "value-word" && Le2.value.endsWith("-") && pe2($e2))
                    continue;
                  if (Le2.type === "value-string" && Le2.quoted) {
                    let $r2 = Le2.value.lastIndexOf("#{"), Vr2 = Le2.value.lastIndexOf("}");
                    $r2 !== -1 && Vr2 !== -1 ? Qe2 = $r2 > Vr2 : $r2 !== -1 ? Qe2 = true : Vr2 !== -1 && (Qe2 = false);
                  }
                  if (Qe2 || Ne2(Le2) || Ne2($e2) || Le2.type === "value-atword" && (Le2.value === "" || Le2.value.endsWith("[")) || $e2.type === "value-word" && $e2.value.startsWith("]") || Le2.value === "~" || Le2.value && Le2.value.includes("\\") && $e2 && $e2.type !== "value-comment" || Ze2 && Ze2.value && Ze2.value.indexOf("\\") === Ze2.value.length - 1 && Le2.type === "value-operator" && Le2.value === "/" || Le2.value === "\\" || se(Le2, $e2) || he(Le2) || we2(Le2) || ke2($e2) || we2($e2) && de2($e2) || ke2(Le2) && de2($e2) || Le2.value === "--" && he($e2))
                    continue;
                  let Rr = j2(Le2), ou = j2($e2);
                  if ((Rr && he($e2) || ou && ke2(Le2)) && de2($e2) || !Ze2 && L(Le2) || C2(Te2, "calc") && (Q2(Le2) || Q2($e2) || V(Le2) || V($e2)) && de2($e2))
                    continue;
                  let qo = (Q2(Le2) || V(Le2)) && at3 === 0 && ($e2.type === "value-number" || $e2.isHex) && We2 && oe2(We2) && !de2($e2), lu = sr2 && sr2.type === "value-func" || sr2 && Re2(sr2) || Le2.type === "value-func" || Re2(Le2), cu = $e2.type === "value-func" || Re2($e2) || Ze2 && Ze2.type === "value-func" || Ze2 && Re2(Ze2);
                  if (!(!(J3($e2) || J3(Le2)) && !C2(Te2, "calc") && !qo && (L($e2) && !lu || L(Le2) && !cu || Q2($e2) && !lu || Q2(Le2) && !cu || V($e2) || V(Le2)) && (de2($e2) || Rr && (!Ze2 || Ze2 && j2(Ze2)))) && !((je2.parser === "scss" || je2.parser === "less") && Rr && Le2.value === "-" && le($e2) && Ee2(Le2) === Ae2($e2.open) && $e2.open.value === "(")) {
                    if (ge(Le2)) {
                      if (Ve2.type === "value-paren_group") {
                        Ge2.push(_(h));
                        continue;
                      }
                      Ge2.push(h);
                      continue;
                    }
                    if (me2 && (q2($e2) || R($e2) || ce2($e2) || Y3(Le2) || ie2(Le2))) {
                      Ge2.push(" ");
                      continue;
                    }
                    if (O2 && O2.name.toLowerCase() === "namespace") {
                      Ge2.push(" ");
                      continue;
                    }
                    if (st2) {
                      Le2.source && $e2.source && Le2.source.start.line !== $e2.source.start.line ? (Ge2.push(h), rt = true) : Ge2.push(" ");
                      continue;
                    }
                    if (ou) {
                      Ge2.push(" ");
                      continue;
                    }
                    if (!($e2 && $e2.value === "...") && !(pe2(Le2) && pe2($e2) && Ee2(Le2) === Ae2($e2))) {
                      if (pe2(Le2) && le($e2) && Ee2(Le2) === Ae2($e2.open)) {
                        Ge2.push(g2);
                        continue;
                      }
                      if (Le2.value === "with" && le($e2)) {
                        Ge2.push(" ");
                        continue;
                      }
                      (tt = Le2.value) !== null && tt !== void 0 && tt.endsWith("#") && $e2.value === "{" && le($e2.group) || Ge2.push(y);
                    }
                  }
                }
                return _e && Ge2.push(E), rt && Ge2.unshift(h), me2 ? c(F2(Ge2)) : v2(Te2) ? c(f2(Ge2)) : c(F2(f2(Ge2)));
              }
              case "value-paren_group": {
                let Ve2 = Te2.getParentNode();
                if (Ve2 && ee2(Ve2) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:")))
                  return [ae.open ? Me2("open") : "", p(",", Te2.map(Me2, "groups")), ae.close ? Me2("close") : ""];
                if (!ae.open) {
                  let it = Te2.map(Me2, "groups"), Qe2 = [];
                  for (let rt = 0; rt < it.length; rt++)
                    rt !== 0 && Qe2.push([",", y]), Qe2.push(it[rt]);
                  return c(F2(f2(Qe2)));
                }
                let We2 = fe2(Te2), Xe2 = t2(ae.groups), st2 = Xe2 && Xe2.type === "value-comment", O2 = Fe2(ae, Ve2), me2 = X2(ae, Ve2), _e = me2 || We2 && !O2, He2 = me2 || O2, Ge2 = c([ae.open ? Me2("open") : "", F2([g2, p([y], Te2.map((it, Qe2) => {
                  let rt = it.getValue(), at3 = Qe2 === ae.groups.length - 1, Ze2 = [Me2(), at3 ? "" : ","];
                  if (ue2(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                    let Le2 = x2(Ze2[0].contents.contents);
                    Le2[1] = c(Le2[1]), Ze2 = [c(_(Ze2))];
                  }
                  if (!at3 && rt.type === "value-comma_group" && l(rt.groups)) {
                    let Le2 = t2(rt.groups);
                    !Le2.source && Le2.close && (Le2 = Le2.close), Le2.source && i2(je2.originalText, Le2, Ee2) && Ze2.push(h);
                  }
                  return Ze2;
                }, "groups"))]), w2(!st2 && A2(je2.parser, je2.originalText) && We2 && re2(je2) ? "," : ""), g2, ae.close ? Me2("close") : ""], { shouldBreak: _e });
                return He2 ? _(Ge2) : Ge2;
              }
              case "value-func":
                return [ae.value, d2(Te2, "supports") && Pe2(ae) ? " " : "", Me2("group")];
              case "value-paren":
                return ae.value;
              case "value-number":
                return [Je2(ae.value), G2(ae.unit)];
              case "value-operator":
                return ae.value;
              case "value-word":
                return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
              case "value-colon": {
                let Ve2 = Te2.getParentNode(), We2 = Ve2 && Ve2.groups.indexOf(ae), Xe2 = We2 && Ve2.groups[We2 - 1];
                return [ae.value, Xe2 && typeof Xe2.value == "string" && t2(Xe2.value) === "\\" || C2(Te2, "url") ? "" : y];
              }
              case "value-comma":
                return [ae.value, " "];
              case "value-string":
                return a(ae.raws.quote + ae.value + ae.raws.quote, je2);
              case "value-atword":
                return ["@", ae.value];
              case "value-unicode-range":
                return ae.value;
              case "value-unknown":
                return ae.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
            }
          }
          function Ce2(Te2, je2, Me2) {
            let ae = [];
            return Te2.each((nt, tt, Ve2) => {
              let We2 = Ve2[tt - 1];
              if (We2 && We2.type === "css-comment" && We2.text.trim() === "prettier-ignore") {
                let Xe2 = nt.getValue();
                ae.push(je2.originalText.slice(Ae2(Xe2), Ee2(Xe2)));
              } else
                ae.push(Me2());
              tt !== Ve2.length - 1 && (Ve2[tt + 1].type === "css-comment" && !n2(je2.originalText, Ae2(Ve2[tt + 1]), { backwards: true }) && !u(Ve2[tt]) || Ve2[tt + 1].type === "css-atrule" && Ve2[tt + 1].name === "else" && Ve2[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je2.__isHTMLStyleAttribute ? y : h), i2(je2.originalText, nt.getValue(), Ee2) && !u(Ve2[tt]) && ae.push(h)));
            }, "nodes"), ae;
          }
          var Be2 = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be2 = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye2 = new RegExp(Be2.source + `|(${be2.source})?(${ve.source})(${ze.source})?`, "g");
          function Se2(Te2, je2) {
            return Te2.replace(Be2, (Me2) => a(Me2, je2));
          }
          function Ie2(Te2, je2) {
            let Me2 = je2.singleQuote ? "'" : '"';
            return Te2.includes('"') || Te2.includes("'") ? Te2 : Me2 + Te2 + Me2;
          }
          function Oe2(Te2) {
            return Te2.replace(Ye2, (je2, Me2, ae, nt, tt) => !ae && nt ? Je2(nt) + m(tt || "") : je2);
          }
          function Je2(Te2) {
            return s(Te2).replace(/\.0(?=$|e)/, "");
          }
          r.exports = { print: ye, embed: P, insertPragma: $, massageAstNode: I };
        } }), Rd = te2({ "src/language-css/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Mt();
          r.exports = { singleQuote: t2.singleQuote };
        } }), $d = te2({ "src/language-css/parsers.js"() {
          ne2();
        } }), Vd = te2({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
          r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Wd = te2({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
          r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Hd = te2({ "node_modules/linguist-languages/data/Less.json"(e, r) {
          r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Gd = te2({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
          r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Ud = te2({ "src/language-css/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = Md(), a = Rd(), n2 = $d(), u = [t2(Vd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t2(Wd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t2(Hd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t2(Gd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i2 = { postcss: s };
          r.exports = { languages: u, options: a, printers: i2, parsers: n2 };
        } }), Jd = te2({ "src/language-handlebars/loc.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return a.loc.start.offset;
          }
          function s(a) {
            return a.loc.end.offset;
          }
          r.exports = { locStart: t2, locEnd: s };
        } }), zd = te2({ "src/language-handlebars/clean.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a) {
            if (s.type === "TextNode") {
              let n2 = s.chars.trim();
              if (!n2)
                return null;
              a.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          t2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t2;
        } }), Xd = te2({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
          r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
        } }), Kd = te2({ "src/language-handlebars/utils.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2(), s = Xd();
          function a(x2) {
            let I = x2.getValue(), P = x2.getParentNode(0);
            return !!(g2(x2, ["ElementNode"]) && t2(P.children) === I || g2(x2, ["Block"]) && t2(P.body) === I);
          }
          function n2(x2) {
            return x2.toUpperCase() === x2;
          }
          function u(x2) {
            return h(x2, ["ElementNode"]) && typeof x2.tag == "string" && !x2.tag.startsWith(":") && (n2(x2.tag[0]) || x2.tag.includes("."));
          }
          var i2 = new Set(s);
          function l(x2) {
            return i2.has(x2.toLowerCase()) && !n2(x2[0]);
          }
          function p(x2) {
            return x2.selfClosing === true || l(x2.tag) || u(x2) && x2.children.every((I) => y(I));
          }
          function y(x2) {
            return h(x2, ["TextNode"]) && !/\S/.test(x2.chars);
          }
          function h(x2, I) {
            return x2 && I.includes(x2.type);
          }
          function g2(x2, I) {
            let P = x2.getParentNode(0);
            return h(P, I);
          }
          function c(x2, I) {
            let P = _(x2);
            return h(P, I);
          }
          function f2(x2, I) {
            let P = w2(x2);
            return h(P, I);
          }
          function F2(x2, I) {
            var P, $, D, T;
            let m = x2.getValue(), C2 = (P = x2.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($ = (D = (T = C2.children) !== null && T !== void 0 ? T : C2.body) !== null && D !== void 0 ? D : C2.parts) !== null && $ !== void 0 ? $ : [], d2 = o.indexOf(m);
            return d2 !== -1 && o[d2 + I];
          }
          function _(x2) {
            let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return F2(x2, -I);
          }
          function w2(x2) {
            return F2(x2, 1);
          }
          function E(x2) {
            return h(x2, ["MustacheCommentStatement"]) && typeof x2.value == "string" && x2.value.trim() === "prettier-ignore";
          }
          function N2(x2) {
            let I = x2.getValue(), P = _(x2, 2);
            return E(I) || E(P);
          }
          r.exports = { getNextNode: w2, getPreviousNode: _, hasPrettierIgnore: N2, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f2, isNodeOfSomeType: h, isParentOfSomeType: g2, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: y };
        } }), Yd = te2({ "src/language-handlebars/printer-glimmer.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { dedent: t2, fill: s, group: a, hardline: n2, ifBreak: u, indent: i2, join: l, line: p, softline: y }, utils: { getDocParts: h, replaceTextEndOfLine: g2 } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f2 } = Ue2(), { locStart: F2, locEnd: _ } = Jd(), w2 = zd(), { getNextNode: E, getPreviousNode: N2, hasPrettierIgnore: x2, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C2 } = Kd(), o = 2;
          function d2(H, pe2, X2) {
            let le = H.getValue();
            if (!le)
              return "";
            if (x2(H))
              return pe2.originalText.slice(F2(le), _(le));
            let Ae2 = pe2.singleQuote ? "'" : '"';
            switch (le.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(H.map(X2, "body"));
              case "ElementNode": {
                let Ee2 = a(S(H, X2)), De3 = pe2.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                if (m(le))
                  return [Ee2, De3];
                let A2 = ["</", le.tag, ">"];
                return le.children.length === 0 ? [Ee2, i2(A2), De3] : pe2.htmlWhitespaceSensitivity === "ignore" ? [Ee2, i2(b(H, pe2, X2)), n2, i2(A2), De3] : [Ee2, i2(a(b(H, pe2, X2))), i2(A2), De3];
              }
              case "BlockStatement": {
                let Ee2 = H.getParentNode(1);
                return Ee2 && Ee2.inverse && Ee2.inverse.body.length === 1 && Ee2.inverse.body[0] === le && Ee2.inverse.body[0].path.parts[0] === Ee2.path.parts[0] ? [ie2(H, X2, Ee2.inverse.body[0].path.parts[0]), de2(H, X2, pe2), ue2(H, X2, pe2)] : [j2(H, X2), a([de2(H, X2, pe2), ue2(H, X2, pe2), ee2(H, X2, pe2)])];
              }
              case "ElementModifierStatement":
                return a(["{{", Re2(H, X2), "}}"]);
              case "MustacheStatement":
                return a([k(le), Re2(H, X2), M(le)]);
              case "SubExpression":
                return a(["(", ke2(H, X2), y, ")"]);
              case "AttrNode": {
                let Ee2 = le.value.type === "TextNode";
                if (Ee2 && le.value.chars === "" && F2(le.value) === _(le.value))
                  return le.name;
                let A2 = Ee2 ? c(le.value.chars, Ae2).quote : le.value.type === "ConcatStatement" ? c(le.value.parts.filter((re2) => re2.type === "TextNode").map((re2) => re2.chars).join(""), Ae2).quote : "", G2 = X2("value");
                return [le.name, "=", A2, le.name === "class" && A2 ? a(i2(G2)) : G2, A2];
              }
              case "ConcatStatement":
                return H.map(X2, "parts");
              case "Hash":
                return l(p, H.map(X2, "pairs"));
              case "HashPair":
                return [le.key, "=", X2("value")];
              case "TextNode": {
                let Ee2 = le.chars.replace(/{{/g, "\\{{"), De3 = U2(H);
                if (De3) {
                  if (De3 === "class") {
                    let Ye2 = Ee2.trim().split(/\s+/).join(" "), Se2 = false, Ie2 = false;
                    return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee2) && (Se2 = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee2) && Ye2 !== "" && (Ie2 = true)), [Se2 ? p : "", Ye2, Ie2 ? p : ""];
                  }
                  return g2(Ee2);
                }
                let G2 = /^[\t\n\f\r ]*$/.test(Ee2), re2 = !N2(H), ye = !E(H);
                if (pe2.htmlWhitespaceSensitivity !== "ignore") {
                  let Ye2 = /^[\t\n\f\r ]*/, Se2 = /[\t\n\f\r ]*$/, Ie2 = ye && D(H, ["Template"]), Oe2 = re2 && D(H, ["Template"]);
                  if (G2) {
                    if (Oe2 || Ie2)
                      return "";
                    let ae = [p], nt = Z(Ee2);
                    return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t2(tt))), ae;
                  }
                  let [Je2] = Ee2.match(Ye2), [Te2] = Ee2.match(Se2), je2 = [];
                  if (Je2) {
                    je2 = [p];
                    let ae = Z(Je2);
                    ae && (je2 = ge(ae)), Ee2 = Ee2.replace(Ye2, "");
                  }
                  let Me2 = [];
                  if (Te2) {
                    if (!Ie2) {
                      Me2 = [p];
                      let ae = Z(Te2);
                      ae && (Me2 = ge(ae)), I(H) && (Me2 = Me2.map((nt) => t2(nt)));
                    }
                    Ee2 = Ee2.replace(Se2, "");
                  }
                  return [...je2, s(Fe2(Ee2)), ...Me2];
                }
                let Ce2 = Z(Ee2), Be2 = se(Ee2), ve = fe2(Ee2);
                if ((re2 || ye) && G2 && D(H, ["Block", "ElementNode", "Template"]))
                  return "";
                G2 && Ce2 ? (Be2 = Math.min(Ce2, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be2 = Math.max(Be2, 1)));
                let ze = "", be2 = "";
                return ve === 0 && P(H, ["MustacheStatement"]) && (be2 = " "), Be2 === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re2 && (Be2 = 0, ze = ""), ye && (ve = 0, be2 = ""), Ee2 = Ee2.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be2), [...ge(Be2), s(Fe2(Ee2)), ...ge(ve)];
              }
              case "MustacheCommentStatement": {
                let Ee2 = F2(le), De3 = _(le), A2 = pe2.originalText.charAt(Ee2 + 2) === "~", G2 = pe2.originalText.charAt(De3 - 3) === "~", re2 = le.value.includes("}}") ? "--" : "";
                return ["{{", A2 ? "~" : "", "!", re2, le.value, re2, G2 ? "~" : "", "}}"];
              }
              case "PathExpression":
                return le.original;
              case "BooleanLiteral":
                return String(le.value);
              case "CommentStatement":
                return ["<!--", le.value, "-->"];
              case "StringLiteral": {
                if (we2(H)) {
                  let Ee2 = pe2.singleQuote ? '"' : "'";
                  return he(le.value, Ee2);
                }
                return he(le.value, Ae2);
              }
              case "NumberLiteral":
                return String(le.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
            }
          }
          function v2(H, pe2) {
            return F2(H) - F2(pe2);
          }
          function S(H, pe2) {
            let X2 = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee2) => f2(X2[Ee2])), Ae2 = le.flatMap((Ee2) => X2[Ee2]).sort(v2);
            for (let Ee2 of le)
              H.each((De3) => {
                let A2 = Ae2.indexOf(De3.getValue());
                Ae2.splice(A2, 1, [p, pe2()]);
              }, Ee2);
            return f2(X2.blockParams) && Ae2.push(p, oe2(X2)), ["<", X2.tag, i2(Ae2), B(X2)];
          }
          function b(H, pe2, X2) {
            let Ae2 = H.getValue().children.every((Ee2) => C2(Ee2));
            return pe2.htmlWhitespaceSensitivity === "ignore" && Ae2 ? "" : H.map((Ee2, De3) => {
              let A2 = X2();
              return De3 === 0 && pe2.htmlWhitespaceSensitivity === "ignore" ? [y, A2] : A2;
            }, "children");
          }
          function B(H) {
            return m(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
          }
          function k(H) {
            let pe2 = H.escaped === false ? "{{{" : "{{", X2 = H.strip && H.strip.open ? "~" : "";
            return [pe2, X2];
          }
          function M(H) {
            let pe2 = H.escaped === false ? "}}}" : "}}";
            return [H.strip && H.strip.close ? "~" : "", pe2];
          }
          function R(H) {
            let pe2 = k(H), X2 = H.openStrip.open ? "~" : "";
            return [pe2, X2, "#"];
          }
          function q2(H) {
            let pe2 = M(H);
            return [H.openStrip.close ? "~" : "", pe2];
          }
          function J3(H) {
            let pe2 = k(H), X2 = H.closeStrip.open ? "~" : "";
            return [pe2, X2, "/"];
          }
          function L(H) {
            let pe2 = M(H);
            return [H.closeStrip.close ? "~" : "", pe2];
          }
          function Q2(H) {
            let pe2 = k(H), X2 = H.inverseStrip.open ? "~" : "";
            return [pe2, X2];
          }
          function V(H) {
            let pe2 = M(H);
            return [H.inverseStrip.close ? "~" : "", pe2];
          }
          function j2(H, pe2) {
            let X2 = H.getValue(), le = [], Ae2 = Pe2(H, pe2);
            return Ae2 && le.push(a(Ae2)), f2(X2.program.blockParams) && le.push(oe2(X2.program)), a([R(X2), Ne2(H, pe2), le.length > 0 ? i2([p, l(p, le)]) : "", y, q2(X2)]);
          }
          function Y3(H, pe2) {
            return [pe2.htmlWhitespaceSensitivity === "ignore" ? n2 : "", Q2(H), "else", V(H)];
          }
          function ie2(H, pe2, X2) {
            let le = H.getValue(), Ae2 = H.getParentNode(1);
            return a([Q2(Ae2), ["else", " ", X2], i2([p, a(Pe2(H, pe2)), ...f2(le.program.blockParams) ? [p, oe2(le.program)] : []]), y, V(Ae2)]);
          }
          function ee2(H, pe2, X2) {
            let le = H.getValue();
            return X2.htmlWhitespaceSensitivity === "ignore" ? [ce2(le) ? y : n2, J3(le), pe2("path"), L(le)] : [J3(le), pe2("path"), L(le)];
          }
          function ce2(H) {
            return $(H, ["BlockStatement"]) && H.program.body.every((pe2) => C2(pe2));
          }
          function W(H) {
            return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
          }
          function K(H) {
            return $(H, ["BlockStatement"]) && H.inverse;
          }
          function de2(H, pe2, X2) {
            let le = H.getValue();
            if (ce2(le))
              return "";
            let Ae2 = pe2("program");
            return X2.htmlWhitespaceSensitivity === "ignore" ? i2([n2, Ae2]) : i2(Ae2);
          }
          function ue2(H, pe2, X2) {
            let le = H.getValue(), Ae2 = pe2("inverse"), Ee2 = X2.htmlWhitespaceSensitivity === "ignore" ? [n2, Ae2] : Ae2;
            return W(le) ? Ee2 : K(le) ? [Y3(le, X2), i2(Ee2)] : "";
          }
          function Fe2(H) {
            return h(l(p, z(H)));
          }
          function z(H) {
            return H.split(/[\t\n\f\r ]+/);
          }
          function U2(H) {
            for (let pe2 = 0; pe2 < 2; pe2++) {
              let X2 = H.getParentNode(pe2);
              if (X2 && X2.type === "AttrNode")
                return X2.name.toLowerCase();
            }
          }
          function Z(H) {
            return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
          }
          function se(H) {
            H = typeof H == "string" ? H : "";
            let pe2 = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(pe2);
          }
          function fe2(H) {
            H = typeof H == "string" ? H : "";
            let pe2 = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(pe2);
          }
          function ge() {
            let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(H, o) }).fill(n2);
          }
          function he(H, pe2) {
            let { quote: X2, regex: le } = c(H, pe2);
            return [X2, H.replace(le, `\\${X2}`), X2];
          }
          function we2(H) {
            let pe2 = 0, X2 = H.getParentNode(pe2);
            for (; X2 && $(X2, ["SubExpression"]); )
              pe2++, X2 = H.getParentNode(pe2);
            return !!(X2 && $(H.getParentNode(pe2 + 1), ["ConcatStatement"]) && $(H.getParentNode(pe2 + 2), ["AttrNode"]));
          }
          function ke2(H, pe2) {
            let X2 = Ne2(H, pe2), le = Pe2(H, pe2);
            return le ? i2([X2, p, a(le)]) : X2;
          }
          function Re2(H, pe2) {
            let X2 = Ne2(H, pe2), le = Pe2(H, pe2);
            return le ? [i2([X2, p, le]), y] : X2;
          }
          function Ne2(H, pe2) {
            return pe2("path");
          }
          function Pe2(H, pe2) {
            let X2 = H.getValue(), le = [];
            if (X2.params.length > 0) {
              let Ae2 = H.map(pe2, "params");
              le.push(...Ae2);
            }
            if (X2.hash && X2.hash.pairs.length > 0) {
              let Ae2 = pe2("hash");
              le.push(Ae2);
            }
            return le.length === 0 ? "" : l(p, le);
          }
          function oe2(H) {
            return ["as |", H.blockParams.join(" "), "|"];
          }
          r.exports = { print: d2, massageAstNode: w2 };
        } }), Qd = te2({ "src/language-handlebars/parsers.js"() {
          ne2();
        } }), Zd = te2({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
          r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), eg = te2({ "src/language-handlebars/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = Yd(), a = Qd(), n2 = [t2(Zd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
          r.exports = { languages: n2, printers: u, parsers: a };
        } }), tg = te2({ "src/language-graphql/pragma.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          function s(a) {
            return `# @format

` + a;
          }
          r.exports = { hasPragma: t2, insertPragma: s };
        } }), rg = te2({ "src/language-graphql/loc.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          r.exports = { locStart: t2, locEnd: s };
        } }), ng = te2({ "src/language-graphql/printer-graphql.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { join: t2, hardline: s, line: a, softline: n2, group: u, indent: i2, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: y } = Ue2(), { insertPragma: h } = tg(), { locStart: g2, locEnd: c } = rg();
          function f2(P, $, D) {
            let T = P.getValue();
            if (!T)
              return "";
            if (typeof T == "string")
              return T;
            switch (T.kind) {
              case "Document": {
                let m = [];
                return P.each((C2, o, d2) => {
                  m.push(D()), o !== d2.length - 1 && (m.push(s), p($.originalText, C2.getValue(), c) && m.push(s));
                }, "definitions"), [...m, s];
              }
              case "OperationDefinition": {
                let m = $.originalText[g2(T)] !== "{", C2 = Boolean(T.name);
                return [m ? T.operation : "", m && C2 ? [" ", D("name")] : "", m && !C2 && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i2([n2, t2([l("", ", "), n2], P.map(D, "variableDefinitions"))]), n2, ")"]) : "", F2(P, D, T), T.selectionSet ? !m && !C2 ? "" : " " : "", D("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i2([n2, t2([l("", ", "), n2], P.map(D, "variableDefinitions"))]), n2, ")"]) : "", " on ", D("typeCondition"), F2(P, D, T), " ", D("selectionSet")];
              case "SelectionSet":
                return ["{", i2([s, t2(s, _(P, $, D, "selections"))]), s, "}"];
              case "Field":
                return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i2([n2, t2([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : "", F2(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
              case "Name":
                return T.value;
              case "StringValue": {
                if (T.block) {
                  let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                  return m.length === 1 && (m[0] = m[0].trim()), m.every((C2) => C2 === "") && (m.length = 0), t2(s, ['"""', ...m, '"""']);
                }
                return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return T.value;
              case "BooleanValue":
                return T.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", D("name")];
              case "ListValue":
                return u(["[", i2([n2, t2([l("", ", "), n2], P.map(D, "values"))]), n2, "]"]);
              case "ObjectValue":
                return u(["{", $.bracketSpacing && T.fields.length > 0 ? " " : "", i2([n2, t2([l("", ", "), n2], P.map(D, "fields"))]), n2, l("", $.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [D("name"), ": ", D("value")];
              case "Directive":
                return ["@", D("name"), T.arguments.length > 0 ? u(["(", i2([n2, t2([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : ""];
              case "NamedType":
                return D("name");
              case "VariableDefinition":
                return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F2(P, D, T)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N2(P, $, D)] : "", F2(P, D, T), T.fields.length > 0 ? [" {", i2([s, t2(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i2([n2, t2([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : "", ": ", D("type"), F2(P, D, T)];
              case "DirectiveDefinition":
                return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i2([n2, t2([l("", ", "), n2], _(P, $, D, "arguments"))]), n2, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t2(" | ", P.map(D, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F2(P, D, T), T.values.length > 0 ? [" {", i2([s, t2(s, _(P, $, D, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [D("description"), T.description ? s : "", D("name"), F2(P, D, T)];
              case "InputValueDefinition":
                return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F2(P, D, T)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F2(P, D, T), T.fields.length > 0 ? [" {", i2([s, t2(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", F2(P, D, T), ...T.operationTypes.length > 0 ? [" {", i2([s, t2(s, _(P, $, D, "operationTypes"))]), s, "}"] : []];
              case "SchemaDefinition":
                return [D("description"), T.description ? s : "", "schema", F2(P, D, T), " {", T.operationTypes.length > 0 ? i2([s, t2(s, _(P, $, D, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [D("operation"), ": ", D("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N2(P, $, D)] : "", F2(P, D, T), T.fields.length > 0 ? [" {", i2([s, t2(s, _(P, $, D, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", D("name"), F2(P, D, T)];
              case "InlineFragment":
                return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F2(P, D, T), " ", D("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F2(P, D, T), T.types.length > 0 ? [" =", l("", " "), i2([l([a, "  "]), t2([a, "| "], P.map(D, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F2(P, D, T)];
              case "NonNullType":
                return [D("type"), "!"];
              case "ListType":
                return ["[", D("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
            }
          }
          function F2(P, $, D) {
            if (D.directives.length === 0)
              return "";
            let T = t2(a, P.map($, "directives"));
            return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i2([n2, T]))];
          }
          function _(P, $, D, T) {
            return P.map((m, C2, o) => {
              let d2 = D();
              return C2 < o.length - 1 && p($.originalText, m.getValue(), c) ? [d2, s] : d2;
            }, T);
          }
          function w2(P) {
            return P.kind && P.kind !== "Comment";
          }
          function E(P) {
            let $ = P.getValue();
            if ($.kind === "Comment")
              return "#" + $.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify($));
          }
          function N2(P, $, D) {
            let T = P.getNode(), m = [], { interfaces: C2 } = T, o = P.map((d2) => D(d2), "interfaces");
            for (let d2 = 0; d2 < C2.length; d2++) {
              let v2 = C2[d2];
              m.push(o[d2]);
              let S = C2[d2 + 1];
              if (S) {
                let b = $.originalText.slice(v2.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                m.push(k === "," ? "," : " &", B ? a : " ");
              }
            }
            return m;
          }
          function x2(P, $) {
            P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
          }
          x2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(P) {
            var $;
            let D = P.getValue();
            return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some((T) => T.value.trim() === "prettier-ignore");
          }
          r.exports = { print: f2, massageAstNode: x2, hasPrettierIgnore: I, insertPragma: h, printComment: E, canAttachComment: w2 };
        } }), ug = te2({ "src/language-graphql/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Mt();
          r.exports = { bracketSpacing: t2.bracketSpacing };
        } }), sg = te2({ "src/language-graphql/parsers.js"() {
          ne2();
        } }), ig2 = te2({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
          r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), ag = te2({ "src/language-graphql/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = ng(), a = ug(), n2 = sg(), u = [t2(ig2(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i2 = { graphql: s };
          r.exports = { languages: u, options: a, printers: i2, parsers: n2 };
        } }), Po = te2({ "node_modules/collapse-white-space/index.js"(e, r) {
          "use strict";
          ne2(), r.exports = t2;
          function t2(s) {
            return String(s).replace(/\s+/g, " ");
          }
        } }), Io = te2({ "src/language-markdown/loc.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r.exports = { locStart: t2, locEnd: s };
        } }), og = te2({ "src/language-markdown/constants.evaluate.js"(e, r) {
          r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), iu = te2({ "src/language-markdown/utils.js"(e, r) {
          "use strict";
          ne2();
          var { getLast: t2 } = Ue2(), { locStart: s, locEnd: a } = Io(), { cjkPattern: n2, kPattern: u, punctuationPattern: i2 } = og(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h = new RegExp(i2);
          function g2(E, N2) {
            let x2 = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", D = [], T = (N2.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n2})
(${n2})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [C2, o] of T.entries()) {
              if (C2 % 2 === 1) {
                D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                continue;
              }
              if ((C2 === 0 || C2 === T.length - 1) && o === "")
                continue;
              let d2 = o.split(new RegExp(`(${n2})`));
              for (let [v2, S] of d2.entries())
                if (!((v2 === 0 || v2 === d2.length - 1) && S === "")) {
                  if (v2 % 2 === 0) {
                    S !== "" && m({ type: "word", value: S, kind: x2, hasLeadingPunctuation: h.test(S[0]), hasTrailingPunctuation: h.test(t2(S)) });
                    continue;
                  }
                  m(h.test(S) ? { type: "word", value: S, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return D;
            function m(C2) {
              let o = t2(D);
              o && o.type === "word" && (o.kind === x2 && C2.kind === I && !o.hasTrailingPunctuation || o.kind === I && C2.kind === x2 && !C2.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d2(x2, $) && ![o.value, C2.value].some((v2) => /\u3000/.test(v2)) && D.push({ type: "whitespace", value: "" })), D.push(C2);
              function d2(v2, S) {
                return o.kind === v2 && C2.kind === S || o.kind === S && C2.kind === v2;
              }
            }
          }
          function c(E, N2) {
            let [, x2, I, P] = N2.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: x2, marker: I, leadingSpaces: P };
          }
          function f2(E, N2) {
            if (!E.ordered || E.children.length < 2)
              return false;
            let x2 = Number(c(E.children[0], N2.originalText).numberText), I = Number(c(E.children[1], N2.originalText).numberText);
            if (x2 === 0 && E.children.length > 2) {
              let P = Number(c(E.children[2], N2.originalText).numberText);
              return I === 1 && P === 1;
            }
            return I === 1;
          }
          function F2(E, N2) {
            let { value: x2 } = E;
            return E.position.end.offset === N2.length && x2.endsWith(`
`) && N2.endsWith(`
`) ? x2.slice(0, -1) : x2;
          }
          function _(E, N2) {
            return function x2(I, P, $) {
              let D = Object.assign({}, N2(I, P, $));
              return D.children && (D.children = D.children.map((T, m) => x2(T, m, [D, ...$]))), D;
            }(E, null, []);
          }
          function w2(E) {
            if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1)
              return false;
            let [N2] = E.children;
            return s(E) === s(N2) && a(E) === a(N2);
          }
          r.exports = { mapAst: _, splitText: g2, punctuationPattern: i2, getFencedCodeBlockValue: F2, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f2, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w2 };
        } }), lg = te2({ "src/language-markdown/embed.js"(e, r) {
          "use strict";
          ne2();
          var { inferParserByLanguage: t2, getMaxContinuousCount: s } = Ue2(), { builders: { hardline: a, markAsRoot: n2 }, utils: { replaceEndOfLine: u } } = qe(), i2 = su(), { getFencedCodeBlockValue: l } = iu();
          function p(y, h, g2, c) {
            let f2 = y.getValue();
            if (f2.type === "code" && f2.lang !== null) {
              let F2 = t2(f2.lang, c);
              if (F2) {
                let _ = c.__inJsTemplate ? "~" : "`", w2 = _.repeat(Math.max(3, s(f2.value, _) + 1)), E = { parser: F2 };
                f2.lang === "tsx" && (E.filepath = "dummy.tsx");
                let N2 = g2(l(f2, c.originalText), E, { stripTrailingHardline: true });
                return n2([w2, f2.lang, f2.meta ? " " + f2.meta : "", a, u(N2), a, w2]);
              }
            }
            switch (f2.type) {
              case "front-matter":
                return i2(f2, g2);
              case "importExport":
                return [g2(f2.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
              case "jsx":
                return g2(`<$>${f2.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          r.exports = p;
        } }), ko = te2({ "src/language-markdown/pragma.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _o(), s = ["format", "prettier"];
          function a(n2) {
            let u = `@(${s.join("|")})`, i2 = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n2.match(i2);
            return (l == null ? void 0 : l.index) === 0;
          }
          r.exports = { startWithPragma: a, hasPragma: (n2) => a(t2(n2).content.trimStart()), insertPragma: (n2) => {
            let u = t2(n2), i2 = `<!-- @${s[0]} -->`;
            return u.frontMatter ? `${u.frontMatter.raw}

${i2}

${u.content}` : `${i2}

${u.content}`;
          } };
        } }), cg = te2({ "src/language-markdown/print-preprocess.js"(e, r) {
          "use strict";
          ne2();
          var t2 = lt2(), { getOrderedListItemInfo: s, mapAst: a, splitText: n2 } = iu(), u = /^.$/su;
          function i2(w2, E) {
            return w2 = y(w2, E), w2 = c(w2), w2 = p(w2, E), w2 = F2(w2, E), w2 = _(w2, E), w2 = f2(w2, E), w2 = l(w2), w2 = h(w2), w2;
          }
          function l(w2) {
            return a(w2, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
          }
          function p(w2, E) {
            return a(w2, (N2) => N2.type !== "inlineCode" || E.proseWrap === "preserve" ? N2 : Object.assign(Object.assign({}, N2), {}, { value: N2.value.replace(/\s+/g, " ") }));
          }
          function y(w2, E) {
            return a(w2, (N2) => N2.type !== "text" || N2.value === "*" || N2.value === "_" || !u.test(N2.value) || N2.position.end.offset - N2.position.start.offset === N2.value.length ? N2 : Object.assign(Object.assign({}, N2), {}, { value: E.originalText.slice(N2.position.start.offset, N2.position.end.offset) }));
          }
          function h(w2) {
            return g2(w2, (E, N2) => E.type === "importExport" && N2.type === "importExport", (E, N2) => ({ type: "importExport", value: E.value + `

` + N2.value, position: { start: E.position.start, end: N2.position.end } }));
          }
          function g2(w2, E, N2) {
            return a(w2, (x2) => {
              if (!x2.children)
                return x2;
              let I = x2.children.reduce((P, $) => {
                let D = t2(P);
                return D && E(D, $) ? P.splice(-1, 1, N2(D, $)) : P.push($), P;
              }, []);
              return Object.assign(Object.assign({}, x2), {}, { children: I });
            });
          }
          function c(w2) {
            return g2(w2, (E, N2) => E.type === "text" && N2.type === "text", (E, N2) => ({ type: "text", value: E.value + N2.value, position: { start: E.position.start, end: N2.position.end } }));
          }
          function f2(w2, E) {
            return a(w2, (N2, x2, I) => {
              let [P] = I;
              if (N2.type !== "text")
                return N2;
              let { value: $ } = N2;
              return P.type === "paragraph" && (x2 === 0 && ($ = $.trimStart()), x2 === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: N2.position, children: n2($, E) };
            });
          }
          function F2(w2, E) {
            return a(w2, (N2, x2, I) => {
              if (N2.type === "code") {
                let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N2.position.start.offset, N2.position.end.offset));
                if (N2.isIndented = P, P)
                  for (let $ = 0; $ < I.length; $++) {
                    let D = I[$];
                    if (D.hasIndentedCodeblock)
                      break;
                    D.type === "list" && (D.hasIndentedCodeblock = true);
                  }
              }
              return N2;
            });
          }
          function _(w2, E) {
            return a(w2, (I, P, $) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let D = 0; D < $.length; D++) {
                  let T = $[D];
                  if (T.type === "list" && !T.isAligned)
                    return I.isAligned = false, I;
                }
                I.isAligned = x2(I);
              }
              return I;
            });
            function N2(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            function x2(I) {
              if (!I.ordered)
                return true;
              let [P, $] = I.children;
              if (s(P, E.originalText).leadingSpaces.length > 1)
                return true;
              let T = N2(P);
              if (T === -1)
                return false;
              if (I.children.length === 1)
                return T % E.tabWidth === 0;
              let m = N2($);
              return T !== m ? false : T % E.tabWidth === 0 ? true : s($, E.originalText).leadingSpaces.length > 1;
            }
          }
          r.exports = i2;
        } }), pg = te2({ "src/language-markdown/clean.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Po(), { isFrontMatterNode: s } = Ue2(), { startWithPragma: a } = ko(), n2 = /* @__PURE__ */ new Set(["position", "raw"]);
          function u(i2, l, p) {
            if ((i2.type === "front-matter" || i2.type === "code" || i2.type === "yaml" || i2.type === "import" || i2.type === "export" || i2.type === "jsx") && delete l.value, i2.type === "list" && delete l.isAligned, (i2.type === "list" || i2.type === "listItem") && (delete l.spread, delete l.loose), i2.type === "text" || (i2.type === "inlineCode" && (l.value = i2.value.replace(/[\t\n ]+/g, " ")), i2.type === "wikiLink" && (l.value = i2.value.trim().replace(/[\t\n]+/g, " ")), (i2.type === "definition" || i2.type === "linkReference" || i2.type === "imageReference") && (l.label = t2(i2.label)), (i2.type === "definition" || i2.type === "link" || i2.type === "image") && i2.title && (l.title = i2.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i2 || s(p.children[0]) && p.children[1] === i2) && i2.type === "html" && a(i2.value)))
              return null;
          }
          u.ignoredProperties = n2, r.exports = u;
        } }), fg = te2({ "src/language-markdown/printer-markdown.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Po(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n2, getStringWidth: u, isNonEmptyArray: i2 } = Ue2(), { builders: { breakParent: l, join: p, line: y, literalline: h, markAsRoot: g2, hardline: c, softline: f2, ifBreak: F2, fill: _, align: w2, indent: E, group: N2, hardlineWithoutBreakParent: x2 }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $ } } = qe(), D = lg(), { insertPragma: T } = ko(), { locStart: m, locEnd: C2 } = Io(), o = cg(), d2 = pg(), { getFencedCodeBlockValue: v2, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = iu(), q2 = /* @__PURE__ */ new Set(["importExport"]), J3 = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function Q2(oe2, H, pe2) {
            let X2 = oe2.getValue();
            if (ge(oe2))
              return b(H.originalText.slice(X2.position.start.offset, X2.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe2, le.value, H));
            switch (X2.type) {
              case "front-matter":
                return H.originalText.slice(X2.position.start.offset, X2.position.end.offset);
              case "root":
                return X2.children.length === 0 ? "" : [I(de2(oe2, H, pe2)), q2.has(z(X2).type) ? "" : c];
              case "paragraph":
                return ue2(oe2, H, pe2, { postprocessor: _ });
              case "sentence":
                return ue2(oe2, H, pe2);
              case "word": {
                let le = X2.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De3, A2, G2, re2, ye) => (G2 ? `${A2}${G2}` : `${re2}${ye}`).replace(/_/g, "\\_")), Ae2 = (De3, A2, G2) => De3.type === "sentence" && G2 === 0, Ee2 = (De3, A2, G2) => R(De3.children[G2 - 1]);
                return le !== X2.value && (oe2.match(void 0, Ae2, Ee2) || oe2.match(void 0, Ae2, (De3, A2, G2) => De3.type === "emphasis" && G2 === 0, Ee2)) && (le = le.replace(/^(\\?[*_])+/, (De3) => De3.replace(/\\/g, ""))), le;
              }
              case "whitespace": {
                let le = oe2.getParentNode(), Ae2 = le.children.indexOf(X2), Ee2 = le.children[Ae2 + 1], De3 = Ee2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee2.value) ? "never" : H.proseWrap;
                return W(oe2, X2.value, { proseWrap: De3 });
              }
              case "emphasis": {
                let le;
                if (R(X2.children[0]))
                  le = H.originalText[X2.position.start.offset];
                else {
                  let Ae2 = oe2.getParentNode(), Ee2 = Ae2.children.indexOf(X2), De3 = Ae2.children[Ee2 - 1], A2 = Ae2.children[Ee2 + 1];
                  le = De3 && De3.type === "sentence" && De3.children.length > 0 && s(De3.children).type === "word" && !s(De3.children).hasTrailingPunctuation || A2 && A2.type === "sentence" && A2.children.length > 0 && A2.children[0].type === "word" && !A2.children[0].hasLeadingPunctuation || ce2(oe2, "emphasis") ? "*" : "_";
                }
                return [le, ue2(oe2, H, pe2), le];
              }
              case "strong":
                return ["**", ue2(oe2, H, pe2), "**"];
              case "delete":
                return ["~~", ue2(oe2, H, pe2), "~~"];
              case "inlineCode": {
                let le = a(X2.value, "`"), Ae2 = "`".repeat(le || 1), Ee2 = le && !/^\s/.test(X2.value) ? " " : "";
                return [Ae2, Ee2, X2.value, Ee2, Ae2];
              }
              case "wikiLink": {
                let le = "";
                return H.proseWrap === "preserve" ? le = X2.value : le = X2.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
              }
              case "link":
                switch (H.originalText[X2.position.start.offset]) {
                  case "<": {
                    let le = "mailto:";
                    return ["<", X2.url.startsWith(le) && H.originalText.slice(X2.position.start.offset + 1, X2.position.start.offset + 1 + le.length) !== le ? X2.url.slice(le.length) : X2.url, ">"];
                  }
                  case "[":
                    return ["[", ue2(oe2, H, pe2), "](", he(X2.url, ")"), we2(X2.title, H), ")"];
                  default:
                    return H.originalText.slice(X2.position.start.offset, X2.position.end.offset);
                }
              case "image":
                return ["![", X2.alt || "", "](", he(X2.url, ")"), we2(X2.title, H), ")"];
              case "blockquote":
                return ["> ", w2("> ", ue2(oe2, H, pe2))];
              case "heading":
                return ["#".repeat(X2.depth) + " ", ue2(oe2, H, pe2)];
              case "code": {
                if (X2.isIndented) {
                  let Ee2 = " ".repeat(4);
                  return w2(Ee2, [Ee2, ...P(X2.value, c)]);
                }
                let le = H.__inJsTemplate ? "~" : "`", Ae2 = le.repeat(Math.max(3, n2(X2.value, le) + 1));
                return [Ae2, X2.lang || "", X2.meta ? " " + X2.meta : "", c, ...P(v2(X2, H.originalText), c), c, Ae2];
              }
              case "html": {
                let le = oe2.getParentNode(), Ae2 = le.type === "root" && s(le.children) === X2 ? X2.value.trimEnd() : X2.value, Ee2 = /^<!--.*-->$/s.test(Ae2);
                return P(Ae2, Ee2 ? c : g2(h));
              }
              case "list": {
                let le = Y3(X2, oe2.getParentNode()), Ae2 = S(X2, H);
                return ue2(oe2, H, pe2, { processor: (Ee2, De3) => {
                  let A2 = re2(), G2 = Ee2.getValue();
                  if (G2.children.length === 2 && G2.children[1].type === "html" && G2.children[0].position.start.column !== G2.children[1].position.start.column)
                    return [A2, V(Ee2, H, pe2, A2)];
                  return [A2, w2(" ".repeat(A2.length), V(Ee2, H, pe2, A2))];
                  function re2() {
                    let ye = X2.ordered ? (De3 === 0 ? X2.start : Ae2 ? 1 : X2.start + De3) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                    return X2.isAligned || X2.hasIndentedCodeblock ? j2(ye, H) : ye;
                  }
                } });
              }
              case "thematicBreak": {
                let le = ee2(oe2, "list");
                return le === -1 ? "---" : Y3(oe2.getParentNode(le), oe2.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue2(oe2, H, pe2), "]", X2.referenceType === "full" ? Ne2(X2) : X2.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (X2.referenceType) {
                  case "full":
                    return ["![", X2.alt || "", "]", Ne2(X2)];
                  default:
                    return ["![", X2.alt, "]", X2.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let le = H.proseWrap === "always" ? y : " ";
                return N2([Ne2(X2), ":", E([le, he(X2.url), X2.title === null ? "" : [le, we2(X2.title, H, false)]])]);
              }
              case "footnote":
                return ["[^", ue2(oe2, H, pe2), "]"];
              case "footnoteReference":
                return Pe2(X2);
              case "footnoteDefinition": {
                let le = oe2.getParentNode().children[oe2.getName() + 1], Ae2 = X2.children.length === 1 && X2.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X2.children[0].position.start.line === X2.children[0].position.end.line);
                return [Pe2(X2), ": ", Ae2 ? ue2(oe2, H, pe2) : N2([w2(" ".repeat(4), ue2(oe2, H, pe2, { processor: (Ee2, De3) => De3 === 0 ? N2([f2, pe2()]) : pe2() })), le && le.type === "footnoteDefinition" ? f2 : ""])];
              }
              case "table":
                return K(oe2, H, pe2);
              case "tableCell":
                return ue2(oe2, H, pe2);
              case "break":
                return /\s/.test(H.originalText[X2.position.start.offset]) ? ["  ", g2(h)] : ["\\", c];
              case "liquidNode":
                return P(X2.value, c);
              case "importExport":
                return [X2.value, c];
              case "esComment":
                return ["{/* ", X2.value, " */}"];
              case "jsx":
                return X2.value;
              case "math":
                return ["$$", c, X2.value ? [...P(X2.value, c), c] : "", "$$"];
              case "inlineMath":
                return H.originalText.slice(m(X2), C2(X2));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(X2.type)}`);
            }
          }
          function V(oe2, H, pe2, X2) {
            let le = oe2.getValue(), Ae2 = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
            return [Ae2, ue2(oe2, H, pe2, { processor: (Ee2, De3) => {
              if (De3 === 0 && Ee2.getValue().type !== "list")
                return w2(" ".repeat(Ae2.length), pe2());
              let A2 = " ".repeat(ke2(H.tabWidth - X2.length, 0, 3));
              return [A2, w2(A2, pe2())];
            } })];
          }
          function j2(oe2, H) {
            let pe2 = X2();
            return oe2 + " ".repeat(pe2 >= 4 ? 0 : pe2);
            function X2() {
              let le = oe2.length % H.tabWidth;
              return le === 0 ? 0 : H.tabWidth - le;
            }
          }
          function Y3(oe2, H) {
            return ie2(oe2, H, (pe2) => pe2.ordered === oe2.ordered);
          }
          function ie2(oe2, H, pe2) {
            let X2 = -1;
            for (let le of H.children)
              if (le.type === oe2.type && pe2(le) ? X2++ : X2 = -1, le === oe2)
                return X2;
          }
          function ee2(oe2, H) {
            let pe2 = Array.isArray(H) ? H : [H], X2 = -1, le;
            for (; le = oe2.getParentNode(++X2); )
              if (pe2.includes(le.type))
                return X2;
            return -1;
          }
          function ce2(oe2, H) {
            let pe2 = ee2(oe2, H);
            return pe2 === -1 ? null : oe2.getParentNode(pe2);
          }
          function W(oe2, H, pe2) {
            if (pe2.proseWrap === "preserve" && H === `
`)
              return c;
            let X2 = pe2.proseWrap === "always" && !ce2(oe2, J3);
            return H !== "" ? X2 ? y : " " : X2 ? f2 : "";
          }
          function K(oe2, H, pe2) {
            let X2 = oe2.getValue(), le = [], Ae2 = oe2.map((ye) => ye.map((Ce2, Be2) => {
              let ve = $(pe2(), H).formatted, ze = u(ve);
              return le[Be2] = Math.max(le[Be2] || 3, ze), { text: ve, width: ze };
            }, "children"), "children"), Ee2 = A2(false);
            if (H.proseWrap !== "never")
              return [l, Ee2];
            let De3 = A2(true);
            return [l, N2(F2(De3, Ee2))];
            function A2(ye) {
              let Ce2 = [re2(Ae2[0], ye), G2(ye)];
              return Ae2.length > 1 && Ce2.push(p(x2, Ae2.slice(1).map((Be2) => re2(Be2, ye)))), p(x2, Ce2);
            }
            function G2(ye) {
              return `| ${le.map((Be2, ve) => {
                let ze = X2.align[ve], be2 = ze === "center" || ze === "left" ? ":" : "-", Ye2 = ze === "center" || ze === "right" ? ":" : "-", Se2 = ye ? "-" : "-".repeat(Be2 - 2);
                return `${be2}${Se2}${Ye2}`;
              }).join(" | ")} |`;
            }
            function re2(ye, Ce2) {
              return `| ${ye.map((ve, ze) => {
                let { text: be2, width: Ye2 } = ve;
                if (Ce2)
                  return be2;
                let Se2 = le[ze] - Ye2, Ie2 = X2.align[ze], Oe2 = 0;
                Ie2 === "right" ? Oe2 = Se2 : Ie2 === "center" && (Oe2 = Math.floor(Se2 / 2));
                let Je2 = Se2 - Oe2;
                return `${" ".repeat(Oe2)}${be2}${" ".repeat(Je2)}`;
              }).join(" | ")} |`;
            }
          }
          function de2(oe2, H, pe2) {
            let X2 = [], le = null, { children: Ae2 } = oe2.getValue();
            for (let [Ee2, De3] of Ae2.entries())
              switch (U2(De3)) {
                case "start":
                  le === null && (le = { index: Ee2, offset: De3.position.end.offset });
                  break;
                case "end":
                  le !== null && (X2.push({ start: le, end: { index: Ee2, offset: De3.position.start.offset } }), le = null);
                  break;
                default:
                  break;
              }
            return ue2(oe2, H, pe2, { processor: (Ee2, De3) => {
              if (X2.length > 0) {
                let A2 = X2[0];
                if (De3 === A2.start.index)
                  return [Fe2(Ae2[A2.start.index]), H.originalText.slice(A2.start.offset, A2.end.offset), Fe2(Ae2[A2.end.index])];
                if (A2.start.index < De3 && De3 < A2.end.index)
                  return false;
                if (De3 === A2.end.index)
                  return X2.shift(), false;
              }
              return pe2();
            } });
          }
          function ue2(oe2, H, pe2) {
            let X2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X2, Ae2 = X2.processor || (() => pe2()), Ee2 = oe2.getValue(), De3 = [], A2;
            return oe2.each((G2, re2) => {
              let ye = G2.getValue(), Ce2 = Ae2(G2, re2);
              if (Ce2 !== false) {
                let Be2 = { parts: De3, prevNode: A2, parentNode: Ee2, options: H };
                Z(ye, Be2) && (De3.push(c), A2 && q2.has(A2.type) || (se(ye, Be2) || fe2(ye, Be2)) && De3.push(c), fe2(ye, Be2) && De3.push(c)), De3.push(Ce2), A2 = ye;
              }
            }, "children"), le ? le(De3) : De3;
          }
          function Fe2(oe2) {
            if (oe2.type === "html")
              return oe2.value;
            if (oe2.type === "paragraph" && Array.isArray(oe2.children) && oe2.children.length === 1 && oe2.children[0].type === "esComment")
              return ["{/* ", oe2.children[0].value, " */}"];
          }
          function z(oe2) {
            let H = oe2;
            for (; i2(H.children); )
              H = s(H.children);
            return H;
          }
          function U2(oe2) {
            let H;
            if (oe2.type === "html")
              H = oe2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let pe2;
              oe2.type === "esComment" ? pe2 = oe2 : oe2.type === "paragraph" && oe2.children.length === 1 && oe2.children[0].type === "esComment" && (pe2 = oe2.children[0]), pe2 && (H = pe2.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return H ? H[1] || "next" : false;
          }
          function Z(oe2, H) {
            let pe2 = H.parts.length === 0, X2 = k.includes(oe2.type), le = oe2.type === "html" && M.includes(H.parentNode.type);
            return !pe2 && !X2 && !le;
          }
          function se(oe2, H) {
            var pe2, X2, le;
            let Ee2 = (H.prevNode && H.prevNode.type) === oe2.type && L.has(oe2.type), De3 = H.parentNode.type === "listItem" && !H.parentNode.loose, A2 = ((pe2 = H.prevNode) === null || pe2 === void 0 ? void 0 : pe2.type) === "listItem" && H.prevNode.loose, G2 = U2(H.prevNode) === "next", re2 = oe2.type === "html" && ((X2 = H.prevNode) === null || X2 === void 0 ? void 0 : X2.type) === "html" && H.prevNode.position.end.line + 1 === oe2.position.start.line, ye = oe2.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe2.position.start.line;
            return A2 || !(Ee2 || De3 || G2 || re2 || ye);
          }
          function fe2(oe2, H) {
            let pe2 = H.prevNode && H.prevNode.type === "list", X2 = oe2.type === "code" && oe2.isIndented;
            return pe2 && X2;
          }
          function ge(oe2) {
            let H = ce2(oe2, ["linkReference", "imageReference"]);
            return H && (H.type !== "linkReference" || H.referenceType !== "full");
          }
          function he(oe2) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe2 = [" ", ...Array.isArray(H) ? H : [H]];
            return new RegExp(pe2.map((X2) => `\\${X2}`).join("|")).test(oe2) ? `<${oe2}>` : oe2;
          }
          function we2(oe2, H) {
            let pe2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!oe2)
              return "";
            if (pe2)
              return " " + we2(oe2, H, false);
            if (oe2 = oe2.replace(/\\(["')])/g, "$1"), oe2.includes('"') && oe2.includes("'") && !oe2.includes(")"))
              return `(${oe2})`;
            let X2 = oe2.split("'").length - 1, le = oe2.split('"').length - 1, Ae2 = X2 > le ? '"' : le > X2 || H.singleQuote ? "'" : '"';
            return oe2 = oe2.replace(/\\/, "\\\\"), oe2 = oe2.replace(new RegExp(`(${Ae2})`, "g"), "\\$1"), `${Ae2}${oe2}${Ae2}`;
          }
          function ke2(oe2, H, pe2) {
            return oe2 < H ? H : oe2 > pe2 ? pe2 : oe2;
          }
          function Re2(oe2) {
            let H = Number(oe2.getName());
            if (H === 0)
              return false;
            let pe2 = oe2.getParentNode().children[H - 1];
            return U2(pe2) === "next";
          }
          function Ne2(oe2) {
            return `[${t2(oe2.label)}]`;
          }
          function Pe2(oe2) {
            return `[^${oe2.label}]`;
          }
          r.exports = { preprocess: o, print: Q2, embed: D, massageAstNode: d2, hasPrettierIgnore: Re2, insertPragma: T };
        } }), Dg = te2({ "src/language-markdown/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Mt();
          r.exports = { proseWrap: t2.proseWrap, singleQuote: t2.singleQuote };
        } }), mg = te2({ "src/language-markdown/parsers.js"() {
          ne2();
        } }), _a = te2({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
          r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), dg = te2({ "src/language-markdown/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = fg(), a = Dg(), n2 = mg(), u = [t2(_a(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t2(_a(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i2 = { mdast: s };
          r.exports = { languages: u, options: a, printers: i2, parsers: n2 };
        } }), gg = te2({ "src/language-html/clean.js"(e, r) {
          "use strict";
          ne2();
          var { isFrontMatterNode: t2 } = Ue2(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(n2, u) {
            if (n2.type === "text" || n2.type === "comment" || t2(n2) || n2.type === "yaml" || n2.type === "toml")
              return null;
            n2.type === "attribute" && delete u.value, n2.type === "docType" && delete u.value;
          }
          a.ignoredProperties = s, r.exports = a;
        } }), yg = te2({ "src/language-html/constants.evaluate.js"(e, r) {
          r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), hg = te2({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
          "use strict";
          ne2();
          function t2(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          r.exports = t2;
        } }), Rt = te2({ "src/language-html/utils/index.js"(e, r) {
          "use strict";
          ne2();
          var { inferParserByLanguage: t2, isFrontMatterNode: s } = Ue2(), { builders: { line: a, hardline: n2, join: u }, utils: { getDocParts: i2, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g2 } = yg(), c = hg(), f2 = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F2 = (A2) => A2.replace(/^[\t\n\f\r ]+/, ""), _ = (A2) => A2.replace(/[\t\n\f\r ]+$/, ""), w2 = (A2) => F2(_(A2)), E = (A2) => A2.replace(/^[\t\f\r ]*\n/g, ""), N2 = (A2) => E(_(A2)), x2 = (A2) => A2.split(/[\t\n\f\r ]+/), I = (A2) => A2.match(/^[\t\n\f\r ]*/)[0], P = (A2) => {
            let [, G2, re2, ye] = A2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G2, trailingWhitespace: ye, text: re2 };
          }, $ = (A2) => /[\t\n\f\r ]/.test(A2);
          function D(A2, G2) {
            return !!(A2.type === "ieConditionalComment" && A2.lastChild && !A2.lastChild.isSelfClosing && !A2.lastChild.endSourceSpan || A2.type === "ieConditionalComment" && !A2.complete || se(A2) && A2.children.some((re2) => re2.type !== "text" && re2.type !== "interpolation") || X2(A2, G2) && !o(A2) && A2.type !== "interpolation");
          }
          function T(A2) {
            return A2.type === "attribute" || !A2.parent || !A2.prev ? false : m(A2.prev);
          }
          function m(A2) {
            return A2.type === "comment" && A2.value.trim() === "prettier-ignore";
          }
          function C2(A2) {
            return A2.type === "text" || A2.type === "comment";
          }
          function o(A2) {
            return A2.type === "element" && (A2.fullName === "script" || A2.fullName === "style" || A2.fullName === "svg:style" || c(A2) && (A2.name === "script" || A2.name === "style"));
          }
          function d2(A2) {
            return A2.children && !o(A2);
          }
          function v2(A2) {
            return o(A2) || A2.type === "interpolation" || S(A2);
          }
          function S(A2) {
            return we2(A2).startsWith("pre");
          }
          function b(A2, G2) {
            let re2 = ye();
            if (re2 && !A2.prev && A2.parent && A2.parent.tagDefinition && A2.parent.tagDefinition.ignoreFirstLf)
              return A2.type === "interpolation";
            return re2;
            function ye() {
              return s(A2) ? false : (A2.type === "text" || A2.type === "interpolation") && A2.prev && (A2.prev.type === "text" || A2.prev.type === "interpolation") ? true : !A2.parent || A2.parent.cssDisplay === "none" ? false : se(A2.parent) ? true : !(!A2.prev && (A2.parent.type === "root" || se(A2) && A2.parent || o(A2.parent) || H(A2.parent, G2) || !ue2(A2.parent.cssDisplay)) || A2.prev && !U2(A2.prev.cssDisplay));
            }
          }
          function B(A2, G2) {
            return s(A2) ? false : (A2.type === "text" || A2.type === "interpolation") && A2.next && (A2.next.type === "text" || A2.next.type === "interpolation") ? true : !A2.parent || A2.parent.cssDisplay === "none" ? false : se(A2.parent) ? true : !(!A2.next && (A2.parent.type === "root" || se(A2) && A2.parent || o(A2.parent) || H(A2.parent, G2) || !Fe2(A2.parent.cssDisplay)) || A2.next && !z(A2.next.cssDisplay));
          }
          function k(A2) {
            return Z(A2.cssDisplay) && !o(A2);
          }
          function M(A2) {
            return s(A2) || A2.next && A2.sourceSpan.end && A2.sourceSpan.end.line + 1 < A2.next.sourceSpan.start.line;
          }
          function R(A2) {
            return q2(A2) || A2.type === "element" && A2.children.length > 0 && (["body", "script", "style"].includes(A2.name) || A2.children.some((G2) => ee2(G2))) || A2.firstChild && A2.firstChild === A2.lastChild && A2.firstChild.type !== "text" && V(A2.firstChild) && (!A2.lastChild.isTrailingSpaceSensitive || j2(A2.lastChild));
          }
          function q2(A2) {
            return A2.type === "element" && A2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A2.name) || A2.cssDisplay.startsWith("table") && A2.cssDisplay !== "table-cell");
          }
          function J3(A2) {
            return Y3(A2) || A2.prev && L(A2.prev) || Q2(A2);
          }
          function L(A2) {
            return Y3(A2) || A2.type === "element" && A2.fullName === "br" || Q2(A2);
          }
          function Q2(A2) {
            return V(A2) && j2(A2);
          }
          function V(A2) {
            return A2.hasLeadingSpaces && (A2.prev ? A2.prev.sourceSpan.end.line < A2.sourceSpan.start.line : A2.parent.type === "root" || A2.parent.startSourceSpan.end.line < A2.sourceSpan.start.line);
          }
          function j2(A2) {
            return A2.hasTrailingSpaces && (A2.next ? A2.next.sourceSpan.start.line > A2.sourceSpan.end.line : A2.parent.type === "root" || A2.parent.endSourceSpan && A2.parent.endSourceSpan.start.line > A2.sourceSpan.end.line);
          }
          function Y3(A2) {
            switch (A2.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(A2.name);
            }
            return false;
          }
          function ie2(A2) {
            return A2.lastChild ? ie2(A2.lastChild) : A2;
          }
          function ee2(A2) {
            return A2.children && A2.children.some((G2) => G2.type !== "text");
          }
          function ce2(A2) {
            let { type: G2, lang: re2 } = A2.attrMap;
            if (G2 === "module" || G2 === "text/javascript" || G2 === "text/babel" || G2 === "application/javascript" || re2 === "jsx")
              return "babel";
            if (G2 === "application/x-typescript" || re2 === "ts" || re2 === "tsx")
              return "typescript";
            if (G2 === "text/markdown")
              return "markdown";
            if (G2 === "text/html")
              return "html";
            if (G2 && (G2.endsWith("json") || G2.endsWith("importmap")) || G2 === "speculationrules")
              return "json";
            if (G2 === "text/x-handlebars-template")
              return "glimmer";
          }
          function W(A2, G2) {
            let { lang: re2 } = A2.attrMap;
            if (!re2 || re2 === "postcss" || re2 === "css")
              return "css";
            if (re2 === "scss")
              return "scss";
            if (re2 === "less")
              return "less";
            if (re2 === "stylus")
              return t2("stylus", G2);
          }
          function K(A2, G2) {
            if (A2.name === "script" && !A2.attrMap.src)
              return !A2.attrMap.lang && !A2.attrMap.type ? "babel" : ce2(A2);
            if (A2.name === "style")
              return W(A2, G2);
            if (G2 && X2(A2, G2))
              return ce2(A2) || !("src" in A2.attrMap) && t2(A2.attrMap.lang, G2);
          }
          function de2(A2) {
            return A2 === "block" || A2 === "list-item" || A2.startsWith("table");
          }
          function ue2(A2) {
            return !de2(A2) && A2 !== "inline-block";
          }
          function Fe2(A2) {
            return !de2(A2) && A2 !== "inline-block";
          }
          function z(A2) {
            return !de2(A2);
          }
          function U2(A2) {
            return !de2(A2);
          }
          function Z(A2) {
            return !de2(A2) && A2 !== "inline-block";
          }
          function se(A2) {
            return we2(A2).startsWith("pre");
          }
          function fe2(A2, G2) {
            let re2 = 0;
            for (let ye = A2.stack.length - 1; ye >= 0; ye--) {
              let Ce2 = A2.stack[ye];
              Ce2 && typeof Ce2 == "object" && !Array.isArray(Ce2) && G2(Ce2) && re2++;
            }
            return re2;
          }
          function ge(A2, G2) {
            let re2 = A2;
            for (; re2; ) {
              if (G2(re2))
                return true;
              re2 = re2.parent;
            }
            return false;
          }
          function he(A2, G2) {
            if (A2.prev && A2.prev.type === "comment") {
              let ye = A2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (ye)
                return ye[1];
            }
            let re2 = false;
            if (A2.type === "element" && A2.namespace === "svg")
              if (ge(A2, (ye) => ye.fullName === "svg:foreignObject"))
                re2 = true;
              else
                return A2.name === "svg" ? "inline-block" : "block";
            switch (G2.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G2.parser === "vue" && A2.parent && A2.parent.type === "root" ? "block" : A2.type === "element" && (!A2.namespace || re2 || c(A2)) && p[A2.name] || y;
            }
          }
          function we2(A2) {
            return A2.type === "element" && (!A2.namespace || c(A2)) && h[A2.name] || g2;
          }
          function ke2(A2) {
            let G2 = Number.POSITIVE_INFINITY;
            for (let re2 of A2.split(`
`)) {
              if (re2.length === 0)
                continue;
              if (!f2.has(re2[0]))
                return 0;
              let ye = I(re2).length;
              re2.length !== ye && ye < G2 && (G2 = ye);
            }
            return G2 === Number.POSITIVE_INFINITY ? 0 : G2;
          }
          function Re2(A2) {
            let G2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke2(A2);
            return G2 === 0 ? A2 : A2.split(`
`).map((re2) => re2.slice(G2)).join(`
`);
          }
          function Ne2(A2, G2) {
            let re2 = 0;
            for (let ye = 0; ye < A2.length; ye++)
              A2[ye] === G2 && re2++;
            return re2;
          }
          function Pe2(A2) {
            return A2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var oe2 = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function H(A2, G2) {
            return pe2(A2, G2) && !oe2.has(A2.fullName);
          }
          function pe2(A2, G2) {
            return G2.parser === "vue" && A2.type === "element" && A2.parent.type === "root" && A2.fullName.toLowerCase() !== "html";
          }
          function X2(A2, G2) {
            return pe2(A2, G2) && (H(A2, G2) || A2.attrMap.lang && A2.attrMap.lang !== "html");
          }
          function le(A2) {
            let G2 = A2.fullName;
            return G2.charAt(0) === "#" || G2 === "slot-scope" || G2 === "v-slot" || G2.startsWith("v-slot:");
          }
          function Ae2(A2, G2) {
            let re2 = A2.parent;
            if (!pe2(re2, G2))
              return false;
            let ye = re2.fullName, Ce2 = A2.fullName;
            return ye === "script" && Ce2 === "setup" || ye === "style" && Ce2 === "vars";
          }
          function Ee2(A2) {
            let G2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A2.value;
            return A2.parent.isWhitespaceSensitive ? A2.parent.isIndentationSensitive ? l(G2) : l(Re2(N2(G2)), n2) : i2(u(a, x2(G2)));
          }
          function De3(A2, G2) {
            return pe2(A2, G2) && A2.name === "script";
          }
          r.exports = { htmlTrim: w2, htmlTrimPreserveIndentation: N2, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d2, countChars: Ne2, countParents: fe2, dedentString: Re2, forceBreakChildren: q2, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie2, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we2, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X2, isVueScriptTag: De3, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae2, isVueSfcBlock: pe2, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C2, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v2, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J3, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe2, getTextValueParts: Ee2 };
        } }), vg = te2({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function r(i2) {
            return i2 >= e.$TAB && i2 <= e.$SPACE || i2 == e.$NBSP;
          }
          e.isWhitespace = r;
          function t2(i2) {
            return e.$0 <= i2 && i2 <= e.$9;
          }
          e.isDigit = t2;
          function s(i2) {
            return i2 >= e.$a && i2 <= e.$z || i2 >= e.$A && i2 <= e.$Z;
          }
          e.isAsciiLetter = s;
          function a(i2) {
            return i2 >= e.$a && i2 <= e.$f || i2 >= e.$A && i2 <= e.$F || t2(i2);
          }
          e.isAsciiHexDigit = a;
          function n2(i2) {
            return i2 === e.$LF || i2 === e.$CR;
          }
          e.isNewLine = n2;
          function u(i2) {
            return e.$0 <= i2 && i2 <= e.$7;
          }
          e.isOctalDigit = u;
        } }), Cg = te2({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = class {
            constructor(s, a, n2) {
              this.filePath = s, this.name = a, this.members = n2;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          };
          e.StaticSymbol = r;
          var t2 = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, a, n2) {
              n2 = n2 || [];
              let u = n2.length ? `.${n2.join(".")}` : "", i2 = `"${s}".${a}${u}`, l = this.cache.get(i2);
              return l || (l = new r(s, a, n2), this.cache.set(i2, l)), l;
            }
          };
          e.StaticSymbolCache = t2;
        } }), Eg = te2({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = /-+([a-z0-9])/g;
          function t2(o) {
            return o.replace(r, function() {
              for (var d2 = arguments.length, v2 = new Array(d2), S = 0; S < d2; S++)
                v2[S] = arguments[S];
              return v2[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t2;
          function s(o, d2) {
            return n2(o, ":", d2);
          }
          e.splitAtColon = s;
          function a(o, d2) {
            return n2(o, ".", d2);
          }
          e.splitAtPeriod = a;
          function n2(o, d2, v2) {
            let S = o.indexOf(d2);
            return S == -1 ? v2 : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
          }
          function u(o, d2, v2) {
            return Array.isArray(o) ? d2.visitArray(o, v2) : E(o) ? d2.visitStringMap(o, v2) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d2.visitPrimitive(o, v2) : d2.visitOther(o, v2);
          }
          e.visitValue = u;
          function i2(o) {
            return o != null;
          }
          e.isDefined = i2;
          function l(o) {
            return o === void 0 ? null : o;
          }
          e.noUndefined = l;
          var p = class {
            visitArray(o, d2) {
              return o.map((v2) => u(v2, this, d2));
            }
            visitStringMap(o, d2) {
              let v2 = {};
              return Object.keys(o).forEach((S) => {
                v2[S] = u(o[S], this, d2);
              }), v2;
            }
            visitPrimitive(o, d2) {
              return o;
            }
            visitOther(o, d2) {
              return o;
            }
          };
          e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
            if (P(o))
              throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, d2) => P(o) ? o.then(d2) : d2(o), all: (o) => o.some(P) ? Promise.all(o) : o };
          function y(o) {
            throw new Error(`Internal Error: ${o}`);
          }
          e.error = y;
          function h(o, d2) {
            let v2 = Error(o);
            return v2[g2] = true, d2 && (v2[c] = d2), v2;
          }
          e.syntaxError = h;
          var g2 = "ngSyntaxError", c = "ngParseErrors";
          function f2(o) {
            return o[g2];
          }
          e.isSyntaxError = f2;
          function F2(o) {
            return o[c] || [];
          }
          e.getParseErrors = F2;
          function _(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = _;
          var w2 = Object.getPrototypeOf({});
          function E(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w2;
          }
          function N2(o) {
            let d2 = "";
            for (let v2 = 0; v2 < o.length; v2++) {
              let S = o.charCodeAt(v2);
              if (S >= 55296 && S <= 56319 && o.length > v2 + 1) {
                let b = o.charCodeAt(v2 + 1);
                b >= 56320 && b <= 57343 && (v2++, S = (S - 55296 << 10) + b - 56320 + 65536);
              }
              S <= 127 ? d2 += String.fromCharCode(S) : S <= 2047 ? d2 += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d2 += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d2 += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
            }
            return d2;
          }
          e.utf8Encode = N2;
          function x2(o) {
            if (typeof o == "string")
              return o;
            if (o instanceof Array)
              return "[" + o.map(x2).join(", ") + "]";
            if (o == null)
              return "" + o;
            if (o.overriddenName)
              return `${o.overriddenName}`;
            if (o.name)
              return `${o.name}`;
            if (!o.toString)
              return "object";
            let d2 = o.toString();
            if (d2 == null)
              return "" + d2;
            let v2 = d2.indexOf(`
`);
            return v2 === -1 ? d2 : d2.substring(0, v2);
          }
          e.stringify = x2;
          function I(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          e.resolveForwardRef = I;
          function P(o) {
            return !!o && typeof o.then == "function";
          }
          e.isPromise = P;
          var $ = class {
            constructor(o) {
              this.full = o;
              let d2 = o.split(".");
              this.major = d2[0], this.minor = d2[1], this.patch = d2.slice(2).join(".");
            }
          };
          e.Version = $;
          var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C2 = m || D || T;
          e.global = C2;
        } }), Fg = te2({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Cg(), t2 = Eg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(v2) {
            return v2.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a;
          var n2 = 0;
          function u(v2) {
            if (!v2 || !v2.reference)
              return null;
            let S = v2.reference;
            if (S instanceof r.StaticSymbol)
              return S.name;
            if (S.__anonymousType)
              return S.__anonymousType;
            let b = t2.stringify(S);
            return b.indexOf("(") >= 0 ? (b = `anonymous_${n2++}`, S.__anonymousType = b) : b = a(b), b;
          }
          e.identifierName = u;
          function i2(v2) {
            let S = v2.reference;
            return S instanceof r.StaticSymbol ? S.filePath : `./${t2.stringify(S)}`;
          }
          e.identifierModuleUrl = i2;
          function l(v2, S) {
            return `View_${u({ reference: v2 })}_${S}`;
          }
          e.viewClassName = l;
          function p(v2) {
            return `RenderType_${u({ reference: v2 })}`;
          }
          e.rendererTypeName = p;
          function y(v2) {
            return `HostView_${u({ reference: v2 })}`;
          }
          e.hostViewClassName = y;
          function h(v2) {
            return `${u({ reference: v2 })}NgFactory`;
          }
          e.componentFactoryName = h;
          var g2;
          (function(v2) {
            v2[v2.Pipe = 0] = "Pipe", v2[v2.Directive = 1] = "Directive", v2[v2.NgModule = 2] = "NgModule", v2[v2.Injectable = 3] = "Injectable";
          })(g2 = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function c(v2) {
            return v2.value != null ? a(v2.value) : u(v2.identifier);
          }
          e.tokenName = c;
          function f2(v2) {
            return v2.identifier != null ? v2.identifier.reference : v2.value;
          }
          e.tokenReference = f2;
          var F2 = class {
            constructor() {
              let { moduleUrl: v2, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = v2 || null, this.styles = P(S), this.styleUrls = P(b);
            }
          };
          e.CompileStylesheetMetadata = F2;
          var _ = class {
            constructor(v2) {
              let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q2, animations: J3, ngContentSelectors: L, interpolation: Q2, isInline: V, preserveWhitespaces: j2 } = v2;
              if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q2), this.animations = J3 ? D(J3) : [], this.ngContentSelectors = L || [], Q2 && Q2.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Q2, this.isInline = V, this.preserveWhitespaces = j2;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = _;
          var w2 = class {
            static create(v2) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q2, outputs: J3, host: L, providers: Q2, viewProviders: V, queries: j2, guards: Y3, viewQueries: ie2, entryComponents: ee2, template: ce2, componentViewType: W, rendererType: K, componentFactory: de2 } = v2, ue2 = {}, Fe2 = {}, z = {};
              L != null && Object.keys(L).forEach((se) => {
                let fe2 = L[se], ge = se.match(s);
                ge === null ? z[se] = fe2 : ge[1] != null ? Fe2[ge[1]] = fe2 : ge[2] != null && (ue2[ge[2]] = fe2);
              });
              let U2 = {};
              q2 != null && q2.forEach((se) => {
                let fe2 = t2.splitAtColon(se, [se, se]);
                U2[fe2[0]] = fe2[1];
              });
              let Z = {};
              return J3 != null && J3.forEach((se) => {
                let fe2 = t2.splitAtColon(se, [se, se]);
                Z[fe2[0]] = fe2[1];
              }), new w2({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U2, outputs: Z, hostListeners: ue2, hostProperties: Fe2, hostAttributes: z, providers: Q2, viewProviders: V, queries: j2, guards: Y3, viewQueries: ie2, entryComponents: ee2, template: ce2, componentViewType: W, rendererType: K, componentFactory: de2 });
            }
            constructor(v2) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q2, outputs: J3, hostListeners: L, hostProperties: Q2, hostAttributes: V, providers: j2, viewProviders: Y3, queries: ie2, guards: ee2, viewQueries: ce2, entryComponents: W, template: K, componentViewType: de2, rendererType: ue2, componentFactory: Fe2 } = v2;
              this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q2, this.outputs = J3, this.hostListeners = L, this.hostProperties = Q2, this.hostAttributes = V, this.providers = P(j2), this.viewProviders = P(Y3), this.queries = P(ie2), this.guards = ee2, this.viewQueries = P(ce2), this.entryComponents = P(W), this.template = K, this.componentViewType = de2, this.rendererType = ue2, this.componentFactory = Fe2;
            }
            toSummary() {
              return { summaryKind: g2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = w2;
          var E = class {
            constructor(v2) {
              let { type: S, name: b, pure: B } = v2;
              this.type = S, this.name = b, this.pure = !!B;
            }
            toSummary() {
              return { summaryKind: g2.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = E;
          var N2 = class {
          };
          e.CompileShallowModuleMetadata = N2;
          var x2 = class {
            constructor(v2) {
              let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q2, bootstrapComponents: J3, importedModules: L, exportedModules: Q2, schemas: V, transitiveModule: j2, id: Y3 } = v2;
              this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q2), this.bootstrapComponents = P(J3), this.importedModules = P(L), this.exportedModules = P(Q2), this.schemas = P(V), this.id = Y3 || null, this.transitiveModule = j2 || null;
            }
            toSummary() {
              let v2 = this.transitiveModule;
              return { summaryKind: g2.NgModule, type: this.type, entryComponents: v2.entryComponents, providers: v2.providers, modules: v2.modules, exportedDirectives: v2.exportedDirectives, exportedPipes: v2.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = x2;
          var I = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(v2, S) {
              this.providers.push({ provider: v2, module: S });
            }
            addDirective(v2) {
              this.directivesSet.has(v2.reference) || (this.directivesSet.add(v2.reference), this.directives.push(v2));
            }
            addExportedDirective(v2) {
              this.exportedDirectivesSet.has(v2.reference) || (this.exportedDirectivesSet.add(v2.reference), this.exportedDirectives.push(v2));
            }
            addPipe(v2) {
              this.pipesSet.has(v2.reference) || (this.pipesSet.add(v2.reference), this.pipes.push(v2));
            }
            addExportedPipe(v2) {
              this.exportedPipesSet.has(v2.reference) || (this.exportedPipesSet.add(v2.reference), this.exportedPipes.push(v2));
            }
            addModule(v2) {
              this.modulesSet.has(v2.reference) || (this.modulesSet.add(v2.reference), this.modules.push(v2));
            }
            addEntryComponent(v2) {
              this.entryComponentsSet.has(v2.componentType) || (this.entryComponentsSet.add(v2.componentType), this.entryComponents.push(v2));
            }
          };
          e.TransitiveCompileNgModuleMetadata = I;
          function P(v2) {
            return v2 || [];
          }
          var $ = class {
            constructor(v2, S) {
              let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q2 } = S;
              this.token = v2, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q2;
            }
          };
          e.ProviderMeta = $;
          function D(v2) {
            return v2.reduce((S, b) => {
              let B = Array.isArray(b) ? D(b) : b;
              return S.concat(B);
            }, []);
          }
          e.flatten = D;
          function T(v2) {
            return v2.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function m(v2, S, b) {
            let B;
            return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v2)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
          }
          e.templateSourceUrl = m;
          function C2(v2, S) {
            let b = v2.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
            return T(`css/${S}${B}.ngstyle.js`);
          }
          e.sharedStylesheetJitUrl = C2;
          function o(v2) {
            return T(`${u(v2.type)}/module.ngfactory.js`);
          }
          e.ngModuleJitUrl = o;
          function d2(v2, S) {
            return T(`${u(v2)}/${u(S.type)}.ngfactory.js`);
          }
          e.templateJitUrl = d2;
        } }), Ag = te2({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          "use strict";
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = vg(), t2 = Fg(), s = class {
            constructor(y, h, g2, c) {
              this.file = y, this.offset = h, this.line = g2, this.col = c;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y) {
              let h = this.file.content, g2 = h.length, c = this.offset, f2 = this.line, F2 = this.col;
              for (; c > 0 && y < 0; )
                if (c--, y++, h.charCodeAt(c) == r.$LF) {
                  f2--;
                  let w2 = h.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
                  F2 = w2 > 0 ? c - w2 : c;
                } else
                  F2--;
              for (; c < g2 && y > 0; ) {
                let _ = h.charCodeAt(c);
                c++, y--, _ == r.$LF ? (f2++, F2 = 0) : F2++;
              }
              return new s(this.file, c, f2, F2);
            }
            getContext(y, h) {
              let g2 = this.file.content, c = this.offset;
              if (c != null) {
                c > g2.length - 1 && (c = g2.length - 1);
                let f2 = c, F2 = 0, _ = 0;
                for (; F2 < y && c > 0 && (c--, F2++, !(g2[c] == `
` && ++_ == h)); )
                  ;
                for (F2 = 0, _ = 0; F2 < y && f2 < g2.length - 1 && (f2++, F2++, !(g2[f2] == `
` && ++_ == h)); )
                  ;
                return { before: g2.substring(c, this.offset), after: g2.substring(this.offset, f2 + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s;
          var a = class {
            constructor(y, h) {
              this.content = y, this.url = h;
            }
          };
          e.ParseSourceFile = a;
          var n2 = class {
            constructor(y, h) {
              let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y, this.end = h, this.details = g2;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = n2, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n2(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(y) {
            y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i2 = class {
            constructor(y, h) {
              let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = y, this.msg = h, this.level = g2;
            }
            contextualMessage() {
              let y = this.span.start.getContext(100, 3);
              return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
            }
            toString() {
              let y = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y}`;
            }
          };
          e.ParseError = i2;
          function l(y, h) {
            let g2 = t2.identifierModuleUrl(h), c = g2 != null ? `in ${y} ${t2.identifierName(h)} in ${g2}` : `in ${y} ${t2.identifierName(h)}`, f2 = new a("", c);
            return new n2(new s(f2, -1, -1, -1), new s(f2, -1, -1, -1));
          }
          e.typeSourceSpan = l;
          function p(y, h, g2) {
            let c = `in ${y} ${h} in ${g2}`, f2 = new a("", c);
            return new n2(new s(f2, -1, -1, -1), new s(f2, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = p;
        } }), Sg = te2({ "src/language-html/print-preprocess.js"(e, r) {
          "use strict";
          ne2();
          var { ParseSourceSpan: t2 } = Ag(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n2, canHaveInterpolation: u, getNodeCssStyleDisplay: i2, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g2, isVueScriptTag: c } = Rt(), f2 = [_, w2, N2, I, P, T, $, D, m, x2, C2];
          function F2(o, d2) {
            for (let v2 of f2)
              v2(o, d2);
            return o;
          }
          function _(o) {
            o.walk((d2) => {
              if (d2.type === "element" && d2.tagDefinition.ignoreFirstLf && d2.children.length > 0 && d2.children[0].type === "text" && d2.children[0].value[0] === `
`) {
                let v2 = d2.children[0];
                v2.value.length === 1 ? d2.removeChild(v2) : v2.value = v2.value.slice(1);
              }
            });
          }
          function w2(o) {
            let d2 = (v2) => v2.type === "element" && v2.prev && v2.prev.type === "ieConditionalStartComment" && v2.prev.sourceSpan.end.offset === v2.startSourceSpan.start.offset && v2.firstChild && v2.firstChild.type === "ieConditionalEndComment" && v2.firstChild.sourceSpan.start.offset === v2.startSourceSpan.end.offset;
            o.walk((v2) => {
              if (v2.children)
                for (let S = 0; S < v2.children.length; S++) {
                  let b = v2.children[S];
                  if (!d2(b))
                    continue;
                  let B = b.prev, k = b.firstChild;
                  v2.removeChild(B), S--;
                  let M = new t2(B.sourceSpan.start, k.sourceSpan.end), R = new t2(M.start, b.sourceSpan.end);
                  b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
                }
            });
          }
          function E(o, d2, v2) {
            o.walk((S) => {
              if (S.children)
                for (let b = 0; b < S.children.length; b++) {
                  let B = S.children[b];
                  if (B.type !== "text" && !d2(B))
                    continue;
                  B.type !== "text" && (B.type = "text", B.value = v2(B));
                  let k = B.prev;
                  !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t2(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
                }
            });
          }
          function N2(o) {
            return E(o, (d2) => d2.type === "cdata", (d2) => `<![CDATA[${d2.value}]]>`);
          }
          function x2(o) {
            let d2 = (v2) => v2.type === "element" && v2.attrs.length === 0 && v2.children.length === 1 && v2.firstChild.type === "text" && !n2(v2.children[0].value) && !v2.firstChild.hasLeadingSpaces && !v2.firstChild.hasTrailingSpaces && v2.isLeadingSpaceSensitive && !v2.hasLeadingSpaces && v2.isTrailingSpaceSensitive && !v2.hasTrailingSpaces && v2.prev && v2.prev.type === "text" && v2.next && v2.next.type === "text";
            o.walk((v2) => {
              if (v2.children)
                for (let S = 0; S < v2.children.length; S++) {
                  let b = v2.children[S];
                  if (!d2(b))
                    continue;
                  let B = b.prev, k = b.next;
                  B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t2(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v2.removeChild(b), S--, v2.removeChild(k);
                }
            });
          }
          function I(o, d2) {
            if (d2.parser === "html")
              return;
            let v2 = /{{(.+?)}}/s;
            o.walk((S) => {
              if (u(S))
                for (let b of S.children) {
                  if (b.type !== "text")
                    continue;
                  let B = b.sourceSpan.start, k = null, M = b.value.split(v2);
                  for (let R = 0; R < M.length; R++, B = k) {
                    let q2 = M[R];
                    if (R % 2 === 0) {
                      k = B.moveBy(q2.length), q2.length > 0 && S.insertChildBefore(b, { type: "text", value: q2, sourceSpan: new t2(B, k) });
                      continue;
                    }
                    k = B.moveBy(q2.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t2(B, k), children: q2.length === 0 ? [] : [{ type: "text", value: q2, sourceSpan: new t2(B.moveBy(2), k.moveBy(-2)) }] });
                  }
                  S.removeChild(b);
                }
            });
          }
          function P(o) {
            o.walk((d2) => {
              if (!d2.children)
                return;
              if (d2.children.length === 0 || d2.children.length === 1 && d2.children[0].type === "text" && s(d2.children[0].value).length === 0) {
                d2.hasDanglingSpaces = d2.children.length > 0, d2.children = [];
                return;
              }
              let v2 = g2(d2), S = p(d2);
              if (!v2)
                for (let b = 0; b < d2.children.length; b++) {
                  let B = d2.children[b];
                  if (B.type !== "text")
                    continue;
                  let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a(B.value), q2 = B.prev, J3 = B.next;
                  M ? (B.value = M, B.sourceSpan = new t2(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q2 && (q2.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J3 && (J3.hasLeadingSpaces = true))) : (d2.removeChild(B), b--, (k || R) && (q2 && (q2.hasTrailingSpaces = true), J3 && (J3.hasLeadingSpaces = true)));
                }
              d2.isWhitespaceSensitive = v2, d2.isIndentationSensitive = S;
            });
          }
          function $(o) {
            o.walk((d2) => {
              d2.isSelfClosing = !d2.children || d2.type === "element" && (d2.tagDefinition.isVoid || d2.startSourceSpan === d2.endSourceSpan);
            });
          }
          function D(o, d2) {
            o.walk((v2) => {
              v2.type === "element" && (v2.hasHtmComponentClosingTag = v2.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d2.originalText.slice(v2.endSourceSpan.start.offset, v2.endSourceSpan.end.offset)));
            });
          }
          function T(o, d2) {
            o.walk((v2) => {
              v2.cssDisplay = i2(v2, d2);
            });
          }
          function m(o, d2) {
            o.walk((v2) => {
              let { children: S } = v2;
              if (S) {
                if (S.length === 0) {
                  v2.isDanglingSpaceSensitive = l(v2);
                  return;
                }
                for (let b of S)
                  b.isLeadingSpaceSensitive = y(b, d2), b.isTrailingSpaceSensitive = h(b, d2);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function C2(o, d2) {
            if (d2.parser === "vue") {
              let v2 = o.children.find((b) => c(b, d2));
              if (!v2)
                return;
              let { lang: S } = v2.attrMap;
              (S === "ts" || S === "typescript") && (d2.__should_parse_vue_template_with_ts = true);
            }
          }
          r.exports = F2;
        } }), xg = te2({ "src/language-html/pragma.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          function s(a) {
            return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
          }
          r.exports = { hasPragma: t2, insertPragma: s };
        } }), au = te2({ "src/language-html/loc.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return a.sourceSpan.start.offset;
          }
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          r.exports = { locStart: t2, locEnd: s };
        } }), ur2 = te2({ "src/language-html/print/tag.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Zt(), { isNonEmptyArray: s } = Ue2(), { builders: { indent: a, join: n2, line: u, softline: i2, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: y, locEnd: h } = au(), { isTextLikeNode: g2, getLastDescendant: c, isPreLikeNode: f2, hasPrettierIgnore: F2, shouldPreserveContent: _, isVueSfcBlock: w2 } = Rt();
          function E(L, Q2) {
            return [L.isSelfClosing ? "" : N2(L, Q2), x2(L, Q2)];
          }
          function N2(L, Q2) {
            return L.lastChild && o(L.lastChild) ? "" : [I(L, Q2), $(L, Q2)];
          }
          function x2(L, Q2) {
            return (L.next ? m(L.next) : C2(L.parent)) ? "" : [D(L, Q2), P(L, Q2)];
          }
          function I(L, Q2) {
            return C2(L) ? D(L.lastChild, Q2) : "";
          }
          function P(L, Q2) {
            return o(L) ? $(L.parent, Q2) : d2(L) ? q2(L.next) : "";
          }
          function $(L, Q2) {
            if (t2(!L.isSelfClosing), T(L, Q2))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return `</${L.rawName}`;
            }
          }
          function D(L, Q2) {
            if (T(L, Q2))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          function T(L, Q2) {
            return !L.isSelfClosing && !L.endSourceSpan && (F2(L) || _(L.parent, Q2));
          }
          function m(L) {
            return L.prev && L.prev.type !== "docType" && !g2(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function C2(L) {
            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g2(c(L.lastChild)) && !f2(L);
          }
          function o(L) {
            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g2(c(L));
          }
          function d2(L) {
            return L.next && !g2(L.next) && g2(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
          }
          function v2(L) {
            let Q2 = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Q2 ? Q2[1] ? Q2[1].split(/\s+/) : true : false;
          }
          function S(L) {
            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function b(L, Q2, V) {
            let j2 = L.getValue();
            if (!s(j2.attrs))
              return j2.isSelfClosing ? " " : "";
            let Y3 = j2.prev && j2.prev.type === "comment" && v2(j2.prev.value), ie2 = typeof Y3 == "boolean" ? () => Y3 : Array.isArray(Y3) ? (ue2) => Y3.includes(ue2.rawName) : () => false, ee2 = L.map((ue2) => {
              let Fe2 = ue2.getValue();
              return ie2(Fe2) ? p(Q2.originalText.slice(y(Fe2), h(Fe2))) : V();
            }, "attrs"), ce2 = j2.type === "element" && j2.fullName === "script" && j2.attrs.length === 1 && j2.attrs[0].fullName === "src" && j2.children.length === 0, K = Q2.singleAttributePerLine && j2.attrs.length > 1 && !w2(j2, Q2) ? l : u, de2 = [a([ce2 ? " " : u, n2(K, ee2)])];
            return j2.firstChild && S(j2.firstChild) || j2.isSelfClosing && C2(j2.parent) || ce2 ? de2.push(j2.isSelfClosing ? " " : "") : de2.push(Q2.bracketSameLine ? j2.isSelfClosing ? " " : "" : j2.isSelfClosing ? u : i2), de2;
          }
          function B(L) {
            return L.firstChild && S(L.firstChild) ? "" : J3(L);
          }
          function k(L, Q2, V) {
            let j2 = L.getValue();
            return [M(j2, Q2), b(L, Q2, V), j2.isSelfClosing ? "" : B(j2)];
          }
          function M(L, Q2) {
            return L.prev && d2(L.prev) ? "" : [R(L, Q2), q2(L)];
          }
          function R(L, Q2) {
            return S(L) ? J3(L.parent) : m(L) ? D(L.prev, Q2) : "";
          }
          function q2(L) {
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L.condition)
                  return `<!--[if ${L.condition}]><!--><${L.rawName}`;
              default:
                return `<${L.rawName}`;
            }
          }
          function J3(L) {
            switch (t2(!L.isSelfClosing), L.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          r.exports = { printClosingTag: E, printClosingTagStart: N2, printClosingTagStartMarker: $, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x2, needsToBorrowLastChildClosingTagEndMarker: C2, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q2, printOpeningTagEndMarker: J3, needsToBorrowNextOpeningTagStartMarker: d2, needsToBorrowParentOpeningTagEndMarker: S };
        } }), bg = te2({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
          ne2(), function(t2, s) {
            typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t2.parseSrcset = s();
          }(e, function() {
            return function(t2, s) {
              var a = s && s.logger || console;
              function n2($) {
                return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
              }
              function u($) {
                var D, T = $.exec(t2.substring(N2));
                if (T)
                  return D = T[0], N2 += D.length, D;
              }
              for (var i2 = t2.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g2 = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f2, F2, _, w2, E, N2 = 0, x2 = []; ; ) {
                if (u(p), N2 >= i2)
                  return x2;
                f2 = u(y), F2 = [], f2.slice(-1) === "," ? (f2 = f2.replace(h, ""), P()) : I();
              }
              function I() {
                for (u(l), _ = "", w2 = "in descriptor"; ; ) {
                  if (E = t2.charAt(N2), w2 === "in descriptor")
                    if (n2(E))
                      _ && (F2.push(_), _ = "", w2 = "after descriptor");
                    else if (E === ",") {
                      N2 += 1, _ && F2.push(_), P();
                      return;
                    } else if (E === "(")
                      _ = _ + E, w2 = "in parens";
                    else if (E === "") {
                      _ && F2.push(_), P();
                      return;
                    } else
                      _ = _ + E;
                  else if (w2 === "in parens")
                    if (E === ")")
                      _ = _ + E, w2 = "in descriptor";
                    else if (E === "") {
                      F2.push(_), P();
                      return;
                    } else
                      _ = _ + E;
                  else if (w2 === "after descriptor" && !n2(E))
                    if (E === "") {
                      P();
                      return;
                    } else
                      w2 = "in descriptor", N2 -= 1;
                  N2 += 1;
                }
              }
              function P() {
                var $ = false, D, T, m, C2, o = {}, d2, v2, S, b, B;
                for (C2 = 0; C2 < F2.length; C2++)
                  d2 = F2[C2], v2 = d2[d2.length - 1], S = d2.substring(0, d2.length - 1), b = parseInt(S, 10), B = parseFloat(S), g2.test(S) && v2 === "w" ? ((D || T) && ($ = true), b === 0 ? $ = true : D = b) : c.test(S) && v2 === "x" ? ((D || T || m) && ($ = true), B < 0 ? $ = true : T = B) : g2.test(S) && v2 === "h" ? ((m || T) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                $ ? a && a.error && a.error("Invalid srcset descriptor found in '" + t2 + "' at '" + d2 + "'.") : (o.url = f2, D && (o.w = D), T && (o.d = T), m && (o.h = m), x2.push(o));
              }
            };
          });
        } }), Tg = te2({ "src/language-html/syntax-attribute.js"(e, r) {
          "use strict";
          ne2();
          var t2 = bg(), { builders: { ifBreak: s, join: a, line: n2 } } = qe();
          function u(l) {
            let p = t2(l, { logger: { error(I) {
              throw new Error(I);
            } } }), y = p.some((I) => {
              let { w: P } = I;
              return P;
            }), h = p.some((I) => {
              let { h: P } = I;
              return P;
            }), g2 = p.some((I) => {
              let { d: P } = I;
              return P;
            });
            if (y + h + g2 > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let c = y ? "w" : h ? "h" : "d", f2 = y ? "w" : h ? "h" : "x", F2 = (I) => Math.max(...I), _ = p.map((I) => I.url), w2 = F2(_.map((I) => I.length)), E = p.map((I) => I[c]).map((I) => I ? I.toString() : ""), N2 = E.map((I) => {
              let P = I.indexOf(".");
              return P === -1 ? I.length : P;
            }), x2 = F2(N2);
            return a([",", n2], _.map((I, P) => {
              let $ = [I], D = E[P];
              if (D) {
                let T = w2 - I.length + 1, m = x2 - N2[P], C2 = " ".repeat(T + m);
                $.push(s(C2, " "), D + f2);
              }
              return $;
            }));
          }
          function i2(l) {
            return l.trim().split(/\s+/).join(" ");
          }
          r.exports = { printImgSrcset: u, printClassNames: i2 };
        } }), Bg2 = te2({ "src/language-html/syntax-vue.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { group: t2 } } = qe();
          function s(i2, l) {
            let { left: p, operator: y, right: h } = a(i2);
            return [t2(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a(i2) {
            let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h = i2.match(l);
            if (!h)
              return;
            let g2 = {};
            if (g2.for = h[3].trim(), !g2.for)
              return;
            let c = h[1].trim().replace(y, ""), f2 = c.match(p);
            f2 ? (g2.alias = c.replace(p, ""), g2.iterator1 = f2[1].trim(), f2[2] && (g2.iterator2 = f2[2].trim())) : g2.alias = c;
            let F2 = [g2.alias, g2.iterator1, g2.iterator2];
            if (!F2.some((_, w2) => !_ && (w2 === 0 || F2.slice(w2 + 1).some(Boolean))))
              return { left: F2.filter(Boolean).join(","), operator: h[2], right: g2.for };
          }
          function n2(i2, l) {
            return l(`function _(${i2}) {}`, { parser: "babel", __isVueBindings: true });
          }
          function u(i2) {
            let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i2.trim();
            return l.test(y) || p.test(y);
          }
          r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n2 };
        } }), Lo = te2({ "src/language-html/get-node-content.js"(e, r) {
          "use strict";
          ne2();
          var { needsToBorrowParentClosingTagStartMarker: t2, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n2, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i2 } = ur2();
          function l(p, y) {
            let h = p.startSourceSpan.end.offset;
            p.firstChild && u(p.firstChild) && (h -= i2(p).length);
            let g2 = p.endSourceSpan.start.offset;
            return p.lastChild && t2(p.lastChild) ? g2 += s(p, y).length : a(p) && (g2 -= n2(p.lastChild, y).length), y.originalText.slice(h, g2);
          }
          r.exports = l;
        } }), Ng = te2({ "src/language-html/embed.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { breakParent: t2, group: s, hardline: a, indent: n2, line: u, fill: i2, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y } } = qe(), h = su(), { printClosingTag: g2, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f2, printOpeningTagPrefix: F2, printOpeningTag: _ } = ur2(), { printImgSrcset: w2, printClassNames: E } = Tg(), { printVueFor: N2, printVueBindings: x2, isVueEventBindingExpression: I } = Bg2(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C2, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d2, getTextValueParts: v2 } = Rt(), S = Lo();
          function b(k, M, R) {
            let q2 = (ee2) => new RegExp(ee2.join("|")).test(k.fullName), J3 = () => C2(k.value), L = false, Q2 = (ee2, ce2) => {
              let W = ee2.type === "NGRoot" ? ee2.node.type === "NGMicrosyntax" && ee2.node.body.length === 1 && ee2.node.body[0].type === "NGMicrosyntaxExpression" ? ee2.node.body[0].expression : ee2.node : ee2.type === "JsExpressionRoot" ? ee2.node : ee2;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce2.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
            }, V = (ee2) => s(ee2), j2 = function(ee2) {
              let ce2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s([n2([l, ee2]), ce2 ? l : ""]);
            }, Y3 = (ee2) => L ? V(ee2) : j2(ee2), ie2 = (ee2, ce2) => M(ee2, Object.assign({ __onHtmlBindingRoot: Q2, __embeddedInHtml: true }, ce2));
            if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
              return j2(w2(J3()));
            if (k.fullName === "class" && !R.parentParser) {
              let ee2 = J3();
              if (!ee2.includes("{{"))
                return E(ee2);
            }
            if (k.fullName === "style" && !R.parentParser) {
              let ee2 = J3();
              if (!ee2.includes("{{"))
                return j2(ie2(ee2, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (R.parser === "vue") {
              if (k.fullName === "v-for")
                return N2(J3(), ie2);
              if (o(k) || d2(k, R))
                return x2(J3(), ie2);
              let ee2 = ["^@", "^v-on:"], ce2 = ["^:", "^v-bind:"], W = ["^v-"];
              if (q2(ee2)) {
                let K = J3(), de2 = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Y3(ie2(K, { parser: de2 }));
              }
              if (q2(ce2))
                return Y3(ie2(J3(), { parser: "__vue_expression" }));
              if (q2(W))
                return Y3(ie2(J3(), { parser: "__js_expression" }));
            }
            if (R.parser === "angular") {
              let ee2 = (z, U2) => ie2(z, Object.assign(Object.assign({}, U2), {}, { trailingComma: "none" })), ce2 = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de2 = ["^i18n(-.+)?$"];
              if (q2(W))
                return Y3(ee2(J3(), { parser: "__ng_action" }));
              if (q2(K))
                return Y3(ee2(J3(), { parser: "__ng_binding" }));
              if (q2(de2)) {
                let z = J3().trim();
                return j2(i2(v2(k, z)), !z.includes("@@"));
              }
              if (q2(ce2))
                return Y3(ee2(J3(), { parser: "__ng_directive" }));
              let ue2 = /{{(.+?)}}/s, Fe2 = J3();
              if (ue2.test(Fe2)) {
                let z = [];
                for (let [U2, Z] of Fe2.split(ue2).entries())
                  if (U2 % 2 === 0)
                    z.push(y(Z));
                  else
                    try {
                      z.push(s(["{{", n2([u, ee2(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                    } catch {
                      z.push("{{", y(Z), "}}");
                    }
                return s(z);
              }
            }
            return null;
          }
          function B(k, M, R, q2) {
            let J3 = k.getValue();
            switch (J3.type) {
              case "element": {
                if (P(J3) || J3.type === "interpolation")
                  return;
                if (!J3.isSelfClosing && $(J3, q2)) {
                  let L = D(J3, q2);
                  if (!L)
                    return;
                  let Q2 = S(J3, q2), V = /^\s*$/.test(Q2), j2 = "";
                  return V || (j2 = R(T(Q2), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j2 === ""), [F2(J3, q2), s(_(k, q2, M)), V ? "" : a, j2, V ? "" : a, g2(J3, q2), c(J3, q2)];
                }
                break;
              }
              case "text": {
                if (P(J3.parent)) {
                  let L = D(J3.parent, q2);
                  if (L) {
                    let Q2 = L === "markdown" ? m(J3.value.replace(/^[^\S\n]*\n/, "")) : J3.value, V = { parser: L, __embeddedInHtml: true };
                    if (q2.parser === "html" && L === "babel") {
                      let j2 = "script", { attrMap: Y3 } = J3.parent;
                      Y3 && (Y3.type === "module" || Y3.type === "text/babel" && Y3["data-type"] === "module") && (j2 = "module"), V.__babelSourceType = j2;
                    }
                    return [t2, F2(J3, q2), R(Q2, V, { stripTrailingHardline: true }), c(J3, q2)];
                  }
                } else if (J3.parent.type === "interpolation") {
                  let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q2.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q2.parser === "vue" ? L.parser = q2.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n2([u, R(J3.value, L, { stripTrailingHardline: true })]), J3.parent.next && f2(J3.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!J3.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q2.originalText.slice(J3.valueSpan.start.offset, J3.valueSpan.end.offset)))
                  return [J3.rawName, "=", J3.value];
                if (q2.parser === "lwc" && /^{.*}$/s.test(q2.originalText.slice(J3.valueSpan.start.offset, J3.valueSpan.end.offset)))
                  return [J3.rawName, "=", J3.value];
                let L = b(J3, (Q2, V) => R(Q2, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q2);
                if (L)
                  return [J3.rawName, '="', s(p(L, (Q2) => typeof Q2 == "string" ? Q2.replace(/"/g, "&quot;") : Q2)), '"'];
                break;
              }
              case "front-matter":
                return h(J3, R);
            }
          }
          r.exports = B;
        } }), Oo = te2({ "src/language-html/print/children.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { breakParent: t2, group: s, ifBreak: a, line: n2, softline: u, hardline: i2 }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: y } = au(), { forceBreakChildren: h, forceNextEmptyLine: g2, isTextLikeNode: c, hasPrettierIgnore: f2, preferHardlineAsLeadingSpaces: F2 } = Rt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w2, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N2, printClosingTagEndMarker: x2, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur2();
          function $(m, C2, o) {
            let d2 = m.getValue();
            return f2(d2) ? [_(d2, C2), ...l(C2.originalText.slice(p(d2) + (d2.prev && w2(d2.prev) ? E(d2).length : 0), y(d2) - (d2.next && N2(d2.next) ? x2(d2, C2).length : 0))), I(d2, C2)] : o();
          }
          function D(m, C2) {
            return c(m) && c(C2) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F2(C2) ? i2 : n2 : "" : F2(C2) ? i2 : u : w2(m) && (f2(C2) || C2.firstChild || C2.isSelfClosing || C2.type === "element" && C2.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N2(C2) ? "" : !C2.isLeadingSpaceSensitive || F2(C2) || N2(C2) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i2 : C2.hasLeadingSpaces ? n2 : u;
          }
          function T(m, C2, o) {
            let d2 = m.getValue();
            if (h(d2))
              return [t2, ...m.map((S) => {
                let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
                return [B ? [B, g2(b.prev) ? i2 : ""] : "", $(S, C2, o)];
              }, "children")];
            let v2 = d2.children.map(() => Symbol(""));
            return m.map((S, b) => {
              let B = S.getValue();
              if (c(B)) {
                if (B.prev && c(B.prev)) {
                  let Q2 = D(B.prev, B);
                  if (Q2)
                    return g2(B.prev) ? [i2, i2, $(S, C2, o)] : [Q2, $(S, C2, o)];
                }
                return $(S, C2, o);
              }
              let k = [], M = [], R = [], q2 = [], J3 = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
              return J3 && (g2(B.prev) ? k.push(i2, i2) : J3 === i2 ? k.push(i2) : c(B.prev) ? M.push(J3) : M.push(a("", u, { groupId: v2[b - 1] }))), L && (g2(B) ? c(B.next) && q2.push(i2, i2) : L === i2 ? c(B.next) && q2.push(i2) : R.push(L)), [...k, s([...M, s([$(S, C2, o), ...R], { id: v2[b] })]), ...q2];
            }, "children");
          }
          r.exports = { printChildren: T };
        } }), wg = te2({ "src/language-html/print/element.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { breakParent: t2, dedentToRoot: s, group: a, ifBreak: n2, indentIfBreak: u, indent: i2, line: l, softline: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = Lo(), { shouldPreserveContent: g2, isScriptLikeTag: c, isVueCustomBlock: f2, countParents: F2, forceBreakContent: _ } = Rt(), { printOpeningTagPrefix: w2, printOpeningTag: E, printClosingTagSuffix: N2, printClosingTag: x2, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur2(), { printChildren: $ } = Oo();
          function D(T, m, C2) {
            let o = T.getValue();
            if (g2(o, m))
              return [w2(o, m), a(E(T, m, C2)), ...y(h(o, m)), ...x2(o, m), N2(o, m)];
            let d2 = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v2 = Symbol("element-attr-group-id"), S = (M) => a([a(E(T, m, C2), { id: v2 }), M, x2(o, m)]), b = (M) => d2 ? u(M, { groupId: v2 }) : (c(o) || f2(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i2(M), B = () => d2 ? n2(p, "", { groupId: v2 }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d2 ? n2(p, "", { groupId: v2 }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F2(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
            return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t2 : "", b([B(), $(T, m, C2)]), k()]);
          }
          r.exports = { printElement: D };
        } }), _g = te2({ "src/language-html/printer-html.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { fill: t2, group: s, hardline: a, literalline: n2 }, utils: { cleanDoc: u, getDocParts: i2, isConcat: l, replaceTextEndOfLine: p } } = qe(), y = gg(), { countChars: h, unescapeQuoteEntities: g2, getTextValueParts: c } = Rt(), f2 = Sg(), { insertPragma: F2 } = xg(), { locStart: _, locEnd: w2 } = au(), E = Ng(), { printClosingTagSuffix: N2, printClosingTagEnd: x2, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur2(), { printElement: $ } = wg(), { printChildren: D } = Oo();
          function T(m, C2, o) {
            let d2 = m.getValue();
            switch (d2.type) {
              case "front-matter":
                return p(d2.raw);
              case "root":
                return C2.__onHtmlRoot && C2.__onHtmlRoot(d2), [s(D(m, C2, o)), a];
              case "element":
              case "ieConditionalComment":
                return $(m, C2, o);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P(d2), x2(d2)];
              case "interpolation":
                return [P(d2, C2), ...m.map(o, "children"), x2(d2, C2)];
              case "text": {
                if (d2.parent.type === "interpolation") {
                  let S = /\n[^\S\n]*$/, b = S.test(d2.value), B = b ? d2.value.replace(S, "") : d2.value;
                  return [...p(B), b ? a : ""];
                }
                let v2 = u([I(d2, C2), ...c(d2), N2(d2, C2)]);
                return l(v2) || v2.type === "fill" ? t2(i2(v2)) : v2;
              }
              case "docType":
                return [s([P(d2, C2), " ", d2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x2(d2, C2)];
              case "comment":
                return [I(d2, C2), ...p(C2.originalText.slice(_(d2), w2(d2)), n2), N2(d2, C2)];
              case "attribute": {
                if (d2.value === null)
                  return d2.rawName;
                let v2 = g2(d2.value), S = h(v2, "'"), b = h(v2, '"'), B = S < b ? "'" : '"';
                return [d2.rawName, "=", B, ...p(B === '"' ? v2.replace(/"/g, "&quot;") : v2.replace(/'/g, "&apos;")), B];
              }
              default:
                throw new Error(`Unexpected node type ${d2.type}`);
            }
          }
          r.exports = { preprocess: f2, print: T, insertPragma: F2, massageAstNode: y, embed: E };
        } }), Pg = te2({ "src/language-html/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Mt(), s = "HTML";
          r.exports = { bracketSameLine: t2.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t2.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), Ig = te2({ "src/language-html/parsers.js"() {
          ne2();
        } }), On = te2({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
          r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), kg2 = te2({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
          r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Lg = te2({ "src/language-html/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = _g(), a = Pg(), n2 = Ig(), u = [t2(On(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t2(On(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t2(On(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t2(kg2(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i2 = { html: s };
          r.exports = { languages: u, printers: i2, options: a, parsers: n2 };
        } }), Og = te2({ "src/language-yaml/pragma.js"(e, r) {
          "use strict";
          ne2();
          function t2(n2) {
            return /^\s*@(?:prettier|format)\s*$/.test(n2);
          }
          function s(n2) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n2);
          }
          function a(n2) {
            return `# @format

${n2}`;
          }
          r.exports = { isPragma: t2, hasPragma: s, insertPragma: a };
        } }), jg = te2({ "src/language-yaml/loc.js"(e, r) {
          "use strict";
          ne2();
          function t2(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r.exports = { locStart: t2, locEnd: s };
        } }), qg = te2({ "src/language-yaml/embed.js"(e, r) {
          "use strict";
          ne2();
          function t2(s, a, n2, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
              return n2(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          r.exports = t2;
        } }), $t = te2({ "src/language-yaml/utils.js"(e, r) {
          "use strict";
          ne2();
          var { getLast: t2, isNonEmptyArray: s } = Ue2();
          function a(D, T) {
            let m = 0, C2 = D.stack.length - 1;
            for (let o = 0; o < C2; o++) {
              let d2 = D.stack[o];
              n2(d2) && T(d2) && m++;
            }
            return m;
          }
          function n2(D, T) {
            return D && typeof D.type == "string" && (!T || T.includes(D.type));
          }
          function u(D, T, m) {
            return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C2) => u(C2, T, D)) }) : D, m);
          }
          function i2(D, T, m) {
            Object.defineProperty(D, T, { get: m, enumerable: false });
          }
          function l(D, T) {
            let m = 0, C2 = T.length;
            for (let o = D.position.end.offset - 1; o < C2; o++) {
              let d2 = T[o];
              if (d2 === `
` && m++, m === 1 && /\S/.test(d2))
                return false;
              if (m === 2)
                return true;
            }
            return false;
          }
          function p(D) {
            switch (D.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m = D.stack.length;
            for (let C2 = 1; C2 < m; C2++) {
              let o = D.stack[C2], d2 = D.stack[C2 - 1];
              if (Array.isArray(d2) && typeof o == "number" && o !== d2.length - 1)
                return false;
            }
            return true;
          }
          function y(D) {
            return s(D.children) ? y(t2(D.children)) : D;
          }
          function h(D) {
            return D.value.trim() === "prettier-ignore";
          }
          function g2(D) {
            let T = D.getValue();
            if (T.type === "documentBody") {
              let m = D.getParentNode();
              return N2(m.head) && h(t2(m.head.endComments));
            }
            return F2(T) && h(t2(T.leadingComments));
          }
          function c(D) {
            return !s(D.children) && !f2(D);
          }
          function f2(D) {
            return F2(D) || _(D) || w2(D) || E(D) || N2(D);
          }
          function F2(D) {
            return s(D == null ? void 0 : D.leadingComments);
          }
          function _(D) {
            return s(D == null ? void 0 : D.middleComments);
          }
          function w2(D) {
            return D == null ? void 0 : D.indicatorComment;
          }
          function E(D) {
            return D == null ? void 0 : D.trailingComment;
          }
          function N2(D) {
            return s(D == null ? void 0 : D.endComments);
          }
          function x2(D) {
            let T = [], m;
            for (let C2 of D.split(/( +)/))
              C2 !== " " ? m === " " ? T.push(C2) : T.push((T.pop() || "") + C2) : m === void 0 && T.unshift(""), m = C2;
            return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
          }
          function I(D, T, m) {
            let C2 = T.split(`
`).map((o, d2, v2) => d2 === 0 && d2 === v2.length - 1 ? o : d2 !== 0 && d2 !== v2.length - 1 ? o.trim() : d2 === 0 ? o.trimEnd() : o.trimStart());
            return m.proseWrap === "preserve" ? C2.map((o) => o.length === 0 ? [] : [o]) : C2.map((o) => o.length === 0 ? [] : x2(o)).reduce((o, d2, v2) => v2 !== 0 && C2[v2 - 1].length > 0 && d2.length > 0 && !(D === "quoteDouble" && t2(t2(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t2(o), ...d2]] : [...o, d2], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
          }
          function P(D, T) {
            let { parentIndent: m, isLastDescendant: C2, options: o } = T, d2 = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v2;
            if (D.indent === null) {
              let B = d2.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              v2 = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              v2 = D.indent - 1 + m;
            let S = d2.split(`
`).map((B) => B.slice(v2));
            if (o.proseWrap === "preserve" || D.type === "blockLiteral")
              return b(S.map((B) => B.length === 0 ? [] : [B]));
            return b(S.map((B) => B.length === 0 ? [] : x2(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t2(B)) ? [...B.slice(0, -1), [...t2(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t2(k)) ? [...k.slice(0, -1), t2(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
            function b(B) {
              if (D.chomping === "keep")
                return t2(B).length === 0 ? B.slice(0, -1) : B;
              let k = 0;
              for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
                k++;
              return k === 0 ? B : k >= 2 && !C2 ? B.slice(0, -(k - 1)) : B.slice(0, -k);
            }
          }
          function $(D) {
            if (!D)
              return true;
            switch (D.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          r.exports = { getLast: t2, getAncestorCount: a, isNode: n2, isEmptyNode: c, isInlineNode: $, mapNode: u, defineShortcut: i2, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g2, hasLeadingComments: F2, hasMiddleComments: _, hasIndicatorComment: w2, hasTrailingComment: E, hasEndComments: N2 };
        } }), Mg = te2({ "src/language-yaml/print-preprocess.js"(e, r) {
          "use strict";
          ne2();
          var { defineShortcut: t2, mapNode: s } = $t();
          function a(u) {
            return s(u, n2);
          }
          function n2(u) {
            switch (u.type) {
              case "document":
                t2(u, "head", () => u.children[0]), t2(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t2(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t2(u, "key", () => u.children[0]), t2(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          r.exports = a;
        } }), Mr2 = te2({ "src/language-yaml/print/misc.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { softline: t2, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n2, isNode: u } = $t(), i2 = /* @__PURE__ */ new WeakMap();
          function l(h, g2) {
            let c = h.getValue(), f2 = h.stack[0], F2;
            return i2.has(f2) ? F2 = i2.get(f2) : (F2 = /* @__PURE__ */ new Set(), i2.set(f2, F2)), !F2.has(c.position.end.line) && (F2.add(c.position.end.line), n2(c, g2) && !p(h.getParentNode())) ? t2 : "";
          }
          function p(h) {
            return a(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function y(h, g2) {
            return s(" ".repeat(h), g2);
          }
          r.exports = { alignWithSpaces: y, shouldPrintEndComments: p, printNextEmptyLine: l };
        } }), Rg = te2({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { ifBreak: t2, line: s, softline: a, hardline: n2, join: u } } = qe(), { isEmptyNode: i2, getLast: l, hasEndComments: p } = $t(), { printNextEmptyLine: y, alignWithSpaces: h } = Mr2();
          function g2(f2, F2, _) {
            let w2 = f2.getValue(), E = w2.type === "flowMapping", N2 = E ? "{" : "[", x2 = E ? "}" : "]", I = a;
            E && w2.children.length > 0 && _.bracketSpacing && (I = s);
            let P = l(w2.children), $ = P && P.type === "flowMappingItem" && i2(P.key) && i2(P.value);
            return [N2, h(_.tabWidth, [I, c(f2, F2, _), _.trailingComma === "none" ? "" : t2(","), p(w2) ? [n2, u(n2, f2.map(F2, "endComments"))] : ""]), $ ? "" : I, x2];
          }
          function c(f2, F2, _) {
            let w2 = f2.getValue();
            return f2.map((N2, x2) => [F2(), x2 === w2.children.length - 1 ? "" : [",", s, w2.children[x2].position.start.line !== w2.children[x2 + 1].position.start.line ? y(N2, _.originalText) : ""]], "children");
          }
          r.exports = { printFlowMapping: g2, printFlowSequence: g2 };
        } }), $g = te2({ "src/language-yaml/print/mapping-item.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { conditionalGroup: t2, group: s, hardline: a, ifBreak: n2, join: u, line: i2 } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y, hasEndComments: h, isNode: g2, isEmptyNode: c, isInlineNode: f2 } = $t(), { alignWithSpaces: F2 } = Mr2();
          function _(x2, I, P, $, D) {
            let { key: T, value: m } = x2, C2 = c(T), o = c(m);
            if (C2 && o)
              return ": ";
            let d2 = $("key"), v2 = E(x2) ? " " : "";
            if (o)
              return x2.type === "flowMappingItem" && I.type === "flowMapping" ? d2 : x2.type === "mappingItem" && w2(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d2, v2, ":"] : ["? ", F2(2, d2)];
            let S = $("value");
            if (C2)
              return [": ", F2(2, S)];
            if (l(m) || !f2(T.content))
              return ["? ", F2(2, d2), a, u("", P.map($, "value", "leadingComments").map((q2) => [q2, a])), ": ", F2(2, S)];
            if (N2(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h(T) && !l(m.content) && !p(m.content) && !h(m) && w2(m.content, D))
              return [d2, v2, ": ", S];
            let b = Symbol("mappingKey"), B = s([n2("? "), s(F2(2, d2), { id: b })]), k = [a, ": ", F2(2, S)], M = [v2, ":"];
            l(m.content) || h(m) && m.content && !g2(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f2(m.content) || g2(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i2), M.push(S);
            let R = F2(D.tabWidth, M);
            return w2(T.content, D) && !l(T.content) && !p(T.content) && !h(T) ? t2([[d2, R]]) : t2([[B, n2(k, R, { groupId: b })]]);
          }
          function w2(x2, I) {
            if (!x2)
              return true;
            switch (x2.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve")
              return x2.position.start.line === x2.position.end.line;
            if (/\\$/m.test(I.originalText.slice(x2.position.start.offset, x2.position.end.offset)))
              return false;
            switch (I.proseWrap) {
              case "never":
                return !x2.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(x2.value);
              default:
                return false;
            }
          }
          function E(x2) {
            return x2.key.content && x2.key.content.type === "alias";
          }
          function N2(x2) {
            if (!x2)
              return true;
            switch (x2.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return x2.position.start.line === x2.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          r.exports = _;
        } }), Vg = te2({ "src/language-yaml/print/block.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { dedent: t2, dedentToRoot: s, fill: a, hardline: n2, join: u, line: i2, literalline: l, markAsRoot: p }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h, getBlockValueLineContents: g2, hasIndicatorComment: c, isLastDescendantNode: f2, isNode: F2 } = $t(), { alignWithSpaces: _ } = Mr2();
          function w2(E, N2, x2) {
            let I = E.getValue(), P = h(E, (C2) => F2(C2, ["sequence", "mapping"])), $ = f2(E), D = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c(I) && D.push(" ", N2("indicatorComment"));
            let T = g2(I, { parentIndent: P, isLastDescendant: $, options: x2 }), m = [];
            for (let [C2, o] of T.entries())
              C2 === 0 && m.push(n2), m.push(a(y(u(i2, o)))), C2 !== T.length - 1 ? m.push(o.length === 0 ? n2 : p(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? n2 : l));
            return I.indent === null ? D.push(t2(_(x2.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
          }
          r.exports = w2;
        } }), Wg = te2({ "src/language-yaml/printer-yaml.js"(e, r) {
          "use strict";
          ne2();
          var { builders: { breakParent: t2, fill: s, group: a, hardline: n2, join: u, line: i2, lineSuffix: l, literalline: p }, utils: { getDocParts: y, replaceTextEndOfLine: h } } = qe(), { isPreviousLineEmpty: g2 } = Ue2(), { insertPragma: c, isPragma: f2 } = Og(), { locStart: F2 } = jg(), _ = qg(), { getFlowScalarLineContents: w2, getLastDescendantNode: E, hasLeadingComments: N2, hasMiddleComments: x2, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t(), C2 = Mg(), { alignWithSpaces: o, printNextEmptyLine: d2, shouldPrintEndComments: v2 } = Mr2(), { printFlowMapping: S, printFlowSequence: b } = Rg(), B = $g(), k = Vg();
          function M(j2, Y3, ie2) {
            let ee2 = j2.getValue(), ce2 = [];
            ee2.type !== "mappingValue" && N2(ee2) && ce2.push([u(n2, j2.map(ie2, "leadingComments")), n2]);
            let { tag: W, anchor: K } = ee2;
            W && ce2.push(ie2("tag")), W && K && ce2.push(" "), K && ce2.push(ie2("anchor"));
            let de2 = "";
            T(ee2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j2) && (de2 = d2(j2, Y3.originalText)), (W || K) && (T(ee2, ["sequence", "mapping"]) && !x2(ee2) ? ce2.push(n2) : ce2.push(" ")), x2(ee2) && ce2.push([ee2.middleComments.length === 1 ? "" : n2, u(n2, j2.map(ie2, "middleComments")), n2]);
            let ue2 = j2.getParentNode();
            return $(j2) ? ce2.push(h(Y3.originalText.slice(ee2.position.start.offset, ee2.position.end.offset).trimEnd(), p)) : ce2.push(a(R(ee2, ue2, j2, Y3, ie2))), I(ee2) && !T(ee2, ["document", "documentHead"]) && ce2.push(l([ee2.type === "mappingValue" && !ee2.content ? "" : " ", ue2.type === "mappingKey" && j2.getParentNode(2).type === "mapping" && m(ee2) ? "" : t2, ie2("trailingComment")])), v2(ee2) && ce2.push(o(ee2.type === "sequenceItem" ? 2 : 0, [n2, u(n2, j2.map((Fe2) => [g2(Y3.originalText, Fe2.getValue(), F2) ? n2 : "", ie2()], "endComments"))])), ce2.push(de2), ce2;
          }
          function R(j2, Y3, ie2, ee2, ce2) {
            switch (j2.type) {
              case "root": {
                let { children: W } = j2, K = [];
                ie2.each((ue2, Fe2) => {
                  let z = W[Fe2], U2 = W[Fe2 + 1];
                  Fe2 !== 0 && K.push(n2), K.push(ce2()), J3(z, U2) ? (K.push(n2, "..."), I(z) && K.push(" ", ce2("trailingComment"))) : U2 && !I(U2.head) && K.push(n2, "---");
                }, "children");
                let de2 = E(j2);
                return (!T(de2, ["blockLiteral", "blockFolded"]) || de2.chomping !== "keep") && K.push(n2), K;
              }
              case "document": {
                let W = Y3.children[ie2.getName() + 1], K = [];
                return L(j2, W, Y3, ee2) === "head" && ((j2.head.children.length > 0 || j2.head.endComments.length > 0) && K.push(ce2("head")), I(j2.head) ? K.push(["---", " ", ce2(["head", "trailingComment"])]) : K.push("---")), q2(j2) && K.push(ce2("body")), u(n2, K);
              }
              case "documentHead":
                return u(n2, [...ie2.map(ce2, "children"), ...ie2.map(ce2, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: K } = j2, de2 = "";
                if (W.length > 0 && K.length > 0) {
                  let ue2 = E(j2);
                  T(ue2, ["blockFolded", "blockLiteral"]) ? ue2.chomping !== "keep" && (de2 = [n2, n2]) : de2 = n2;
                }
                return [u(n2, ie2.map(ce2, "children")), de2, u(n2, ie2.map(ce2, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [j2.name, ...j2.parameters])];
              case "comment":
                return ["#", j2.value];
              case "alias":
                return ["*", j2.value];
              case "tag":
                return ee2.originalText.slice(j2.position.start.offset, j2.position.end.offset);
              case "anchor":
                return ["&", j2.value];
              case "plain":
                return Q2(j2.type, ee2.originalText.slice(j2.position.start.offset, j2.position.end.offset), ee2);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", K = '"', de2 = ee2.originalText.slice(j2.position.start.offset + 1, j2.position.end.offset - 1);
                if (j2.type === "quoteSingle" && de2.includes("\\") || j2.type === "quoteDouble" && /\\[^"]/.test(de2)) {
                  let Fe2 = j2.type === "quoteDouble" ? K : W;
                  return [Fe2, Q2(j2.type, de2, ee2), Fe2];
                }
                if (de2.includes(K))
                  return [W, Q2(j2.type, j2.type === "quoteDouble" ? de2.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de2, ee2), W];
                if (de2.includes(W))
                  return [K, Q2(j2.type, j2.type === "quoteSingle" ? de2.replace(/''/g, W) : de2, ee2), K];
                let ue2 = ee2.singleQuote ? W : K;
                return [ue2, Q2(j2.type, de2, ee2), ue2];
              }
              case "blockFolded":
              case "blockLiteral":
                return k(ie2, ce2, ee2);
              case "mapping":
              case "sequence":
                return u(n2, ie2.map(ce2, "children"));
              case "sequenceItem":
                return ["- ", o(2, j2.content ? ce2("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return j2.content ? ce2("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return B(j2, Y3, ie2, ce2, ee2);
              case "flowMapping":
                return S(ie2, ce2, ee2);
              case "flowSequence":
                return b(ie2, ce2, ee2);
              case "flowSequenceItem":
                return ce2("content");
              default:
                throw new Error(`Unexpected node type ${j2.type}`);
            }
          }
          function q2(j2) {
            return j2.body.children.length > 0 || P(j2.body);
          }
          function J3(j2, Y3) {
            return I(j2) || Y3 && (Y3.head.children.length > 0 || P(Y3.head));
          }
          function L(j2, Y3, ie2, ee2) {
            return ie2.children[0] === j2 && /---(?:\s|$)/.test(ee2.originalText.slice(F2(j2), F2(j2) + 4)) || j2.head.children.length > 0 || P(j2.head) || I(j2.head) ? "head" : J3(j2, Y3) ? false : Y3 ? "root" : false;
          }
          function Q2(j2, Y3, ie2) {
            let ee2 = w2(j2, Y3, ie2);
            return u(n2, ee2.map((ce2) => s(y(u(i2, ce2)))));
          }
          function V(j2, Y3) {
            if (T(Y3))
              switch (delete Y3.position, Y3.type) {
                case "comment":
                  if (f2(Y3.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  Y3.type = "quote";
                  break;
              }
          }
          r.exports = { preprocess: C2, embed: _, print: M, massageAstNode: V, insertPragma: c };
        } }), Hg = te2({ "src/language-yaml/options.js"(e, r) {
          "use strict";
          ne2();
          var t2 = Mt();
          r.exports = { bracketSpacing: t2.bracketSpacing, singleQuote: t2.singleQuote, proseWrap: t2.proseWrap };
        } }), Gg = te2({ "src/language-yaml/parsers.js"() {
          ne2();
        } }), Ug = te2({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
          r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Jg = te2({ "src/language-yaml/index.js"(e, r) {
          "use strict";
          ne2();
          var t2 = _t(), s = Wg(), a = Hg(), n2 = Gg(), u = [t2(Ug(), (i2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i2.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n2 };
        } }), zg = te2({ "src/languages.js"(e, r) {
          "use strict";
          ne2(), r.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];
        } });
        ne2();
        var { version: Xg } = Ia(), Ot = Gm2(), { getSupportInfo: Kg } = Xn(), Yg = Um(), Qg = zg(), Zg = qe();
        function Nt(e) {
          let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t2 = arguments.length, s = new Array(t2), a = 0; a < t2; a++)
              s[a] = arguments[a];
            let n2 = s[r] || {}, u = n2.plugins || [];
            return s[r] = Object.assign(Object.assign({}, n2), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
          };
        }
        var jn = Nt(Ot.formatWithCursor);
        jo.exports = { formatWithCursor: jn, format(e, r) {
          return jn(e, r).formatted;
        }, check(e, r) {
          let { formatted: t2 } = jn(e, r);
          return t2 === e;
        }, doc: Zg, getSupportInfo: Nt(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt(Ot.parse), formatAST: Nt(Ot.formatAST), formatDoc: Nt(Ot.formatDoc), printToDoc: Nt(Ot.printToDoc), printDocToString: Nt(Ot.printDocToString) } };
      });
      return e0();
    });
  }
});

// node_modules/prettier/parser-typescript.js
var require_parser_typescript = __commonJS({
  "node_modules/prettier/parser-typescript.js"(exports2, module2) {
    (function(e) {
      if (typeof exports2 == "object" && typeof module2 == "object")
        module2.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var i2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        i2.prettierPlugins = i2.prettierPlugins || {}, i2.prettierPlugins.typescript = e();
      }
    })(function() {
      "use strict";
      var dt = (a, _) => () => (_ || a((_ = { exports: {} }).exports, _), _.exports);
      var Mi = dt((dH, J7) => {
        var Yh = function(a) {
          return a && a.Math == Math && a;
        };
        J7.exports = Yh(typeof globalThis == "object" && globalThis) || Yh(typeof window == "object" && window) || Yh(typeof self == "object" && self) || Yh(typeof global == "object" && global) || function() {
          return this;
        }() || Function("return this")();
      });
      var Ha = dt((mH, F7) => {
        F7.exports = function(a) {
          try {
            return !!a();
          } catch {
            return true;
          }
        };
      });
      var As = dt((hH, B7) => {
        var tq = Ha();
        B7.exports = !tq(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var p6 = dt((gH, q7) => {
        var rq = Ha();
        q7.exports = !rq(function() {
          var a = (function() {
          }).bind();
          return typeof a != "function" || a.hasOwnProperty("prototype");
        });
      });
      var Zh = dt((yH, U7) => {
        var nq = p6(), Qh = Function.prototype.call;
        U7.exports = nq ? Qh.bind(Qh) : function() {
          return Qh.apply(Qh, arguments);
        };
      });
      var H7 = dt((V7) => {
        "use strict";
        var z7 = {}.propertyIsEnumerable, W7 = Object.getOwnPropertyDescriptor, iq = W7 && !z7.call({ 1: 2 }, 1);
        V7.f = iq ? function(_) {
          var v2 = W7(this, _);
          return !!v2 && v2.enumerable;
        } : z7;
      });
      var f6 = dt((bH, G7) => {
        G7.exports = function(a, _) {
          return { enumerable: !(a & 1), configurable: !(a & 2), writable: !(a & 4), value: _ };
        };
      });
      var Ps = dt((TH, X7) => {
        var $7 = p6(), K7 = Function.prototype, d6 = K7.call, aq = $7 && K7.bind.bind(d6, d6);
        X7.exports = $7 ? aq : function(a) {
          return function() {
            return d6.apply(a, arguments);
          };
        };
      });
      var Z7 = dt((SH, Q7) => {
        var Y7 = Ps(), sq = Y7({}.toString), oq = Y7("".slice);
        Q7.exports = function(a) {
          return oq(sq(a), 8, -1);
        };
      });
      var tw = dt((xH, ew) => {
        var _q = Ps(), cq = Ha(), lq = Z7(), m6 = Object, uq = _q("".split);
        ew.exports = cq(function() {
          return !m6("z").propertyIsEnumerable(0);
        }) ? function(a) {
          return lq(a) == "String" ? uq(a, "") : m6(a);
        } : m6;
      });
      var h6 = dt((EH, rw) => {
        rw.exports = function(a) {
          return a == null;
        };
      });
      var g6 = dt((wH, nw) => {
        var pq = h6(), fq = TypeError;
        nw.exports = function(a) {
          if (pq(a))
            throw fq("Can't call method on " + a);
          return a;
        };
      });
      var e1 = dt((CH, iw) => {
        var dq = tw(), mq = g6();
        iw.exports = function(a) {
          return dq(mq(a));
        };
      });
      var v6 = dt((AH, aw) => {
        var y6 = typeof document == "object" && document.all, hq = typeof y6 > "u" && y6 !== void 0;
        aw.exports = { all: y6, IS_HTMLDDA: hq };
      });
      var aa = dt((PH, ow) => {
        var sw = v6(), gq = sw.all;
        ow.exports = sw.IS_HTMLDDA ? function(a) {
          return typeof a == "function" || a === gq;
        } : function(a) {
          return typeof a == "function";
        };
      });
      var Jc = dt((DH, lw) => {
        var _w = aa(), cw = v6(), yq = cw.all;
        lw.exports = cw.IS_HTMLDDA ? function(a) {
          return typeof a == "object" ? a !== null : _w(a) || a === yq;
        } : function(a) {
          return typeof a == "object" ? a !== null : _w(a);
        };
      });
      var t1 = dt((kH, uw) => {
        var b6 = Mi(), vq = aa(), bq = function(a) {
          return vq(a) ? a : void 0;
        };
        uw.exports = function(a, _) {
          return arguments.length < 2 ? bq(b6[a]) : b6[a] && b6[a][_];
        };
      });
      var fw = dt((IH, pw) => {
        var Tq = Ps();
        pw.exports = Tq({}.isPrototypeOf);
      });
      var mw = dt((NH, dw) => {
        var Sq = t1();
        dw.exports = Sq("navigator", "userAgent") || "";
      });
      var Sw = dt((OH, Tw) => {
        var bw = Mi(), T6 = mw(), hw = bw.process, gw = bw.Deno, yw = hw && hw.versions || gw && gw.version, vw = yw && yw.v8, sa, r1;
        vw && (sa = vw.split("."), r1 = sa[0] > 0 && sa[0] < 4 ? 1 : +(sa[0] + sa[1]));
        !r1 && T6 && (sa = T6.match(/Edge\/(\d+)/), (!sa || sa[1] >= 74) && (sa = T6.match(/Chrome\/(\d+)/), sa && (r1 = +sa[1])));
        Tw.exports = r1;
      });
      var S6 = dt((MH, Ew) => {
        var xw = Sw(), xq2 = Ha();
        Ew.exports = !!Object.getOwnPropertySymbols && !xq2(function() {
          var a = Symbol();
          return !String(a) || !(Object(a) instanceof Symbol) || !Symbol.sham && xw && xw < 41;
        });
      });
      var x6 = dt((LH, ww) => {
        var Eq = S6();
        ww.exports = Eq && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var E6 = dt((RH, Cw) => {
        var wq = t1(), Cq = aa(), Aq = fw(), Pq = x6(), Dq = Object;
        Cw.exports = Pq ? function(a) {
          return typeof a == "symbol";
        } : function(a) {
          var _ = wq("Symbol");
          return Cq(_) && Aq(_.prototype, Dq(a));
        };
      });
      var Pw = dt((jH, Aw) => {
        var kq = String;
        Aw.exports = function(a) {
          try {
            return kq(a);
          } catch {
            return "Object";
          }
        };
      });
      var kw = dt((JH, Dw) => {
        var Iq = aa(), Nq = Pw(), Oq = TypeError;
        Dw.exports = function(a) {
          if (Iq(a))
            return a;
          throw Oq(Nq(a) + " is not a function");
        };
      });
      var Nw = dt((FH, Iw) => {
        var Mq = kw(), Lq = h6();
        Iw.exports = function(a, _) {
          var v2 = a[_];
          return Lq(v2) ? void 0 : Mq(v2);
        };
      });
      var Mw = dt((BH, Ow) => {
        var w6 = Zh(), C6 = aa(), A6 = Jc(), Rq = TypeError;
        Ow.exports = function(a, _) {
          var v2, h;
          if (_ === "string" && C6(v2 = a.toString) && !A6(h = w6(v2, a)) || C6(v2 = a.valueOf) && !A6(h = w6(v2, a)) || _ !== "string" && C6(v2 = a.toString) && !A6(h = w6(v2, a)))
            return h;
          throw Rq("Can't convert object to primitive value");
        };
      });
      var Rw = dt((qH, Lw) => {
        Lw.exports = false;
      });
      var n1 = dt((UH, Jw) => {
        var jw = Mi(), jq = Object.defineProperty;
        Jw.exports = function(a, _) {
          try {
            jq(jw, a, { value: _, configurable: true, writable: true });
          } catch {
            jw[a] = _;
          }
          return _;
        };
      });
      var i1 = dt((zH, Bw) => {
        var Jq = Mi(), Fq = n1(), Fw = "__core-js_shared__", Bq = Jq[Fw] || Fq(Fw, {});
        Bw.exports = Bq;
      });
      var P6 = dt((WH, Uw) => {
        var qq = Rw(), qw = i1();
        (Uw.exports = function(a, _) {
          return qw[a] || (qw[a] = _ !== void 0 ? _ : {});
        })("versions", []).push({ version: "3.26.1", mode: qq ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Ww = dt((VH, zw) => {
        var Uq = g6(), zq2 = Object;
        zw.exports = function(a) {
          return zq2(Uq(a));
        };
      });
      var oo = dt((HH, Vw) => {
        var Wq = Ps(), Vq = Ww(), Hq = Wq({}.hasOwnProperty);
        Vw.exports = Object.hasOwn || function(_, v2) {
          return Hq(Vq(_), v2);
        };
      });
      var D6 = dt((GH, Hw) => {
        var Gq = Ps(), $q = 0, Kq = Math.random(), Xq = Gq(1 .toString);
        Hw.exports = function(a) {
          return "Symbol(" + (a === void 0 ? "" : a) + ")_" + Xq(++$q + Kq, 36);
        };
      });
      var Qw = dt(($H, Yw) => {
        var Yq = Mi(), Qq = P6(), Gw = oo(), Zq = D6(), $w = S6(), Xw = x6(), Fc = Qq("wks"), p_ = Yq.Symbol, Kw = p_ && p_.for, eU = Xw ? p_ : p_ && p_.withoutSetter || Zq;
        Yw.exports = function(a) {
          if (!Gw(Fc, a) || !($w || typeof Fc[a] == "string")) {
            var _ = "Symbol." + a;
            $w && Gw(p_, a) ? Fc[a] = p_[a] : Xw && Kw ? Fc[a] = Kw(_) : Fc[a] = eU(_);
          }
          return Fc[a];
        };
      });
      var rC = dt((KH, tC) => {
        var tU = Zh(), Zw = Jc(), eC = E6(), rU = Nw(), nU = Mw(), iU = Qw(), aU = TypeError, sU = iU("toPrimitive");
        tC.exports = function(a, _) {
          if (!Zw(a) || eC(a))
            return a;
          var v2 = rU(a, sU), h;
          if (v2) {
            if (_ === void 0 && (_ = "default"), h = tU(v2, a, _), !Zw(h) || eC(h))
              return h;
            throw aU("Can't convert object to primitive value");
          }
          return _ === void 0 && (_ = "number"), nU(a, _);
        };
      });
      var k6 = dt((XH, nC) => {
        var oU = rC(), _U = E6();
        nC.exports = function(a) {
          var _ = oU(a, "string");
          return _U(_) ? _ : _ + "";
        };
      });
      var sC = dt((YH, aC) => {
        var cU = Mi(), iC = Jc(), I6 = cU.document, lU = iC(I6) && iC(I6.createElement);
        aC.exports = function(a) {
          return lU ? I6.createElement(a) : {};
        };
      });
      var N6 = dt((QH, oC) => {
        var uU = As(), pU = Ha(), fU = sC();
        oC.exports = !uU && !pU(function() {
          return Object.defineProperty(fU("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var O6 = dt((cC) => {
        var dU = As(), mU = Zh(), hU = H7(), gU = f6(), yU = e1(), vU = k6(), bU = oo(), TU = N6(), _C = Object.getOwnPropertyDescriptor;
        cC.f = dU ? _C : function(_, v2) {
          if (_ = yU(_), v2 = vU(v2), TU)
            try {
              return _C(_, v2);
            } catch {
            }
          if (bU(_, v2))
            return gU(!mU(hU.f, _, v2), _[v2]);
        };
      });
      var uC = dt((eG, lC) => {
        var SU = As(), xU = Ha();
        lC.exports = SU && xU(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var a1 = dt((tG, pC) => {
        var EU = Jc(), wU = String, CU = TypeError;
        pC.exports = function(a) {
          if (EU(a))
            return a;
          throw CU(wU(a) + " is not an object");
        };
      });
      var dp = dt((dC) => {
        var AU = As(), PU = N6(), DU = uC(), s1 = a1(), fC = k6(), kU = TypeError, M6 = Object.defineProperty, IU = Object.getOwnPropertyDescriptor, L6 = "enumerable", R6 = "configurable", j6 = "writable";
        dC.f = AU ? DU ? function(_, v2, h) {
          if (s1(_), v2 = fC(v2), s1(h), typeof _ == "function" && v2 === "prototype" && "value" in h && j6 in h && !h[j6]) {
            var D = IU(_, v2);
            D && D[j6] && (_[v2] = h.value, h = { configurable: R6 in h ? h[R6] : D[R6], enumerable: L6 in h ? h[L6] : D[L6], writable: false });
          }
          return M6(_, v2, h);
        } : M6 : function(_, v2, h) {
          if (s1(_), v2 = fC(v2), s1(h), PU)
            try {
              return M6(_, v2, h);
            } catch {
            }
          if ("get" in h || "set" in h)
            throw kU("Accessors not supported");
          return "value" in h && (_[v2] = h.value), _;
        };
      });
      var J6 = dt((nG, mC) => {
        var NU = As(), OU = dp(), MU = f6();
        mC.exports = NU ? function(a, _, v2) {
          return OU.f(a, _, MU(1, v2));
        } : function(a, _, v2) {
          return a[_] = v2, a;
        };
      });
      var yC = dt((iG, gC) => {
        var F6 = As(), LU = oo(), hC = Function.prototype, RU = F6 && Object.getOwnPropertyDescriptor, B6 = LU(hC, "name"), jU = B6 && (function() {
        }).name === "something", JU = B6 && (!F6 || F6 && RU(hC, "name").configurable);
        gC.exports = { EXISTS: B6, PROPER: jU, CONFIGURABLE: JU };
      });
      var bC = dt((aG, vC) => {
        var FU = Ps(), BU = aa(), q6 = i1(), qU = FU(Function.toString);
        BU(q6.inspectSource) || (q6.inspectSource = function(a) {
          return qU(a);
        });
        vC.exports = q6.inspectSource;
      });
      var xC = dt((sG, SC2) => {
        var UU = Mi(), zU = aa(), TC = UU.WeakMap;
        SC2.exports = zU(TC) && /native code/.test(String(TC));
      });
      var CC = dt((oG, wC) => {
        var WU = P6(), VU = D6(), EC = WU("keys");
        wC.exports = function(a) {
          return EC[a] || (EC[a] = VU(a));
        };
      });
      var U6 = dt((_G, AC) => {
        AC.exports = {};
      });
      var IC = dt((cG, kC) => {
        var HU = xC(), DC = Mi(), GU = Jc(), $U = J6(), z6 = oo(), W6 = i1(), KU = CC(), XU = U6(), PC = "Object already initialized", V6 = DC.TypeError, YU = DC.WeakMap, o1, mp, _1, QU = function(a) {
          return _1(a) ? mp(a) : o1(a, {});
        }, ZU = function(a) {
          return function(_) {
            var v2;
            if (!GU(_) || (v2 = mp(_)).type !== a)
              throw V6("Incompatible receiver, " + a + " required");
            return v2;
          };
        };
        HU || W6.state ? (oa = W6.state || (W6.state = new YU()), oa.get = oa.get, oa.has = oa.has, oa.set = oa.set, o1 = function(a, _) {
          if (oa.has(a))
            throw V6(PC);
          return _.facade = a, oa.set(a, _), _;
        }, mp = function(a) {
          return oa.get(a) || {};
        }, _1 = function(a) {
          return oa.has(a);
        }) : (f_ = KU("state"), XU[f_] = true, o1 = function(a, _) {
          if (z6(a, f_))
            throw V6(PC);
          return _.facade = a, $U(a, f_, _), _;
        }, mp = function(a) {
          return z6(a, f_) ? a[f_] : {};
        }, _1 = function(a) {
          return z6(a, f_);
        });
        var oa, f_;
        kC.exports = { set: o1, get: mp, has: _1, enforce: QU, getterFor: ZU };
      });
      var G6 = dt((lG, OC) => {
        var ez = Ha(), tz = aa(), c1 = oo(), H6 = As(), rz = yC().CONFIGURABLE, nz = bC(), NC = IC(), iz = NC.enforce, az = NC.get, l1 = Object.defineProperty, sz = H6 && !ez(function() {
          return l1(function() {
          }, "length", { value: 8 }).length !== 8;
        }), oz = String(String).split("String"), _z = OC.exports = function(a, _, v2) {
          String(_).slice(0, 7) === "Symbol(" && (_ = "[" + String(_).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), v2 && v2.getter && (_ = "get " + _), v2 && v2.setter && (_ = "set " + _), (!c1(a, "name") || rz && a.name !== _) && (H6 ? l1(a, "name", { value: _, configurable: true }) : a.name = _), sz && v2 && c1(v2, "arity") && a.length !== v2.arity && l1(a, "length", { value: v2.arity });
          try {
            v2 && c1(v2, "constructor") && v2.constructor ? H6 && l1(a, "prototype", { writable: false }) : a.prototype && (a.prototype = void 0);
          } catch {
          }
          var h = iz(a);
          return c1(h, "source") || (h.source = oz.join(typeof _ == "string" ? _ : "")), a;
        };
        Function.prototype.toString = _z(function() {
          return tz(this) && az(this).source || nz(this);
        }, "toString");
      });
      var LC = dt((uG, MC) => {
        var cz = aa(), lz = dp(), uz = G6(), pz = n1();
        MC.exports = function(a, _, v2, h) {
          h || (h = {});
          var D = h.enumerable, P = h.name !== void 0 ? h.name : _;
          if (cz(v2) && uz(v2, P, h), h.global)
            D ? a[_] = v2 : pz(_, v2);
          else {
            try {
              h.unsafe ? a[_] && (D = true) : delete a[_];
            } catch {
            }
            D ? a[_] = v2 : lz.f(a, _, { value: v2, enumerable: false, configurable: !h.nonConfigurable, writable: !h.nonWritable });
          }
          return a;
        };
      });
      var jC = dt((pG, RC) => {
        var fz = Math.ceil, dz = Math.floor;
        RC.exports = Math.trunc || function(_) {
          var v2 = +_;
          return (v2 > 0 ? dz : fz)(v2);
        };
      });
      var $6 = dt((fG, JC) => {
        var mz = jC();
        JC.exports = function(a) {
          var _ = +a;
          return _ !== _ || _ === 0 ? 0 : mz(_);
        };
      });
      var BC = dt((dG, FC) => {
        var hz = $6(), gz = Math.max, yz = Math.min;
        FC.exports = function(a, _) {
          var v2 = hz(a);
          return v2 < 0 ? gz(v2 + _, 0) : yz(v2, _);
        };
      });
      var UC = dt((mG, qC) => {
        var vz = $6(), bz = Math.min;
        qC.exports = function(a) {
          return a > 0 ? bz(vz(a), 9007199254740991) : 0;
        };
      });
      var WC = dt((hG, zC) => {
        var Tz = UC();
        zC.exports = function(a) {
          return Tz(a.length);
        };
      });
      var GC = dt((gG, HC) => {
        var Sz = e1(), xz = BC(), Ez = WC(), VC = function(a) {
          return function(_, v2, h) {
            var D = Sz(_), P = Ez(D), y = xz(h, P), m;
            if (a && v2 != v2) {
              for (; P > y; )
                if (m = D[y++], m != m)
                  return true;
            } else
              for (; P > y; y++)
                if ((a || y in D) && D[y] === v2)
                  return a || y || 0;
            return !a && -1;
          };
        };
        HC.exports = { includes: VC(true), indexOf: VC(false) };
      });
      var XC = dt((yG, KC) => {
        var wz = Ps(), K6 = oo(), Cz = e1(), Az = GC().indexOf, Pz = U6(), $C = wz([].push);
        KC.exports = function(a, _) {
          var v2 = Cz(a), h = 0, D = [], P;
          for (P in v2)
            !K6(Pz, P) && K6(v2, P) && $C(D, P);
          for (; _.length > h; )
            K6(v2, P = _[h++]) && (~Az(D, P) || $C(D, P));
          return D;
        };
      });
      var QC = dt((vG, YC) => {
        YC.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var e9 = dt((ZC) => {
        var Dz = XC(), kz = QC(), Iz = kz.concat("length", "prototype");
        ZC.f = Object.getOwnPropertyNames || function(_) {
          return Dz(_, Iz);
        };
      });
      var r9 = dt((t9) => {
        t9.f = Object.getOwnPropertySymbols;
      });
      var i9 = dt((SG, n9) => {
        var Nz = t1(), Oz = Ps(), Mz = e9(), Lz = r9(), Rz = a1(), jz = Oz([].concat);
        n9.exports = Nz("Reflect", "ownKeys") || function(_) {
          var v2 = Mz.f(Rz(_)), h = Lz.f;
          return h ? jz(v2, h(_)) : v2;
        };
      });
      var o9 = dt((xG, s9) => {
        var a9 = oo(), Jz = i9(), Fz = O6(), Bz = dp();
        s9.exports = function(a, _, v2) {
          for (var h = Jz(_), D = Bz.f, P = Fz.f, y = 0; y < h.length; y++) {
            var m = h[y];
            !a9(a, m) && !(v2 && a9(v2, m)) && D(a, m, P(_, m));
          }
        };
      });
      var c9 = dt((EG, _9) => {
        var qz = Ha(), Uz = aa(), zz = /#|\.prototype\./, hp2 = function(a, _) {
          var v2 = Vz[Wz(a)];
          return v2 == Gz ? true : v2 == Hz ? false : Uz(_) ? qz(_) : !!_;
        }, Wz = hp2.normalize = function(a) {
          return String(a).replace(zz, ".").toLowerCase();
        }, Vz = hp2.data = {}, Hz = hp2.NATIVE = "N", Gz = hp2.POLYFILL = "P";
        _9.exports = hp2;
      });
      var u9 = dt((wG, l9) => {
        var X6 = Mi(), $z = O6().f, Kz = J6(), Xz = LC(), Yz = n1(), Qz = o9(), Zz = c9();
        l9.exports = function(a, _) {
          var v2 = a.target, h = a.global, D = a.stat, P, y, m, C2, d2, E;
          if (h ? y = X6 : D ? y = X6[v2] || Yz(v2, {}) : y = (X6[v2] || {}).prototype, y)
            for (m in _) {
              if (d2 = _[m], a.dontCallGetSet ? (E = $z(y, m), C2 = E && E.value) : C2 = y[m], P = Zz(h ? m : v2 + (D ? "." : "#") + m, a.forced), !P && C2 !== void 0) {
                if (typeof d2 == typeof C2)
                  continue;
                Qz(d2, C2);
              }
              (a.sham || C2 && C2.sham) && Kz(d2, "sham", true), Xz(y, m, d2, a);
            }
        };
      });
      var p9 = dt(() => {
        var eW = u9(), Y6 = Mi();
        eW({ global: true, forced: Y6.globalThis !== Y6 }, { globalThis: Y6 });
      });
      var f9 = dt(() => {
        p9();
      });
      var h9 = dt((kG, m9) => {
        var d9 = G6(), tW = dp();
        m9.exports = function(a, _, v2) {
          return v2.get && d9(v2.get, _, { getter: true }), v2.set && d9(v2.set, _, { setter: true }), tW.f(a, _, v2);
        };
      });
      var y9 = dt((IG, g9) => {
        "use strict";
        var rW = a1();
        g9.exports = function() {
          var a = rW(this), _ = "";
          return a.hasIndices && (_ += "d"), a.global && (_ += "g"), a.ignoreCase && (_ += "i"), a.multiline && (_ += "m"), a.dotAll && (_ += "s"), a.unicode && (_ += "u"), a.unicodeSets && (_ += "v"), a.sticky && (_ += "y"), _;
        };
      });
      var T9 = dt(() => {
        var nW = Mi(), iW = As(), aW = h9(), sW = y9(), oW = Ha(), v9 = nW.RegExp, b9 = v9.prototype, _W = iW && oW(function() {
          var a = true;
          try {
            v9(".", "d");
          } catch {
            a = false;
          }
          var _ = {}, v2 = "", h = a ? "dgimsy" : "gimsy", D = function(C2, d2) {
            Object.defineProperty(_, C2, { get: function() {
              return v2 += d2, true;
            } });
          }, P = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          a && (P.hasIndices = "d");
          for (var y in P)
            D(y, P[y]);
          var m = Object.getOwnPropertyDescriptor(b9, "flags").get.call(_);
          return m !== h || v2 !== h;
        });
        _W && aW(b9, "flags", { configurable: true, get: sW });
      });
      var uH = dt((MG, v5) => {
        f9();
        T9();
        var iT = Object.defineProperty, cW = Object.getOwnPropertyDescriptor, aT = Object.getOwnPropertyNames, lW = Object.prototype.hasOwnProperty, yp = (a, _) => function() {
          return a && (_ = (0, a[aT(a)[0]])(a = 0)), _;
        }, Oe2 = (a, _) => function() {
          return _ || (0, a[aT(a)[0]])((_ = { exports: {} }).exports, _), _.exports;
        }, m1 = (a, _) => {
          for (var v2 in _)
            iT(a, v2, { get: _[v2], enumerable: true });
        }, uW = (a, _, v2, h) => {
          if (_ && typeof _ == "object" || typeof _ == "function")
            for (let D of aT(_))
              !lW.call(a, D) && D !== v2 && iT(a, D, { get: () => _[D], enumerable: !(h = cW(_, D)) || h.enumerable });
          return a;
        }, Li = (a) => uW(iT({}, "__esModule", { value: true }), a), cn, De3 = yp({ "<define:process>"() {
          cn = { env: {}, argv: [] };
        } }), w9 = Oe2({ "src/common/parser-create-error.js"(a, _) {
          "use strict";
          De3();
          function v2(h, D) {
            let P = new SyntaxError(h + " (" + D.start.line + ":" + D.start.column + ")");
            return P.loc = D, P;
          }
          _.exports = v2;
        } }), pW = Oe2({ "src/utils/try-combinations.js"(a, _) {
          "use strict";
          De3();
          function v2() {
            let h;
            for (var D = arguments.length, P = new Array(D), y = 0; y < D; y++)
              P[y] = arguments[y];
            for (let [m, C2] of P.entries())
              try {
                return { result: C2() };
              } catch (d2) {
                m === 0 && (h = d2);
              }
            return { error: h };
          }
          _.exports = v2;
        } }), C9 = {};
        m1(C9, { EOL: () => eT, arch: () => fW, cpus: () => O9, default: () => J9, endianness: () => A9, freemem: () => I9, getNetworkInterfaces: () => j9, hostname: () => P9, loadavg: () => D9, networkInterfaces: () => R9, platform: () => dW, release: () => L9, tmpDir: () => Q6, tmpdir: () => Z6, totalmem: () => N9, type: () => M9, uptime: () => k9 });
        function A9() {
          if (typeof u1 > "u") {
            var a = new ArrayBuffer(2), _ = new Uint8Array(a), v2 = new Uint16Array(a);
            if (_[0] = 1, _[1] = 2, v2[0] === 258)
              u1 = "BE";
            else if (v2[0] === 513)
              u1 = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return u1;
        }
        function P9() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function D9() {
          return [];
        }
        function k9() {
          return 0;
        }
        function I9() {
          return Number.MAX_VALUE;
        }
        function N9() {
          return Number.MAX_VALUE;
        }
        function O9() {
          return [];
        }
        function M9() {
          return "Browser";
        }
        function L9() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function R9() {
        }
        function j9() {
        }
        function fW() {
          return "javascript";
        }
        function dW() {
          return "browser";
        }
        function Q6() {
          return "/tmp";
        }
        var u1, Z6, eT, J9, mW = yp({ "node-modules-polyfills:os"() {
          De3(), Z6 = Q6, eT = `
`, J9 = { EOL: eT, tmpdir: Z6, tmpDir: Q6, networkInterfaces: R9, getNetworkInterfaces: j9, release: L9, type: M9, cpus: O9, totalmem: N9, freemem: I9, uptime: k9, loadavg: D9, hostname: P9, endianness: A9 };
        } }), hW = Oe2({ "node-modules-polyfills-commonjs:os"(a, _) {
          De3();
          var v2 = (mW(), Li(C9));
          if (v2 && v2.default) {
            _.exports = v2.default;
            for (let h in v2)
              _.exports[h] = v2[h];
          } else
            v2 && (_.exports = v2);
        } }), gW = Oe2({ "node_modules/detect-newline/index.js"(a, _) {
          "use strict";
          De3();
          var v2 = (h) => {
            if (typeof h != "string")
              throw new TypeError("Expected a string");
            let D = h.match(/(?:\r?\n)/g) || [];
            if (D.length === 0)
              return;
            let P = D.filter((m) => m === `\r
`).length, y = D.length - P;
            return P > y ? `\r
` : `
`;
          };
          _.exports = v2, _.exports.graceful = (h) => typeof h == "string" && v2(h) || `
`;
        } }), yW = Oe2({ "node_modules/jest-docblock/build/index.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.extract = M, a.parse = W, a.parseWithComments = K, a.print = ce2, a.strip = q2;
          function _() {
            let me2 = hW();
            return _ = function() {
              return me2;
            }, me2;
          }
          function v2() {
            let me2 = h(gW());
            return v2 = function() {
              return me2;
            }, me2;
          }
          function h(me2) {
            return me2 && me2.__esModule ? me2 : { default: me2 };
          }
          var D = /\*\/$/, P = /^\/\*\*?/, y = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, m = /(^|\s+)\/\/([^\r\n]*)/g, C2 = /^(\r?\n)+/, d2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, E = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, I = /(\r?\n|^) *\* ?/g, c = [];
          function M(me2) {
            let Ae2 = me2.match(y);
            return Ae2 ? Ae2[0].trimLeft() : "";
          }
          function q2(me2) {
            let Ae2 = me2.match(y);
            return Ae2 && Ae2[0] ? me2.substring(Ae2[0].length) : me2;
          }
          function W(me2) {
            return K(me2).pragmas;
          }
          function K(me2) {
            let Ae2 = (0, v2().default)(me2) || _().EOL;
            me2 = me2.replace(P, "").replace(D, "").replace(I, "$1");
            let te2 = "";
            for (; te2 !== me2; )
              te2 = me2, me2 = me2.replace(d2, `${Ae2}$1 $2${Ae2}`);
            me2 = me2.replace(C2, "").trimRight();
            let he = /* @__PURE__ */ Object.create(null), Pe2 = me2.replace(E, "").replace(C2, "").trimRight(), R;
            for (; R = E.exec(me2); ) {
              let pe2 = R[2].replace(m, "");
              typeof he[R[1]] == "string" || Array.isArray(he[R[1]]) ? he[R[1]] = c.concat(he[R[1]], pe2) : he[R[1]] = pe2;
            }
            return { comments: Pe2, pragmas: he };
          }
          function ce2(me2) {
            let { comments: Ae2 = "", pragmas: te2 = {} } = me2, he = (0, v2().default)(Ae2) || _().EOL, Pe2 = "/**", R = " *", pe2 = " */", ke2 = Object.keys(te2), Je2 = ke2.map((ee2) => Ie2(ee2, te2[ee2])).reduce((ee2, je2) => ee2.concat(je2), []).map((ee2) => `${R} ${ee2}${he}`).join("");
            if (!Ae2) {
              if (ke2.length === 0)
                return "";
              if (ke2.length === 1 && !Array.isArray(te2[ke2[0]])) {
                let ee2 = te2[ke2[0]];
                return `${Pe2} ${Ie2(ke2[0], ee2)[0]}${pe2}`;
              }
            }
            let Xe2 = Ae2.split(he).map((ee2) => `${R} ${ee2}`).join(he) + he;
            return Pe2 + he + (Ae2 ? Xe2 : "") + (Ae2 && ke2.length ? R + he : "") + Je2 + pe2;
          }
          function Ie2(me2, Ae2) {
            return c.concat(Ae2).map((te2) => `@${me2} ${te2}`.trim());
          }
        } }), vW = Oe2({ "src/common/end-of-line.js"(a, _) {
          "use strict";
          De3();
          function v2(y) {
            let m = y.indexOf("\r");
            return m >= 0 ? y.charAt(m + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function h(y) {
            switch (y) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function D(y, m) {
            let C2;
            switch (m) {
              case `
`:
                C2 = /\n/g;
                break;
              case "\r":
                C2 = /\r/g;
                break;
              case `\r
`:
                C2 = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(m)}.`);
            }
            let d2 = y.match(C2);
            return d2 ? d2.length : 0;
          }
          function P(y) {
            return y.replace(/\r\n?/g, `
`);
          }
          _.exports = { guessEndOfLine: v2, convertEndOfLineToChars: h, countEndOfLineChars: D, normalizeEndOfLine: P };
        } }), bW = Oe2({ "src/language-js/utils/get-shebang.js"(a, _) {
          "use strict";
          De3();
          function v2(h) {
            if (!h.startsWith("#!"))
              return "";
            let D = h.indexOf(`
`);
            return D === -1 ? h : h.slice(0, D);
          }
          _.exports = v2;
        } }), TW = Oe2({ "src/language-js/pragma.js"(a, _) {
          "use strict";
          De3();
          var { parseWithComments: v2, strip: h, extract: D, print: P } = yW(), { normalizeEndOfLine: y } = vW(), m = bW();
          function C2(I) {
            let c = m(I);
            c && (I = I.slice(c.length + 1));
            let M = D(I), { pragmas: q2, comments: W } = v2(M);
            return { shebang: c, text: I, pragmas: q2, comments: W };
          }
          function d2(I) {
            let c = Object.keys(C2(I).pragmas);
            return c.includes("prettier") || c.includes("format");
          }
          function E(I) {
            let { shebang: c, text: M, pragmas: q2, comments: W } = C2(I), K = h(M), ce2 = P({ pragmas: Object.assign({ format: "" }, q2), comments: W.trimStart() });
            return (c ? `${c}
` : "") + y(ce2) + (K.startsWith(`
`) ? `
` : `

`) + K;
          }
          _.exports = { hasPragma: d2, insertPragma: E };
        } }), F9 = Oe2({ "src/utils/is-non-empty-array.js"(a, _) {
          "use strict";
          De3();
          function v2(h) {
            return Array.isArray(h) && h.length > 0;
          }
          _.exports = v2;
        } }), B9 = Oe2({ "src/language-js/loc.js"(a, _) {
          "use strict";
          De3();
          var v2 = F9();
          function h(C2) {
            var d2, E;
            let I = C2.range ? C2.range[0] : C2.start, c = (d2 = (E = C2.declaration) === null || E === void 0 ? void 0 : E.decorators) !== null && d2 !== void 0 ? d2 : C2.decorators;
            return v2(c) ? Math.min(h(c[0]), I) : I;
          }
          function D(C2) {
            return C2.range ? C2.range[1] : C2.end;
          }
          function P(C2, d2) {
            let E = h(C2);
            return Number.isInteger(E) && E === h(d2);
          }
          function y(C2, d2) {
            let E = D(C2);
            return Number.isInteger(E) && E === D(d2);
          }
          function m(C2, d2) {
            return P(C2, d2) && y(C2, d2);
          }
          _.exports = { locStart: h, locEnd: D, hasSameLocStart: P, hasSameLoc: m };
        } }), SW = Oe2({ "src/language-js/parse/utils/create-parser.js"(a, _) {
          "use strict";
          De3();
          var { hasPragma: v2 } = TW(), { locStart: h, locEnd: D } = B9();
          function P(y) {
            return y = typeof y == "function" ? { parse: y } : y, Object.assign({ astFormat: "estree", hasPragma: v2, locStart: h, locEnd: D }, y);
          }
          _.exports = P;
        } }), xW = Oe2({ "src/language-js/parse/utils/replace-hashbang.js"(a, _) {
          "use strict";
          De3();
          function v2(h) {
            return h.charAt(0) === "#" && h.charAt(1) === "!" ? "//" + h.slice(2) : h;
          }
          _.exports = v2;
        } }), EW = Oe2({ "src/language-js/utils/is-ts-keyword-type.js"(a, _) {
          "use strict";
          De3();
          function v2(h) {
            let { type: D } = h;
            return D.startsWith("TS") && D.endsWith("Keyword");
          }
          _.exports = v2;
        } }), wW = Oe2({ "src/language-js/utils/is-block-comment.js"(a, _) {
          "use strict";
          De3();
          var v2 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), h = (D) => v2.has(D == null ? void 0 : D.type);
          _.exports = h;
        } }), CW = Oe2({ "src/language-js/utils/is-type-cast-comment.js"(a, _) {
          "use strict";
          De3();
          var v2 = wW();
          function h(D) {
            return v2(D) && D.value[0] === "*" && /@(?:type|satisfies)\b/.test(D.value);
          }
          _.exports = h;
        } }), AW = Oe2({ "src/utils/get-last.js"(a, _) {
          "use strict";
          De3();
          var v2 = (h) => h[h.length - 1];
          _.exports = v2;
        } }), q9 = Oe2({ "src/language-js/parse/postprocess/visit-node.js"(a, _) {
          "use strict";
          De3();
          function v2(h, D) {
            if (Array.isArray(h)) {
              for (let P = 0; P < h.length; P++)
                h[P] = v2(h[P], D);
              return h;
            }
            if (h && typeof h == "object" && typeof h.type == "string") {
              let P = Object.keys(h);
              for (let y = 0; y < P.length; y++)
                h[P[y]] = v2(h[P[y]], D);
              return D(h) || h;
            }
            return h;
          }
          _.exports = v2;
        } }), U9 = Oe2({ "src/language-js/parse/postprocess/throw-syntax-error.js"(a, _) {
          "use strict";
          De3();
          var v2 = w9();
          function h(D, P) {
            let { start: y, end: m } = D.loc;
            throw v2(P, { start: { line: y.line, column: y.column + 1 }, end: { line: m.line, column: m.column + 1 } });
          }
          _.exports = h;
        } }), PW = Oe2({ "src/language-js/parse/postprocess/index.js"(a, _) {
          "use strict";
          De3();
          var { locStart: v2, locEnd: h } = B9(), D = EW(), P = CW(), y = AW(), m = q9(), C2 = U9();
          function d2(M, q2) {
            if (q2.parser !== "typescript" && q2.parser !== "flow" && q2.parser !== "acorn" && q2.parser !== "espree" && q2.parser !== "meriyah") {
              let K = /* @__PURE__ */ new Set();
              M = m(M, (ce2) => {
                ce2.leadingComments && ce2.leadingComments.some(P) && K.add(v2(ce2));
              }), M = m(M, (ce2) => {
                if (ce2.type === "ParenthesizedExpression") {
                  let { expression: Ie2 } = ce2;
                  if (Ie2.type === "TypeCastExpression")
                    return Ie2.range = ce2.range, Ie2;
                  let me2 = v2(ce2);
                  if (!K.has(me2))
                    return Ie2.extra = Object.assign(Object.assign({}, Ie2.extra), {}, { parenthesized: true }), Ie2;
                }
              });
            }
            return M = m(M, (K) => {
              switch (K.type) {
                case "ChainExpression":
                  return E(K.expression);
                case "LogicalExpression": {
                  if (I(K))
                    return c(K);
                  break;
                }
                case "VariableDeclaration": {
                  let ce2 = y(K.declarations);
                  ce2 && ce2.init && W(K, ce2);
                  break;
                }
                case "TSParenthesizedType":
                  return D(K.typeAnnotation) || K.typeAnnotation.type === "TSThisType" || (K.typeAnnotation.range = [v2(K), h(K)]), K.typeAnnotation;
                case "TSTypeParameter":
                  if (typeof K.name == "string") {
                    let ce2 = v2(K);
                    K.name = { type: "Identifier", name: K.name, range: [ce2, ce2 + K.name.length] };
                  }
                  break;
                case "ObjectExpression":
                  if (q2.parser === "typescript") {
                    let ce2 = K.properties.find((Ie2) => Ie2.type === "Property" && Ie2.value.type === "TSEmptyBodyFunctionExpression");
                    ce2 && C2(ce2.value, "Unexpected token.");
                  }
                  break;
                case "SequenceExpression": {
                  let ce2 = y(K.expressions);
                  K.range = [v2(K), Math.min(h(ce2), h(K))];
                  break;
                }
                case "TopicReference":
                  q2.__isUsingHackPipeline = true;
                  break;
                case "ExportAllDeclaration": {
                  let { exported: ce2 } = K;
                  if (q2.parser === "meriyah" && ce2 && ce2.type === "Identifier") {
                    let Ie2 = q2.originalText.slice(v2(ce2), h(ce2));
                    (Ie2.startsWith('"') || Ie2.startsWith("'")) && (K.exported = Object.assign(Object.assign({}, K.exported), {}, { type: "Literal", value: K.exported.name, raw: Ie2 }));
                  }
                  break;
                }
                case "PropertyDefinition":
                  if (q2.parser === "meriyah" && K.static && !K.computed && !K.key) {
                    let ce2 = "static", Ie2 = v2(K);
                    Object.assign(K, { static: false, key: { type: "Identifier", name: ce2, range: [Ie2, Ie2 + ce2.length] } });
                  }
                  break;
              }
            }), M;
            function W(K, ce2) {
              q2.originalText[h(ce2)] !== ";" && (K.range = [v2(K), h(ce2)]);
            }
          }
          function E(M) {
            switch (M.type) {
              case "CallExpression":
                M.type = "OptionalCallExpression", M.callee = E(M.callee);
                break;
              case "MemberExpression":
                M.type = "OptionalMemberExpression", M.object = E(M.object);
                break;
              case "TSNonNullExpression":
                M.expression = E(M.expression);
                break;
            }
            return M;
          }
          function I(M) {
            return M.type === "LogicalExpression" && M.right.type === "LogicalExpression" && M.operator === M.right.operator;
          }
          function c(M) {
            return I(M) ? c({ type: "LogicalExpression", operator: M.operator, left: c({ type: "LogicalExpression", operator: M.operator, left: M.left, right: M.right.left, range: [v2(M.left), h(M.right.left)] }), right: M.right.right, range: [v2(M), h(M)] }) : M;
          }
          _.exports = d2;
        } }), vr = Oe2({ "node_modules/typescript/lib/typescript.js"(a, _) {
          De3();
          var v2 = Object.defineProperty, h = Object.getOwnPropertyNames, D = (e, t6) => function() {
            return e && (t6 = (0, e[h(e)[0]])(e = 0)), t6;
          }, P = (e, t6) => function() {
            return t6 || (0, e[h(e)[0]])((t6 = { exports: {} }).exports, t6), t6.exports;
          }, y = (e, t6) => {
            for (var r in t6)
              v2(e, r, { get: t6[r], enumerable: true });
          }, m, C2, d2, E = D({ "src/compiler/corePublic.ts"() {
            "use strict";
            m = "5.0", C2 = "5.0.2", d2 = ((e) => (e[e.LessThan = -1] = "LessThan", e[e.EqualTo = 0] = "EqualTo", e[e.GreaterThan = 1] = "GreaterThan", e))(d2 || {});
          } });
          function I(e) {
            return e ? e.length : 0;
          }
          function c(e, t6) {
            if (e)
              for (let r = 0; r < e.length; r++) {
                let s = t6(e[r], r);
                if (s)
                  return s;
              }
          }
          function M(e, t6) {
            if (e)
              for (let r = e.length - 1; r >= 0; r--) {
                let s = t6(e[r], r);
                if (s)
                  return s;
              }
          }
          function q2(e, t6) {
            if (e !== void 0)
              for (let r = 0; r < e.length; r++) {
                let s = t6(e[r], r);
                if (s !== void 0)
                  return s;
              }
          }
          function W(e, t6) {
            for (let r of e) {
              let s = t6(r);
              if (s !== void 0)
                return s;
            }
          }
          function K(e, t6, r) {
            let s = r;
            if (e) {
              let f10 = 0;
              for (let x10 of e)
                s = t6(s, x10, f10), f10++;
            }
            return s;
          }
          function ce2(e, t6, r) {
            let s = [];
            Y3.assertEqual(e.length, t6.length);
            for (let f10 = 0; f10 < e.length; f10++)
              s.push(r(e[f10], t6[f10], f10));
            return s;
          }
          function Ie2(e, t6) {
            if (e.length <= 1)
              return e;
            let r = [];
            for (let s = 0, f10 = e.length; s < f10; s++)
              s && r.push(t6), r.push(e[s]);
            return r;
          }
          function me2(e, t6) {
            if (e) {
              for (let r = 0; r < e.length; r++)
                if (!t6(e[r], r))
                  return false;
            }
            return true;
          }
          function Ae2(e, t6, r) {
            if (e !== void 0)
              for (let s = r != null ? r : 0; s < e.length; s++) {
                let f10 = e[s];
                if (t6(f10, s))
                  return f10;
              }
          }
          function te2(e, t6, r) {
            if (e !== void 0)
              for (let s = r != null ? r : e.length - 1; s >= 0; s--) {
                let f10 = e[s];
                if (t6(f10, s))
                  return f10;
              }
          }
          function he(e, t6, r) {
            if (e === void 0)
              return -1;
            for (let s = r != null ? r : 0; s < e.length; s++)
              if (t6(e[s], s))
                return s;
            return -1;
          }
          function Pe2(e, t6, r) {
            if (e === void 0)
              return -1;
            for (let s = r != null ? r : e.length - 1; s >= 0; s--)
              if (t6(e[s], s))
                return s;
            return -1;
          }
          function R(e, t6) {
            for (let r = 0; r < e.length; r++) {
              let s = t6(e[r], r);
              if (s)
                return s;
            }
            return Y3.fail();
          }
          function pe2(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fa;
            if (e) {
              for (let s of e)
                if (r(s, t6))
                  return true;
            }
            return false;
          }
          function ke2(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fa;
            return e.length === t6.length && e.every((s, f10) => r(s, t6[f10]));
          }
          function Je2(e, t6, r) {
            for (let s = r || 0; s < e.length; s++)
              if (pe2(t6, e.charCodeAt(s)))
                return s;
            return -1;
          }
          function Xe2(e, t6) {
            let r = 0;
            if (e)
              for (let s = 0; s < e.length; s++) {
                let f10 = e[s];
                t6(f10, s) && r++;
              }
            return r;
          }
          function ee2(e, t6) {
            if (e) {
              let r = e.length, s = 0;
              for (; s < r && t6(e[s]); )
                s++;
              if (s < r) {
                let f10 = e.slice(0, s);
                for (s++; s < r; ) {
                  let x10 = e[s];
                  t6(x10) && f10.push(x10), s++;
                }
                return f10;
              }
            }
            return e;
          }
          function je2(e, t6) {
            let r = 0;
            for (let s = 0; s < e.length; s++)
              t6(e[s], s, e) && (e[r] = e[s], r++);
            e.length = r;
          }
          function nt(e) {
            e.length = 0;
          }
          function Ze2(e, t6) {
            let r;
            if (e) {
              r = [];
              for (let s = 0; s < e.length; s++)
                r.push(t6(e[s], s));
            }
            return r;
          }
          function* st2(e, t6) {
            for (let r of e)
              yield t6(r);
          }
          function tt(e, t6) {
            if (e)
              for (let r = 0; r < e.length; r++) {
                let s = e[r], f10 = t6(s, r);
                if (s !== f10) {
                  let x10 = e.slice(0, r);
                  for (x10.push(f10), r++; r < e.length; r++)
                    x10.push(t6(e[r], r));
                  return x10;
                }
              }
            return e;
          }
          function ct(e) {
            let t6 = [];
            for (let r of e)
              r && (ir2(r) ? jr2(t6, r) : t6.push(r));
            return t6;
          }
          function ne2(e, t6) {
            let r;
            if (e)
              for (let s = 0; s < e.length; s++) {
                let f10 = t6(e[s], s);
                f10 && (ir2(f10) ? r = jr2(r, f10) : r = tr2(r, f10));
              }
            return r || Bt;
          }
          function ge(e, t6) {
            let r = [];
            if (e)
              for (let s = 0; s < e.length; s++) {
                let f10 = t6(e[s], s);
                f10 && (ir2(f10) ? jr2(r, f10) : r.push(f10));
              }
            return r;
          }
          function* Fe2(e, t6) {
            for (let r of e) {
              let s = t6(r);
              s && (yield* s);
            }
          }
          function at3(e, t6) {
            let r;
            if (e)
              for (let s = 0; s < e.length; s++) {
                let f10 = e[s], x10 = t6(f10, s);
                (r || f10 !== x10 || ir2(x10)) && (r || (r = e.slice(0, s)), ir2(x10) ? jr2(r, x10) : r.push(x10));
              }
            return r || e;
          }
          function Pt(e, t6) {
            let r = [];
            for (let s = 0; s < e.length; s++) {
              let f10 = t6(e[s], s);
              if (f10 === void 0)
                return;
              r.push(f10);
            }
            return r;
          }
          function qt(e, t6) {
            let r = [];
            if (e)
              for (let s = 0; s < e.length; s++) {
                let f10 = t6(e[s], s);
                f10 !== void 0 && r.push(f10);
              }
            return r;
          }
          function* Zr2(e, t6) {
            for (let r of e) {
              let s = t6(r);
              s !== void 0 && (yield s);
            }
          }
          function Ri(e, t6) {
            if (!e)
              return;
            let r = /* @__PURE__ */ new Map();
            return e.forEach((s, f10) => {
              let x10 = t6(f10, s);
              if (x10 !== void 0) {
                let [w6, A6] = x10;
                w6 !== void 0 && A6 !== void 0 && r.set(w6, A6);
              }
            }), r;
          }
          function la(e, t6, r) {
            if (e.has(t6))
              return e.get(t6);
            let s = r();
            return e.set(t6, s), s;
          }
          function ua(e, t6) {
            return e.has(t6) ? false : (e.add(t6), true);
          }
          function* Ka(e) {
            yield e;
          }
          function co(e, t6, r) {
            let s;
            if (e) {
              s = [];
              let f10 = e.length, x10, w6, A6 = 0, g9 = 0;
              for (; A6 < f10; ) {
                for (; g9 < f10; ) {
                  let B = e[g9];
                  if (w6 = t6(B, g9), g9 === 0)
                    x10 = w6;
                  else if (w6 !== x10)
                    break;
                  g9++;
                }
                if (A6 < g9) {
                  let B = r(e.slice(A6, g9), x10, A6, g9);
                  B && s.push(B), A6 = g9;
                }
                x10 = w6, g9++;
              }
            }
            return s;
          }
          function be2(e, t6) {
            if (!e)
              return;
            let r = /* @__PURE__ */ new Map();
            return e.forEach((s, f10) => {
              let [x10, w6] = t6(f10, s);
              r.set(x10, w6);
            }), r;
          }
          function Ke3(e, t6) {
            if (e)
              if (t6) {
                for (let r of e)
                  if (t6(r))
                    return true;
              } else
                return e.length > 0;
            return false;
          }
          function Et(e, t6, r) {
            let s;
            for (let f10 = 0; f10 < e.length; f10++)
              t6(e[f10]) ? s = s === void 0 ? f10 : s : s !== void 0 && (r(s, f10), s = void 0);
            s !== void 0 && r(s, e.length);
          }
          function Ft(e, t6) {
            return Ke3(t6) ? Ke3(e) ? [...e, ...t6] : t6 : e;
          }
          function or2(e, t6) {
            return t6;
          }
          function Wr2(e) {
            return e.map(or2);
          }
          function m_(e, t6, r) {
            let s = Wr2(e);
            ks(e, s, r);
            let f10 = e[s[0]], x10 = [s[0]];
            for (let w6 = 1; w6 < s.length; w6++) {
              let A6 = s[w6], g9 = e[A6];
              t6(f10, g9) || (x10.push(A6), f10 = g9);
            }
            return x10.sort(), x10.map((w6) => e[w6]);
          }
          function Uc(e, t6) {
            let r = [];
            for (let s of e)
              qn(r, s, t6);
            return r;
          }
          function ji(e, t6, r) {
            return e.length === 0 ? [] : e.length === 1 ? e.slice() : r ? m_(e, t6, r) : Uc(e, t6);
          }
          function lo(e, t6) {
            if (e.length === 0)
              return Bt;
            let r = e[0], s = [r];
            for (let f10 = 1; f10 < e.length; f10++) {
              let x10 = e[f10];
              switch (t6(x10, r)) {
                case true:
                case 0:
                  continue;
                case -1:
                  return Y3.fail("Array is unsorted.");
              }
              s.push(r = x10);
            }
            return s;
          }
          function zc() {
            return [];
          }
          function Qn(e, t6, r, s) {
            if (e.length === 0)
              return e.push(t6), true;
            let f10 = Ya(e, t6, rr2, r);
            return f10 < 0 ? (e.splice(~f10, 0, t6), true) : s ? (e.splice(f10, 0, t6), true) : false;
          }
          function uo(e, t6, r) {
            return lo(Is(e, t6), r || t6 || ri);
          }
          function Wc(e, t6) {
            if (e.length < 2)
              return true;
            for (let r = 1, s = e.length; r < s; r++)
              if (t6(e[r - 1], e[r]) === 1)
                return false;
            return true;
          }
          function Vc(e, t6, r, s) {
            let f10 = 3;
            if (e.length < 2)
              return f10;
            let x10 = t6(e[0]);
            for (let w6 = 1, A6 = e.length; w6 < A6 && f10 !== 0; w6++) {
              let g9 = t6(e[w6]);
              f10 & 1 && r(x10, g9) > 0 && (f10 &= -2), f10 & 2 && s(x10, g9) > 0 && (f10 &= -3), x10 = g9;
            }
            return f10;
          }
          function Hc(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fa;
            if (!e || !t6)
              return e === t6;
            if (e.length !== t6.length)
              return false;
            for (let s = 0; s < e.length; s++)
              if (!r(e[s], t6[s], s))
                return false;
            return true;
          }
          function Gc(e) {
            let t6;
            if (e)
              for (let r = 0; r < e.length; r++) {
                let s = e[r];
                (t6 || !s) && (t6 || (t6 = e.slice(0, r)), s && t6.push(s));
              }
            return t6 || e;
          }
          function h_(e, t6, r) {
            if (!t6 || !e || t6.length === 0 || e.length === 0)
              return t6;
            let s = [];
            e:
              for (let f10 = 0, x10 = 0; x10 < t6.length; x10++) {
                x10 > 0 && Y3.assertGreaterThanOrEqual(r(t6[x10], t6[x10 - 1]), 0);
                t:
                  for (let w6 = f10; f10 < e.length; f10++)
                    switch (f10 > w6 && Y3.assertGreaterThanOrEqual(r(e[f10], e[f10 - 1]), 0), r(t6[x10], e[f10])) {
                      case -1:
                        s.push(t6[x10]);
                        continue e;
                      case 0:
                        continue e;
                      case 1:
                        continue t;
                    }
              }
            return s;
          }
          function tr2(e, t6) {
            return t6 === void 0 ? e : e === void 0 ? [t6] : (e.push(t6), e);
          }
          function $c(e, t6) {
            return e === void 0 ? t6 : t6 === void 0 ? e : ir2(e) ? ir2(t6) ? Ft(e, t6) : tr2(e, t6) : ir2(t6) ? tr2(t6, e) : [e, t6];
          }
          function po(e, t6) {
            return t6 < 0 ? e.length + t6 : t6;
          }
          function jr2(e, t6, r, s) {
            if (t6 === void 0 || t6.length === 0)
              return e;
            if (e === void 0)
              return t6.slice(r, s);
            r = r === void 0 ? 0 : po(t6, r), s = s === void 0 ? t6.length : po(t6, s);
            for (let f10 = r; f10 < s && f10 < t6.length; f10++)
              t6[f10] !== void 0 && e.push(t6[f10]);
            return e;
          }
          function qn(e, t6, r) {
            return pe2(e, t6, r) ? false : (e.push(t6), true);
          }
          function g_(e, t6, r) {
            return e ? (qn(e, t6, r), e) : [t6];
          }
          function ks(e, t6, r) {
            t6.sort((s, f10) => r(e[s], e[f10]) || Vr2(s, f10));
          }
          function Is(e, t6) {
            return e.length === 0 ? e : e.slice().sort(t6);
          }
          function* y_(e) {
            for (let t6 = e.length - 1; t6 >= 0; t6--)
              yield e[t6];
          }
          function Ns(e, t6) {
            let r = Wr2(e);
            return ks(e, r, t6), r.map((s) => e[s]);
          }
          function Kc(e, t6, r, s) {
            for (; r < s; ) {
              if (e[r] !== t6[r])
                return false;
              r++;
            }
            return true;
          }
          function pa(e) {
            return e === void 0 || e.length === 0 ? void 0 : e[0];
          }
          function Xc(e) {
            if (e)
              for (let t6 of e)
                return t6;
          }
          function fo2(e) {
            return Y3.assert(e.length !== 0), e[0];
          }
          function v_(e) {
            for (let t6 of e)
              return t6;
            Y3.fail("iterator is empty");
          }
          function Cn(e) {
            return e === void 0 || e.length === 0 ? void 0 : e[e.length - 1];
          }
          function Zn(e) {
            return Y3.assert(e.length !== 0), e[e.length - 1];
          }
          function Xa(e) {
            return e && e.length === 1 ? e[0] : void 0;
          }
          function Yc2(e) {
            return Y3.checkDefined(Xa(e));
          }
          function mo(e) {
            return e && e.length === 1 ? e[0] : e;
          }
          function ei(e, t6, r) {
            let s = e.slice(0);
            return s[t6] = r, s;
          }
          function Ya(e, t6, r, s, f10) {
            return b_(e, r(t6), r, s, f10);
          }
          function b_(e, t6, r, s, f10) {
            if (!Ke3(e))
              return -1;
            let x10 = f10 || 0, w6 = e.length - 1;
            for (; x10 <= w6; ) {
              let A6 = x10 + (w6 - x10 >> 1), g9 = r(e[A6], A6);
              switch (s(g9, t6)) {
                case -1:
                  x10 = A6 + 1;
                  break;
                case 0:
                  return A6;
                case 1:
                  w6 = A6 - 1;
                  break;
              }
            }
            return ~x10;
          }
          function Qa(e, t6, r, s, f10) {
            if (e && e.length > 0) {
              let x10 = e.length;
              if (x10 > 0) {
                let w6 = s === void 0 || s < 0 ? 0 : s, A6 = f10 === void 0 || w6 + f10 > x10 - 1 ? x10 - 1 : w6 + f10, g9;
                for (arguments.length <= 2 ? (g9 = e[w6], w6++) : g9 = r; w6 <= A6; )
                  g9 = t6(g9, e[w6], w6), w6++;
                return g9;
              }
            }
            return r;
          }
          function Jr(e, t6) {
            return ni.call(e, t6);
          }
          function Qc(e, t6) {
            return ni.call(e, t6) ? e[t6] : void 0;
          }
          function ho(e) {
            let t6 = [];
            for (let r in e)
              ni.call(e, r) && t6.push(r);
            return t6;
          }
          function T_(e) {
            let t6 = [];
            do {
              let r = Object.getOwnPropertyNames(e);
              for (let s of r)
                qn(t6, s);
            } while (e = Object.getPrototypeOf(e));
            return t6;
          }
          function go(e) {
            let t6 = [];
            for (let r in e)
              ni.call(e, r) && t6.push(e[r]);
            return t6;
          }
          function yo(e, t6) {
            let r = new Array(e);
            for (let s = 0; s < e; s++)
              r[s] = t6(s);
            return r;
          }
          function Za(e, t6) {
            let r = [];
            for (let s of e)
              r.push(t6 ? t6(s) : s);
            return r;
          }
          function vo(e) {
            for (var t6 = arguments.length, r = new Array(t6 > 1 ? t6 - 1 : 0), s = 1; s < t6; s++)
              r[s - 1] = arguments[s];
            for (let f10 of r)
              if (f10 !== void 0)
                for (let x10 in f10)
                  Jr(f10, x10) && (e[x10] = f10[x10]);
            return e;
          }
          function S_(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fa;
            if (e === t6)
              return true;
            if (!e || !t6)
              return false;
            for (let s in e)
              if (ni.call(e, s) && (!ni.call(t6, s) || !r(e[s], t6[s])))
                return false;
            for (let s in t6)
              if (ni.call(t6, s) && !ni.call(e, s))
                return false;
            return true;
          }
          function Zc(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rr2, s = /* @__PURE__ */ new Map();
            for (let f10 of e) {
              let x10 = t6(f10);
              x10 !== void 0 && s.set(x10, r(f10));
            }
            return s;
          }
          function Os(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rr2, s = [];
            for (let f10 of e)
              s[t6(f10)] = r(f10);
            return s;
          }
          function bo(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rr2, s = Be2();
            for (let f10 of e)
              s.add(t6(f10), r(f10));
            return s;
          }
          function el(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rr2;
            return Za(bo(e, t6).values(), r);
          }
          function x_(e, t6) {
            var r;
            let s = {};
            if (e)
              for (let f10 of e) {
                let x10 = `${t6(f10)}`;
                ((r = s[x10]) != null ? r : s[x10] = []).push(f10);
              }
            return s;
          }
          function E_(e) {
            let t6 = {};
            for (let r in e)
              ni.call(e, r) && (t6[r] = e[r]);
            return t6;
          }
          function S(e, t6) {
            let r = {};
            for (let s in t6)
              ni.call(t6, s) && (r[s] = t6[s]);
            for (let s in e)
              ni.call(e, s) && (r[s] = e[s]);
            return r;
          }
          function H(e, t6) {
            for (let r in t6)
              ni.call(t6, r) && (e[r] = t6[r]);
          }
          function le(e, t6) {
            return t6 ? t6.bind(e) : void 0;
          }
          function Be2() {
            let e = /* @__PURE__ */ new Map();
            return e.add = rt, e.remove = ut, e;
          }
          function rt(e, t6) {
            let r = this.get(e);
            return r ? r.push(t6) : this.set(e, r = [t6]), r;
          }
          function ut(e, t6) {
            let r = this.get(e);
            r && (bT(r, t6), r.length || this.delete(e));
          }
          function Ht() {
            return Be2();
          }
          function Fr2(e) {
            let t6 = (e == null ? void 0 : e.slice()) || [], r = 0;
            function s() {
              return r === t6.length;
            }
            function f10() {
              t6.push(...arguments);
            }
            function x10() {
              if (s())
                throw new Error("Queue is empty");
              let w6 = t6[r];
              if (t6[r] = void 0, r++, r > 100 && r > t6.length >> 1) {
                let A6 = t6.length - r;
                t6.copyWithin(0, r), t6.length = A6, r = 0;
              }
              return w6;
            }
            return { enqueue: f10, dequeue: x10, isEmpty: s };
          }
          function Cr2(e, t6) {
            let r = /* @__PURE__ */ new Map(), s = 0;
            function* f10() {
              for (let w6 of r.values())
                ir2(w6) ? yield* w6 : yield w6;
            }
            let x10 = { has(w6) {
              let A6 = e(w6);
              if (!r.has(A6))
                return false;
              let g9 = r.get(A6);
              if (!ir2(g9))
                return t6(g9, w6);
              for (let B of g9)
                if (t6(B, w6))
                  return true;
              return false;
            }, add(w6) {
              let A6 = e(w6);
              if (r.has(A6)) {
                let g9 = r.get(A6);
                if (ir2(g9))
                  pe2(g9, w6, t6) || (g9.push(w6), s++);
                else {
                  let B = g9;
                  t6(B, w6) || (r.set(A6, [B, w6]), s++);
                }
              } else
                r.set(A6, w6), s++;
              return this;
            }, delete(w6) {
              let A6 = e(w6);
              if (!r.has(A6))
                return false;
              let g9 = r.get(A6);
              if (ir2(g9)) {
                for (let B = 0; B < g9.length; B++)
                  if (t6(g9[B], w6))
                    return g9.length === 1 ? r.delete(A6) : g9.length === 2 ? r.set(A6, g9[1 - B]) : U1(g9, B), s--, true;
              } else if (t6(g9, w6))
                return r.delete(A6), s--, true;
              return false;
            }, clear() {
              r.clear(), s = 0;
            }, get size() {
              return s;
            }, forEach(w6) {
              for (let A6 of Za(r.values()))
                if (ir2(A6))
                  for (let g9 of A6)
                    w6(g9, g9, x10);
                else {
                  let g9 = A6;
                  w6(g9, g9, x10);
                }
            }, keys() {
              return f10();
            }, values() {
              return f10();
            }, *entries() {
              for (let w6 of f10())
                yield [w6, w6];
            }, [Symbol.iterator]: () => f10(), [Symbol.toStringTag]: r[Symbol.toStringTag] };
            return x10;
          }
          function ir2(e) {
            return Array.isArray(e);
          }
          function en(e) {
            return ir2(e) ? e : [e];
          }
          function Ji(e) {
            return typeof e == "string";
          }
          function gi(e) {
            return typeof e == "number";
          }
          function ln(e, t6) {
            return e !== void 0 && t6(e) ? e : void 0;
          }
          function ti(e, t6) {
            return e !== void 0 && t6(e) ? e : Y3.fail(`Invalid cast. The supplied value ${e} did not pass the test '${Y3.getFunctionName(t6)}'.`);
          }
          function yn(e) {
          }
          function w_() {
            return false;
          }
          function vp() {
            return true;
          }
          function C1() {
          }
          function rr2(e) {
            return e;
          }
          function bp(e) {
            return e.toLowerCase();
          }
          function Tp(e) {
            return G1.test(e) ? e.replace(G1, bp) : e;
          }
          function A1() {
            throw new Error("Not implemented");
          }
          function tl(e) {
            let t6;
            return () => (e && (t6 = e(), e = void 0), t6);
          }
          function An(e) {
            let t6 = /* @__PURE__ */ new Map();
            return (r) => {
              let s = `${typeof r}:${r}`, f10 = t6.get(s);
              return f10 === void 0 && !t6.has(s) && (f10 = e(r), t6.set(s, f10)), f10;
            };
          }
          function P1(e) {
            let t6 = /* @__PURE__ */ new WeakMap();
            return (r) => {
              let s = t6.get(r);
              return s === void 0 && !t6.has(r) && (s = e(r), t6.set(r, s)), s;
            };
          }
          function D1(e, t6) {
            return function() {
              for (var r = arguments.length, s = new Array(r), f10 = 0; f10 < r; f10++)
                s[f10] = arguments[f10];
              let x10 = t6.get(s);
              return x10 === void 0 && !t6.has(s) && (x10 = e(...s), t6.set(s, x10)), x10;
            };
          }
          function k1(e, t6, r, s, f10) {
            if (f10) {
              let x10 = [];
              for (let w6 = 0; w6 < arguments.length; w6++)
                x10[w6] = arguments[w6];
              return (w6) => Qa(x10, (A6, g9) => g9(A6), w6);
            } else
              return s ? (x10) => s(r(t6(e(x10)))) : r ? (x10) => r(t6(e(x10))) : t6 ? (x10) => t6(e(x10)) : e ? (x10) => e(x10) : (x10) => x10;
          }
          function fa(e, t6) {
            return e === t6;
          }
          function Ms(e, t6) {
            return e === t6 || e !== void 0 && t6 !== void 0 && e.toUpperCase() === t6.toUpperCase();
          }
          function To(e, t6) {
            return fa(e, t6);
          }
          function Sp(e, t6) {
            return e === t6 ? 0 : e === void 0 ? -1 : t6 === void 0 ? 1 : e < t6 ? -1 : 1;
          }
          function Vr2(e, t6) {
            return Sp(e, t6);
          }
          function I1(e, t6) {
            return Vr2(e == null ? void 0 : e.start, t6 == null ? void 0 : t6.start) || Vr2(e == null ? void 0 : e.length, t6 == null ? void 0 : t6.length);
          }
          function N1(e, t6) {
            return Qa(e, (r, s) => t6(r, s) === -1 ? r : s);
          }
          function C_(e, t6) {
            return e === t6 ? 0 : e === void 0 ? -1 : t6 === void 0 ? 1 : (e = e.toUpperCase(), t6 = t6.toUpperCase(), e < t6 ? -1 : e > t6 ? 1 : 0);
          }
          function O1(e, t6) {
            return e === t6 ? 0 : e === void 0 ? -1 : t6 === void 0 ? 1 : (e = e.toLowerCase(), t6 = t6.toLowerCase(), e < t6 ? -1 : e > t6 ? 1 : 0);
          }
          function ri(e, t6) {
            return Sp(e, t6);
          }
          function rl(e) {
            return e ? C_ : ri;
          }
          function M1() {
            return Ap;
          }
          function xp(e) {
            Ap !== e && (Ap = e, K1 = void 0);
          }
          function L1(e, t6) {
            return (K1 || (K1 = AT(Ap)))(e, t6);
          }
          function R1(e, t6, r, s) {
            return e === t6 ? 0 : e === void 0 ? -1 : t6 === void 0 ? 1 : s(e[r], t6[r]);
          }
          function j1(e, t6) {
            return Vr2(e ? 1 : 0, t6 ? 1 : 0);
          }
          function Ep(e, t6, r) {
            let s = Math.max(2, Math.floor(e.length * 0.34)), f10 = Math.floor(e.length * 0.4) + 1, x10;
            for (let w6 of t6) {
              let A6 = r(w6);
              if (A6 !== void 0 && Math.abs(A6.length - e.length) <= s) {
                if (A6 === e || A6.length < 3 && A6.toLowerCase() !== e.toLowerCase())
                  continue;
                let g9 = J1(e, A6, f10 - 0.1);
                if (g9 === void 0)
                  continue;
                Y3.assert(g9 < f10), f10 = g9, x10 = w6;
              }
            }
            return x10;
          }
          function J1(e, t6, r) {
            let s = new Array(t6.length + 1), f10 = new Array(t6.length + 1), x10 = r + 0.01;
            for (let A6 = 0; A6 <= t6.length; A6++)
              s[A6] = A6;
            for (let A6 = 1; A6 <= e.length; A6++) {
              let g9 = e.charCodeAt(A6 - 1), B = Math.ceil(A6 > r ? A6 - r : 1), N10 = Math.floor(t6.length > r + A6 ? r + A6 : t6.length);
              f10[0] = A6;
              let X2 = A6;
              for (let $ = 1; $ < B; $++)
                f10[$] = x10;
              for (let $ = B; $ <= N10; $++) {
                let ae = e[A6 - 1].toLowerCase() === t6[$ - 1].toLowerCase() ? s[$ - 1] + 0.1 : s[$ - 1] + 2, Te2 = g9 === t6.charCodeAt($ - 1) ? s[$ - 1] : Math.min(s[$] + 1, f10[$ - 1] + 1, ae);
                f10[$] = Te2, X2 = Math.min(X2, Te2);
              }
              for (let $ = N10 + 1; $ <= t6.length; $++)
                f10[$] = x10;
              if (X2 > r)
                return;
              let F2 = s;
              s = f10, f10 = F2;
            }
            let w6 = s[t6.length];
            return w6 > r ? void 0 : w6;
          }
          function es(e, t6) {
            let r = e.length - t6.length;
            return r >= 0 && e.indexOf(t6, r) === r;
          }
          function F1(e, t6) {
            return es(e, t6) ? e.slice(0, e.length - t6.length) : e;
          }
          function B1(e, t6) {
            return es(e, t6) ? e.slice(0, e.length - t6.length) : void 0;
          }
          function Fi(e, t6) {
            return e.indexOf(t6) !== -1;
          }
          function q1(e) {
            let t6 = e.length;
            for (let r = t6 - 1; r > 0; r--) {
              let s = e.charCodeAt(r);
              if (s >= 48 && s <= 57)
                do
                  --r, s = e.charCodeAt(r);
                while (r > 0 && s >= 48 && s <= 57);
              else if (r > 4 && (s === 110 || s === 78)) {
                if (--r, s = e.charCodeAt(r), s !== 105 && s !== 73 || (--r, s = e.charCodeAt(r), s !== 109 && s !== 77))
                  break;
                --r, s = e.charCodeAt(r);
              } else
                break;
              if (s !== 45 && s !== 46)
                break;
              t6 = r;
            }
            return t6 === e.length ? e : e.slice(0, t6);
          }
          function J3(e, t6) {
            for (let r = 0; r < e.length; r++)
              if (e[r] === t6)
                return vT(e, r), true;
            return false;
          }
          function vT(e, t6) {
            for (let r = t6; r < e.length - 1; r++)
              e[r] = e[r + 1];
            e.pop();
          }
          function U1(e, t6) {
            e[t6] = e[e.length - 1], e.pop();
          }
          function bT(e, t6) {
            return b5(e, (r) => r === t6);
          }
          function b5(e, t6) {
            for (let r = 0; r < e.length; r++)
              if (t6(e[r]))
                return U1(e, r), true;
            return false;
          }
          function wp(e) {
            return e ? rr2 : Tp;
          }
          function T5(e) {
            let { prefix: t6, suffix: r } = e;
            return `${t6}*${r}`;
          }
          function S5(e, t6) {
            return Y3.assert(z1(e, t6)), t6.substring(e.prefix.length, t6.length - e.suffix.length);
          }
          function TT(e, t6, r) {
            let s, f10 = -1;
            for (let x10 of e) {
              let w6 = t6(x10);
              z1(w6, r) && w6.prefix.length > f10 && (f10 = w6.prefix.length, s = x10);
            }
            return s;
          }
          function Pn(e, t6) {
            return e.lastIndexOf(t6, 0) === 0;
          }
          function x5(e, t6) {
            return Pn(e, t6) ? e.substr(t6.length) : e;
          }
          function ST(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rr2;
            return Pn(r(e), r(t6)) ? e.substring(t6.length) : void 0;
          }
          function z1(e, t6) {
            let { prefix: r, suffix: s } = e;
            return t6.length >= r.length + s.length && Pn(t6, r) && es(t6, s);
          }
          function E5(e, t6) {
            return (r) => e(r) && t6(r);
          }
          function W1() {
            for (var e = arguments.length, t6 = new Array(e), r = 0; r < e; r++)
              t6[r] = arguments[r];
            return function() {
              let s;
              for (let f10 of t6)
                if (s = f10(...arguments), s)
                  return s;
              return s;
            };
          }
          function w5(e) {
            return function() {
              return !e(...arguments);
            };
          }
          function C5(e) {
          }
          function Cp(e) {
            return e === void 0 ? void 0 : [e];
          }
          function A5(e, t6, r, s, f10, x10) {
            x10 = x10 || yn;
            let w6 = 0, A6 = 0, g9 = e.length, B = t6.length, N10 = false;
            for (; w6 < g9 && A6 < B; ) {
              let X2 = e[w6], F2 = t6[A6], $ = r(X2, F2);
              $ === -1 ? (s(X2), w6++, N10 = true) : $ === 1 ? (f10(F2), A6++, N10 = true) : (x10(F2, X2), w6++, A6++);
            }
            for (; w6 < g9; )
              s(e[w6++]), N10 = true;
            for (; A6 < B; )
              f10(t6[A6++]), N10 = true;
            return N10;
          }
          function P5(e) {
            let t6 = [];
            return xT(e, t6, void 0, 0), t6;
          }
          function xT(e, t6, r, s) {
            for (let f10 of e[s]) {
              let x10;
              r ? (x10 = r.slice(), x10.push(f10)) : x10 = [f10], s === e.length - 1 ? t6.push(x10) : xT(e, t6, x10, s + 1);
            }
          }
          function D5(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : " ";
            return t6 <= e.length ? e : r.repeat(t6 - e.length) + e;
          }
          function k5(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : " ";
            return t6 <= e.length ? e : e + r.repeat(t6 - e.length);
          }
          function I5(e, t6) {
            if (e) {
              let r = e.length, s = 0;
              for (; s < r && t6(e[s]); )
                s++;
              return e.slice(0, s);
            }
          }
          function N5(e, t6) {
            if (e) {
              let r = e.length, s = 0;
              for (; s < r && t6(e[s]); )
                s++;
              return e.slice(s);
            }
          }
          function O5(e) {
            let t6 = e.length - 1;
            for (; t6 >= 0 && os(e.charCodeAt(t6)); )
              t6--;
            return e.slice(0, t6 + 1);
          }
          function M5() {
            return typeof cn < "u" && cn.nextTick && !cn.browser && typeof _ == "object";
          }
          var Bt, V1, ET, H1, wT, ni, CT, G1, $1, AT, K1, Ap, Pp, X1, nl, L5 = D({ "src/compiler/core.ts"() {
            "use strict";
            nn(), Bt = [], V1 = /* @__PURE__ */ new Map(), ET = /* @__PURE__ */ new Set(), H1 = ((e) => (e[e.None = 0] = "None", e[e.CaseSensitive = 1] = "CaseSensitive", e[e.CaseInsensitive = 2] = "CaseInsensitive", e[e.Both = 3] = "Both", e))(H1 || {}), wT = Array.prototype.at ? (e, t6) => e == null ? void 0 : e.at(t6) : (e, t6) => {
              if (e && (t6 = po(e, t6), t6 < e.length))
                return e[t6];
            }, ni = Object.prototype.hasOwnProperty, CT = { push: yn, length: 0 }, G1 = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g, $1 = ((e) => (e[e.None = 0] = "None", e[e.Normal = 1] = "Normal", e[e.Aggressive = 2] = "Aggressive", e[e.VeryAggressive = 3] = "VeryAggressive", e))($1 || {}), AT = (() => {
              let e, t6, r = A6();
              return g9;
              function s(B, N10, X2) {
                if (B === N10)
                  return 0;
                if (B === void 0)
                  return -1;
                if (N10 === void 0)
                  return 1;
                let F2 = X2(B, N10);
                return F2 < 0 ? -1 : F2 > 0 ? 1 : 0;
              }
              function f10(B) {
                let N10 = new Intl.Collator(B, { usage: "sort", sensitivity: "variant" }).compare;
                return (X2, F2) => s(X2, F2, N10);
              }
              function x10(B) {
                if (B !== void 0)
                  return w6();
                return (X2, F2) => s(X2, F2, N10);
                function N10(X2, F2) {
                  return X2.localeCompare(F2);
                }
              }
              function w6() {
                return (X2, F2) => s(X2, F2, B);
                function B(X2, F2) {
                  return N10(X2.toUpperCase(), F2.toUpperCase()) || N10(X2, F2);
                }
                function N10(X2, F2) {
                  return X2 < F2 ? -1 : X2 > F2 ? 1 : 0;
                }
              }
              function A6() {
                return typeof Intl == "object" && typeof Intl.Collator == "function" ? f10 : typeof String.prototype.localeCompare == "function" && typeof String.prototype.toLocaleUpperCase == "function" && "a".localeCompare("B") < 0 ? x10 : w6;
              }
              function g9(B) {
                return B === void 0 ? e || (e = r(B)) : B === "en-US" ? t6 || (t6 = r(B)) : r(B);
              }
            })(), Pp = String.prototype.trim ? (e) => e.trim() : (e) => X1(nl(e)), X1 = String.prototype.trimEnd ? (e) => e.trimEnd() : O5, nl = String.prototype.trimStart ? (e) => e.trimStart() : (e) => e.replace(/^\s+/g, "");
          } }), Y1, Y3, PT = D({ "src/compiler/debug.ts"() {
            "use strict";
            nn(), nn(), Y1 = ((e) => (e[e.Off = 0] = "Off", e[e.Error = 1] = "Error", e[e.Warning = 2] = "Warning", e[e.Info = 3] = "Info", e[e.Verbose = 4] = "Verbose", e))(Y1 || {}), ((e) => {
              let t6 = 0;
              e.currentLogLevel = 2, e.isDebugging = false;
              function r(ue2) {
                return e.currentLogLevel <= ue2;
              }
              e.shouldLog = r;
              function s(ue2, He2) {
                e.loggingHost && r(ue2) && e.loggingHost.log(ue2, He2);
              }
              function f10(ue2) {
                s(3, ue2);
              }
              e.log = f10, ((ue2) => {
                function He2(zt) {
                  s(1, zt);
                }
                ue2.error = He2;
                function _t(zt) {
                  s(2, zt);
                }
                ue2.warn = _t;
                function ft(zt) {
                  s(3, zt);
                }
                ue2.log = ft;
                function Kt(zt) {
                  s(4, zt);
                }
                ue2.trace = Kt;
              })(f10 = e.log || (e.log = {}));
              let x10 = {};
              function w6() {
                return t6;
              }
              e.getAssertionLevel = w6;
              function A6(ue2) {
                let He2 = t6;
                if (t6 = ue2, ue2 > He2)
                  for (let _t of ho(x10)) {
                    let ft = x10[_t];
                    ft !== void 0 && e[_t] !== ft.assertion && ue2 >= ft.level && (e[_t] = ft, x10[_t] = void 0);
                  }
              }
              e.setAssertionLevel = A6;
              function g9(ue2) {
                return t6 >= ue2;
              }
              e.shouldAssert = g9;
              function B(ue2, He2) {
                return g9(ue2) ? true : (x10[He2] = { level: ue2, assertion: e[He2] }, e[He2] = yn, false);
              }
              function N10(ue2, He2) {
                debugger;
                let _t = new Error(ue2 ? `Debug Failure. ${ue2}` : "Debug Failure.");
                throw Error.captureStackTrace && Error.captureStackTrace(_t, He2 || N10), _t;
              }
              e.fail = N10;
              function X2(ue2, He2, _t) {
                return N10(`${He2 || "Unexpected node."}\r
Node ${mr2(ue2.kind)} was unexpected.`, _t || X2);
              }
              e.failBadSyntaxKind = X2;
              function F2(ue2, He2, _t, ft) {
                ue2 || (He2 = He2 ? `False expression: ${He2}` : "False expression.", _t && (He2 += `\r
Verbose Debug Information: ` + (typeof _t == "string" ? _t : _t())), N10(He2, ft || F2));
              }
              e.assert = F2;
              function $(ue2, He2, _t, ft, Kt) {
                if (ue2 !== He2) {
                  let zt = _t ? ft ? `${_t} ${ft}` : _t : "";
                  N10(`Expected ${ue2} === ${He2}. ${zt}`, Kt || $);
                }
              }
              e.assertEqual = $;
              function ae(ue2, He2, _t, ft) {
                ue2 >= He2 && N10(`Expected ${ue2} < ${He2}. ${_t || ""}`, ft || ae);
              }
              e.assertLessThan = ae;
              function Te2(ue2, He2, _t) {
                ue2 > He2 && N10(`Expected ${ue2} <= ${He2}`, _t || Te2);
              }
              e.assertLessThanOrEqual = Te2;
              function Se2(ue2, He2, _t) {
                ue2 < He2 && N10(`Expected ${ue2} >= ${He2}`, _t || Se2);
              }
              e.assertGreaterThanOrEqual = Se2;
              function Ye2(ue2, He2, _t) {
                ue2 == null && N10(He2, _t || Ye2);
              }
              e.assertIsDefined = Ye2;
              function Ne2(ue2, He2, _t) {
                return Ye2(ue2, He2, _t || Ne2), ue2;
              }
              e.checkDefined = Ne2;
              function oe2(ue2, He2, _t) {
                for (let ft of ue2)
                  Ye2(ft, He2, _t || oe2);
              }
              e.assertEachIsDefined = oe2;
              function Ve2(ue2, He2, _t) {
                return oe2(ue2, He2, _t || Ve2), ue2;
              }
              e.checkEachDefined = Ve2;
              function pt2(ue2) {
                let He2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Illegal value:", _t = arguments.length > 2 ? arguments[2] : void 0, ft = typeof ue2 == "object" && Jr(ue2, "kind") && Jr(ue2, "pos") ? "SyntaxKind: " + mr2(ue2.kind) : JSON.stringify(ue2);
                return N10(`${He2} ${ft}`, _t || pt2);
              }
              e.assertNever = pt2;
              function Gt(ue2, He2, _t, ft) {
                B(1, "assertEachNode") && F2(He2 === void 0 || me2(ue2, He2), _t || "Unexpected node.", () => `Node array did not pass test '${pn(He2)}'.`, ft || Gt);
              }
              e.assertEachNode = Gt;
              function Nt(ue2, He2, _t, ft) {
                B(1, "assertNode") && F2(ue2 !== void 0 && (He2 === void 0 || He2(ue2)), _t || "Unexpected node.", () => `Node ${mr2(ue2 == null ? void 0 : ue2.kind)} did not pass test '${pn(He2)}'.`, ft || Nt);
              }
              e.assertNode = Nt;
              function Xt(ue2, He2, _t, ft) {
                B(1, "assertNotNode") && F2(ue2 === void 0 || He2 === void 0 || !He2(ue2), _t || "Unexpected node.", () => `Node ${mr2(ue2.kind)} should not have passed test '${pn(He2)}'.`, ft || Xt);
              }
              e.assertNotNode = Xt;
              function er2(ue2, He2, _t, ft) {
                B(1, "assertOptionalNode") && F2(He2 === void 0 || ue2 === void 0 || He2(ue2), _t || "Unexpected node.", () => `Node ${mr2(ue2 == null ? void 0 : ue2.kind)} did not pass test '${pn(He2)}'.`, ft || er2);
              }
              e.assertOptionalNode = er2;
              function Tn(ue2, He2, _t, ft) {
                B(1, "assertOptionalToken") && F2(He2 === void 0 || ue2 === void 0 || ue2.kind === He2, _t || "Unexpected node.", () => `Node ${mr2(ue2 == null ? void 0 : ue2.kind)} was not a '${mr2(He2)}' token.`, ft || Tn);
              }
              e.assertOptionalToken = Tn;
              function Hr2(ue2, He2, _t) {
                B(1, "assertMissingNode") && F2(ue2 === void 0, He2 || "Unexpected node.", () => `Node ${mr2(ue2.kind)} was unexpected'.`, _t || Hr2);
              }
              e.assertMissingNode = Hr2;
              function Gi(ue2) {
              }
              e.type = Gi;
              function pn(ue2) {
                if (typeof ue2 != "function")
                  return "";
                if (Jr(ue2, "name"))
                  return ue2.name;
                {
                  let He2 = Function.prototype.toString.call(ue2), _t = /^function\s+([\w\$]+)\s*\(/.exec(He2);
                  return _t ? _t[1] : "";
                }
              }
              e.getFunctionName = pn;
              function fn(ue2) {
                return `{ name: ${dl(ue2.escapedName)}; flags: ${Sn(ue2.flags)}; declarations: ${Ze2(ue2.declarations, (He2) => mr2(He2.kind))} }`;
              }
              e.formatSymbol = fn;
              function Ut() {
                let ue2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, He2 = arguments.length > 1 ? arguments[1] : void 0, _t = arguments.length > 2 ? arguments[2] : void 0, ft = an(He2);
                if (ue2 === 0)
                  return ft.length > 0 && ft[0][0] === 0 ? ft[0][1] : "0";
                if (_t) {
                  let Kt = [], zt = ue2;
                  for (let [xe2, Le2] of ft) {
                    if (xe2 > ue2)
                      break;
                    xe2 !== 0 && xe2 & ue2 && (Kt.push(Le2), zt &= ~xe2);
                  }
                  if (zt === 0)
                    return Kt.join("|");
                } else
                  for (let [Kt, zt] of ft)
                    if (Kt === ue2)
                      return zt;
                return ue2.toString();
              }
              e.formatEnum = Ut;
              let kn = /* @__PURE__ */ new Map();
              function an(ue2) {
                let He2 = kn.get(ue2);
                if (He2)
                  return He2;
                let _t = [];
                for (let Kt in ue2) {
                  let zt = ue2[Kt];
                  typeof zt == "number" && _t.push([zt, Kt]);
                }
                let ft = Ns(_t, (Kt, zt) => Vr2(Kt[0], zt[0]));
                return kn.set(ue2, ft), ft;
              }
              function mr2(ue2) {
                return Ut(ue2, Np, false);
              }
              e.formatSyntaxKind = mr2;
              function $i(ue2) {
                return Ut(ue2, zp, false);
              }
              e.formatSnippetKind = $i;
              function dn(ue2) {
                return Ut(ue2, Op, true);
              }
              e.formatNodeFlags = dn;
              function Ur2(ue2) {
                return Ut(ue2, Mp, true);
              }
              e.formatModifierFlags = Ur2;
              function Gr2(ue2) {
                return Ut(ue2, Up, true);
              }
              e.formatTransformFlags = Gr2;
              function _r2(ue2) {
                return Ut(ue2, Wp, true);
              }
              e.formatEmitFlags = _r2;
              function Sn(ue2) {
                return Ut(ue2, jp, true);
              }
              e.formatSymbolFlags = Sn;
              function In(ue2) {
                return Ut(ue2, Jp, true);
              }
              e.formatTypeFlags = In;
              function pr2(ue2) {
                return Ut(ue2, Bp, true);
              }
              e.formatSignatureFlags = pr2;
              function Zt(ue2) {
                return Ut(ue2, Fp, true);
              }
              e.formatObjectFlags = Zt;
              function Or2(ue2) {
                return Ut(ue2, il, true);
              }
              e.formatFlowFlags = Or2;
              function Nn(ue2) {
                return Ut(ue2, Lp, true);
              }
              e.formatRelationComparisonResult = Nn;
              function ar2(ue2) {
                return Ut(ue2, CheckMode, true);
              }
              e.formatCheckMode = ar2;
              function oi(ue2) {
                return Ut(ue2, SignatureCheckMode, true);
              }
              e.formatSignatureCheckMode = oi;
              function cr2(ue2) {
                return Ut(ue2, TypeFacts, true);
              }
              e.formatTypeFacts = cr2;
              let $r2 = false, hr2;
              function On(ue2) {
                "__debugFlowFlags" in ue2 || Object.defineProperties(ue2, { __tsDebuggerDisplay: { value() {
                  let He2 = this.flags & 2 ? "FlowStart" : this.flags & 4 ? "FlowBranchLabel" : this.flags & 8 ? "FlowLoopLabel" : this.flags & 16 ? "FlowAssignment" : this.flags & 32 ? "FlowTrueCondition" : this.flags & 64 ? "FlowFalseCondition" : this.flags & 128 ? "FlowSwitchClause" : this.flags & 256 ? "FlowArrayMutation" : this.flags & 512 ? "FlowCall" : this.flags & 1024 ? "FlowReduceLabel" : this.flags & 1 ? "FlowUnreachable" : "UnknownFlow", _t = this.flags & ~(2048 - 1);
                  return `${He2}${_t ? ` (${Or2(_t)})` : ""}`;
                } }, __debugFlowFlags: { get() {
                  return Ut(this.flags, il, true);
                } }, __debugToString: { value() {
                  return St(this);
                } } });
              }
              function nr2(ue2) {
                $r2 && (typeof Object.setPrototypeOf == "function" ? (hr2 || (hr2 = Object.create(Object.prototype), On(hr2)), Object.setPrototypeOf(ue2, hr2)) : On(ue2));
              }
              e.attachFlowNodeDebugInfo = nr2;
              let br2;
              function Kr2(ue2) {
                "__tsDebuggerDisplay" in ue2 || Object.defineProperties(ue2, { __tsDebuggerDisplay: { value(He2) {
                  return He2 = String(He2).replace(/(?:,[\s\w\d_]+:[^,]+)+\]$/, "]"), `NodeArray ${He2}`;
                } } });
              }
              function wa(ue2) {
                $r2 && (typeof Object.setPrototypeOf == "function" ? (br2 || (br2 = Object.create(Array.prototype), Kr2(br2)), Object.setPrototypeOf(ue2, br2)) : Kr2(ue2));
              }
              e.attachNodeArrayDebugInfo = wa;
              function $n() {
                if ($r2)
                  return;
                let ue2 = /* @__PURE__ */ new WeakMap(), He2 = /* @__PURE__ */ new WeakMap();
                Object.defineProperties(lr2.getSymbolConstructor().prototype, { __tsDebuggerDisplay: { value() {
                  let ft = this.flags & 33554432 ? "TransientSymbol" : "Symbol", Kt = this.flags & -33554433;
                  return `${ft} '${rf(this)}'${Kt ? ` (${Sn(Kt)})` : ""}`;
                } }, __debugFlags: { get() {
                  return Sn(this.flags);
                } } }), Object.defineProperties(lr2.getTypeConstructor().prototype, { __tsDebuggerDisplay: { value() {
                  let ft = this.flags & 98304 ? "NullableType" : this.flags & 384 ? `LiteralType ${JSON.stringify(this.value)}` : this.flags & 2048 ? `LiteralType ${this.value.negative ? "-" : ""}${this.value.base10Value}n` : this.flags & 8192 ? "UniqueESSymbolType" : this.flags & 32 ? "EnumType" : this.flags & 67359327 ? `IntrinsicType ${this.intrinsicName}` : this.flags & 1048576 ? "UnionType" : this.flags & 2097152 ? "IntersectionType" : this.flags & 4194304 ? "IndexType" : this.flags & 8388608 ? "IndexedAccessType" : this.flags & 16777216 ? "ConditionalType" : this.flags & 33554432 ? "SubstitutionType" : this.flags & 262144 ? "TypeParameter" : this.flags & 524288 ? this.objectFlags & 3 ? "InterfaceType" : this.objectFlags & 4 ? "TypeReference" : this.objectFlags & 8 ? "TupleType" : this.objectFlags & 16 ? "AnonymousType" : this.objectFlags & 32 ? "MappedType" : this.objectFlags & 1024 ? "ReverseMappedType" : this.objectFlags & 256 ? "EvolvingArrayType" : "ObjectType" : "Type", Kt = this.flags & 524288 ? this.objectFlags & -1344 : 0;
                  return `${ft}${this.symbol ? ` '${rf(this.symbol)}'` : ""}${Kt ? ` (${Zt(Kt)})` : ""}`;
                } }, __debugFlags: { get() {
                  return In(this.flags);
                } }, __debugObjectFlags: { get() {
                  return this.flags & 524288 ? Zt(this.objectFlags) : "";
                } }, __debugTypeToString: { value() {
                  let ft = ue2.get(this);
                  return ft === void 0 && (ft = this.checker.typeToString(this), ue2.set(this, ft)), ft;
                } } }), Object.defineProperties(lr2.getSignatureConstructor().prototype, { __debugFlags: { get() {
                  return pr2(this.flags);
                } }, __debugSignatureToString: { value() {
                  var ft;
                  return (ft = this.checker) == null ? void 0 : ft.signatureToString(this);
                } } });
                let _t = [lr2.getNodeConstructor(), lr2.getIdentifierConstructor(), lr2.getTokenConstructor(), lr2.getSourceFileConstructor()];
                for (let ft of _t)
                  Jr(ft.prototype, "__debugKind") || Object.defineProperties(ft.prototype, { __tsDebuggerDisplay: { value() {
                    return `${cs(this) ? "GeneratedIdentifier" : yt(this) ? `Identifier '${qr2(this)}'` : vn(this) ? `PrivateIdentifier '${qr2(this)}'` : Gn(this) ? `StringLiteral ${JSON.stringify(this.text.length < 10 ? this.text : this.text.slice(10) + "...")}` : zs(this) ? `NumericLiteral ${this.text}` : Uv(this) ? `BigIntLiteral ${this.text}n` : Fo(this) ? "TypeParameterDeclaration" : Vs(this) ? "ParameterDeclaration" : nc(this) ? "ConstructorDeclaration" : Gl(this) ? "GetAccessorDeclaration" : ic(this) ? "SetAccessorDeclaration" : Vv(this) ? "CallSignatureDeclaration" : R8(this) ? "ConstructSignatureDeclaration" : Hv(this) ? "IndexSignatureDeclaration" : j8(this) ? "TypePredicateNode" : ac(this) ? "TypeReferenceNode" : $l(this) ? "FunctionTypeNode" : Gv(this) ? "ConstructorTypeNode" : J8(this) ? "TypeQueryNode" : id(this) ? "TypeLiteralNode" : F8(this) ? "ArrayTypeNode" : B8(this) ? "TupleTypeNode" : q8(this) ? "OptionalTypeNode" : U8(this) ? "RestTypeNode" : z8(this) ? "UnionTypeNode" : W8(this) ? "IntersectionTypeNode" : V8(this) ? "ConditionalTypeNode" : H8(this) ? "InferTypeNode" : Kv(this) ? "ParenthesizedTypeNode" : Xv(this) ? "ThisTypeNode" : G8(this) ? "TypeOperatorNode" : $8(this) ? "IndexedAccessTypeNode" : K8(this) ? "MappedTypeNode" : Yv(this) ? "LiteralTypeNode" : $v(this) ? "NamedTupleMember" : Kl(this) ? "ImportTypeNode" : mr2(this.kind)}${this.flags ? ` (${dn(this.flags)})` : ""}`;
                  } }, __debugKind: { get() {
                    return mr2(this.kind);
                  } }, __debugNodeFlags: { get() {
                    return dn(this.flags);
                  } }, __debugModifierFlags: { get() {
                    return Ur2(Y4(this));
                  } }, __debugTransformFlags: { get() {
                    return Gr2(this.transformFlags);
                  } }, __debugIsParseTreeNode: { get() {
                    return pl(this);
                  } }, __debugEmitFlags: { get() {
                    return _r2(xi(this));
                  } }, __debugGetText: { value(Kt) {
                    if (fs(this))
                      return "";
                    let zt = He2.get(this);
                    if (zt === void 0) {
                      let xe2 = fl(this), Le2 = xe2 && Si(xe2);
                      zt = Le2 ? No(Le2, xe2, Kt) : "", He2.set(this, zt);
                    }
                    return zt;
                  } } });
                $r2 = true;
              }
              e.enableDebugInfo = $n;
              function Ki(ue2) {
                let He2 = ue2 & 7, _t = He2 === 0 ? "in out" : He2 === 3 ? "[bivariant]" : He2 === 2 ? "in" : He2 === 1 ? "out" : He2 === 4 ? "[independent]" : "";
                return ue2 & 8 ? _t += " (unmeasurable)" : ue2 & 16 && (_t += " (unreliable)"), _t;
              }
              e.formatVariance = Ki;
              class Mn {
                __debugToString() {
                  var He2;
                  switch (this.kind) {
                    case 3:
                      return ((He2 = this.debugInfo) == null ? void 0 : He2.call(this)) || "(function mapper)";
                    case 0:
                      return `${this.source.__debugTypeToString()} -> ${this.target.__debugTypeToString()}`;
                    case 1:
                      return ce2(this.sources, this.targets || Ze2(this.sources, () => "any"), (_t, ft) => `${_t.__debugTypeToString()} -> ${typeof ft == "string" ? ft : ft.__debugTypeToString()}`).join(", ");
                    case 2:
                      return ce2(this.sources, this.targets, (_t, ft) => `${_t.__debugTypeToString()} -> ${ft().__debugTypeToString()}`).join(", ");
                    case 5:
                    case 4:
                      return `m1: ${this.mapper1.__debugToString().split(`
`).join(`
    `)}
m2: ${this.mapper2.__debugToString().split(`
`).join(`
    `)}`;
                    default:
                      return pt2(this);
                  }
                }
              }
              e.DebugTypeMapper = Mn;
              function _i(ue2) {
                return e.isDebugging ? Object.setPrototypeOf(ue2, Mn.prototype) : ue2;
              }
              e.attachDebugPrototypeIfDebug = _i;
              function Ca(ue2) {
                return console.log(St(ue2));
              }
              e.printControlFlowGraph = Ca;
              function St(ue2) {
                let He2 = -1;
                function _t(U2) {
                  return U2.id || (U2.id = He2, He2--), U2.id;
                }
                let ft;
                ((U2) => {
                  U2.lr = "â", U2.ud = "â", U2.dr = "â­", U2.dl = "â®", U2.ul = "â¯", U2.ur = "â°", U2.udr = "â", U2.udl = "â¤", U2.dlr = "â¬", U2.ulr = "â´", U2.udlr = "â«";
                })(ft || (ft = {}));
                let Kt;
                ((U2) => {
                  U2[U2.None = 0] = "None", U2[U2.Up = 1] = "Up", U2[U2.Down = 2] = "Down", U2[U2.Left = 4] = "Left", U2[U2.Right = 8] = "Right", U2[U2.UpDown = 3] = "UpDown", U2[U2.LeftRight = 12] = "LeftRight", U2[U2.UpLeft = 5] = "UpLeft", U2[U2.UpRight = 9] = "UpRight", U2[U2.DownLeft = 6] = "DownLeft", U2[U2.DownRight = 10] = "DownRight", U2[U2.UpDownLeft = 7] = "UpDownLeft", U2[U2.UpDownRight = 11] = "UpDownRight", U2[U2.UpLeftRight = 13] = "UpLeftRight", U2[U2.DownLeftRight = 14] = "DownLeftRight", U2[U2.UpDownLeftRight = 15] = "UpDownLeftRight", U2[U2.NoChildren = 16] = "NoChildren";
                })(Kt || (Kt = {}));
                let zt = 2032, xe2 = 882, Le2 = /* @__PURE__ */ Object.create(null), Re2 = [], ot2 = [], Ct = Aa(ue2, /* @__PURE__ */ new Set());
                for (let U2 of Re2)
                  U2.text = xn(U2.flowNode, U2.circular), $s(U2);
                let Mt = li(Ct), It = Yi2(Mt);
                return Qi(Ct, 0), Dt();
                function Mr2(U2) {
                  return !!(U2.flags & 128);
                }
                function gr2(U2) {
                  return !!(U2.flags & 12) && !!U2.antecedents;
                }
                function Ln(U2) {
                  return !!(U2.flags & zt);
                }
                function ys(U2) {
                  return !!(U2.flags & xe2);
                }
                function ci(U2) {
                  let L = [];
                  for (let fe2 of U2.edges)
                    fe2.source === U2 && L.push(fe2.target);
                  return L;
                }
                function Xi(U2) {
                  let L = [];
                  for (let fe2 of U2.edges)
                    fe2.target === U2 && L.push(fe2.source);
                  return L;
                }
                function Aa(U2, L) {
                  let fe2 = _t(U2), T = Le2[fe2];
                  if (T && L.has(U2))
                    return T.circular = true, T = { id: -1, flowNode: U2, edges: [], text: "", lane: -1, endLane: -1, level: -1, circular: "circularity" }, Re2.push(T), T;
                  if (L.add(U2), !T)
                    if (Le2[fe2] = T = { id: fe2, flowNode: U2, edges: [], text: "", lane: -1, endLane: -1, level: -1, circular: false }, Re2.push(T), gr2(U2))
                      for (let it of U2.antecedents)
                        vs(T, it, L);
                    else
                      Ln(U2) && vs(T, U2.antecedent, L);
                  return L.delete(U2), T;
                }
                function vs(U2, L, fe2) {
                  let T = Aa(L, fe2), it = { source: U2, target: T };
                  ot2.push(it), U2.edges.push(it), T.edges.push(it);
                }
                function $s(U2) {
                  if (U2.level !== -1)
                    return U2.level;
                  let L = 0;
                  for (let fe2 of Xi(U2))
                    L = Math.max(L, $s(fe2) + 1);
                  return U2.level = L;
                }
                function li(U2) {
                  let L = 0;
                  for (let fe2 of ci(U2))
                    L = Math.max(L, li(fe2));
                  return L + 1;
                }
                function Yi2(U2) {
                  let L = Z(Array(U2), 0);
                  for (let fe2 of Re2)
                    L[fe2.level] = Math.max(L[fe2.level], fe2.text.length);
                  return L;
                }
                function Qi(U2, L) {
                  if (U2.lane === -1) {
                    U2.lane = L, U2.endLane = L;
                    let fe2 = ci(U2);
                    for (let T = 0; T < fe2.length; T++) {
                      T > 0 && L++;
                      let it = fe2[T];
                      Qi(it, L), it.endLane > U2.endLane && (L = it.endLane);
                    }
                    U2.endLane = L;
                  }
                }
                function bs(U2) {
                  if (U2 & 2)
                    return "Start";
                  if (U2 & 4)
                    return "Branch";
                  if (U2 & 8)
                    return "Loop";
                  if (U2 & 16)
                    return "Assignment";
                  if (U2 & 32)
                    return "True";
                  if (U2 & 64)
                    return "False";
                  if (U2 & 128)
                    return "SwitchClause";
                  if (U2 & 256)
                    return "ArrayMutation";
                  if (U2 & 512)
                    return "Call";
                  if (U2 & 1024)
                    return "ReduceLabel";
                  if (U2 & 1)
                    return "Unreachable";
                  throw new Error();
                }
                function Ai(U2) {
                  let L = Si(U2);
                  return No(L, U2, false);
                }
                function xn(U2, L) {
                  let fe2 = bs(U2.flags);
                  if (L && (fe2 = `${fe2}#${_t(U2)}`), ys(U2))
                    U2.node && (fe2 += ` (${Ai(U2.node)})`);
                  else if (Mr2(U2)) {
                    let T = [];
                    for (let it = U2.clauseStart; it < U2.clauseEnd; it++) {
                      let mt = U2.switchStatement.caseBlock.clauses[it];
                      oE(mt) ? T.push("default") : T.push(Ai(mt.expression));
                    }
                    fe2 += ` (${T.join(", ")})`;
                  }
                  return L === "circularity" ? `Circular(${fe2})` : fe2;
                }
                function Dt() {
                  let U2 = It.length, L = Re2.reduce((_e, Ge2) => Math.max(_e, Ge2.lane), 0) + 1, fe2 = Z(Array(L), ""), T = It.map(() => Array(L)), it = It.map(() => Z(Array(L), 0));
                  for (let _e of Re2) {
                    T[_e.level][_e.lane] = _e;
                    let Ge2 = ci(_e);
                    for (let jt = 0; jt < Ge2.length; jt++) {
                      let Yt = Ge2[jt], $t = 8;
                      Yt.lane === _e.lane && ($t |= 4), jt > 0 && ($t |= 1), jt < Ge2.length - 1 && ($t |= 2), it[_e.level][Yt.lane] |= $t;
                    }
                    Ge2.length === 0 && (it[_e.level][_e.lane] |= 16);
                    let bt = Xi(_e);
                    for (let jt = 0; jt < bt.length; jt++) {
                      let Yt = bt[jt], $t = 4;
                      jt > 0 && ($t |= 1), jt < bt.length - 1 && ($t |= 2), it[_e.level - 1][Yt.lane] |= $t;
                    }
                  }
                  for (let _e = 0; _e < U2; _e++)
                    for (let Ge2 = 0; Ge2 < L; Ge2++) {
                      let bt = _e > 0 ? it[_e - 1][Ge2] : 0, jt = Ge2 > 0 ? it[_e][Ge2 - 1] : 0, Yt = it[_e][Ge2];
                      Yt || (bt & 8 && (Yt |= 12), jt & 2 && (Yt |= 3), it[_e][Ge2] = Yt);
                    }
                  for (let _e = 0; _e < U2; _e++)
                    for (let Ge2 = 0; Ge2 < fe2.length; Ge2++) {
                      let bt = it[_e][Ge2], jt = bt & 4 ? "â" : " ", Yt = T[_e][Ge2];
                      Yt ? (mt(Ge2, Yt.text), _e < U2 - 1 && (mt(Ge2, " "), mt(Ge2, ie2(jt, It[_e] - Yt.text.length)))) : _e < U2 - 1 && mt(Ge2, ie2(jt, It[_e] + 1)), mt(Ge2, Pi(bt)), mt(Ge2, bt & 8 && _e < U2 - 1 && !T[_e + 1][Ge2] ? "â" : " ");
                    }
                  return `
${fe2.join(`
`)}
`;
                  function mt(_e, Ge2) {
                    fe2[_e] += Ge2;
                  }
                }
                function Pi(U2) {
                  switch (U2) {
                    case 3:
                      return "â";
                    case 12:
                      return "â";
                    case 5:
                      return "â¯";
                    case 9:
                      return "â°";
                    case 6:
                      return "â®";
                    case 10:
                      return "â­";
                    case 7:
                      return "â¤";
                    case 11:
                      return "â";
                    case 13:
                      return "â´";
                    case 14:
                      return "â¬";
                    case 15:
                      return "â«";
                  }
                  return " ";
                }
                function Z(U2, L) {
                  if (U2.fill)
                    U2.fill(L);
                  else
                    for (let fe2 = 0; fe2 < U2.length; fe2++)
                      U2[fe2] = L;
                  return U2;
                }
                function ie2(U2, L) {
                  if (U2.repeat)
                    return L > 0 ? U2.repeat(L) : "";
                  let fe2 = "";
                  for (; fe2.length < L; )
                    fe2 += U2;
                  return fe2;
                }
              }
              e.formatControlFlowGraph = St;
            })(Y3 || (Y3 = {}));
          } }), R5 = () => {
          }, j5 = () => {
          }, J5 = () => {
          }, ts = Date.now, F5 = () => {
          }, Dp = new Proxy(() => {
          }, { get: () => Dp });
          function DT(e) {
            var t6;
            if (Q1) {
              let r = (t6 = Z1.get(e)) != null ? t6 : 0;
              Z1.set(e, r + 1), Ip.set(e, ts()), kp == null || kp.mark(e), typeof onProfilerEvent == "function" && onProfilerEvent(e);
            }
          }
          function B5(e, t6, r) {
            var s, f10;
            if (Q1) {
              let x10 = (s = r !== void 0 ? Ip.get(r) : void 0) != null ? s : ts(), w6 = (f10 = t6 !== void 0 ? Ip.get(t6) : void 0) != null ? f10 : kT, A6 = eg.get(e) || 0;
              eg.set(e, A6 + (x10 - w6)), kp == null || kp.measure(e, t6, r);
            }
          }
          var kp, q5, Q1, kT, Ip, Z1, eg, pH = D({ "src/compiler/performance.ts"() {
            "use strict";
            nn(), q5 = { enter: yn, exit: yn }, Q1 = false, kT = ts(), Ip = /* @__PURE__ */ new Map(), Z1 = /* @__PURE__ */ new Map(), eg = /* @__PURE__ */ new Map();
          } }), IT = () => {
          }, U5 = () => {
          }, rs;
          function z5(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, r = qp[e.category];
            return t6 ? r.toLowerCase() : r;
          }
          var Np, Op, Mp, tg, Lp, rg, ng, il, ig2, Rp, ag, sg, og, _g, cg, lg, ug, pg, fg, dg, mg, hg, gg, yg, vg, jp, bg, Tg, Sg, xg, Jp, Fp, Eg, wg, Cg, Ag, Pg, Bp, Dg, kg2, Ig, Ng, Og, Mg, qp, Lg, Rg, jg, Jg, Fg, Bg2, qg, Ug, zg, Wg, Vg, Hg, Gg, $g, Kg, Up, zp, Wp, Xg, Yg, Qg, Zg, ey, ty, ry, ny, Vp, NT = D({ "src/compiler/types.ts"() {
            "use strict";
            Np = ((e) => (e[e.Unknown = 0] = "Unknown", e[e.EndOfFileToken = 1] = "EndOfFileToken", e[e.SingleLineCommentTrivia = 2] = "SingleLineCommentTrivia", e[e.MultiLineCommentTrivia = 3] = "MultiLineCommentTrivia", e[e.NewLineTrivia = 4] = "NewLineTrivia", e[e.WhitespaceTrivia = 5] = "WhitespaceTrivia", e[e.ShebangTrivia = 6] = "ShebangTrivia", e[e.ConflictMarkerTrivia = 7] = "ConflictMarkerTrivia", e[e.NumericLiteral = 8] = "NumericLiteral", e[e.BigIntLiteral = 9] = "BigIntLiteral", e[e.StringLiteral = 10] = "StringLiteral", e[e.JsxText = 11] = "JsxText", e[e.JsxTextAllWhiteSpaces = 12] = "JsxTextAllWhiteSpaces", e[e.RegularExpressionLiteral = 13] = "RegularExpressionLiteral", e[e.NoSubstitutionTemplateLiteral = 14] = "NoSubstitutionTemplateLiteral", e[e.TemplateHead = 15] = "TemplateHead", e[e.TemplateMiddle = 16] = "TemplateMiddle", e[e.TemplateTail = 17] = "TemplateTail", e[e.OpenBraceToken = 18] = "OpenBraceToken", e[e.CloseBraceToken = 19] = "CloseBraceToken", e[e.OpenParenToken = 20] = "OpenParenToken", e[e.CloseParenToken = 21] = "CloseParenToken", e[e.OpenBracketToken = 22] = "OpenBracketToken", e[e.CloseBracketToken = 23] = "CloseBracketToken", e[e.DotToken = 24] = "DotToken", e[e.DotDotDotToken = 25] = "DotDotDotToken", e[e.SemicolonToken = 26] = "SemicolonToken", e[e.CommaToken = 27] = "CommaToken", e[e.QuestionDotToken = 28] = "QuestionDotToken", e[e.LessThanToken = 29] = "LessThanToken", e[e.LessThanSlashToken = 30] = "LessThanSlashToken", e[e.GreaterThanToken = 31] = "GreaterThanToken", e[e.LessThanEqualsToken = 32] = "LessThanEqualsToken", e[e.GreaterThanEqualsToken = 33] = "GreaterThanEqualsToken", e[e.EqualsEqualsToken = 34] = "EqualsEqualsToken", e[e.ExclamationEqualsToken = 35] = "ExclamationEqualsToken", e[e.EqualsEqualsEqualsToken = 36] = "EqualsEqualsEqualsToken", e[e.ExclamationEqualsEqualsToken = 37] = "ExclamationEqualsEqualsToken", e[e.EqualsGreaterThanToken = 38] = "EqualsGreaterThanToken", e[e.PlusToken = 39] = "PlusToken", e[e.MinusToken = 40] = "MinusToken", e[e.AsteriskToken = 41] = "AsteriskToken", e[e.AsteriskAsteriskToken = 42] = "AsteriskAsteriskToken", e[e.SlashToken = 43] = "SlashToken", e[e.PercentToken = 44] = "PercentToken", e[e.PlusPlusToken = 45] = "PlusPlusToken", e[e.MinusMinusToken = 46] = "MinusMinusToken", e[e.LessThanLessThanToken = 47] = "LessThanLessThanToken", e[e.GreaterThanGreaterThanToken = 48] = "GreaterThanGreaterThanToken", e[e.GreaterThanGreaterThanGreaterThanToken = 49] = "GreaterThanGreaterThanGreaterThanToken", e[e.AmpersandToken = 50] = "AmpersandToken", e[e.BarToken = 51] = "BarToken", e[e.CaretToken = 52] = "CaretToken", e[e.ExclamationToken = 53] = "ExclamationToken", e[e.TildeToken = 54] = "TildeToken", e[e.AmpersandAmpersandToken = 55] = "AmpersandAmpersandToken", e[e.BarBarToken = 56] = "BarBarToken", e[e.QuestionToken = 57] = "QuestionToken", e[e.ColonToken = 58] = "ColonToken", e[e.AtToken = 59] = "AtToken", e[e.QuestionQuestionToken = 60] = "QuestionQuestionToken", e[e.BacktickToken = 61] = "BacktickToken", e[e.HashToken = 62] = "HashToken", e[e.EqualsToken = 63] = "EqualsToken", e[e.PlusEqualsToken = 64] = "PlusEqualsToken", e[e.MinusEqualsToken = 65] = "MinusEqualsToken", e[e.AsteriskEqualsToken = 66] = "AsteriskEqualsToken", e[e.AsteriskAsteriskEqualsToken = 67] = "AsteriskAsteriskEqualsToken", e[e.SlashEqualsToken = 68] = "SlashEqualsToken", e[e.PercentEqualsToken = 69] = "PercentEqualsToken", e[e.LessThanLessThanEqualsToken = 70] = "LessThanLessThanEqualsToken", e[e.GreaterThanGreaterThanEqualsToken = 71] = "GreaterThanGreaterThanEqualsToken", e[e.GreaterThanGreaterThanGreaterThanEqualsToken = 72] = "GreaterThanGreaterThanGreaterThanEqualsToken", e[e.AmpersandEqualsToken = 73] = "AmpersandEqualsToken", e[e.BarEqualsToken = 74] = "BarEqualsToken", e[e.BarBarEqualsToken = 75] = "BarBarEqualsToken", e[e.AmpersandAmpersandEqualsToken = 76] = "AmpersandAmpersandEqualsToken", e[e.QuestionQuestionEqualsToken = 77] = "QuestionQuestionEqualsToken", e[e.CaretEqualsToken = 78] = "CaretEqualsToken", e[e.Identifier = 79] = "Identifier", e[e.PrivateIdentifier = 80] = "PrivateIdentifier", e[e.BreakKeyword = 81] = "BreakKeyword", e[e.CaseKeyword = 82] = "CaseKeyword", e[e.CatchKeyword = 83] = "CatchKeyword", e[e.ClassKeyword = 84] = "ClassKeyword", e[e.ConstKeyword = 85] = "ConstKeyword", e[e.ContinueKeyword = 86] = "ContinueKeyword", e[e.DebuggerKeyword = 87] = "DebuggerKeyword", e[e.DefaultKeyword = 88] = "DefaultKeyword", e[e.DeleteKeyword = 89] = "DeleteKeyword", e[e.DoKeyword = 90] = "DoKeyword", e[e.ElseKeyword = 91] = "ElseKeyword", e[e.EnumKeyword = 92] = "EnumKeyword", e[e.ExportKeyword = 93] = "ExportKeyword", e[e.ExtendsKeyword = 94] = "ExtendsKeyword", e[e.FalseKeyword = 95] = "FalseKeyword", e[e.FinallyKeyword = 96] = "FinallyKeyword", e[e.ForKeyword = 97] = "ForKeyword", e[e.FunctionKeyword = 98] = "FunctionKeyword", e[e.IfKeyword = 99] = "IfKeyword", e[e.ImportKeyword = 100] = "ImportKeyword", e[e.InKeyword = 101] = "InKeyword", e[e.InstanceOfKeyword = 102] = "InstanceOfKeyword", e[e.NewKeyword = 103] = "NewKeyword", e[e.NullKeyword = 104] = "NullKeyword", e[e.ReturnKeyword = 105] = "ReturnKeyword", e[e.SuperKeyword = 106] = "SuperKeyword", e[e.SwitchKeyword = 107] = "SwitchKeyword", e[e.ThisKeyword = 108] = "ThisKeyword", e[e.ThrowKeyword = 109] = "ThrowKeyword", e[e.TrueKeyword = 110] = "TrueKeyword", e[e.TryKeyword = 111] = "TryKeyword", e[e.TypeOfKeyword = 112] = "TypeOfKeyword", e[e.VarKeyword = 113] = "VarKeyword", e[e.VoidKeyword = 114] = "VoidKeyword", e[e.WhileKeyword = 115] = "WhileKeyword", e[e.WithKeyword = 116] = "WithKeyword", e[e.ImplementsKeyword = 117] = "ImplementsKeyword", e[e.InterfaceKeyword = 118] = "InterfaceKeyword", e[e.LetKeyword = 119] = "LetKeyword", e[e.PackageKeyword = 120] = "PackageKeyword", e[e.PrivateKeyword = 121] = "PrivateKeyword", e[e.ProtectedKeyword = 122] = "ProtectedKeyword", e[e.PublicKeyword = 123] = "PublicKeyword", e[e.StaticKeyword = 124] = "StaticKeyword", e[e.YieldKeyword = 125] = "YieldKeyword", e[e.AbstractKeyword = 126] = "AbstractKeyword", e[e.AccessorKeyword = 127] = "AccessorKeyword", e[e.AsKeyword = 128] = "AsKeyword", e[e.AssertsKeyword = 129] = "AssertsKeyword", e[e.AssertKeyword = 130] = "AssertKeyword", e[e.AnyKeyword = 131] = "AnyKeyword", e[e.AsyncKeyword = 132] = "AsyncKeyword", e[e.AwaitKeyword = 133] = "AwaitKeyword", e[e.BooleanKeyword = 134] = "BooleanKeyword", e[e.ConstructorKeyword = 135] = "ConstructorKeyword", e[e.DeclareKeyword = 136] = "DeclareKeyword", e[e.GetKeyword = 137] = "GetKeyword", e[e.InferKeyword = 138] = "InferKeyword", e[e.IntrinsicKeyword = 139] = "IntrinsicKeyword", e[e.IsKeyword = 140] = "IsKeyword", e[e.KeyOfKeyword = 141] = "KeyOfKeyword", e[e.ModuleKeyword = 142] = "ModuleKeyword", e[e.NamespaceKeyword = 143] = "NamespaceKeyword", e[e.NeverKeyword = 144] = "NeverKeyword", e[e.OutKeyword = 145] = "OutKeyword", e[e.ReadonlyKeyword = 146] = "ReadonlyKeyword", e[e.RequireKeyword = 147] = "RequireKeyword", e[e.NumberKeyword = 148] = "NumberKeyword", e[e.ObjectKeyword = 149] = "ObjectKeyword", e[e.SatisfiesKeyword = 150] = "SatisfiesKeyword", e[e.SetKeyword = 151] = "SetKeyword", e[e.StringKeyword = 152] = "StringKeyword", e[e.SymbolKeyword = 153] = "SymbolKeyword", e[e.TypeKeyword = 154] = "TypeKeyword", e[e.UndefinedKeyword = 155] = "UndefinedKeyword", e[e.UniqueKeyword = 156] = "UniqueKeyword", e[e.UnknownKeyword = 157] = "UnknownKeyword", e[e.FromKeyword = 158] = "FromKeyword", e[e.GlobalKeyword = 159] = "GlobalKeyword", e[e.BigIntKeyword = 160] = "BigIntKeyword", e[e.OverrideKeyword = 161] = "OverrideKeyword", e[e.OfKeyword = 162] = "OfKeyword", e[e.QualifiedName = 163] = "QualifiedName", e[e.ComputedPropertyName = 164] = "ComputedPropertyName", e[e.TypeParameter = 165] = "TypeParameter", e[e.Parameter = 166] = "Parameter", e[e.Decorator = 167] = "Decorator", e[e.PropertySignature = 168] = "PropertySignature", e[e.PropertyDeclaration = 169] = "PropertyDeclaration", e[e.MethodSignature = 170] = "MethodSignature", e[e.MethodDeclaration = 171] = "MethodDeclaration", e[e.ClassStaticBlockDeclaration = 172] = "ClassStaticBlockDeclaration", e[e.Constructor = 173] = "Constructor", e[e.GetAccessor = 174] = "GetAccessor", e[e.SetAccessor = 175] = "SetAccessor", e[e.CallSignature = 176] = "CallSignature", e[e.ConstructSignature = 177] = "ConstructSignature", e[e.IndexSignature = 178] = "IndexSignature", e[e.TypePredicate = 179] = "TypePredicate", e[e.TypeReference = 180] = "TypeReference", e[e.FunctionType = 181] = "FunctionType", e[e.ConstructorType = 182] = "ConstructorType", e[e.TypeQuery = 183] = "TypeQuery", e[e.TypeLiteral = 184] = "TypeLiteral", e[e.ArrayType = 185] = "ArrayType", e[e.TupleType = 186] = "TupleType", e[e.OptionalType = 187] = "OptionalType", e[e.RestType = 188] = "RestType", e[e.UnionType = 189] = "UnionType", e[e.IntersectionType = 190] = "IntersectionType", e[e.ConditionalType = 191] = "ConditionalType", e[e.InferType = 192] = "InferType", e[e.ParenthesizedType = 193] = "ParenthesizedType", e[e.ThisType = 194] = "ThisType", e[e.TypeOperator = 195] = "TypeOperator", e[e.IndexedAccessType = 196] = "IndexedAccessType", e[e.MappedType = 197] = "MappedType", e[e.LiteralType = 198] = "LiteralType", e[e.NamedTupleMember = 199] = "NamedTupleMember", e[e.TemplateLiteralType = 200] = "TemplateLiteralType", e[e.TemplateLiteralTypeSpan = 201] = "TemplateLiteralTypeSpan", e[e.ImportType = 202] = "ImportType", e[e.ObjectBindingPattern = 203] = "ObjectBindingPattern", e[e.ArrayBindingPattern = 204] = "ArrayBindingPattern", e[e.BindingElement = 205] = "BindingElement", e[e.ArrayLiteralExpression = 206] = "ArrayLiteralExpression", e[e.ObjectLiteralExpression = 207] = "ObjectLiteralExpression", e[e.PropertyAccessExpression = 208] = "PropertyAccessExpression", e[e.ElementAccessExpression = 209] = "ElementAccessExpression", e[e.CallExpression = 210] = "CallExpression", e[e.NewExpression = 211] = "NewExpression", e[e.TaggedTemplateExpression = 212] = "TaggedTemplateExpression", e[e.TypeAssertionExpression = 213] = "TypeAssertionExpression", e[e.ParenthesizedExpression = 214] = "ParenthesizedExpression", e[e.FunctionExpression = 215] = "FunctionExpression", e[e.ArrowFunction = 216] = "ArrowFunction", e[e.DeleteExpression = 217] = "DeleteExpression", e[e.TypeOfExpression = 218] = "TypeOfExpression", e[e.VoidExpression = 219] = "VoidExpression", e[e.AwaitExpression = 220] = "AwaitExpression", e[e.PrefixUnaryExpression = 221] = "PrefixUnaryExpression", e[e.PostfixUnaryExpression = 222] = "PostfixUnaryExpression", e[e.BinaryExpression = 223] = "BinaryExpression", e[e.ConditionalExpression = 224] = "ConditionalExpression", e[e.TemplateExpression = 225] = "TemplateExpression", e[e.YieldExpression = 226] = "YieldExpression", e[e.SpreadElement = 227] = "SpreadElement", e[e.ClassExpression = 228] = "ClassExpression", e[e.OmittedExpression = 229] = "OmittedExpression", e[e.ExpressionWithTypeArguments = 230] = "ExpressionWithTypeArguments", e[e.AsExpression = 231] = "AsExpression", e[e.NonNullExpression = 232] = "NonNullExpression", e[e.MetaProperty = 233] = "MetaProperty", e[e.SyntheticExpression = 234] = "SyntheticExpression", e[e.SatisfiesExpression = 235] = "SatisfiesExpression", e[e.TemplateSpan = 236] = "TemplateSpan", e[e.SemicolonClassElement = 237] = "SemicolonClassElement", e[e.Block = 238] = "Block", e[e.EmptyStatement = 239] = "EmptyStatement", e[e.VariableStatement = 240] = "VariableStatement", e[e.ExpressionStatement = 241] = "ExpressionStatement", e[e.IfStatement = 242] = "IfStatement", e[e.DoStatement = 243] = "DoStatement", e[e.WhileStatement = 244] = "WhileStatement", e[e.ForStatement = 245] = "ForStatement", e[e.ForInStatement = 246] = "ForInStatement", e[e.ForOfStatement = 247] = "ForOfStatement", e[e.ContinueStatement = 248] = "ContinueStatement", e[e.BreakStatement = 249] = "BreakStatement", e[e.ReturnStatement = 250] = "ReturnStatement", e[e.WithStatement = 251] = "WithStatement", e[e.SwitchStatement = 252] = "SwitchStatement", e[e.LabeledStatement = 253] = "LabeledStatement", e[e.ThrowStatement = 254] = "ThrowStatement", e[e.TryStatement = 255] = "TryStatement", e[e.DebuggerStatement = 256] = "DebuggerStatement", e[e.VariableDeclaration = 257] = "VariableDeclaration", e[e.VariableDeclarationList = 258] = "VariableDeclarationList", e[e.FunctionDeclaration = 259] = "FunctionDeclaration", e[e.ClassDeclaration = 260] = "ClassDeclaration", e[e.InterfaceDeclaration = 261] = "InterfaceDeclaration", e[e.TypeAliasDeclaration = 262] = "TypeAliasDeclaration", e[e.EnumDeclaration = 263] = "EnumDeclaration", e[e.ModuleDeclaration = 264] = "ModuleDeclaration", e[e.ModuleBlock = 265] = "ModuleBlock", e[e.CaseBlock = 266] = "CaseBlock", e[e.NamespaceExportDeclaration = 267] = "NamespaceExportDeclaration", e[e.ImportEqualsDeclaration = 268] = "ImportEqualsDeclaration", e[e.ImportDeclaration = 269] = "ImportDeclaration", e[e.ImportClause = 270] = "ImportClause", e[e.NamespaceImport = 271] = "NamespaceImport", e[e.NamedImports = 272] = "NamedImports", e[e.ImportSpecifier = 273] = "ImportSpecifier", e[e.ExportAssignment = 274] = "ExportAssignment", e[e.ExportDeclaration = 275] = "ExportDeclaration", e[e.NamedExports = 276] = "NamedExports", e[e.NamespaceExport = 277] = "NamespaceExport", e[e.ExportSpecifier = 278] = "ExportSpecifier", e[e.MissingDeclaration = 279] = "MissingDeclaration", e[e.ExternalModuleReference = 280] = "ExternalModuleReference", e[e.JsxElement = 281] = "JsxElement", e[e.JsxSelfClosingElement = 282] = "JsxSelfClosingElement", e[e.JsxOpeningElement = 283] = "JsxOpeningElement", e[e.JsxClosingElement = 284] = "JsxClosingElement", e[e.JsxFragment = 285] = "JsxFragment", e[e.JsxOpeningFragment = 286] = "JsxOpeningFragment", e[e.JsxClosingFragment = 287] = "JsxClosingFragment", e[e.JsxAttribute = 288] = "JsxAttribute", e[e.JsxAttributes = 289] = "JsxAttributes", e[e.JsxSpreadAttribute = 290] = "JsxSpreadAttribute", e[e.JsxExpression = 291] = "JsxExpression", e[e.CaseClause = 292] = "CaseClause", e[e.DefaultClause = 293] = "DefaultClause", e[e.HeritageClause = 294] = "HeritageClause", e[e.CatchClause = 295] = "CatchClause", e[e.AssertClause = 296] = "AssertClause", e[e.AssertEntry = 297] = "AssertEntry", e[e.ImportTypeAssertionContainer = 298] = "ImportTypeAssertionContainer", e[e.PropertyAssignment = 299] = "PropertyAssignment", e[e.ShorthandPropertyAssignment = 300] = "ShorthandPropertyAssignment", e[e.SpreadAssignment = 301] = "SpreadAssignment", e[e.EnumMember = 302] = "EnumMember", e[e.UnparsedPrologue = 303] = "UnparsedPrologue", e[e.UnparsedPrepend = 304] = "UnparsedPrepend", e[e.UnparsedText = 305] = "UnparsedText", e[e.UnparsedInternalText = 306] = "UnparsedInternalText", e[e.UnparsedSyntheticReference = 307] = "UnparsedSyntheticReference", e[e.SourceFile = 308] = "SourceFile", e[e.Bundle = 309] = "Bundle", e[e.UnparsedSource = 310] = "UnparsedSource", e[e.InputFiles = 311] = "InputFiles", e[e.JSDocTypeExpression = 312] = "JSDocTypeExpression", e[e.JSDocNameReference = 313] = "JSDocNameReference", e[e.JSDocMemberName = 314] = "JSDocMemberName", e[e.JSDocAllType = 315] = "JSDocAllType", e[e.JSDocUnknownType = 316] = "JSDocUnknownType", e[e.JSDocNullableType = 317] = "JSDocNullableType", e[e.JSDocNonNullableType = 318] = "JSDocNonNullableType", e[e.JSDocOptionalType = 319] = "JSDocOptionalType", e[e.JSDocFunctionType = 320] = "JSDocFunctionType", e[e.JSDocVariadicType = 321] = "JSDocVariadicType", e[e.JSDocNamepathType = 322] = "JSDocNamepathType", e[e.JSDoc = 323] = "JSDoc", e[e.JSDocComment = 323] = "JSDocComment", e[e.JSDocText = 324] = "JSDocText", e[e.JSDocTypeLiteral = 325] = "JSDocTypeLiteral", e[e.JSDocSignature = 326] = "JSDocSignature", e[e.JSDocLink = 327] = "JSDocLink", e[e.JSDocLinkCode = 328] = "JSDocLinkCode", e[e.JSDocLinkPlain = 329] = "JSDocLinkPlain", e[e.JSDocTag = 330] = "JSDocTag", e[e.JSDocAugmentsTag = 331] = "JSDocAugmentsTag", e[e.JSDocImplementsTag = 332] = "JSDocImplementsTag", e[e.JSDocAuthorTag = 333] = "JSDocAuthorTag", e[e.JSDocDeprecatedTag = 334] = "JSDocDeprecatedTag", e[e.JSDocClassTag = 335] = "JSDocClassTag", e[e.JSDocPublicTag = 336] = "JSDocPublicTag", e[e.JSDocPrivateTag = 337] = "JSDocPrivateTag", e[e.JSDocProtectedTag = 338] = "JSDocProtectedTag", e[e.JSDocReadonlyTag = 339] = "JSDocReadonlyTag", e[e.JSDocOverrideTag = 340] = "JSDocOverrideTag", e[e.JSDocCallbackTag = 341] = "JSDocCallbackTag", e[e.JSDocOverloadTag = 342] = "JSDocOverloadTag", e[e.JSDocEnumTag = 343] = "JSDocEnumTag", e[e.JSDocParameterTag = 344] = "JSDocParameterTag", e[e.JSDocReturnTag = 345] = "JSDocReturnTag", e[e.JSDocThisTag = 346] = "JSDocThisTag", e[e.JSDocTypeTag = 347] = "JSDocTypeTag", e[e.JSDocTemplateTag = 348] = "JSDocTemplateTag", e[e.JSDocTypedefTag = 349] = "JSDocTypedefTag", e[e.JSDocSeeTag = 350] = "JSDocSeeTag", e[e.JSDocPropertyTag = 351] = "JSDocPropertyTag", e[e.JSDocThrowsTag = 352] = "JSDocThrowsTag", e[e.JSDocSatisfiesTag = 353] = "JSDocSatisfiesTag", e[e.SyntaxList = 354] = "SyntaxList", e[e.NotEmittedStatement = 355] = "NotEmittedStatement", e[e.PartiallyEmittedExpression = 356] = "PartiallyEmittedExpression", e[e.CommaListExpression = 357] = "CommaListExpression", e[e.MergeDeclarationMarker = 358] = "MergeDeclarationMarker", e[e.EndOfDeclarationMarker = 359] = "EndOfDeclarationMarker", e[e.SyntheticReferenceExpression = 360] = "SyntheticReferenceExpression", e[e.Count = 361] = "Count", e[e.FirstAssignment = 63] = "FirstAssignment", e[e.LastAssignment = 78] = "LastAssignment", e[e.FirstCompoundAssignment = 64] = "FirstCompoundAssignment", e[e.LastCompoundAssignment = 78] = "LastCompoundAssignment", e[e.FirstReservedWord = 81] = "FirstReservedWord", e[e.LastReservedWord = 116] = "LastReservedWord", e[e.FirstKeyword = 81] = "FirstKeyword", e[e.LastKeyword = 162] = "LastKeyword", e[e.FirstFutureReservedWord = 117] = "FirstFutureReservedWord", e[e.LastFutureReservedWord = 125] = "LastFutureReservedWord", e[e.FirstTypeNode = 179] = "FirstTypeNode", e[e.LastTypeNode = 202] = "LastTypeNode", e[e.FirstPunctuation = 18] = "FirstPunctuation", e[e.LastPunctuation = 78] = "LastPunctuation", e[e.FirstToken = 0] = "FirstToken", e[e.LastToken = 162] = "LastToken", e[e.FirstTriviaToken = 2] = "FirstTriviaToken", e[e.LastTriviaToken = 7] = "LastTriviaToken", e[e.FirstLiteralToken = 8] = "FirstLiteralToken", e[e.LastLiteralToken = 14] = "LastLiteralToken", e[e.FirstTemplateToken = 14] = "FirstTemplateToken", e[e.LastTemplateToken = 17] = "LastTemplateToken", e[e.FirstBinaryOperator = 29] = "FirstBinaryOperator", e[e.LastBinaryOperator = 78] = "LastBinaryOperator", e[e.FirstStatement = 240] = "FirstStatement", e[e.LastStatement = 256] = "LastStatement", e[e.FirstNode = 163] = "FirstNode", e[e.FirstJSDocNode = 312] = "FirstJSDocNode", e[e.LastJSDocNode = 353] = "LastJSDocNode", e[e.FirstJSDocTagNode = 330] = "FirstJSDocTagNode", e[e.LastJSDocTagNode = 353] = "LastJSDocTagNode", e[e.FirstContextualKeyword = 126] = "FirstContextualKeyword", e[e.LastContextualKeyword = 162] = "LastContextualKeyword", e))(Np || {}), Op = ((e) => (e[e.None = 0] = "None", e[e.Let = 1] = "Let", e[e.Const = 2] = "Const", e[e.NestedNamespace = 4] = "NestedNamespace", e[e.Synthesized = 8] = "Synthesized", e[e.Namespace = 16] = "Namespace", e[e.OptionalChain = 32] = "OptionalChain", e[e.ExportContext = 64] = "ExportContext", e[e.ContainsThis = 128] = "ContainsThis", e[e.HasImplicitReturn = 256] = "HasImplicitReturn", e[e.HasExplicitReturn = 512] = "HasExplicitReturn", e[e.GlobalAugmentation = 1024] = "GlobalAugmentation", e[e.HasAsyncFunctions = 2048] = "HasAsyncFunctions", e[e.DisallowInContext = 4096] = "DisallowInContext", e[e.YieldContext = 8192] = "YieldContext", e[e.DecoratorContext = 16384] = "DecoratorContext", e[e.AwaitContext = 32768] = "AwaitContext", e[e.DisallowConditionalTypesContext = 65536] = "DisallowConditionalTypesContext", e[e.ThisNodeHasError = 131072] = "ThisNodeHasError", e[e.JavaScriptFile = 262144] = "JavaScriptFile", e[e.ThisNodeOrAnySubNodesHasError = 524288] = "ThisNodeOrAnySubNodesHasError", e[e.HasAggregatedChildData = 1048576] = "HasAggregatedChildData", e[e.PossiblyContainsDynamicImport = 2097152] = "PossiblyContainsDynamicImport", e[e.PossiblyContainsImportMeta = 4194304] = "PossiblyContainsImportMeta", e[e.JSDoc = 8388608] = "JSDoc", e[e.Ambient = 16777216] = "Ambient", e[e.InWithStatement = 33554432] = "InWithStatement", e[e.JsonFile = 67108864] = "JsonFile", e[e.TypeCached = 134217728] = "TypeCached", e[e.Deprecated = 268435456] = "Deprecated", e[e.BlockScoped = 3] = "BlockScoped", e[e.ReachabilityCheckFlags = 768] = "ReachabilityCheckFlags", e[e.ReachabilityAndEmitFlags = 2816] = "ReachabilityAndEmitFlags", e[e.ContextFlags = 50720768] = "ContextFlags", e[e.TypeExcludesFlags = 40960] = "TypeExcludesFlags", e[e.PermanentlySetIncrementalFlags = 6291456] = "PermanentlySetIncrementalFlags", e[e.IdentifierHasExtendedUnicodeEscape = 128] = "IdentifierHasExtendedUnicodeEscape", e[e.IdentifierIsInJSDocNamespace = 2048] = "IdentifierIsInJSDocNamespace", e))(Op || {}), Mp = ((e) => (e[e.None = 0] = "None", e[e.Export = 1] = "Export", e[e.Ambient = 2] = "Ambient", e[e.Public = 4] = "Public", e[e.Private = 8] = "Private", e[e.Protected = 16] = "Protected", e[e.Static = 32] = "Static", e[e.Readonly = 64] = "Readonly", e[e.Accessor = 128] = "Accessor", e[e.Abstract = 256] = "Abstract", e[e.Async = 512] = "Async", e[e.Default = 1024] = "Default", e[e.Const = 2048] = "Const", e[e.HasComputedJSDocModifiers = 4096] = "HasComputedJSDocModifiers", e[e.Deprecated = 8192] = "Deprecated", e[e.Override = 16384] = "Override", e[e.In = 32768] = "In", e[e.Out = 65536] = "Out", e[e.Decorator = 131072] = "Decorator", e[e.HasComputedFlags = 536870912] = "HasComputedFlags", e[e.AccessibilityModifier = 28] = "AccessibilityModifier", e[e.ParameterPropertyModifier = 16476] = "ParameterPropertyModifier", e[e.NonPublicAccessibilityModifier = 24] = "NonPublicAccessibilityModifier", e[e.TypeScriptModifier = 117086] = "TypeScriptModifier", e[e.ExportDefault = 1025] = "ExportDefault", e[e.All = 258047] = "All", e[e.Modifier = 126975] = "Modifier", e))(Mp || {}), tg = ((e) => (e[e.None = 0] = "None", e[e.IntrinsicNamedElement = 1] = "IntrinsicNamedElement", e[e.IntrinsicIndexedElement = 2] = "IntrinsicIndexedElement", e[e.IntrinsicElement = 3] = "IntrinsicElement", e))(tg || {}), Lp = ((e) => (e[e.Succeeded = 1] = "Succeeded", e[e.Failed = 2] = "Failed", e[e.Reported = 4] = "Reported", e[e.ReportsUnmeasurable = 8] = "ReportsUnmeasurable", e[e.ReportsUnreliable = 16] = "ReportsUnreliable", e[e.ReportsMask = 24] = "ReportsMask", e))(Lp || {}), rg = ((e) => (e[e.None = 0] = "None", e[e.Auto = 1] = "Auto", e[e.Loop = 2] = "Loop", e[e.Unique = 3] = "Unique", e[e.Node = 4] = "Node", e[e.KindMask = 7] = "KindMask", e[e.ReservedInNestedScopes = 8] = "ReservedInNestedScopes", e[e.Optimistic = 16] = "Optimistic", e[e.FileLevel = 32] = "FileLevel", e[e.AllowNameSubstitution = 64] = "AllowNameSubstitution", e))(rg || {}), ng = ((e) => (e[e.None = 0] = "None", e[e.PrecedingLineBreak = 1] = "PrecedingLineBreak", e[e.PrecedingJSDocComment = 2] = "PrecedingJSDocComment", e[e.Unterminated = 4] = "Unterminated", e[e.ExtendedUnicodeEscape = 8] = "ExtendedUnicodeEscape", e[e.Scientific = 16] = "Scientific", e[e.Octal = 32] = "Octal", e[e.HexSpecifier = 64] = "HexSpecifier", e[e.BinarySpecifier = 128] = "BinarySpecifier", e[e.OctalSpecifier = 256] = "OctalSpecifier", e[e.ContainsSeparator = 512] = "ContainsSeparator", e[e.UnicodeEscape = 1024] = "UnicodeEscape", e[e.ContainsInvalidEscape = 2048] = "ContainsInvalidEscape", e[e.BinaryOrOctalSpecifier = 384] = "BinaryOrOctalSpecifier", e[e.NumericLiteralFlags = 1008] = "NumericLiteralFlags", e[e.TemplateLiteralLikeFlags = 2048] = "TemplateLiteralLikeFlags", e))(ng || {}), il = ((e) => (e[e.Unreachable = 1] = "Unreachable", e[e.Start = 2] = "Start", e[e.BranchLabel = 4] = "BranchLabel", e[e.LoopLabel = 8] = "LoopLabel", e[e.Assignment = 16] = "Assignment", e[e.TrueCondition = 32] = "TrueCondition", e[e.FalseCondition = 64] = "FalseCondition", e[e.SwitchClause = 128] = "SwitchClause", e[e.ArrayMutation = 256] = "ArrayMutation", e[e.Call = 512] = "Call", e[e.ReduceLabel = 1024] = "ReduceLabel", e[e.Referenced = 2048] = "Referenced", e[e.Shared = 4096] = "Shared", e[e.Label = 12] = "Label", e[e.Condition = 96] = "Condition", e))(il || {}), ig2 = ((e) => (e[e.ExpectError = 0] = "ExpectError", e[e.Ignore = 1] = "Ignore", e))(ig2 || {}), Rp = class {
            }, ag = ((e) => (e[e.RootFile = 0] = "RootFile", e[e.SourceFromProjectReference = 1] = "SourceFromProjectReference", e[e.OutputFromProjectReference = 2] = "OutputFromProjectReference", e[e.Import = 3] = "Import", e[e.ReferenceFile = 4] = "ReferenceFile", e[e.TypeReferenceDirective = 5] = "TypeReferenceDirective", e[e.LibFile = 6] = "LibFile", e[e.LibReferenceDirective = 7] = "LibReferenceDirective", e[e.AutomaticTypeDirectiveFile = 8] = "AutomaticTypeDirectiveFile", e))(ag || {}), sg = ((e) => (e[e.FilePreprocessingReferencedDiagnostic = 0] = "FilePreprocessingReferencedDiagnostic", e[e.FilePreprocessingFileExplainingDiagnostic = 1] = "FilePreprocessingFileExplainingDiagnostic", e[e.ResolutionDiagnostics = 2] = "ResolutionDiagnostics", e))(sg || {}), og = ((e) => (e[e.Js = 0] = "Js", e[e.Dts = 1] = "Dts", e))(og || {}), _g = ((e) => (e[e.Not = 0] = "Not", e[e.SafeModules = 1] = "SafeModules", e[e.Completely = 2] = "Completely", e))(_g || {}), cg = ((e) => (e[e.Success = 0] = "Success", e[e.DiagnosticsPresent_OutputsSkipped = 1] = "DiagnosticsPresent_OutputsSkipped", e[e.DiagnosticsPresent_OutputsGenerated = 2] = "DiagnosticsPresent_OutputsGenerated", e[e.InvalidProject_OutputsSkipped = 3] = "InvalidProject_OutputsSkipped", e[e.ProjectReferenceCycle_OutputsSkipped = 4] = "ProjectReferenceCycle_OutputsSkipped", e))(cg || {}), lg = ((e) => (e[e.Ok = 0] = "Ok", e[e.NeedsOverride = 1] = "NeedsOverride", e[e.HasInvalidOverride = 2] = "HasInvalidOverride", e))(lg || {}), ug = ((e) => (e[e.None = 0] = "None", e[e.Literal = 1] = "Literal", e[e.Subtype = 2] = "Subtype", e))(ug || {}), pg = ((e) => (e[e.None = 0] = "None", e[e.Signature = 1] = "Signature", e[e.NoConstraints = 2] = "NoConstraints", e[e.Completions = 4] = "Completions", e[e.SkipBindingPatterns = 8] = "SkipBindingPatterns", e))(pg || {}), fg = ((e) => (e[e.None = 0] = "None", e[e.NoTruncation = 1] = "NoTruncation", e[e.WriteArrayAsGenericType = 2] = "WriteArrayAsGenericType", e[e.GenerateNamesForShadowedTypeParams = 4] = "GenerateNamesForShadowedTypeParams", e[e.UseStructuralFallback = 8] = "UseStructuralFallback", e[e.ForbidIndexedAccessSymbolReferences = 16] = "ForbidIndexedAccessSymbolReferences", e[e.WriteTypeArgumentsOfSignature = 32] = "WriteTypeArgumentsOfSignature", e[e.UseFullyQualifiedType = 64] = "UseFullyQualifiedType", e[e.UseOnlyExternalAliasing = 128] = "UseOnlyExternalAliasing", e[e.SuppressAnyReturnType = 256] = "SuppressAnyReturnType", e[e.WriteTypeParametersInQualifiedName = 512] = "WriteTypeParametersInQualifiedName", e[e.MultilineObjectLiterals = 1024] = "MultilineObjectLiterals", e[e.WriteClassExpressionAsTypeLiteral = 2048] = "WriteClassExpressionAsTypeLiteral", e[e.UseTypeOfFunction = 4096] = "UseTypeOfFunction", e[e.OmitParameterModifiers = 8192] = "OmitParameterModifiers", e[e.UseAliasDefinedOutsideCurrentScope = 16384] = "UseAliasDefinedOutsideCurrentScope", e[e.UseSingleQuotesForStringLiteralType = 268435456] = "UseSingleQuotesForStringLiteralType", e[e.NoTypeReduction = 536870912] = "NoTypeReduction", e[e.OmitThisParameter = 33554432] = "OmitThisParameter", e[e.AllowThisInObjectLiteral = 32768] = "AllowThisInObjectLiteral", e[e.AllowQualifiedNameInPlaceOfIdentifier = 65536] = "AllowQualifiedNameInPlaceOfIdentifier", e[e.AllowAnonymousIdentifier = 131072] = "AllowAnonymousIdentifier", e[e.AllowEmptyUnionOrIntersection = 262144] = "AllowEmptyUnionOrIntersection", e[e.AllowEmptyTuple = 524288] = "AllowEmptyTuple", e[e.AllowUniqueESSymbolType = 1048576] = "AllowUniqueESSymbolType", e[e.AllowEmptyIndexInfoType = 2097152] = "AllowEmptyIndexInfoType", e[e.WriteComputedProps = 1073741824] = "WriteComputedProps", e[e.AllowNodeModulesRelativePaths = 67108864] = "AllowNodeModulesRelativePaths", e[e.DoNotIncludeSymbolChain = 134217728] = "DoNotIncludeSymbolChain", e[e.IgnoreErrors = 70221824] = "IgnoreErrors", e[e.InObjectTypeLiteral = 4194304] = "InObjectTypeLiteral", e[e.InTypeAlias = 8388608] = "InTypeAlias", e[e.InInitialEntityName = 16777216] = "InInitialEntityName", e))(fg || {}), dg = ((e) => (e[e.None = 0] = "None", e[e.NoTruncation = 1] = "NoTruncation", e[e.WriteArrayAsGenericType = 2] = "WriteArrayAsGenericType", e[e.UseStructuralFallback = 8] = "UseStructuralFallback", e[e.WriteTypeArgumentsOfSignature = 32] = "WriteTypeArgumentsOfSignature", e[e.UseFullyQualifiedType = 64] = "UseFullyQualifiedType", e[e.SuppressAnyReturnType = 256] = "SuppressAnyReturnType", e[e.MultilineObjectLiterals = 1024] = "MultilineObjectLiterals", e[e.WriteClassExpressionAsTypeLiteral = 2048] = "WriteClassExpressionAsTypeLiteral", e[e.UseTypeOfFunction = 4096] = "UseTypeOfFunction", e[e.OmitParameterModifiers = 8192] = "OmitParameterModifiers", e[e.UseAliasDefinedOutsideCurrentScope = 16384] = "UseAliasDefinedOutsideCurrentScope", e[e.UseSingleQuotesForStringLiteralType = 268435456] = "UseSingleQuotesForStringLiteralType", e[e.NoTypeReduction = 536870912] = "NoTypeReduction", e[e.OmitThisParameter = 33554432] = "OmitThisParameter", e[e.AllowUniqueESSymbolType = 1048576] = "AllowUniqueESSymbolType", e[e.AddUndefined = 131072] = "AddUndefined", e[e.WriteArrowStyleSignature = 262144] = "WriteArrowStyleSignature", e[e.InArrayType = 524288] = "InArrayType", e[e.InElementType = 2097152] = "InElementType", e[e.InFirstTypeArgument = 4194304] = "InFirstTypeArgument", e[e.InTypeAlias = 8388608] = "InTypeAlias", e[e.NodeBuilderFlagsMask = 848330091] = "NodeBuilderFlagsMask", e))(dg || {}), mg = ((e) => (e[e.None = 0] = "None", e[e.WriteTypeParametersOrArguments = 1] = "WriteTypeParametersOrArguments", e[e.UseOnlyExternalAliasing = 2] = "UseOnlyExternalAliasing", e[e.AllowAnyNodeKind = 4] = "AllowAnyNodeKind", e[e.UseAliasDefinedOutsideCurrentScope = 8] = "UseAliasDefinedOutsideCurrentScope", e[e.WriteComputedProps = 16] = "WriteComputedProps", e[e.DoNotIncludeSymbolChain = 32] = "DoNotIncludeSymbolChain", e))(mg || {}), hg = ((e) => (e[e.Accessible = 0] = "Accessible", e[e.NotAccessible = 1] = "NotAccessible", e[e.CannotBeNamed = 2] = "CannotBeNamed", e))(hg || {}), gg = ((e) => (e[e.UnionOrIntersection = 0] = "UnionOrIntersection", e[e.Spread = 1] = "Spread", e))(gg || {}), yg = ((e) => (e[e.This = 0] = "This", e[e.Identifier = 1] = "Identifier", e[e.AssertsThis = 2] = "AssertsThis", e[e.AssertsIdentifier = 3] = "AssertsIdentifier", e))(yg || {}), vg = ((e) => (e[e.Unknown = 0] = "Unknown", e[e.TypeWithConstructSignatureAndValue = 1] = "TypeWithConstructSignatureAndValue", e[e.VoidNullableOrNeverType = 2] = "VoidNullableOrNeverType", e[e.NumberLikeType = 3] = "NumberLikeType", e[e.BigIntLikeType = 4] = "BigIntLikeType", e[e.StringLikeType = 5] = "StringLikeType", e[e.BooleanType = 6] = "BooleanType", e[e.ArrayLikeType = 7] = "ArrayLikeType", e[e.ESSymbolType = 8] = "ESSymbolType", e[e.Promise = 9] = "Promise", e[e.TypeWithCallSignature = 10] = "TypeWithCallSignature", e[e.ObjectType = 11] = "ObjectType", e))(vg || {}), jp = ((e) => (e[e.None = 0] = "None", e[e.FunctionScopedVariable = 1] = "FunctionScopedVariable", e[e.BlockScopedVariable = 2] = "BlockScopedVariable", e[e.Property = 4] = "Property", e[e.EnumMember = 8] = "EnumMember", e[e.Function = 16] = "Function", e[e.Class = 32] = "Class", e[e.Interface = 64] = "Interface", e[e.ConstEnum = 128] = "ConstEnum", e[e.RegularEnum = 256] = "RegularEnum", e[e.ValueModule = 512] = "ValueModule", e[e.NamespaceModule = 1024] = "NamespaceModule", e[e.TypeLiteral = 2048] = "TypeLiteral", e[e.ObjectLiteral = 4096] = "ObjectLiteral", e[e.Method = 8192] = "Method", e[e.Constructor = 16384] = "Constructor", e[e.GetAccessor = 32768] = "GetAccessor", e[e.SetAccessor = 65536] = "SetAccessor", e[e.Signature = 131072] = "Signature", e[e.TypeParameter = 262144] = "TypeParameter", e[e.TypeAlias = 524288] = "TypeAlias", e[e.ExportValue = 1048576] = "ExportValue", e[e.Alias = 2097152] = "Alias", e[e.Prototype = 4194304] = "Prototype", e[e.ExportStar = 8388608] = "ExportStar", e[e.Optional = 16777216] = "Optional", e[e.Transient = 33554432] = "Transient", e[e.Assignment = 67108864] = "Assignment", e[e.ModuleExports = 134217728] = "ModuleExports", e[e.All = 67108863] = "All", e[e.Enum = 384] = "Enum", e[e.Variable = 3] = "Variable", e[e.Value = 111551] = "Value", e[e.Type = 788968] = "Type", e[e.Namespace = 1920] = "Namespace", e[e.Module = 1536] = "Module", e[e.Accessor = 98304] = "Accessor", e[e.FunctionScopedVariableExcludes = 111550] = "FunctionScopedVariableExcludes", e[e.BlockScopedVariableExcludes = 111551] = "BlockScopedVariableExcludes", e[e.ParameterExcludes = 111551] = "ParameterExcludes", e[e.PropertyExcludes = 0] = "PropertyExcludes", e[e.EnumMemberExcludes = 900095] = "EnumMemberExcludes", e[e.FunctionExcludes = 110991] = "FunctionExcludes", e[e.ClassExcludes = 899503] = "ClassExcludes", e[e.InterfaceExcludes = 788872] = "InterfaceExcludes", e[e.RegularEnumExcludes = 899327] = "RegularEnumExcludes", e[e.ConstEnumExcludes = 899967] = "ConstEnumExcludes", e[e.ValueModuleExcludes = 110735] = "ValueModuleExcludes", e[e.NamespaceModuleExcludes = 0] = "NamespaceModuleExcludes", e[e.MethodExcludes = 103359] = "MethodExcludes", e[e.GetAccessorExcludes = 46015] = "GetAccessorExcludes", e[e.SetAccessorExcludes = 78783] = "SetAccessorExcludes", e[e.AccessorExcludes = 13247] = "AccessorExcludes", e[e.TypeParameterExcludes = 526824] = "TypeParameterExcludes", e[e.TypeAliasExcludes = 788968] = "TypeAliasExcludes", e[e.AliasExcludes = 2097152] = "AliasExcludes", e[e.ModuleMember = 2623475] = "ModuleMember", e[e.ExportHasLocal = 944] = "ExportHasLocal", e[e.BlockScoped = 418] = "BlockScoped", e[e.PropertyOrAccessor = 98308] = "PropertyOrAccessor", e[e.ClassMember = 106500] = "ClassMember", e[e.ExportSupportsDefaultModifier = 112] = "ExportSupportsDefaultModifier", e[e.ExportDoesNotSupportDefaultModifier = -113] = "ExportDoesNotSupportDefaultModifier", e[e.Classifiable = 2885600] = "Classifiable", e[e.LateBindingContainer = 6256] = "LateBindingContainer", e))(jp || {}), bg = ((e) => (e[e.Numeric = 0] = "Numeric", e[e.Literal = 1] = "Literal", e))(bg || {}), Tg = ((e) => (e[e.None = 0] = "None", e[e.Instantiated = 1] = "Instantiated", e[e.SyntheticProperty = 2] = "SyntheticProperty", e[e.SyntheticMethod = 4] = "SyntheticMethod", e[e.Readonly = 8] = "Readonly", e[e.ReadPartial = 16] = "ReadPartial", e[e.WritePartial = 32] = "WritePartial", e[e.HasNonUniformType = 64] = "HasNonUniformType", e[e.HasLiteralType = 128] = "HasLiteralType", e[e.ContainsPublic = 256] = "ContainsPublic", e[e.ContainsProtected = 512] = "ContainsProtected", e[e.ContainsPrivate = 1024] = "ContainsPrivate", e[e.ContainsStatic = 2048] = "ContainsStatic", e[e.Late = 4096] = "Late", e[e.ReverseMapped = 8192] = "ReverseMapped", e[e.OptionalParameter = 16384] = "OptionalParameter", e[e.RestParameter = 32768] = "RestParameter", e[e.DeferredType = 65536] = "DeferredType", e[e.HasNeverType = 131072] = "HasNeverType", e[e.Mapped = 262144] = "Mapped", e[e.StripOptional = 524288] = "StripOptional", e[e.Unresolved = 1048576] = "Unresolved", e[e.Synthetic = 6] = "Synthetic", e[e.Discriminant = 192] = "Discriminant", e[e.Partial = 48] = "Partial", e))(Tg || {}), Sg = ((e) => (e.Call = "__call", e.Constructor = "__constructor", e.New = "__new", e.Index = "__index", e.ExportStar = "__export", e.Global = "__global", e.Missing = "__missing", e.Type = "__type", e.Object = "__object", e.JSXAttributes = "__jsxAttributes", e.Class = "__class", e.Function = "__function", e.Computed = "__computed", e.Resolving = "__resolving__", e.ExportEquals = "export=", e.Default = "default", e.This = "this", e))(Sg || {}), xg = ((e) => (e[e.None = 0] = "None", e[e.TypeChecked = 1] = "TypeChecked", e[e.LexicalThis = 2] = "LexicalThis", e[e.CaptureThis = 4] = "CaptureThis", e[e.CaptureNewTarget = 8] = "CaptureNewTarget", e[e.SuperInstance = 16] = "SuperInstance", e[e.SuperStatic = 32] = "SuperStatic", e[e.ContextChecked = 64] = "ContextChecked", e[e.MethodWithSuperPropertyAccessInAsync = 128] = "MethodWithSuperPropertyAccessInAsync", e[e.MethodWithSuperPropertyAssignmentInAsync = 256] = "MethodWithSuperPropertyAssignmentInAsync", e[e.CaptureArguments = 512] = "CaptureArguments", e[e.EnumValuesComputed = 1024] = "EnumValuesComputed", e[e.LexicalModuleMergesWithClass = 2048] = "LexicalModuleMergesWithClass", e[e.LoopWithCapturedBlockScopedBinding = 4096] = "LoopWithCapturedBlockScopedBinding", e[e.ContainsCapturedBlockScopeBinding = 8192] = "ContainsCapturedBlockScopeBinding", e[e.CapturedBlockScopedBinding = 16384] = "CapturedBlockScopedBinding", e[e.BlockScopedBindingInLoop = 32768] = "BlockScopedBindingInLoop", e[e.ClassWithBodyScopedClassBinding = 65536] = "ClassWithBodyScopedClassBinding", e[e.BodyScopedClassBinding = 131072] = "BodyScopedClassBinding", e[e.NeedsLoopOutParameter = 262144] = "NeedsLoopOutParameter", e[e.AssignmentsMarked = 524288] = "AssignmentsMarked", e[e.ClassWithConstructorReference = 1048576] = "ClassWithConstructorReference", e[e.ConstructorReferenceInClass = 2097152] = "ConstructorReferenceInClass", e[e.ContainsClassWithPrivateIdentifiers = 4194304] = "ContainsClassWithPrivateIdentifiers", e[e.ContainsSuperPropertyInStaticInitializer = 8388608] = "ContainsSuperPropertyInStaticInitializer", e[e.InCheckIdentifier = 16777216] = "InCheckIdentifier", e))(xg || {}), Jp = ((e) => (e[e.Any = 1] = "Any", e[e.Unknown = 2] = "Unknown", e[e.String = 4] = "String", e[e.Number = 8] = "Number", e[e.Boolean = 16] = "Boolean", e[e.Enum = 32] = "Enum", e[e.BigInt = 64] = "BigInt", e[e.StringLiteral = 128] = "StringLiteral", e[e.NumberLiteral = 256] = "NumberLiteral", e[e.BooleanLiteral = 512] = "BooleanLiteral", e[e.EnumLiteral = 1024] = "EnumLiteral", e[e.BigIntLiteral = 2048] = "BigIntLiteral", e[e.ESSymbol = 4096] = "ESSymbol", e[e.UniqueESSymbol = 8192] = "UniqueESSymbol", e[e.Void = 16384] = "Void", e[e.Undefined = 32768] = "Undefined", e[e.Null = 65536] = "Null", e[e.Never = 131072] = "Never", e[e.TypeParameter = 262144] = "TypeParameter", e[e.Object = 524288] = "Object", e[e.Union = 1048576] = "Union", e[e.Intersection = 2097152] = "Intersection", e[e.Index = 4194304] = "Index", e[e.IndexedAccess = 8388608] = "IndexedAccess", e[e.Conditional = 16777216] = "Conditional", e[e.Substitution = 33554432] = "Substitution", e[e.NonPrimitive = 67108864] = "NonPrimitive", e[e.TemplateLiteral = 134217728] = "TemplateLiteral", e[e.StringMapping = 268435456] = "StringMapping", e[e.AnyOrUnknown = 3] = "AnyOrUnknown", e[e.Nullable = 98304] = "Nullable", e[e.Literal = 2944] = "Literal", e[e.Unit = 109472] = "Unit", e[e.Freshable = 2976] = "Freshable", e[e.StringOrNumberLiteral = 384] = "StringOrNumberLiteral", e[e.StringOrNumberLiteralOrUnique = 8576] = "StringOrNumberLiteralOrUnique", e[e.DefinitelyFalsy = 117632] = "DefinitelyFalsy", e[e.PossiblyFalsy = 117724] = "PossiblyFalsy", e[e.Intrinsic = 67359327] = "Intrinsic", e[e.Primitive = 134348796] = "Primitive", e[e.StringLike = 402653316] = "StringLike", e[e.NumberLike = 296] = "NumberLike", e[e.BigIntLike = 2112] = "BigIntLike", e[e.BooleanLike = 528] = "BooleanLike", e[e.EnumLike = 1056] = "EnumLike", e[e.ESSymbolLike = 12288] = "ESSymbolLike", e[e.VoidLike = 49152] = "VoidLike", e[e.DefinitelyNonNullable = 470302716] = "DefinitelyNonNullable", e[e.DisjointDomains = 469892092] = "DisjointDomains", e[e.UnionOrIntersection = 3145728] = "UnionOrIntersection", e[e.StructuredType = 3670016] = "StructuredType", e[e.TypeVariable = 8650752] = "TypeVariable", e[e.InstantiableNonPrimitive = 58982400] = "InstantiableNonPrimitive", e[e.InstantiablePrimitive = 406847488] = "InstantiablePrimitive", e[e.Instantiable = 465829888] = "Instantiable", e[e.StructuredOrInstantiable = 469499904] = "StructuredOrInstantiable", e[e.ObjectFlagsType = 3899393] = "ObjectFlagsType", e[e.Simplifiable = 25165824] = "Simplifiable", e[e.Singleton = 67358815] = "Singleton", e[e.Narrowable = 536624127] = "Narrowable", e[e.IncludesMask = 205258751] = "IncludesMask", e[e.IncludesMissingType = 262144] = "IncludesMissingType", e[e.IncludesNonWideningType = 4194304] = "IncludesNonWideningType", e[e.IncludesWildcard = 8388608] = "IncludesWildcard", e[e.IncludesEmptyObject = 16777216] = "IncludesEmptyObject", e[e.IncludesInstantiable = 33554432] = "IncludesInstantiable", e[e.NotPrimitiveUnion = 36323363] = "NotPrimitiveUnion", e))(Jp || {}), Fp = ((e) => (e[e.None = 0] = "None", e[e.Class = 1] = "Class", e[e.Interface = 2] = "Interface", e[e.Reference = 4] = "Reference", e[e.Tuple = 8] = "Tuple", e[e.Anonymous = 16] = "Anonymous", e[e.Mapped = 32] = "Mapped", e[e.Instantiated = 64] = "Instantiated", e[e.ObjectLiteral = 128] = "ObjectLiteral", e[e.EvolvingArray = 256] = "EvolvingArray", e[e.ObjectLiteralPatternWithComputedProperties = 512] = "ObjectLiteralPatternWithComputedProperties", e[e.ReverseMapped = 1024] = "ReverseMapped", e[e.JsxAttributes = 2048] = "JsxAttributes", e[e.JSLiteral = 4096] = "JSLiteral", e[e.FreshLiteral = 8192] = "FreshLiteral", e[e.ArrayLiteral = 16384] = "ArrayLiteral", e[e.PrimitiveUnion = 32768] = "PrimitiveUnion", e[e.ContainsWideningType = 65536] = "ContainsWideningType", e[e.ContainsObjectOrArrayLiteral = 131072] = "ContainsObjectOrArrayLiteral", e[e.NonInferrableType = 262144] = "NonInferrableType", e[e.CouldContainTypeVariablesComputed = 524288] = "CouldContainTypeVariablesComputed", e[e.CouldContainTypeVariables = 1048576] = "CouldContainTypeVariables", e[e.ClassOrInterface = 3] = "ClassOrInterface", e[e.RequiresWidening = 196608] = "RequiresWidening", e[e.PropagatingFlags = 458752] = "PropagatingFlags", e[e.ObjectTypeKindMask = 1343] = "ObjectTypeKindMask", e[e.ContainsSpread = 2097152] = "ContainsSpread", e[e.ObjectRestType = 4194304] = "ObjectRestType", e[e.InstantiationExpressionType = 8388608] = "InstantiationExpressionType", e[e.IsClassInstanceClone = 16777216] = "IsClassInstanceClone", e[e.IdenticalBaseTypeCalculated = 33554432] = "IdenticalBaseTypeCalculated", e[e.IdenticalBaseTypeExists = 67108864] = "IdenticalBaseTypeExists", e[e.IsGenericTypeComputed = 2097152] = "IsGenericTypeComputed", e[e.IsGenericObjectType = 4194304] = "IsGenericObjectType", e[e.IsGenericIndexType = 8388608] = "IsGenericIndexType", e[e.IsGenericType = 12582912] = "IsGenericType", e[e.ContainsIntersections = 16777216] = "ContainsIntersections", e[e.IsUnknownLikeUnionComputed = 33554432] = "IsUnknownLikeUnionComputed", e[e.IsUnknownLikeUnion = 67108864] = "IsUnknownLikeUnion", e[e.IsNeverIntersectionComputed = 16777216] = "IsNeverIntersectionComputed", e[e.IsNeverIntersection = 33554432] = "IsNeverIntersection", e))(Fp || {}), Eg = ((e) => (e[e.Invariant = 0] = "Invariant", e[e.Covariant = 1] = "Covariant", e[e.Contravariant = 2] = "Contravariant", e[e.Bivariant = 3] = "Bivariant", e[e.Independent = 4] = "Independent", e[e.VarianceMask = 7] = "VarianceMask", e[e.Unmeasurable = 8] = "Unmeasurable", e[e.Unreliable = 16] = "Unreliable", e[e.AllowsStructuralFallback = 24] = "AllowsStructuralFallback", e))(Eg || {}), wg = ((e) => (e[e.Required = 1] = "Required", e[e.Optional = 2] = "Optional", e[e.Rest = 4] = "Rest", e[e.Variadic = 8] = "Variadic", e[e.Fixed = 3] = "Fixed", e[e.Variable = 12] = "Variable", e[e.NonRequired = 14] = "NonRequired", e[e.NonRest = 11] = "NonRest", e))(wg || {}), Cg = ((e) => (e[e.None = 0] = "None", e[e.IncludeUndefined = 1] = "IncludeUndefined", e[e.NoIndexSignatures = 2] = "NoIndexSignatures", e[e.Writing = 4] = "Writing", e[e.CacheSymbol = 8] = "CacheSymbol", e[e.NoTupleBoundsCheck = 16] = "NoTupleBoundsCheck", e[e.ExpressionPosition = 32] = "ExpressionPosition", e[e.ReportDeprecated = 64] = "ReportDeprecated", e[e.SuppressNoImplicitAnyError = 128] = "SuppressNoImplicitAnyError", e[e.Contextual = 256] = "Contextual", e[e.Persistent = 1] = "Persistent", e))(Cg || {}), Ag = ((e) => (e[e.Component = 0] = "Component", e[e.Function = 1] = "Function", e[e.Mixed = 2] = "Mixed", e))(Ag || {}), Pg = ((e) => (e[e.Call = 0] = "Call", e[e.Construct = 1] = "Construct", e))(Pg || {}), Bp = ((e) => (e[e.None = 0] = "None", e[e.HasRestParameter = 1] = "HasRestParameter", e[e.HasLiteralTypes = 2] = "HasLiteralTypes", e[e.Abstract = 4] = "Abstract", e[e.IsInnerCallChain = 8] = "IsInnerCallChain", e[e.IsOuterCallChain = 16] = "IsOuterCallChain", e[e.IsUntypedSignatureInJSFile = 32] = "IsUntypedSignatureInJSFile", e[e.PropagatingFlags = 39] = "PropagatingFlags", e[e.CallChainFlags = 24] = "CallChainFlags", e))(Bp || {}), Dg = ((e) => (e[e.String = 0] = "String", e[e.Number = 1] = "Number", e))(Dg || {}), kg2 = ((e) => (e[e.Simple = 0] = "Simple", e[e.Array = 1] = "Array", e[e.Deferred = 2] = "Deferred", e[e.Function = 3] = "Function", e[e.Composite = 4] = "Composite", e[e.Merged = 5] = "Merged", e))(kg2 || {}), Ig = ((e) => (e[e.None = 0] = "None", e[e.NakedTypeVariable = 1] = "NakedTypeVariable", e[e.SpeculativeTuple = 2] = "SpeculativeTuple", e[e.SubstituteSource = 4] = "SubstituteSource", e[e.HomomorphicMappedType = 8] = "HomomorphicMappedType", e[e.PartialHomomorphicMappedType = 16] = "PartialHomomorphicMappedType", e[e.MappedTypeConstraint = 32] = "MappedTypeConstraint", e[e.ContravariantConditional = 64] = "ContravariantConditional", e[e.ReturnType = 128] = "ReturnType", e[e.LiteralKeyof = 256] = "LiteralKeyof", e[e.NoConstraints = 512] = "NoConstraints", e[e.AlwaysStrict = 1024] = "AlwaysStrict", e[e.MaxValue = 2048] = "MaxValue", e[e.PriorityImpliesCombination = 416] = "PriorityImpliesCombination", e[e.Circularity = -1] = "Circularity", e))(Ig || {}), Ng = ((e) => (e[e.None = 0] = "None", e[e.NoDefault = 1] = "NoDefault", e[e.AnyDefault = 2] = "AnyDefault", e[e.SkippedGenericFunction = 4] = "SkippedGenericFunction", e))(Ng || {}), Og = ((e) => (e[e.False = 0] = "False", e[e.Unknown = 1] = "Unknown", e[e.Maybe = 3] = "Maybe", e[e.True = -1] = "True", e))(Og || {}), Mg = ((e) => (e[e.None = 0] = "None", e[e.ExportsProperty = 1] = "ExportsProperty", e[e.ModuleExports = 2] = "ModuleExports", e[e.PrototypeProperty = 3] = "PrototypeProperty", e[e.ThisProperty = 4] = "ThisProperty", e[e.Property = 5] = "Property", e[e.Prototype = 6] = "Prototype", e[e.ObjectDefinePropertyValue = 7] = "ObjectDefinePropertyValue", e[e.ObjectDefinePropertyExports = 8] = "ObjectDefinePropertyExports", e[e.ObjectDefinePrototypeProperty = 9] = "ObjectDefinePrototypeProperty", e))(Mg || {}), qp = ((e) => (e[e.Warning = 0] = "Warning", e[e.Error = 1] = "Error", e[e.Suggestion = 2] = "Suggestion", e[e.Message = 3] = "Message", e))(qp || {}), Lg = ((e) => (e[e.Classic = 1] = "Classic", e[e.NodeJs = 2] = "NodeJs", e[e.Node10 = 2] = "Node10", e[e.Node16 = 3] = "Node16", e[e.NodeNext = 99] = "NodeNext", e[e.Bundler = 100] = "Bundler", e))(Lg || {}), Rg = ((e) => (e[e.Legacy = 1] = "Legacy", e[e.Auto = 2] = "Auto", e[e.Force = 3] = "Force", e))(Rg || {}), jg = ((e) => (e[e.FixedPollingInterval = 0] = "FixedPollingInterval", e[e.PriorityPollingInterval = 1] = "PriorityPollingInterval", e[e.DynamicPriorityPolling = 2] = "DynamicPriorityPolling", e[e.FixedChunkSizePolling = 3] = "FixedChunkSizePolling", e[e.UseFsEvents = 4] = "UseFsEvents", e[e.UseFsEventsOnParentDirectory = 5] = "UseFsEventsOnParentDirectory", e))(jg || {}), Jg = ((e) => (e[e.UseFsEvents = 0] = "UseFsEvents", e[e.FixedPollingInterval = 1] = "FixedPollingInterval", e[e.DynamicPriorityPolling = 2] = "DynamicPriorityPolling", e[e.FixedChunkSizePolling = 3] = "FixedChunkSizePolling", e))(Jg || {}), Fg = ((e) => (e[e.FixedInterval = 0] = "FixedInterval", e[e.PriorityInterval = 1] = "PriorityInterval", e[e.DynamicPriority = 2] = "DynamicPriority", e[e.FixedChunkSize = 3] = "FixedChunkSize", e))(Fg || {}), Bg2 = ((e) => (e[e.None = 0] = "None", e[e.CommonJS = 1] = "CommonJS", e[e.AMD = 2] = "AMD", e[e.UMD = 3] = "UMD", e[e.System = 4] = "System", e[e.ES2015 = 5] = "ES2015", e[e.ES2020 = 6] = "ES2020", e[e.ES2022 = 7] = "ES2022", e[e.ESNext = 99] = "ESNext", e[e.Node16 = 100] = "Node16", e[e.NodeNext = 199] = "NodeNext", e))(Bg2 || {}), qg = ((e) => (e[e.None = 0] = "None", e[e.Preserve = 1] = "Preserve", e[e.React = 2] = "React", e[e.ReactNative = 3] = "ReactNative", e[e.ReactJSX = 4] = "ReactJSX", e[e.ReactJSXDev = 5] = "ReactJSXDev", e))(qg || {}), Ug = ((e) => (e[e.Remove = 0] = "Remove", e[e.Preserve = 1] = "Preserve", e[e.Error = 2] = "Error", e))(Ug || {}), zg = ((e) => (e[e.CarriageReturnLineFeed = 0] = "CarriageReturnLineFeed", e[e.LineFeed = 1] = "LineFeed", e))(zg || {}), Wg = ((e) => (e[e.Unknown = 0] = "Unknown", e[e.JS = 1] = "JS", e[e.JSX = 2] = "JSX", e[e.TS = 3] = "TS", e[e.TSX = 4] = "TSX", e[e.External = 5] = "External", e[e.JSON = 6] = "JSON", e[e.Deferred = 7] = "Deferred", e))(Wg || {}), Vg = ((e) => (e[e.ES3 = 0] = "ES3", e[e.ES5 = 1] = "ES5", e[e.ES2015 = 2] = "ES2015", e[e.ES2016 = 3] = "ES2016", e[e.ES2017 = 4] = "ES2017", e[e.ES2018 = 5] = "ES2018", e[e.ES2019 = 6] = "ES2019", e[e.ES2020 = 7] = "ES2020", e[e.ES2021 = 8] = "ES2021", e[e.ES2022 = 9] = "ES2022", e[e.ESNext = 99] = "ESNext", e[e.JSON = 100] = "JSON", e[e.Latest = 99] = "Latest", e))(Vg || {}), Hg = ((e) => (e[e.Standard = 0] = "Standard", e[e.JSX = 1] = "JSX", e))(Hg || {}), Gg = ((e) => (e[e.None = 0] = "None", e[e.Recursive = 1] = "Recursive", e))(Gg || {}), $g = ((e) => (e[e.nullCharacter = 0] = "nullCharacter", e[e.maxAsciiCharacter = 127] = "maxAsciiCharacter", e[e.lineFeed = 10] = "lineFeed", e[e.carriageReturn = 13] = "carriageReturn", e[e.lineSeparator = 8232] = "lineSeparator", e[e.paragraphSeparator = 8233] = "paragraphSeparator", e[e.nextLine = 133] = "nextLine", e[e.space = 32] = "space", e[e.nonBreakingSpace = 160] = "nonBreakingSpace", e[e.enQuad = 8192] = "enQuad", e[e.emQuad = 8193] = "emQuad", e[e.enSpace = 8194] = "enSpace", e[e.emSpace = 8195] = "emSpace", e[e.threePerEmSpace = 8196] = "threePerEmSpace", e[e.fourPerEmSpace = 8197] = "fourPerEmSpace", e[e.sixPerEmSpace = 8198] = "sixPerEmSpace", e[e.figureSpace = 8199] = "figureSpace", e[e.punctuationSpace = 8200] = "punctuationSpace", e[e.thinSpace = 8201] = "thinSpace", e[e.hairSpace = 8202] = "hairSpace", e[e.zeroWidthSpace = 8203] = "zeroWidthSpace", e[e.narrowNoBreakSpace = 8239] = "narrowNoBreakSpace", e[e.ideographicSpace = 12288] = "ideographicSpace", e[e.mathematicalSpace = 8287] = "mathematicalSpace", e[e.ogham = 5760] = "ogham", e[e._ = 95] = "_", e[e.$ = 36] = "$", e[e._0 = 48] = "_0", e[e._1 = 49] = "_1", e[e._2 = 50] = "_2", e[e._3 = 51] = "_3", e[e._4 = 52] = "_4", e[e._5 = 53] = "_5", e[e._6 = 54] = "_6", e[e._7 = 55] = "_7", e[e._8 = 56] = "_8", e[e._9 = 57] = "_9", e[e.a = 97] = "a", e[e.b = 98] = "b", e[e.c = 99] = "c", e[e.d = 100] = "d", e[e.e = 101] = "e", e[e.f = 102] = "f", e[e.g = 103] = "g", e[e.h = 104] = "h", e[e.i = 105] = "i", e[e.j = 106] = "j", e[e.k = 107] = "k", e[e.l = 108] = "l", e[e.m = 109] = "m", e[e.n = 110] = "n", e[e.o = 111] = "o", e[e.p = 112] = "p", e[e.q = 113] = "q", e[e.r = 114] = "r", e[e.s = 115] = "s", e[e.t = 116] = "t", e[e.u = 117] = "u", e[e.v = 118] = "v", e[e.w = 119] = "w", e[e.x = 120] = "x", e[e.y = 121] = "y", e[e.z = 122] = "z", e[e.A = 65] = "A", e[e.B = 66] = "B", e[e.C = 67] = "C", e[e.D = 68] = "D", e[e.E = 69] = "E", e[e.F = 70] = "F", e[e.G = 71] = "G", e[e.H = 72] = "H", e[e.I = 73] = "I", e[e.J = 74] = "J", e[e.K = 75] = "K", e[e.L = 76] = "L", e[e.M = 77] = "M", e[e.N = 78] = "N", e[e.O = 79] = "O", e[e.P = 80] = "P", e[e.Q = 81] = "Q", e[e.R = 82] = "R", e[e.S = 83] = "S", e[e.T = 84] = "T", e[e.U = 85] = "U", e[e.V = 86] = "V", e[e.W = 87] = "W", e[e.X = 88] = "X", e[e.Y = 89] = "Y", e[e.Z = 90] = "Z", e[e.ampersand = 38] = "ampersand", e[e.asterisk = 42] = "asterisk", e[e.at = 64] = "at", e[e.backslash = 92] = "backslash", e[e.backtick = 96] = "backtick", e[e.bar = 124] = "bar", e[e.caret = 94] = "caret", e[e.closeBrace = 125] = "closeBrace", e[e.closeBracket = 93] = "closeBracket", e[e.closeParen = 41] = "closeParen", e[e.colon = 58] = "colon", e[e.comma = 44] = "comma", e[e.dot = 46] = "dot", e[e.doubleQuote = 34] = "doubleQuote", e[e.equals = 61] = "equals", e[e.exclamation = 33] = "exclamation", e[e.greaterThan = 62] = "greaterThan", e[e.hash = 35] = "hash", e[e.lessThan = 60] = "lessThan", e[e.minus = 45] = "minus", e[e.openBrace = 123] = "openBrace", e[e.openBracket = 91] = "openBracket", e[e.openParen = 40] = "openParen", e[e.percent = 37] = "percent", e[e.plus = 43] = "plus", e[e.question = 63] = "question", e[e.semicolon = 59] = "semicolon", e[e.singleQuote = 39] = "singleQuote", e[e.slash = 47] = "slash", e[e.tilde = 126] = "tilde", e[e.backspace = 8] = "backspace", e[e.formFeed = 12] = "formFeed", e[e.byteOrderMark = 65279] = "byteOrderMark", e[e.tab = 9] = "tab", e[e.verticalTab = 11] = "verticalTab", e))($g || {}), Kg = ((e) => (e.Ts = ".ts", e.Tsx = ".tsx", e.Dts = ".d.ts", e.Js = ".js", e.Jsx = ".jsx", e.Json = ".json", e.TsBuildInfo = ".tsbuildinfo", e.Mjs = ".mjs", e.Mts = ".mts", e.Dmts = ".d.mts", e.Cjs = ".cjs", e.Cts = ".cts", e.Dcts = ".d.cts", e))(Kg || {}), Up = ((e) => (e[e.None = 0] = "None", e[e.ContainsTypeScript = 1] = "ContainsTypeScript", e[e.ContainsJsx = 2] = "ContainsJsx", e[e.ContainsESNext = 4] = "ContainsESNext", e[e.ContainsES2022 = 8] = "ContainsES2022", e[e.ContainsES2021 = 16] = "ContainsES2021", e[e.ContainsES2020 = 32] = "ContainsES2020", e[e.ContainsES2019 = 64] = "ContainsES2019", e[e.ContainsES2018 = 128] = "ContainsES2018", e[e.ContainsES2017 = 256] = "ContainsES2017", e[e.ContainsES2016 = 512] = "ContainsES2016", e[e.ContainsES2015 = 1024] = "ContainsES2015", e[e.ContainsGenerator = 2048] = "ContainsGenerator", e[e.ContainsDestructuringAssignment = 4096] = "ContainsDestructuringAssignment", e[e.ContainsTypeScriptClassSyntax = 8192] = "ContainsTypeScriptClassSyntax", e[e.ContainsLexicalThis = 16384] = "ContainsLexicalThis", e[e.ContainsRestOrSpread = 32768] = "ContainsRestOrSpread", e[e.ContainsObjectRestOrSpread = 65536] = "ContainsObjectRestOrSpread", e[e.ContainsComputedPropertyName = 131072] = "ContainsComputedPropertyName", e[e.ContainsBlockScopedBinding = 262144] = "ContainsBlockScopedBinding", e[e.ContainsBindingPattern = 524288] = "ContainsBindingPattern", e[e.ContainsYield = 1048576] = "ContainsYield", e[e.ContainsAwait = 2097152] = "ContainsAwait", e[e.ContainsHoistedDeclarationOrCompletion = 4194304] = "ContainsHoistedDeclarationOrCompletion", e[e.ContainsDynamicImport = 8388608] = "ContainsDynamicImport", e[e.ContainsClassFields = 16777216] = "ContainsClassFields", e[e.ContainsDecorators = 33554432] = "ContainsDecorators", e[e.ContainsPossibleTopLevelAwait = 67108864] = "ContainsPossibleTopLevelAwait", e[e.ContainsLexicalSuper = 134217728] = "ContainsLexicalSuper", e[e.ContainsUpdateExpressionForIdentifier = 268435456] = "ContainsUpdateExpressionForIdentifier", e[e.ContainsPrivateIdentifierInExpression = 536870912] = "ContainsPrivateIdentifierInExpression", e[e.HasComputedFlags = -2147483648] = "HasComputedFlags", e[e.AssertTypeScript = 1] = "AssertTypeScript", e[e.AssertJsx = 2] = "AssertJsx", e[e.AssertESNext = 4] = "AssertESNext", e[e.AssertES2022 = 8] = "AssertES2022", e[e.AssertES2021 = 16] = "AssertES2021", e[e.AssertES2020 = 32] = "AssertES2020", e[e.AssertES2019 = 64] = "AssertES2019", e[e.AssertES2018 = 128] = "AssertES2018", e[e.AssertES2017 = 256] = "AssertES2017", e[e.AssertES2016 = 512] = "AssertES2016", e[e.AssertES2015 = 1024] = "AssertES2015", e[e.AssertGenerator = 2048] = "AssertGenerator", e[e.AssertDestructuringAssignment = 4096] = "AssertDestructuringAssignment", e[e.OuterExpressionExcludes = -2147483648] = "OuterExpressionExcludes", e[e.PropertyAccessExcludes = -2147483648] = "PropertyAccessExcludes", e[e.NodeExcludes = -2147483648] = "NodeExcludes", e[e.ArrowFunctionExcludes = -2072174592] = "ArrowFunctionExcludes", e[e.FunctionExcludes = -1937940480] = "FunctionExcludes", e[e.ConstructorExcludes = -1937948672] = "ConstructorExcludes", e[e.MethodOrAccessorExcludes = -2005057536] = "MethodOrAccessorExcludes", e[e.PropertyExcludes = -2013249536] = "PropertyExcludes", e[e.ClassExcludes = -2147344384] = "ClassExcludes", e[e.ModuleExcludes = -1941676032] = "ModuleExcludes", e[e.TypeExcludes = -2] = "TypeExcludes", e[e.ObjectLiteralExcludes = -2147278848] = "ObjectLiteralExcludes", e[e.ArrayLiteralOrCallOrNewExcludes = -2147450880] = "ArrayLiteralOrCallOrNewExcludes", e[e.VariableDeclarationListExcludes = -2146893824] = "VariableDeclarationListExcludes", e[e.ParameterExcludes = -2147483648] = "ParameterExcludes", e[e.CatchClauseExcludes = -2147418112] = "CatchClauseExcludes", e[e.BindingPatternExcludes = -2147450880] = "BindingPatternExcludes", e[e.ContainsLexicalThisOrSuper = 134234112] = "ContainsLexicalThisOrSuper", e[e.PropertyNamePropagatingFlags = 134234112] = "PropertyNamePropagatingFlags", e))(Up || {}), zp = ((e) => (e[e.TabStop = 0] = "TabStop", e[e.Placeholder = 1] = "Placeholder", e[e.Choice = 2] = "Choice", e[e.Variable = 3] = "Variable", e))(zp || {}), Wp = ((e) => (e[e.None = 0] = "None", e[e.SingleLine = 1] = "SingleLine", e[e.MultiLine = 2] = "MultiLine", e[e.AdviseOnEmitNode = 4] = "AdviseOnEmitNode", e[e.NoSubstitution = 8] = "NoSubstitution", e[e.CapturesThis = 16] = "CapturesThis", e[e.NoLeadingSourceMap = 32] = "NoLeadingSourceMap", e[e.NoTrailingSourceMap = 64] = "NoTrailingSourceMap", e[e.NoSourceMap = 96] = "NoSourceMap", e[e.NoNestedSourceMaps = 128] = "NoNestedSourceMaps", e[e.NoTokenLeadingSourceMaps = 256] = "NoTokenLeadingSourceMaps", e[e.NoTokenTrailingSourceMaps = 512] = "NoTokenTrailingSourceMaps", e[e.NoTokenSourceMaps = 768] = "NoTokenSourceMaps", e[e.NoLeadingComments = 1024] = "NoLeadingComments", e[e.NoTrailingComments = 2048] = "NoTrailingComments", e[e.NoComments = 3072] = "NoComments", e[e.NoNestedComments = 4096] = "NoNestedComments", e[e.HelperName = 8192] = "HelperName", e[e.ExportName = 16384] = "ExportName", e[e.LocalName = 32768] = "LocalName", e[e.InternalName = 65536] = "InternalName", e[e.Indented = 131072] = "Indented", e[e.NoIndentation = 262144] = "NoIndentation", e[e.AsyncFunctionBody = 524288] = "AsyncFunctionBody", e[e.ReuseTempVariableScope = 1048576] = "ReuseTempVariableScope", e[e.CustomPrologue = 2097152] = "CustomPrologue", e[e.NoHoisting = 4194304] = "NoHoisting", e[e.HasEndOfDeclarationMarker = 8388608] = "HasEndOfDeclarationMarker", e[e.Iterator = 16777216] = "Iterator", e[e.NoAsciiEscaping = 33554432] = "NoAsciiEscaping", e))(Wp || {}), Xg = ((e) => (e[e.None = 0] = "None", e[e.TypeScriptClassWrapper = 1] = "TypeScriptClassWrapper", e[e.NeverApplyImportHelper = 2] = "NeverApplyImportHelper", e[e.IgnoreSourceNewlines = 4] = "IgnoreSourceNewlines", e[e.Immutable = 8] = "Immutable", e[e.IndirectCall = 16] = "IndirectCall", e[e.TransformPrivateStaticElements = 32] = "TransformPrivateStaticElements", e))(Xg || {}), Yg = ((e) => (e[e.Extends = 1] = "Extends", e[e.Assign = 2] = "Assign", e[e.Rest = 4] = "Rest", e[e.Decorate = 8] = "Decorate", e[e.ESDecorateAndRunInitializers = 8] = "ESDecorateAndRunInitializers", e[e.Metadata = 16] = "Metadata", e[e.Param = 32] = "Param", e[e.Awaiter = 64] = "Awaiter", e[e.Generator = 128] = "Generator", e[e.Values = 256] = "Values", e[e.Read = 512] = "Read", e[e.SpreadArray = 1024] = "SpreadArray", e[e.Await = 2048] = "Await", e[e.AsyncGenerator = 4096] = "AsyncGenerator", e[e.AsyncDelegator = 8192] = "AsyncDelegator", e[e.AsyncValues = 16384] = "AsyncValues", e[e.ExportStar = 32768] = "ExportStar", e[e.ImportStar = 65536] = "ImportStar", e[e.ImportDefault = 131072] = "ImportDefault", e[e.MakeTemplateObject = 262144] = "MakeTemplateObject", e[e.ClassPrivateFieldGet = 524288] = "ClassPrivateFieldGet", e[e.ClassPrivateFieldSet = 1048576] = "ClassPrivateFieldSet", e[e.ClassPrivateFieldIn = 2097152] = "ClassPrivateFieldIn", e[e.CreateBinding = 4194304] = "CreateBinding", e[e.SetFunctionName = 8388608] = "SetFunctionName", e[e.PropKey = 16777216] = "PropKey", e[e.FirstEmitHelper = 1] = "FirstEmitHelper", e[e.LastEmitHelper = 16777216] = "LastEmitHelper", e[e.ForOfIncludes = 256] = "ForOfIncludes", e[e.ForAwaitOfIncludes = 16384] = "ForAwaitOfIncludes", e[e.AsyncGeneratorIncludes = 6144] = "AsyncGeneratorIncludes", e[e.AsyncDelegatorIncludes = 26624] = "AsyncDelegatorIncludes", e[e.SpreadIncludes = 1536] = "SpreadIncludes", e))(Yg || {}), Qg = ((e) => (e[e.SourceFile = 0] = "SourceFile", e[e.Expression = 1] = "Expression", e[e.IdentifierName = 2] = "IdentifierName", e[e.MappedTypeParameter = 3] = "MappedTypeParameter", e[e.Unspecified = 4] = "Unspecified", e[e.EmbeddedStatement = 5] = "EmbeddedStatement", e[e.JsxAttributeValue = 6] = "JsxAttributeValue", e))(Qg || {}), Zg = ((e) => (e[e.Parentheses = 1] = "Parentheses", e[e.TypeAssertions = 2] = "TypeAssertions", e[e.NonNullAssertions = 4] = "NonNullAssertions", e[e.PartiallyEmittedExpressions = 8] = "PartiallyEmittedExpressions", e[e.Assertions = 6] = "Assertions", e[e.All = 15] = "All", e[e.ExcludeJSDocTypeAssertion = 16] = "ExcludeJSDocTypeAssertion", e))(Zg || {}), ey = ((e) => (e[e.None = 0] = "None", e[e.InParameters = 1] = "InParameters", e[e.VariablesHoistedInParameters = 2] = "VariablesHoistedInParameters", e))(ey || {}), ty = ((e) => (e.Prologue = "prologue", e.EmitHelpers = "emitHelpers", e.NoDefaultLib = "no-default-lib", e.Reference = "reference", e.Type = "type", e.TypeResolutionModeRequire = "type-require", e.TypeResolutionModeImport = "type-import", e.Lib = "lib", e.Prepend = "prepend", e.Text = "text", e.Internal = "internal", e))(ty || {}), ry = ((e) => (e[e.None = 0] = "None", e[e.SingleLine = 0] = "SingleLine", e[e.MultiLine = 1] = "MultiLine", e[e.PreserveLines = 2] = "PreserveLines", e[e.LinesMask = 3] = "LinesMask", e[e.NotDelimited = 0] = "NotDelimited", e[e.BarDelimited = 4] = "BarDelimited", e[e.AmpersandDelimited = 8] = "AmpersandDelimited", e[e.CommaDelimited = 16] = "CommaDelimited", e[e.AsteriskDelimited = 32] = "AsteriskDelimited", e[e.DelimitersMask = 60] = "DelimitersMask", e[e.AllowTrailingComma = 64] = "AllowTrailingComma", e[e.Indented = 128] = "Indented", e[e.SpaceBetweenBraces = 256] = "SpaceBetweenBraces", e[e.SpaceBetweenSiblings = 512] = "SpaceBetweenSiblings", e[e.Braces = 1024] = "Braces", e[e.Parenthesis = 2048] = "Parenthesis", e[e.AngleBrackets = 4096] = "AngleBrackets", e[e.SquareBrackets = 8192] = "SquareBrackets", e[e.BracketsMask = 15360] = "BracketsMask", e[e.OptionalIfUndefined = 16384] = "OptionalIfUndefined", e[e.OptionalIfEmpty = 32768] = "OptionalIfEmpty", e[e.Optional = 49152] = "Optional", e[e.PreferNewLine = 65536] = "PreferNewLine", e[e.NoTrailingNewLine = 131072] = "NoTrailingNewLine", e[e.NoInterveningComments = 262144] = "NoInterveningComments", e[e.NoSpaceIfEmpty = 524288] = "NoSpaceIfEmpty", e[e.SingleElement = 1048576] = "SingleElement", e[e.SpaceAfterList = 2097152] = "SpaceAfterList", e[e.Modifiers = 2359808] = "Modifiers", e[e.HeritageClauses = 512] = "HeritageClauses", e[e.SingleLineTypeLiteralMembers = 768] = "SingleLineTypeLiteralMembers", e[e.MultiLineTypeLiteralMembers = 32897] = "MultiLineTypeLiteralMembers", e[e.SingleLineTupleTypeElements = 528] = "SingleLineTupleTypeElements", e[e.MultiLineTupleTypeElements = 657] = "MultiLineTupleTypeElements", e[e.UnionTypeConstituents = 516] = "UnionTypeConstituents", e[e.IntersectionTypeConstituents = 520] = "IntersectionTypeConstituents", e[e.ObjectBindingPatternElements = 525136] = "ObjectBindingPatternElements", e[e.ArrayBindingPatternElements = 524880] = "ArrayBindingPatternElements", e[e.ObjectLiteralExpressionProperties = 526226] = "ObjectLiteralExpressionProperties", e[e.ImportClauseEntries = 526226] = "ImportClauseEntries", e[e.ArrayLiteralExpressionElements = 8914] = "ArrayLiteralExpressionElements", e[e.CommaListElements = 528] = "CommaListElements", e[e.CallExpressionArguments = 2576] = "CallExpressionArguments", e[e.NewExpressionArguments = 18960] = "NewExpressionArguments", e[e.TemplateExpressionSpans = 262144] = "TemplateExpressionSpans", e[e.SingleLineBlockStatements = 768] = "SingleLineBlockStatements", e[e.MultiLineBlockStatements = 129] = "MultiLineBlockStatements", e[e.VariableDeclarationList = 528] = "VariableDeclarationList", e[e.SingleLineFunctionBodyStatements = 768] = "SingleLineFunctionBodyStatements", e[e.MultiLineFunctionBodyStatements = 1] = "MultiLineFunctionBodyStatements", e[e.ClassHeritageClauses = 0] = "ClassHeritageClauses", e[e.ClassMembers = 129] = "ClassMembers", e[e.InterfaceMembers = 129] = "InterfaceMembers", e[e.EnumMembers = 145] = "EnumMembers", e[e.CaseBlockClauses = 129] = "CaseBlockClauses", e[e.NamedImportsOrExportsElements = 525136] = "NamedImportsOrExportsElements", e[e.JsxElementOrFragmentChildren = 262144] = "JsxElementOrFragmentChildren", e[e.JsxElementAttributes = 262656] = "JsxElementAttributes", e[e.CaseOrDefaultClauseStatements = 163969] = "CaseOrDefaultClauseStatements", e[e.HeritageClauseTypes = 528] = "HeritageClauseTypes", e[e.SourceFileStatements = 131073] = "SourceFileStatements", e[e.Decorators = 2146305] = "Decorators", e[e.TypeArguments = 53776] = "TypeArguments", e[e.TypeParameters = 53776] = "TypeParameters", e[e.Parameters = 2576] = "Parameters", e[e.IndexSignatureParameters = 8848] = "IndexSignatureParameters", e[e.JSDocComment = 33] = "JSDocComment", e))(ry || {}), ny = ((e) => (e[e.None = 0] = "None", e[e.TripleSlashXML = 1] = "TripleSlashXML", e[e.SingleLine = 2] = "SingleLine", e[e.MultiLine = 4] = "MultiLine", e[e.All = 7] = "All", e[e.Default = 7] = "Default", e))(ny || {}), Vp = { reference: { args: [{ name: "types", optional: true, captureSpan: true }, { name: "lib", optional: true, captureSpan: true }, { name: "path", optional: true, captureSpan: true }, { name: "no-default-lib", optional: true }, { name: "resolution-mode", optional: true }], kind: 1 }, "amd-dependency": { args: [{ name: "path" }, { name: "name", optional: true }], kind: 1 }, "amd-module": { args: [{ name: "name" }], kind: 1 }, "ts-check": { kind: 2 }, "ts-nocheck": { kind: 2 }, jsx: { args: [{ name: "factory" }], kind: 4 }, jsxfrag: { args: [{ name: "factory" }], kind: 4 }, jsximportsource: { args: [{ name: "factory" }], kind: 4 }, jsxruntime: { args: [{ name: "factory" }], kind: 4 } };
          } }), W5 = () => {
          }, iy;
          function ay(e) {
            return e === 47 || e === 92;
          }
          function V5(e) {
            return al(e) < 0;
          }
          function A_(e) {
            return al(e) > 0;
          }
          function H5(e) {
            let t6 = al(e);
            return t6 > 0 && t6 === e.length;
          }
          function sy(e) {
            return al(e) !== 0;
          }
          function So(e) {
            return /^\.\.?($|[\\/])/.test(e);
          }
          function G5(e) {
            return !sy(e) && !So(e);
          }
          function OT(e) {
            return Fi(sl(e), ".");
          }
          function ns(e, t6) {
            return e.length > t6.length && es(e, t6);
          }
          function da(e, t6) {
            for (let r of t6)
              if (ns(e, r))
                return true;
            return false;
          }
          function Hp(e) {
            return e.length > 0 && ay(e.charCodeAt(e.length - 1));
          }
          function MT(e) {
            return e >= 97 && e <= 122 || e >= 65 && e <= 90;
          }
          function $5(e, t6) {
            let r = e.charCodeAt(t6);
            if (r === 58)
              return t6 + 1;
            if (r === 37 && e.charCodeAt(t6 + 1) === 51) {
              let s = e.charCodeAt(t6 + 2);
              if (s === 97 || s === 65)
                return t6 + 3;
            }
            return -1;
          }
          function al(e) {
            if (!e)
              return 0;
            let t6 = e.charCodeAt(0);
            if (t6 === 47 || t6 === 92) {
              if (e.charCodeAt(1) !== t6)
                return 1;
              let s = e.indexOf(t6 === 47 ? zn : py, 2);
              return s < 0 ? e.length : s + 1;
            }
            if (MT(t6) && e.charCodeAt(1) === 58) {
              let s = e.charCodeAt(2);
              if (s === 47 || s === 92)
                return 3;
              if (e.length === 2)
                return 2;
            }
            let r = e.indexOf(fy);
            if (r !== -1) {
              let s = r + fy.length, f10 = e.indexOf(zn, s);
              if (f10 !== -1) {
                let x10 = e.slice(0, r), w6 = e.slice(s, f10);
                if (x10 === "file" && (w6 === "" || w6 === "localhost") && MT(e.charCodeAt(f10 + 1))) {
                  let A6 = $5(e, f10 + 2);
                  if (A6 !== -1) {
                    if (e.charCodeAt(A6) === 47)
                      return ~(A6 + 1);
                    if (A6 === e.length)
                      return ~A6;
                  }
                }
                return ~(f10 + 1);
              }
              return ~e.length;
            }
            return 0;
          }
          function Bi(e) {
            let t6 = al(e);
            return t6 < 0 ? ~t6 : t6;
          }
          function ma(e) {
            e = Eo(e);
            let t6 = Bi(e);
            return t6 === e.length ? e : (e = P_(e), e.slice(0, Math.max(t6, e.lastIndexOf(zn))));
          }
          function sl(e, t6, r) {
            if (e = Eo(e), Bi(e) === e.length)
              return "";
            e = P_(e);
            let f10 = e.slice(Math.max(Bi(e), e.lastIndexOf(zn) + 1)), x10 = t6 !== void 0 && r !== void 0 ? Gp(f10, t6, r) : void 0;
            return x10 ? f10.slice(0, f10.length - x10.length) : f10;
          }
          function LT(e, t6, r) {
            if (Pn(t6, ".") || (t6 = "." + t6), e.length >= t6.length && e.charCodeAt(e.length - t6.length) === 46) {
              let s = e.slice(e.length - t6.length);
              if (r(s, t6))
                return s;
            }
          }
          function K5(e, t6, r) {
            if (typeof t6 == "string")
              return LT(e, t6, r) || "";
            for (let s of t6) {
              let f10 = LT(e, s, r);
              if (f10)
                return f10;
            }
            return "";
          }
          function Gp(e, t6, r) {
            if (t6)
              return K5(P_(e), t6, r ? Ms : To);
            let s = sl(e), f10 = s.lastIndexOf(".");
            return f10 >= 0 ? s.substring(f10) : "";
          }
          function X5(e, t6) {
            let r = e.substring(0, t6), s = e.substring(t6).split(zn);
            return s.length && !Cn(s) && s.pop(), [r, ...s];
          }
          function qi(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            return e = tn(t6, e), X5(e, Bi(e));
          }
          function xo(e) {
            return e.length === 0 ? "" : (e[0] && wo(e[0])) + e.slice(1).join(zn);
          }
          function Eo(e) {
            return e.indexOf("\\") !== -1 ? e.replace(BT, zn) : e;
          }
          function is(e) {
            if (!Ke3(e))
              return [];
            let t6 = [e[0]];
            for (let r = 1; r < e.length; r++) {
              let s = e[r];
              if (s && s !== ".") {
                if (s === "..") {
                  if (t6.length > 1) {
                    if (t6[t6.length - 1] !== "..") {
                      t6.pop();
                      continue;
                    }
                  } else if (t6[0])
                    continue;
                }
                t6.push(s);
              }
            }
            return t6;
          }
          function tn(e) {
            e && (e = Eo(e));
            for (var t6 = arguments.length, r = new Array(t6 > 1 ? t6 - 1 : 0), s = 1; s < t6; s++)
              r[s - 1] = arguments[s];
            for (let f10 of r)
              f10 && (f10 = Eo(f10), !e || Bi(f10) !== 0 ? e = f10 : e = wo(e) + f10);
            return e;
          }
          function oy(e) {
            for (var t6 = arguments.length, r = new Array(t6 > 1 ? t6 - 1 : 0), s = 1; s < t6; s++)
              r[s - 1] = arguments[s];
            return Un(Ke3(r) ? tn(e, ...r) : Eo(e));
          }
          function $p(e, t6) {
            return is(qi(e, t6));
          }
          function as(e, t6) {
            return xo($p(e, t6));
          }
          function Un(e) {
            if (e = Eo(e), !ol.test(e))
              return e;
            let t6 = e.replace(/\/\.\//g, "/").replace(/^\.\//, "");
            if (t6 !== e && (e = t6, !ol.test(e)))
              return e;
            let r = xo(is(qi(e)));
            return r && Hp(e) ? wo(r) : r;
          }
          function Y5(e) {
            return e.length === 0 ? "" : e.slice(1).join(zn);
          }
          function Q5(e, t6) {
            return Y5($p(e, t6));
          }
          function Ui(e, t6, r) {
            let s = A_(e) ? Un(e) : as(e, t6);
            return r(s);
          }
          function P_(e) {
            return Hp(e) ? e.substr(0, e.length - 1) : e;
          }
          function wo(e) {
            return Hp(e) ? e : e + zn;
          }
          function _y(e) {
            return !sy(e) && !So(e) ? "./" + e : e;
          }
          function RT(e, t6, r, s) {
            let f10 = r !== void 0 && s !== void 0 ? Gp(e, r, s) : Gp(e);
            return f10 ? e.slice(0, e.length - f10.length) + (Pn(t6, ".") ? t6 : "." + t6) : e;
          }
          function cy(e, t6, r) {
            if (e === t6)
              return 0;
            if (e === void 0)
              return -1;
            if (t6 === void 0)
              return 1;
            let s = e.substring(0, Bi(e)), f10 = t6.substring(0, Bi(t6)), x10 = C_(s, f10);
            if (x10 !== 0)
              return x10;
            let w6 = e.substring(s.length), A6 = t6.substring(f10.length);
            if (!ol.test(w6) && !ol.test(A6))
              return r(w6, A6);
            let g9 = is(qi(e)), B = is(qi(t6)), N10 = Math.min(g9.length, B.length);
            for (let X2 = 1; X2 < N10; X2++) {
              let F2 = r(g9[X2], B[X2]);
              if (F2 !== 0)
                return F2;
            }
            return Vr2(g9.length, B.length);
          }
          function Z5(e, t6) {
            return cy(e, t6, ri);
          }
          function eA(e, t6) {
            return cy(e, t6, C_);
          }
          function tA(e, t6, r, s) {
            return typeof r == "string" ? (e = tn(r, e), t6 = tn(r, t6)) : typeof r == "boolean" && (s = r), cy(e, t6, rl(s));
          }
          function jT(e, t6, r, s) {
            if (typeof r == "string" ? (e = tn(r, e), t6 = tn(r, t6)) : typeof r == "boolean" && (s = r), e === void 0 || t6 === void 0)
              return false;
            if (e === t6)
              return true;
            let f10 = is(qi(e)), x10 = is(qi(t6));
            if (x10.length < f10.length)
              return false;
            let w6 = s ? Ms : To;
            for (let A6 = 0; A6 < f10.length; A6++)
              if (!(A6 === 0 ? Ms : w6)(f10[A6], x10[A6]))
                return false;
            return true;
          }
          function rA(e, t6, r) {
            let s = r(e), f10 = r(t6);
            return Pn(s, f10 + "/") || Pn(s, f10 + "\\");
          }
          function ly(e, t6, r, s) {
            let f10 = is(qi(e)), x10 = is(qi(t6)), w6;
            for (w6 = 0; w6 < f10.length && w6 < x10.length; w6++) {
              let B = s(f10[w6]), N10 = s(x10[w6]);
              if (!(w6 === 0 ? Ms : r)(B, N10))
                break;
            }
            if (w6 === 0)
              return x10;
            let A6 = x10.slice(w6), g9 = [];
            for (; w6 < f10.length; w6++)
              g9.push("..");
            return ["", ...g9, ...A6];
          }
          function JT(e, t6, r) {
            Y3.assert(Bi(e) > 0 == Bi(t6) > 0, "Paths must either both be absolute or both be relative");
            let x10 = ly(e, t6, (typeof r == "boolean" ? r : false) ? Ms : To, typeof r == "function" ? r : rr2);
            return xo(x10);
          }
          function nA(e, t6, r) {
            return A_(e) ? uy(t6, e, t6, r, false) : e;
          }
          function iA(e, t6, r) {
            return _y(JT(ma(e), t6, r));
          }
          function uy(e, t6, r, s, f10) {
            let x10 = ly(oy(r, e), oy(r, t6), To, s), w6 = x10[0];
            if (f10 && A_(w6)) {
              let A6 = w6.charAt(0) === zn ? "file://" : "file:///";
              x10[0] = A6 + w6;
            }
            return xo(x10);
          }
          function FT(e, t6) {
            for (; ; ) {
              let r = t6(e);
              if (r !== void 0)
                return r;
              let s = ma(e);
              if (s === e)
                return;
              e = s;
            }
          }
          function aA(e) {
            return es(e, "/node_modules");
          }
          var zn, py, fy, BT, ol, sA = D({ "src/compiler/path.ts"() {
            "use strict";
            nn(), zn = "/", py = "\\", fy = "://", BT = /\\/g, ol = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
          } });
          function i2(e, t6, r, s, f10, x10, w6) {
            return { code: e, category: t6, key: r, message: s, reportsUnnecessary: f10, elidedInCompatabilityPyramid: x10, reportsDeprecated: w6 };
          }
          var ve, oA = D({ "src/compiler/diagnosticInformationMap.generated.ts"() {
            "use strict";
            NT(), ve = { Unterminated_string_literal: i2(1002, 1, "Unterminated_string_literal_1002", "Unterminated string literal."), Identifier_expected: i2(1003, 1, "Identifier_expected_1003", "Identifier expected."), _0_expected: i2(1005, 1, "_0_expected_1005", "'{0}' expected."), A_file_cannot_have_a_reference_to_itself: i2(1006, 1, "A_file_cannot_have_a_reference_to_itself_1006", "A file cannot have a reference to itself."), The_parser_expected_to_find_a_1_to_match_the_0_token_here: i2(1007, 1, "The_parser_expected_to_find_a_1_to_match_the_0_token_here_1007", "The parser expected to find a '{1}' to match the '{0}' token here."), Trailing_comma_not_allowed: i2(1009, 1, "Trailing_comma_not_allowed_1009", "Trailing comma not allowed."), Asterisk_Slash_expected: i2(1010, 1, "Asterisk_Slash_expected_1010", "'*/' expected."), An_element_access_expression_should_take_an_argument: i2(1011, 1, "An_element_access_expression_should_take_an_argument_1011", "An element access expression should take an argument."), Unexpected_token: i2(1012, 1, "Unexpected_token_1012", "Unexpected token."), A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: i2(1013, 1, "A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013", "A rest parameter or binding pattern may not have a trailing comma."), A_rest_parameter_must_be_last_in_a_parameter_list: i2(1014, 1, "A_rest_parameter_must_be_last_in_a_parameter_list_1014", "A rest parameter must be last in a parameter list."), Parameter_cannot_have_question_mark_and_initializer: i2(1015, 1, "Parameter_cannot_have_question_mark_and_initializer_1015", "Parameter cannot have question mark and initializer."), A_required_parameter_cannot_follow_an_optional_parameter: i2(1016, 1, "A_required_parameter_cannot_follow_an_optional_parameter_1016", "A required parameter cannot follow an optional parameter."), An_index_signature_cannot_have_a_rest_parameter: i2(1017, 1, "An_index_signature_cannot_have_a_rest_parameter_1017", "An index signature cannot have a rest parameter."), An_index_signature_parameter_cannot_have_an_accessibility_modifier: i2(1018, 1, "An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018", "An index signature parameter cannot have an accessibility modifier."), An_index_signature_parameter_cannot_have_a_question_mark: i2(1019, 1, "An_index_signature_parameter_cannot_have_a_question_mark_1019", "An index signature parameter cannot have a question mark."), An_index_signature_parameter_cannot_have_an_initializer: i2(1020, 1, "An_index_signature_parameter_cannot_have_an_initializer_1020", "An index signature parameter cannot have an initializer."), An_index_signature_must_have_a_type_annotation: i2(1021, 1, "An_index_signature_must_have_a_type_annotation_1021", "An index signature must have a type annotation."), An_index_signature_parameter_must_have_a_type_annotation: i2(1022, 1, "An_index_signature_parameter_must_have_a_type_annotation_1022", "An index signature parameter must have a type annotation."), readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: i2(1024, 1, "readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024", "'readonly' modifier can only appear on a property declaration or index signature."), An_index_signature_cannot_have_a_trailing_comma: i2(1025, 1, "An_index_signature_cannot_have_a_trailing_comma_1025", "An index signature cannot have a trailing comma."), Accessibility_modifier_already_seen: i2(1028, 1, "Accessibility_modifier_already_seen_1028", "Accessibility modifier already seen."), _0_modifier_must_precede_1_modifier: i2(1029, 1, "_0_modifier_must_precede_1_modifier_1029", "'{0}' modifier must precede '{1}' modifier."), _0_modifier_already_seen: i2(1030, 1, "_0_modifier_already_seen_1030", "'{0}' modifier already seen."), _0_modifier_cannot_appear_on_class_elements_of_this_kind: i2(1031, 1, "_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031", "'{0}' modifier cannot appear on class elements of this kind."), super_must_be_followed_by_an_argument_list_or_member_access: i2(1034, 1, "super_must_be_followed_by_an_argument_list_or_member_access_1034", "'super' must be followed by an argument list or member access."), Only_ambient_modules_can_use_quoted_names: i2(1035, 1, "Only_ambient_modules_can_use_quoted_names_1035", "Only ambient modules can use quoted names."), Statements_are_not_allowed_in_ambient_contexts: i2(1036, 1, "Statements_are_not_allowed_in_ambient_contexts_1036", "Statements are not allowed in ambient contexts."), A_declare_modifier_cannot_be_used_in_an_already_ambient_context: i2(1038, 1, "A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038", "A 'declare' modifier cannot be used in an already ambient context."), Initializers_are_not_allowed_in_ambient_contexts: i2(1039, 1, "Initializers_are_not_allowed_in_ambient_contexts_1039", "Initializers are not allowed in ambient contexts."), _0_modifier_cannot_be_used_in_an_ambient_context: i2(1040, 1, "_0_modifier_cannot_be_used_in_an_ambient_context_1040", "'{0}' modifier cannot be used in an ambient context."), _0_modifier_cannot_be_used_here: i2(1042, 1, "_0_modifier_cannot_be_used_here_1042", "'{0}' modifier cannot be used here."), _0_modifier_cannot_appear_on_a_module_or_namespace_element: i2(1044, 1, "_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044", "'{0}' modifier cannot appear on a module or namespace element."), Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier: i2(1046, 1, "Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046", "Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier."), A_rest_parameter_cannot_be_optional: i2(1047, 1, "A_rest_parameter_cannot_be_optional_1047", "A rest parameter cannot be optional."), A_rest_parameter_cannot_have_an_initializer: i2(1048, 1, "A_rest_parameter_cannot_have_an_initializer_1048", "A rest parameter cannot have an initializer."), A_set_accessor_must_have_exactly_one_parameter: i2(1049, 1, "A_set_accessor_must_have_exactly_one_parameter_1049", "A 'set' accessor must have exactly one parameter."), A_set_accessor_cannot_have_an_optional_parameter: i2(1051, 1, "A_set_accessor_cannot_have_an_optional_parameter_1051", "A 'set' accessor cannot have an optional parameter."), A_set_accessor_parameter_cannot_have_an_initializer: i2(1052, 1, "A_set_accessor_parameter_cannot_have_an_initializer_1052", "A 'set' accessor parameter cannot have an initializer."), A_set_accessor_cannot_have_rest_parameter: i2(1053, 1, "A_set_accessor_cannot_have_rest_parameter_1053", "A 'set' accessor cannot have rest parameter."), A_get_accessor_cannot_have_parameters: i2(1054, 1, "A_get_accessor_cannot_have_parameters_1054", "A 'get' accessor cannot have parameters."), Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: i2(1055, 1, "Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055", "Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value."), Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: i2(1056, 1, "Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056", "Accessors are only available when targeting ECMAScript 5 and higher."), The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: i2(1058, 1, "The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058", "The return type of an async function must either be a valid promise or must not contain a callable 'then' member."), A_promise_must_have_a_then_method: i2(1059, 1, "A_promise_must_have_a_then_method_1059", "A promise must have a 'then' method."), The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: i2(1060, 1, "The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060", "The first parameter of the 'then' method of a promise must be a callback."), Enum_member_must_have_initializer: i2(1061, 1, "Enum_member_must_have_initializer_1061", "Enum member must have initializer."), Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: i2(1062, 1, "Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062", "Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method."), An_export_assignment_cannot_be_used_in_a_namespace: i2(1063, 1, "An_export_assignment_cannot_be_used_in_a_namespace_1063", "An export assignment cannot be used in a namespace."), The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0: i2(1064, 1, "The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064", "The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?"), In_ambient_enum_declarations_member_initializer_must_be_constant_expression: i2(1066, 1, "In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066", "In ambient enum declarations member initializer must be constant expression."), Unexpected_token_A_constructor_method_accessor_or_property_was_expected: i2(1068, 1, "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068", "Unexpected token. A constructor, method, accessor, or property was expected."), Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces: i2(1069, 1, "Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069", "Unexpected token. A type parameter name was expected without curly braces."), _0_modifier_cannot_appear_on_a_type_member: i2(1070, 1, "_0_modifier_cannot_appear_on_a_type_member_1070", "'{0}' modifier cannot appear on a type member."), _0_modifier_cannot_appear_on_an_index_signature: i2(1071, 1, "_0_modifier_cannot_appear_on_an_index_signature_1071", "'{0}' modifier cannot appear on an index signature."), A_0_modifier_cannot_be_used_with_an_import_declaration: i2(1079, 1, "A_0_modifier_cannot_be_used_with_an_import_declaration_1079", "A '{0}' modifier cannot be used with an import declaration."), Invalid_reference_directive_syntax: i2(1084, 1, "Invalid_reference_directive_syntax_1084", "Invalid 'reference' directive syntax."), Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: i2(1085, 1, "Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085", "Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'."), _0_modifier_cannot_appear_on_a_constructor_declaration: i2(1089, 1, "_0_modifier_cannot_appear_on_a_constructor_declaration_1089", "'{0}' modifier cannot appear on a constructor declaration."), _0_modifier_cannot_appear_on_a_parameter: i2(1090, 1, "_0_modifier_cannot_appear_on_a_parameter_1090", "'{0}' modifier cannot appear on a parameter."), Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: i2(1091, 1, "Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091", "Only a single variable declaration is allowed in a 'for...in' statement."), Type_parameters_cannot_appear_on_a_constructor_declaration: i2(1092, 1, "Type_parameters_cannot_appear_on_a_constructor_declaration_1092", "Type parameters cannot appear on a constructor declaration."), Type_annotation_cannot_appear_on_a_constructor_declaration: i2(1093, 1, "Type_annotation_cannot_appear_on_a_constructor_declaration_1093", "Type annotation cannot appear on a constructor declaration."), An_accessor_cannot_have_type_parameters: i2(1094, 1, "An_accessor_cannot_have_type_parameters_1094", "An accessor cannot have type parameters."), A_set_accessor_cannot_have_a_return_type_annotation: i2(1095, 1, "A_set_accessor_cannot_have_a_return_type_annotation_1095", "A 'set' accessor cannot have a return type annotation."), An_index_signature_must_have_exactly_one_parameter: i2(1096, 1, "An_index_signature_must_have_exactly_one_parameter_1096", "An index signature must have exactly one parameter."), _0_list_cannot_be_empty: i2(1097, 1, "_0_list_cannot_be_empty_1097", "'{0}' list cannot be empty."), Type_parameter_list_cannot_be_empty: i2(1098, 1, "Type_parameter_list_cannot_be_empty_1098", "Type parameter list cannot be empty."), Type_argument_list_cannot_be_empty: i2(1099, 1, "Type_argument_list_cannot_be_empty_1099", "Type argument list cannot be empty."), Invalid_use_of_0_in_strict_mode: i2(1100, 1, "Invalid_use_of_0_in_strict_mode_1100", "Invalid use of '{0}' in strict mode."), with_statements_are_not_allowed_in_strict_mode: i2(1101, 1, "with_statements_are_not_allowed_in_strict_mode_1101", "'with' statements are not allowed in strict mode."), delete_cannot_be_called_on_an_identifier_in_strict_mode: i2(1102, 1, "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102", "'delete' cannot be called on an identifier in strict mode."), for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: i2(1103, 1, "for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1103", "'for await' loops are only allowed within async functions and at the top levels of modules."), A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: i2(1104, 1, "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104", "A 'continue' statement can only be used within an enclosing iteration statement."), A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: i2(1105, 1, "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105", "A 'break' statement can only be used within an enclosing iteration or switch statement."), The_left_hand_side_of_a_for_of_statement_may_not_be_async: i2(1106, 1, "The_left_hand_side_of_a_for_of_statement_may_not_be_async_1106", "The left-hand side of a 'for...of' statement may not be 'async'."), Jump_target_cannot_cross_function_boundary: i2(1107, 1, "Jump_target_cannot_cross_function_boundary_1107", "Jump target cannot cross function boundary."), A_return_statement_can_only_be_used_within_a_function_body: i2(1108, 1, "A_return_statement_can_only_be_used_within_a_function_body_1108", "A 'return' statement can only be used within a function body."), Expression_expected: i2(1109, 1, "Expression_expected_1109", "Expression expected."), Type_expected: i2(1110, 1, "Type_expected_1110", "Type expected."), A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: i2(1113, 1, "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113", "A 'default' clause cannot appear more than once in a 'switch' statement."), Duplicate_label_0: i2(1114, 1, "Duplicate_label_0_1114", "Duplicate label '{0}'."), A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: i2(1115, 1, "A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115", "A 'continue' statement can only jump to a label of an enclosing iteration statement."), A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: i2(1116, 1, "A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116", "A 'break' statement can only jump to a label of an enclosing statement."), An_object_literal_cannot_have_multiple_properties_with_the_same_name: i2(1117, 1, "An_object_literal_cannot_have_multiple_properties_with_the_same_name_1117", "An object literal cannot have multiple properties with the same name."), An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: i2(1118, 1, "An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118", "An object literal cannot have multiple get/set accessors with the same name."), An_object_literal_cannot_have_property_and_accessor_with_the_same_name: i2(1119, 1, "An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119", "An object literal cannot have property and accessor with the same name."), An_export_assignment_cannot_have_modifiers: i2(1120, 1, "An_export_assignment_cannot_have_modifiers_1120", "An export assignment cannot have modifiers."), Octal_literals_are_not_allowed_in_strict_mode: i2(1121, 1, "Octal_literals_are_not_allowed_in_strict_mode_1121", "Octal literals are not allowed in strict mode."), Variable_declaration_list_cannot_be_empty: i2(1123, 1, "Variable_declaration_list_cannot_be_empty_1123", "Variable declaration list cannot be empty."), Digit_expected: i2(1124, 1, "Digit_expected_1124", "Digit expected."), Hexadecimal_digit_expected: i2(1125, 1, "Hexadecimal_digit_expected_1125", "Hexadecimal digit expected."), Unexpected_end_of_text: i2(1126, 1, "Unexpected_end_of_text_1126", "Unexpected end of text."), Invalid_character: i2(1127, 1, "Invalid_character_1127", "Invalid character."), Declaration_or_statement_expected: i2(1128, 1, "Declaration_or_statement_expected_1128", "Declaration or statement expected."), Statement_expected: i2(1129, 1, "Statement_expected_1129", "Statement expected."), case_or_default_expected: i2(1130, 1, "case_or_default_expected_1130", "'case' or 'default' expected."), Property_or_signature_expected: i2(1131, 1, "Property_or_signature_expected_1131", "Property or signature expected."), Enum_member_expected: i2(1132, 1, "Enum_member_expected_1132", "Enum member expected."), Variable_declaration_expected: i2(1134, 1, "Variable_declaration_expected_1134", "Variable declaration expected."), Argument_expression_expected: i2(1135, 1, "Argument_expression_expected_1135", "Argument expression expected."), Property_assignment_expected: i2(1136, 1, "Property_assignment_expected_1136", "Property assignment expected."), Expression_or_comma_expected: i2(1137, 1, "Expression_or_comma_expected_1137", "Expression or comma expected."), Parameter_declaration_expected: i2(1138, 1, "Parameter_declaration_expected_1138", "Parameter declaration expected."), Type_parameter_declaration_expected: i2(1139, 1, "Type_parameter_declaration_expected_1139", "Type parameter declaration expected."), Type_argument_expected: i2(1140, 1, "Type_argument_expected_1140", "Type argument expected."), String_literal_expected: i2(1141, 1, "String_literal_expected_1141", "String literal expected."), Line_break_not_permitted_here: i2(1142, 1, "Line_break_not_permitted_here_1142", "Line break not permitted here."), or_expected: i2(1144, 1, "or_expected_1144", "'{' or ';' expected."), or_JSX_element_expected: i2(1145, 1, "or_JSX_element_expected_1145", "'{' or JSX element expected."), Declaration_expected: i2(1146, 1, "Declaration_expected_1146", "Declaration expected."), Import_declarations_in_a_namespace_cannot_reference_a_module: i2(1147, 1, "Import_declarations_in_a_namespace_cannot_reference_a_module_1147", "Import declarations in a namespace cannot reference a module."), Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: i2(1148, 1, "Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148", "Cannot use imports, exports, or module augmentations when '--module' is 'none'."), File_name_0_differs_from_already_included_file_name_1_only_in_casing: i2(1149, 1, "File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149", "File name '{0}' differs from already included file name '{1}' only in casing."), const_declarations_must_be_initialized: i2(1155, 1, "const_declarations_must_be_initialized_1155", "'const' declarations must be initialized."), const_declarations_can_only_be_declared_inside_a_block: i2(1156, 1, "const_declarations_can_only_be_declared_inside_a_block_1156", "'const' declarations can only be declared inside a block."), let_declarations_can_only_be_declared_inside_a_block: i2(1157, 1, "let_declarations_can_only_be_declared_inside_a_block_1157", "'let' declarations can only be declared inside a block."), Unterminated_template_literal: i2(1160, 1, "Unterminated_template_literal_1160", "Unterminated template literal."), Unterminated_regular_expression_literal: i2(1161, 1, "Unterminated_regular_expression_literal_1161", "Unterminated regular expression literal."), An_object_member_cannot_be_declared_optional: i2(1162, 1, "An_object_member_cannot_be_declared_optional_1162", "An object member cannot be declared optional."), A_yield_expression_is_only_allowed_in_a_generator_body: i2(1163, 1, "A_yield_expression_is_only_allowed_in_a_generator_body_1163", "A 'yield' expression is only allowed in a generator body."), Computed_property_names_are_not_allowed_in_enums: i2(1164, 1, "Computed_property_names_are_not_allowed_in_enums_1164", "Computed property names are not allowed in enums."), A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: i2(1165, 1, "A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165", "A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type: i2(1166, 1, "A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_1166", "A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type."), A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: i2(1168, 1, "A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168", "A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: i2(1169, 1, "A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169", "A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: i2(1170, 1, "A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170", "A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_comma_expression_is_not_allowed_in_a_computed_property_name: i2(1171, 1, "A_comma_expression_is_not_allowed_in_a_computed_property_name_1171", "A comma expression is not allowed in a computed property name."), extends_clause_already_seen: i2(1172, 1, "extends_clause_already_seen_1172", "'extends' clause already seen."), extends_clause_must_precede_implements_clause: i2(1173, 1, "extends_clause_must_precede_implements_clause_1173", "'extends' clause must precede 'implements' clause."), Classes_can_only_extend_a_single_class: i2(1174, 1, "Classes_can_only_extend_a_single_class_1174", "Classes can only extend a single class."), implements_clause_already_seen: i2(1175, 1, "implements_clause_already_seen_1175", "'implements' clause already seen."), Interface_declaration_cannot_have_implements_clause: i2(1176, 1, "Interface_declaration_cannot_have_implements_clause_1176", "Interface declaration cannot have 'implements' clause."), Binary_digit_expected: i2(1177, 1, "Binary_digit_expected_1177", "Binary digit expected."), Octal_digit_expected: i2(1178, 1, "Octal_digit_expected_1178", "Octal digit expected."), Unexpected_token_expected: i2(1179, 1, "Unexpected_token_expected_1179", "Unexpected token. '{' expected."), Property_destructuring_pattern_expected: i2(1180, 1, "Property_destructuring_pattern_expected_1180", "Property destructuring pattern expected."), Array_element_destructuring_pattern_expected: i2(1181, 1, "Array_element_destructuring_pattern_expected_1181", "Array element destructuring pattern expected."), A_destructuring_declaration_must_have_an_initializer: i2(1182, 1, "A_destructuring_declaration_must_have_an_initializer_1182", "A destructuring declaration must have an initializer."), An_implementation_cannot_be_declared_in_ambient_contexts: i2(1183, 1, "An_implementation_cannot_be_declared_in_ambient_contexts_1183", "An implementation cannot be declared in ambient contexts."), Modifiers_cannot_appear_here: i2(1184, 1, "Modifiers_cannot_appear_here_1184", "Modifiers cannot appear here."), Merge_conflict_marker_encountered: i2(1185, 1, "Merge_conflict_marker_encountered_1185", "Merge conflict marker encountered."), A_rest_element_cannot_have_an_initializer: i2(1186, 1, "A_rest_element_cannot_have_an_initializer_1186", "A rest element cannot have an initializer."), A_parameter_property_may_not_be_declared_using_a_binding_pattern: i2(1187, 1, "A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187", "A parameter property may not be declared using a binding pattern."), Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: i2(1188, 1, "Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188", "Only a single variable declaration is allowed in a 'for...of' statement."), The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: i2(1189, 1, "The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189", "The variable declaration of a 'for...in' statement cannot have an initializer."), The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: i2(1190, 1, "The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190", "The variable declaration of a 'for...of' statement cannot have an initializer."), An_import_declaration_cannot_have_modifiers: i2(1191, 1, "An_import_declaration_cannot_have_modifiers_1191", "An import declaration cannot have modifiers."), Module_0_has_no_default_export: i2(1192, 1, "Module_0_has_no_default_export_1192", "Module '{0}' has no default export."), An_export_declaration_cannot_have_modifiers: i2(1193, 1, "An_export_declaration_cannot_have_modifiers_1193", "An export declaration cannot have modifiers."), Export_declarations_are_not_permitted_in_a_namespace: i2(1194, 1, "Export_declarations_are_not_permitted_in_a_namespace_1194", "Export declarations are not permitted in a namespace."), export_Asterisk_does_not_re_export_a_default: i2(1195, 1, "export_Asterisk_does_not_re_export_a_default_1195", "'export *' does not re-export a default."), Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified: i2(1196, 1, "Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196", "Catch clause variable type annotation must be 'any' or 'unknown' if specified."), Catch_clause_variable_cannot_have_an_initializer: i2(1197, 1, "Catch_clause_variable_cannot_have_an_initializer_1197", "Catch clause variable cannot have an initializer."), An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: i2(1198, 1, "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198", "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive."), Unterminated_Unicode_escape_sequence: i2(1199, 1, "Unterminated_Unicode_escape_sequence_1199", "Unterminated Unicode escape sequence."), Line_terminator_not_permitted_before_arrow: i2(1200, 1, "Line_terminator_not_permitted_before_arrow_1200", "Line terminator not permitted before arrow."), Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: i2(1202, 1, "Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202", `Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from "mod"', 'import {a} from "mod"', 'import d from "mod"', or another module format instead.`), Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: i2(1203, 1, "Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203", "Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead."), Re_exporting_a_type_when_0_is_enabled_requires_using_export_type: i2(1205, 1, "Re_exporting_a_type_when_0_is_enabled_requires_using_export_type_1205", "Re-exporting a type when '{0}' is enabled requires using 'export type'."), Decorators_are_not_valid_here: i2(1206, 1, "Decorators_are_not_valid_here_1206", "Decorators are not valid here."), Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: i2(1207, 1, "Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207", "Decorators cannot be applied to multiple get/set accessors of the same name."), Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0: i2(1209, 1, "Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0_1209", "Invalid optional chain from new expression. Did you mean to call '{0}()'?"), Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode: i2(1210, 1, "Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of__1210", "Code contained in a class is evaluated in JavaScript's strict mode which does not allow this use of '{0}'. For more information, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode."), A_class_declaration_without_the_default_modifier_must_have_a_name: i2(1211, 1, "A_class_declaration_without_the_default_modifier_must_have_a_name_1211", "A class declaration without the 'default' modifier must have a name."), Identifier_expected_0_is_a_reserved_word_in_strict_mode: i2(1212, 1, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212", "Identifier expected. '{0}' is a reserved word in strict mode."), Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: i2(1213, 1, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213", "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode."), Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: i2(1214, 1, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214", "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode."), Invalid_use_of_0_Modules_are_automatically_in_strict_mode: i2(1215, 1, "Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215", "Invalid use of '{0}'. Modules are automatically in strict mode."), Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: i2(1216, 1, "Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216", "Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules."), Export_assignment_is_not_supported_when_module_flag_is_system: i2(1218, 1, "Export_assignment_is_not_supported_when_module_flag_is_system_1218", "Export assignment is not supported when '--module' flag is 'system'."), Generators_are_not_allowed_in_an_ambient_context: i2(1221, 1, "Generators_are_not_allowed_in_an_ambient_context_1221", "Generators are not allowed in an ambient context."), An_overload_signature_cannot_be_declared_as_a_generator: i2(1222, 1, "An_overload_signature_cannot_be_declared_as_a_generator_1222", "An overload signature cannot be declared as a generator."), _0_tag_already_specified: i2(1223, 1, "_0_tag_already_specified_1223", "'{0}' tag already specified."), Signature_0_must_be_a_type_predicate: i2(1224, 1, "Signature_0_must_be_a_type_predicate_1224", "Signature '{0}' must be a type predicate."), Cannot_find_parameter_0: i2(1225, 1, "Cannot_find_parameter_0_1225", "Cannot find parameter '{0}'."), Type_predicate_0_is_not_assignable_to_1: i2(1226, 1, "Type_predicate_0_is_not_assignable_to_1_1226", "Type predicate '{0}' is not assignable to '{1}'."), Parameter_0_is_not_in_the_same_position_as_parameter_1: i2(1227, 1, "Parameter_0_is_not_in_the_same_position_as_parameter_1_1227", "Parameter '{0}' is not in the same position as parameter '{1}'."), A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: i2(1228, 1, "A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228", "A type predicate is only allowed in return type position for functions and methods."), A_type_predicate_cannot_reference_a_rest_parameter: i2(1229, 1, "A_type_predicate_cannot_reference_a_rest_parameter_1229", "A type predicate cannot reference a rest parameter."), A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: i2(1230, 1, "A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230", "A type predicate cannot reference element '{0}' in a binding pattern."), An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration: i2(1231, 1, "An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration_1231", "An export assignment must be at the top level of a file or module declaration."), An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: i2(1232, 1, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1232", "An import declaration can only be used at the top level of a namespace or module."), An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: i2(1233, 1, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1233", "An export declaration can only be used at the top level of a namespace or module."), An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: i2(1234, 1, "An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234", "An ambient module declaration is only allowed at the top level in a file."), A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module: i2(1235, 1, "A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module_1235", "A namespace declaration is only allowed at the top level of a namespace or module."), The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: i2(1236, 1, "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236", "The return type of a property decorator function must be either 'void' or 'any'."), The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: i2(1237, 1, "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237", "The return type of a parameter decorator function must be either 'void' or 'any'."), Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: i2(1238, 1, "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238", "Unable to resolve signature of class decorator when called as an expression."), Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: i2(1239, 1, "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239", "Unable to resolve signature of parameter decorator when called as an expression."), Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: i2(1240, 1, "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240", "Unable to resolve signature of property decorator when called as an expression."), Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: i2(1241, 1, "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241", "Unable to resolve signature of method decorator when called as an expression."), abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: i2(1242, 1, "abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242", "'abstract' modifier can only appear on a class, method, or property declaration."), _0_modifier_cannot_be_used_with_1_modifier: i2(1243, 1, "_0_modifier_cannot_be_used_with_1_modifier_1243", "'{0}' modifier cannot be used with '{1}' modifier."), Abstract_methods_can_only_appear_within_an_abstract_class: i2(1244, 1, "Abstract_methods_can_only_appear_within_an_abstract_class_1244", "Abstract methods can only appear within an abstract class."), Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: i2(1245, 1, "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245", "Method '{0}' cannot have an implementation because it is marked abstract."), An_interface_property_cannot_have_an_initializer: i2(1246, 1, "An_interface_property_cannot_have_an_initializer_1246", "An interface property cannot have an initializer."), A_type_literal_property_cannot_have_an_initializer: i2(1247, 1, "A_type_literal_property_cannot_have_an_initializer_1247", "A type literal property cannot have an initializer."), A_class_member_cannot_have_the_0_keyword: i2(1248, 1, "A_class_member_cannot_have_the_0_keyword_1248", "A class member cannot have the '{0}' keyword."), A_decorator_can_only_decorate_a_method_implementation_not_an_overload: i2(1249, 1, "A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249", "A decorator can only decorate a method implementation, not an overload."), Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: i2(1250, 1, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'."), Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: i2(1251, 1, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode."), Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: i2(1252, 1, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode."), A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference: i2(1254, 1, "A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254", "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."), A_definite_assignment_assertion_is_not_permitted_in_this_context: i2(1255, 1, "A_definite_assignment_assertion_is_not_permitted_in_this_context_1255", "A definite assignment assertion '!' is not permitted in this context."), A_required_element_cannot_follow_an_optional_element: i2(1257, 1, "A_required_element_cannot_follow_an_optional_element_1257", "A required element cannot follow an optional element."), A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration: i2(1258, 1, "A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration_1258", "A default export must be at the top level of a file or module declaration."), Module_0_can_only_be_default_imported_using_the_1_flag: i2(1259, 1, "Module_0_can_only_be_default_imported_using_the_1_flag_1259", "Module '{0}' can only be default-imported using the '{1}' flag"), Keywords_cannot_contain_escape_characters: i2(1260, 1, "Keywords_cannot_contain_escape_characters_1260", "Keywords cannot contain escape characters."), Already_included_file_name_0_differs_from_file_name_1_only_in_casing: i2(1261, 1, "Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261", "Already included file name '{0}' differs from file name '{1}' only in casing."), Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module: i2(1262, 1, "Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262", "Identifier expected. '{0}' is a reserved word at the top-level of a module."), Declarations_with_initializers_cannot_also_have_definite_assignment_assertions: i2(1263, 1, "Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263", "Declarations with initializers cannot also have definite assignment assertions."), Declarations_with_definite_assignment_assertions_must_also_have_type_annotations: i2(1264, 1, "Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264", "Declarations with definite assignment assertions must also have type annotations."), A_rest_element_cannot_follow_another_rest_element: i2(1265, 1, "A_rest_element_cannot_follow_another_rest_element_1265", "A rest element cannot follow another rest element."), An_optional_element_cannot_follow_a_rest_element: i2(1266, 1, "An_optional_element_cannot_follow_a_rest_element_1266", "An optional element cannot follow a rest element."), Property_0_cannot_have_an_initializer_because_it_is_marked_abstract: i2(1267, 1, "Property_0_cannot_have_an_initializer_because_it_is_marked_abstract_1267", "Property '{0}' cannot have an initializer because it is marked abstract."), An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type: i2(1268, 1, "An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type_1268", "An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type."), Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled: i2(1269, 1, "Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled_1269", "Cannot use 'export import' on a type or type-only namespace when '{0}' is enabled."), Decorator_function_return_type_0_is_not_assignable_to_type_1: i2(1270, 1, "Decorator_function_return_type_0_is_not_assignable_to_type_1_1270", "Decorator function return type '{0}' is not assignable to type '{1}'."), Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any: i2(1271, 1, "Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any_1271", "Decorator function return type is '{0}' but is expected to be 'void' or 'any'."), A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled: i2(1272, 1, "A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_w_1272", "A type referenced in a decorated signature must be imported with 'import type' or a namespace import when 'isolatedModules' and 'emitDecoratorMetadata' are enabled."), _0_modifier_cannot_appear_on_a_type_parameter: i2(1273, 1, "_0_modifier_cannot_appear_on_a_type_parameter_1273", "'{0}' modifier cannot appear on a type parameter"), _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias: i2(1274, 1, "_0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias_1274", "'{0}' modifier can only appear on a type parameter of a class, interface or type alias"), accessor_modifier_can_only_appear_on_a_property_declaration: i2(1275, 1, "accessor_modifier_can_only_appear_on_a_property_declaration_1275", "'accessor' modifier can only appear on a property declaration."), An_accessor_property_cannot_be_declared_optional: i2(1276, 1, "An_accessor_property_cannot_be_declared_optional_1276", "An 'accessor' property cannot be declared optional."), _0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class: i2(1277, 1, "_0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class_1277", "'{0}' modifier can only appear on a type parameter of a function, method or class"), The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0: i2(1278, 1, "The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0_1278", "The runtime will invoke the decorator with {1} arguments, but the decorator expects {0}."), The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0: i2(1279, 1, "The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0_1279", "The runtime will invoke the decorator with {1} arguments, but the decorator expects at least {0}."), Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement: i2(1280, 1, "Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to__1280", "Namespaces are not allowed in global script files when '{0}' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement."), Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead: i2(1281, 1, "Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead_1281", "Cannot access '{0}' from another file without qualification when '{1}' is enabled. Use '{2}' instead."), An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type: i2(1282, 1, "An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers__1282", "An 'export =' declaration must reference a value when 'verbatimModuleSyntax' is enabled, but '{0}' only refers to a type."), An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration: i2(1283, 1, "An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolve_1283", "An 'export =' declaration must reference a real value when 'verbatimModuleSyntax' is enabled, but '{0}' resolves to a type-only declaration."), An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type: i2(1284, 1, "An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_1284", "An 'export default' must reference a value when 'verbatimModuleSyntax' is enabled, but '{0}' only refers to a type."), An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration: i2(1285, 1, "An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_1285", "An 'export default' must reference a real value when 'verbatimModuleSyntax' is enabled, but '{0}' resolves to a type-only declaration."), ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled: i2(1286, 1, "ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled_1286", "ESM syntax is not allowed in a CommonJS module when 'verbatimModuleSyntax' is enabled."), A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled: i2(1287, 1, "A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimM_1287", "A top-level 'export' modifier cannot be used on value declarations in a CommonJS module when 'verbatimModuleSyntax' is enabled."), An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled: i2(1288, 1, "An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabl_1288", "An import alias cannot resolve to a type or type-only declaration when 'verbatimModuleSyntax' is enabled."), with_statements_are_not_allowed_in_an_async_function_block: i2(1300, 1, "with_statements_are_not_allowed_in_an_async_function_block_1300", "'with' statements are not allowed in an async function block."), await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: i2(1308, 1, "await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308", "'await' expressions are only allowed within async functions and at the top levels of modules."), The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level: i2(1309, 1, "The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level_1309", "The current file is a CommonJS module and cannot use 'await' at the top level."), Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern: i2(1312, 1, "Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312", "Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern."), The_body_of_an_if_statement_cannot_be_the_empty_statement: i2(1313, 1, "The_body_of_an_if_statement_cannot_be_the_empty_statement_1313", "The body of an 'if' statement cannot be the empty statement."), Global_module_exports_may_only_appear_in_module_files: i2(1314, 1, "Global_module_exports_may_only_appear_in_module_files_1314", "Global module exports may only appear in module files."), Global_module_exports_may_only_appear_in_declaration_files: i2(1315, 1, "Global_module_exports_may_only_appear_in_declaration_files_1315", "Global module exports may only appear in declaration files."), Global_module_exports_may_only_appear_at_top_level: i2(1316, 1, "Global_module_exports_may_only_appear_at_top_level_1316", "Global module exports may only appear at top level."), A_parameter_property_cannot_be_declared_using_a_rest_parameter: i2(1317, 1, "A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317", "A parameter property cannot be declared using a rest parameter."), An_abstract_accessor_cannot_have_an_implementation: i2(1318, 1, "An_abstract_accessor_cannot_have_an_implementation_1318", "An abstract accessor cannot have an implementation."), A_default_export_can_only_be_used_in_an_ECMAScript_style_module: i2(1319, 1, "A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319", "A default export can only be used in an ECMAScript-style module."), Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: i2(1320, 1, "Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320", "Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member."), Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: i2(1321, 1, "Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321", "Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member."), Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: i2(1322, 1, "Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322", "Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member."), Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext: i2(1323, 1, "Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd__1323", "Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', or 'nodenext'."), Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext: i2(1324, 1, "Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nod_1324", "Dynamic imports only support a second argument when the '--module' option is set to 'esnext', 'node16', or 'nodenext'."), Argument_of_dynamic_import_cannot_be_spread_element: i2(1325, 1, "Argument_of_dynamic_import_cannot_be_spread_element_1325", "Argument of dynamic import cannot be spread element."), This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments: i2(1326, 1, "This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot__1326", "This use of 'import' is invalid. 'import()' calls can be written, but they must have parentheses and cannot have type arguments."), String_literal_with_double_quotes_expected: i2(1327, 1, "String_literal_with_double_quotes_expected_1327", "String literal with double quotes expected."), Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: i2(1328, 1, "Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328", "Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal."), _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: i2(1329, 1, "_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329", "'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?"), A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: i2(1330, 1, "A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330", "A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'."), A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: i2(1331, 1, "A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331", "A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'."), A_variable_whose_type_is_a_unique_symbol_type_must_be_const: i2(1332, 1, "A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332", "A variable whose type is a 'unique symbol' type must be 'const'."), unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: i2(1333, 1, "unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333", "'unique symbol' types may not be used on a variable declaration with a binding name."), unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: i2(1334, 1, "unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334", "'unique symbol' types are only allowed on variables in a variable statement."), unique_symbol_types_are_not_allowed_here: i2(1335, 1, "unique_symbol_types_are_not_allowed_here_1335", "'unique symbol' types are not allowed here."), An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead: i2(1337, 1, "An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_o_1337", "An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead."), infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: i2(1338, 1, "infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338", "'infer' declarations are only permitted in the 'extends' clause of a conditional type."), Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: i2(1339, 1, "Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339", "Module '{0}' does not refer to a value, but is used as a value here."), Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0: i2(1340, 1, "Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340", "Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?"), Class_constructor_may_not_be_an_accessor: i2(1341, 1, "Class_constructor_may_not_be_an_accessor_1341", "Class constructor may not be an accessor."), The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext: i2(1343, 1, "The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system__1343", "The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'."), A_label_is_not_allowed_here: i2(1344, 1, "A_label_is_not_allowed_here_1344", "'A label is not allowed here."), An_expression_of_type_void_cannot_be_tested_for_truthiness: i2(1345, 1, "An_expression_of_type_void_cannot_be_tested_for_truthiness_1345", "An expression of type 'void' cannot be tested for truthiness."), This_parameter_is_not_allowed_with_use_strict_directive: i2(1346, 1, "This_parameter_is_not_allowed_with_use_strict_directive_1346", "This parameter is not allowed with 'use strict' directive."), use_strict_directive_cannot_be_used_with_non_simple_parameter_list: i2(1347, 1, "use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347", "'use strict' directive cannot be used with non-simple parameter list."), Non_simple_parameter_declared_here: i2(1348, 1, "Non_simple_parameter_declared_here_1348", "Non-simple parameter declared here."), use_strict_directive_used_here: i2(1349, 1, "use_strict_directive_used_here_1349", "'use strict' directive used here."), Print_the_final_configuration_instead_of_building: i2(1350, 3, "Print_the_final_configuration_instead_of_building_1350", "Print the final configuration instead of building."), An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal: i2(1351, 1, "An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351", "An identifier or keyword cannot immediately follow a numeric literal."), A_bigint_literal_cannot_use_exponential_notation: i2(1352, 1, "A_bigint_literal_cannot_use_exponential_notation_1352", "A bigint literal cannot use exponential notation."), A_bigint_literal_must_be_an_integer: i2(1353, 1, "A_bigint_literal_must_be_an_integer_1353", "A bigint literal must be an integer."), readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types: i2(1354, 1, "readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354", "'readonly' type modifier is only permitted on array and tuple literal types."), A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals: i2(1355, 1, "A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355", "A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals."), Did_you_mean_to_mark_this_function_as_async: i2(1356, 1, "Did_you_mean_to_mark_this_function_as_async_1356", "Did you mean to mark this function as 'async'?"), An_enum_member_name_must_be_followed_by_a_or: i2(1357, 1, "An_enum_member_name_must_be_followed_by_a_or_1357", "An enum member name must be followed by a ',', '=', or '}'."), Tagged_template_expressions_are_not_permitted_in_an_optional_chain: i2(1358, 1, "Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358", "Tagged template expressions are not permitted in an optional chain."), Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here: i2(1359, 1, "Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359", "Identifier expected. '{0}' is a reserved word that cannot be used here."), Type_0_does_not_satisfy_the_expected_type_1: i2(1360, 1, "Type_0_does_not_satisfy_the_expected_type_1_1360", "Type '{0}' does not satisfy the expected type '{1}'."), _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type: i2(1361, 1, "_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361", "'{0}' cannot be used as a value because it was imported using 'import type'."), _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type: i2(1362, 1, "_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362", "'{0}' cannot be used as a value because it was exported using 'export type'."), A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both: i2(1363, 1, "A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363", "A type-only import can specify a default import or named bindings, but not both."), Convert_to_type_only_export: i2(1364, 3, "Convert_to_type_only_export_1364", "Convert to type-only export"), Convert_all_re_exported_types_to_type_only_exports: i2(1365, 3, "Convert_all_re_exported_types_to_type_only_exports_1365", "Convert all re-exported types to type-only exports"), Split_into_two_separate_import_declarations: i2(1366, 3, "Split_into_two_separate_import_declarations_1366", "Split into two separate import declarations"), Split_all_invalid_type_only_imports: i2(1367, 3, "Split_all_invalid_type_only_imports_1367", "Split all invalid type-only imports"), Class_constructor_may_not_be_a_generator: i2(1368, 1, "Class_constructor_may_not_be_a_generator_1368", "Class constructor may not be a generator."), Did_you_mean_0: i2(1369, 3, "Did_you_mean_0_1369", "Did you mean '{0}'?"), This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error: i2(1371, 1, "This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set__1371", "This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'."), Convert_to_type_only_import: i2(1373, 3, "Convert_to_type_only_import_1373", "Convert to type-only import"), Convert_all_imports_not_used_as_a_value_to_type_only_imports: i2(1374, 3, "Convert_all_imports_not_used_as_a_value_to_type_only_imports_1374", "Convert all imports not used as a value to type-only imports"), await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: i2(1375, 1, "await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375", "'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), _0_was_imported_here: i2(1376, 3, "_0_was_imported_here_1376", "'{0}' was imported here."), _0_was_exported_here: i2(1377, 3, "_0_was_exported_here_1377", "'{0}' was exported here."), Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: i2(1378, 1, "Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_n_1378", "Top-level 'await' expressions are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."), An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type: i2(1379, 1, "An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379", "An import alias cannot reference a declaration that was exported using 'export type'."), An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type: i2(1380, 1, "An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380", "An import alias cannot reference a declaration that was imported using 'import type'."), Unexpected_token_Did_you_mean_or_rbrace: i2(1381, 1, "Unexpected_token_Did_you_mean_or_rbrace_1381", "Unexpected token. Did you mean `{'}'}` or `&rbrace;`?"), Unexpected_token_Did_you_mean_or_gt: i2(1382, 1, "Unexpected_token_Did_you_mean_or_gt_1382", "Unexpected token. Did you mean `{'>'}` or `&gt;`?"), Function_type_notation_must_be_parenthesized_when_used_in_a_union_type: i2(1385, 1, "Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385", "Function type notation must be parenthesized when used in a union type."), Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type: i2(1386, 1, "Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386", "Constructor type notation must be parenthesized when used in a union type."), Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: i2(1387, 1, "Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387", "Function type notation must be parenthesized when used in an intersection type."), Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: i2(1388, 1, "Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388", "Constructor type notation must be parenthesized when used in an intersection type."), _0_is_not_allowed_as_a_variable_declaration_name: i2(1389, 1, "_0_is_not_allowed_as_a_variable_declaration_name_1389", "'{0}' is not allowed as a variable declaration name."), _0_is_not_allowed_as_a_parameter_name: i2(1390, 1, "_0_is_not_allowed_as_a_parameter_name_1390", "'{0}' is not allowed as a parameter name."), An_import_alias_cannot_use_import_type: i2(1392, 1, "An_import_alias_cannot_use_import_type_1392", "An import alias cannot use 'import type'"), Imported_via_0_from_file_1: i2(1393, 3, "Imported_via_0_from_file_1_1393", "Imported via {0} from file '{1}'"), Imported_via_0_from_file_1_with_packageId_2: i2(1394, 3, "Imported_via_0_from_file_1_with_packageId_2_1394", "Imported via {0} from file '{1}' with packageId '{2}'"), Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions: i2(1395, 3, "Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395", "Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions"), Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions: i2(1396, 3, "Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396", "Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions"), Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions: i2(1397, 3, "Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397", "Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions"), Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions: i2(1398, 3, "Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398", "Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions"), File_is_included_via_import_here: i2(1399, 3, "File_is_included_via_import_here_1399", "File is included via import here."), Referenced_via_0_from_file_1: i2(1400, 3, "Referenced_via_0_from_file_1_1400", "Referenced via '{0}' from file '{1}'"), File_is_included_via_reference_here: i2(1401, 3, "File_is_included_via_reference_here_1401", "File is included via reference here."), Type_library_referenced_via_0_from_file_1: i2(1402, 3, "Type_library_referenced_via_0_from_file_1_1402", "Type library referenced via '{0}' from file '{1}'"), Type_library_referenced_via_0_from_file_1_with_packageId_2: i2(1403, 3, "Type_library_referenced_via_0_from_file_1_with_packageId_2_1403", "Type library referenced via '{0}' from file '{1}' with packageId '{2}'"), File_is_included_via_type_library_reference_here: i2(1404, 3, "File_is_included_via_type_library_reference_here_1404", "File is included via type library reference here."), Library_referenced_via_0_from_file_1: i2(1405, 3, "Library_referenced_via_0_from_file_1_1405", "Library referenced via '{0}' from file '{1}'"), File_is_included_via_library_reference_here: i2(1406, 3, "File_is_included_via_library_reference_here_1406", "File is included via library reference here."), Matched_by_include_pattern_0_in_1: i2(1407, 3, "Matched_by_include_pattern_0_in_1_1407", "Matched by include pattern '{0}' in '{1}'"), File_is_matched_by_include_pattern_specified_here: i2(1408, 3, "File_is_matched_by_include_pattern_specified_here_1408", "File is matched by include pattern specified here."), Part_of_files_list_in_tsconfig_json: i2(1409, 3, "Part_of_files_list_in_tsconfig_json_1409", "Part of 'files' list in tsconfig.json"), File_is_matched_by_files_list_specified_here: i2(1410, 3, "File_is_matched_by_files_list_specified_here_1410", "File is matched by 'files' list specified here."), Output_from_referenced_project_0_included_because_1_specified: i2(1411, 3, "Output_from_referenced_project_0_included_because_1_specified_1411", "Output from referenced project '{0}' included because '{1}' specified"), Output_from_referenced_project_0_included_because_module_is_specified_as_none: i2(1412, 3, "Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412", "Output from referenced project '{0}' included because '--module' is specified as 'none'"), File_is_output_from_referenced_project_specified_here: i2(1413, 3, "File_is_output_from_referenced_project_specified_here_1413", "File is output from referenced project specified here."), Source_from_referenced_project_0_included_because_1_specified: i2(1414, 3, "Source_from_referenced_project_0_included_because_1_specified_1414", "Source from referenced project '{0}' included because '{1}' specified"), Source_from_referenced_project_0_included_because_module_is_specified_as_none: i2(1415, 3, "Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415", "Source from referenced project '{0}' included because '--module' is specified as 'none'"), File_is_source_from_referenced_project_specified_here: i2(1416, 3, "File_is_source_from_referenced_project_specified_here_1416", "File is source from referenced project specified here."), Entry_point_of_type_library_0_specified_in_compilerOptions: i2(1417, 3, "Entry_point_of_type_library_0_specified_in_compilerOptions_1417", "Entry point of type library '{0}' specified in compilerOptions"), Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1: i2(1418, 3, "Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418", "Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'"), File_is_entry_point_of_type_library_specified_here: i2(1419, 3, "File_is_entry_point_of_type_library_specified_here_1419", "File is entry point of type library specified here."), Entry_point_for_implicit_type_library_0: i2(1420, 3, "Entry_point_for_implicit_type_library_0_1420", "Entry point for implicit type library '{0}'"), Entry_point_for_implicit_type_library_0_with_packageId_1: i2(1421, 3, "Entry_point_for_implicit_type_library_0_with_packageId_1_1421", "Entry point for implicit type library '{0}' with packageId '{1}'"), Library_0_specified_in_compilerOptions: i2(1422, 3, "Library_0_specified_in_compilerOptions_1422", "Library '{0}' specified in compilerOptions"), File_is_library_specified_here: i2(1423, 3, "File_is_library_specified_here_1423", "File is library specified here."), Default_library: i2(1424, 3, "Default_library_1424", "Default library"), Default_library_for_target_0: i2(1425, 3, "Default_library_for_target_0_1425", "Default library for target '{0}'"), File_is_default_library_for_target_specified_here: i2(1426, 3, "File_is_default_library_for_target_specified_here_1426", "File is default library for target specified here."), Root_file_specified_for_compilation: i2(1427, 3, "Root_file_specified_for_compilation_1427", "Root file specified for compilation"), File_is_output_of_project_reference_source_0: i2(1428, 3, "File_is_output_of_project_reference_source_0_1428", "File is output of project reference source '{0}'"), File_redirects_to_file_0: i2(1429, 3, "File_redirects_to_file_0_1429", "File redirects to file '{0}'"), The_file_is_in_the_program_because_Colon: i2(1430, 3, "The_file_is_in_the_program_because_Colon_1430", "The file is in the program because:"), for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: i2(1431, 1, "for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_1431", "'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: i2(1432, 1, "Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_nod_1432", "Top-level 'for await' loops are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."), Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters: i2(1433, 1, "Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters_1433", "Neither decorators nor modifiers may be applied to 'this' parameters."), Unexpected_keyword_or_identifier: i2(1434, 1, "Unexpected_keyword_or_identifier_1434", "Unexpected keyword or identifier."), Unknown_keyword_or_identifier_Did_you_mean_0: i2(1435, 1, "Unknown_keyword_or_identifier_Did_you_mean_0_1435", "Unknown keyword or identifier. Did you mean '{0}'?"), Decorators_must_precede_the_name_and_all_keywords_of_property_declarations: i2(1436, 1, "Decorators_must_precede_the_name_and_all_keywords_of_property_declarations_1436", "Decorators must precede the name and all keywords of property declarations."), Namespace_must_be_given_a_name: i2(1437, 1, "Namespace_must_be_given_a_name_1437", "Namespace must be given a name."), Interface_must_be_given_a_name: i2(1438, 1, "Interface_must_be_given_a_name_1438", "Interface must be given a name."), Type_alias_must_be_given_a_name: i2(1439, 1, "Type_alias_must_be_given_a_name_1439", "Type alias must be given a name."), Variable_declaration_not_allowed_at_this_location: i2(1440, 1, "Variable_declaration_not_allowed_at_this_location_1440", "Variable declaration not allowed at this location."), Cannot_start_a_function_call_in_a_type_annotation: i2(1441, 1, "Cannot_start_a_function_call_in_a_type_annotation_1441", "Cannot start a function call in a type annotation."), Expected_for_property_initializer: i2(1442, 1, "Expected_for_property_initializer_1442", "Expected '=' for property initializer."), Module_declaration_names_may_only_use_or_quoted_strings: i2(1443, 1, "Module_declaration_names_may_only_use_or_quoted_strings_1443", `Module declaration names may only use ' or " quoted strings.`), _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: i2(1444, 1, "_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedMod_1444", "'{0}' is a type and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."), _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: i2(1446, 1, "_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveVa_1446", "'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."), _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled: i2(1448, 1, "_0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_1448", "'{0}' resolves to a type-only declaration and must be re-exported using a type-only re-export when '{1}' is enabled."), Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed: i2(1449, 3, "Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed_1449", "Preserve unused imported values in the JavaScript output that would otherwise be removed."), Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments: i2(1450, 3, "Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments_1450", "Dynamic imports can only accept a module specifier and an optional assertion as arguments"), Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression: i2(1451, 1, "Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member__1451", "Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression"), resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext: i2(1452, 1, "resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext_1452", "'resolution-mode' assertions are only supported when `moduleResolution` is `node16` or `nodenext`."), resolution_mode_should_be_either_require_or_import: i2(1453, 1, "resolution_mode_should_be_either_require_or_import_1453", "`resolution-mode` should be either `require` or `import`."), resolution_mode_can_only_be_set_for_type_only_imports: i2(1454, 1, "resolution_mode_can_only_be_set_for_type_only_imports_1454", "`resolution-mode` can only be set for type-only imports."), resolution_mode_is_the_only_valid_key_for_type_import_assertions: i2(1455, 1, "resolution_mode_is_the_only_valid_key_for_type_import_assertions_1455", "`resolution-mode` is the only valid key for type import assertions."), Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: i2(1456, 1, "Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1456", "Type import assertions should have exactly one key - `resolution-mode` - with value `import` or `require`."), Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk: i2(1457, 3, "Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk_1457", "Matched by default include pattern '**/*'"), File_is_ECMAScript_module_because_0_has_field_type_with_value_module: i2(1458, 3, "File_is_ECMAScript_module_because_0_has_field_type_with_value_module_1458", `File is ECMAScript module because '{0}' has field "type" with value "module"`), File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module: i2(1459, 3, "File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module_1459", `File is CommonJS module because '{0}' has field "type" whose value is not "module"`), File_is_CommonJS_module_because_0_does_not_have_field_type: i2(1460, 3, "File_is_CommonJS_module_because_0_does_not_have_field_type_1460", `File is CommonJS module because '{0}' does not have field "type"`), File_is_CommonJS_module_because_package_json_was_not_found: i2(1461, 3, "File_is_CommonJS_module_because_package_json_was_not_found_1461", "File is CommonJS module because 'package.json' was not found"), The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output: i2(1470, 1, "The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output_1470", "The 'import.meta' meta-property is not allowed in files which will build into CommonJS output."), Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead: i2(1471, 1, "Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_c_1471", "Module '{0}' cannot be imported using this construct. The specifier only resolves to an ES module, which cannot be imported with 'require'. Use an ECMAScript import instead."), catch_or_finally_expected: i2(1472, 1, "catch_or_finally_expected_1472", "'catch' or 'finally' expected."), An_import_declaration_can_only_be_used_at_the_top_level_of_a_module: i2(1473, 1, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_module_1473", "An import declaration can only be used at the top level of a module."), An_export_declaration_can_only_be_used_at_the_top_level_of_a_module: i2(1474, 1, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_module_1474", "An export declaration can only be used at the top level of a module."), Control_what_method_is_used_to_detect_module_format_JS_files: i2(1475, 3, "Control_what_method_is_used_to_detect_module_format_JS_files_1475", "Control what method is used to detect module-format JS files."), auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules: i2(1476, 3, "auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_w_1476", '"auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.'), An_instantiation_expression_cannot_be_followed_by_a_property_access: i2(1477, 1, "An_instantiation_expression_cannot_be_followed_by_a_property_access_1477", "An instantiation expression cannot be followed by a property access."), Identifier_or_string_literal_expected: i2(1478, 1, "Identifier_or_string_literal_expected_1478", "Identifier or string literal expected."), The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead: i2(1479, 1, "The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_reference_1479", `The current file is a CommonJS module whose imports will produce 'require' calls; however, the referenced file is an ECMAScript module and cannot be imported with 'require'. Consider writing a dynamic 'import("{0}")' call instead.`), To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module: i2(1480, 3, "To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_packag_1480", 'To convert this file to an ECMAScript module, change its file extension to \'{0}\' or create a local package.json file with `{ "type": "module" }`.'), To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1: i2(1481, 3, "To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Co_1481", `To convert this file to an ECMAScript module, change its file extension to '{0}', or add the field \`"type": "module"\` to '{1}'.`), To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0: i2(1482, 3, "To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0_1482", 'To convert this file to an ECMAScript module, add the field `"type": "module"` to \'{0}\'.'), To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module: i2(1483, 3, "To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module_1483", 'To convert this file to an ECMAScript module, create a local package.json file with `{ "type": "module" }`.'), _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled: i2(1484, 1, "_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled_1484", "'{0}' is a type and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled."), _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled: i2(1485, 1, "_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimMo_1485", "'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled."), Decorator_used_before_export_here: i2(1486, 1, "Decorator_used_before_export_here_1486", "Decorator used before 'export' here."), The_types_of_0_are_incompatible_between_these_types: i2(2200, 1, "The_types_of_0_are_incompatible_between_these_types_2200", "The types of '{0}' are incompatible between these types."), The_types_returned_by_0_are_incompatible_between_these_types: i2(2201, 1, "The_types_returned_by_0_are_incompatible_between_these_types_2201", "The types returned by '{0}' are incompatible between these types."), Call_signature_return_types_0_and_1_are_incompatible: i2(2202, 1, "Call_signature_return_types_0_and_1_are_incompatible_2202", "Call signature return types '{0}' and '{1}' are incompatible.", void 0, true), Construct_signature_return_types_0_and_1_are_incompatible: i2(2203, 1, "Construct_signature_return_types_0_and_1_are_incompatible_2203", "Construct signature return types '{0}' and '{1}' are incompatible.", void 0, true), Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: i2(2204, 1, "Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204", "Call signatures with no arguments have incompatible return types '{0}' and '{1}'.", void 0, true), Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: i2(2205, 1, "Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205", "Construct signatures with no arguments have incompatible return types '{0}' and '{1}'.", void 0, true), The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement: i2(2206, 1, "The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement_2206", "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."), The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement: i2(2207, 1, "The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement_2207", "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."), This_type_parameter_might_need_an_extends_0_constraint: i2(2208, 1, "This_type_parameter_might_need_an_extends_0_constraint_2208", "This type parameter might need an `extends {0}` constraint."), The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: i2(2209, 1, "The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_roo_2209", "The project root is ambiguous, but is required to resolve export map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."), The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: i2(2210, 1, "The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_roo_2210", "The project root is ambiguous, but is required to resolve import map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."), Add_extends_constraint: i2(2211, 3, "Add_extends_constraint_2211", "Add `extends` constraint."), Add_extends_constraint_to_all_type_parameters: i2(2212, 3, "Add_extends_constraint_to_all_type_parameters_2212", "Add `extends` constraint to all type parameters"), Duplicate_identifier_0: i2(2300, 1, "Duplicate_identifier_0_2300", "Duplicate identifier '{0}'."), Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: i2(2301, 1, "Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301", "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."), Static_members_cannot_reference_class_type_parameters: i2(2302, 1, "Static_members_cannot_reference_class_type_parameters_2302", "Static members cannot reference class type parameters."), Circular_definition_of_import_alias_0: i2(2303, 1, "Circular_definition_of_import_alias_0_2303", "Circular definition of import alias '{0}'."), Cannot_find_name_0: i2(2304, 1, "Cannot_find_name_0_2304", "Cannot find name '{0}'."), Module_0_has_no_exported_member_1: i2(2305, 1, "Module_0_has_no_exported_member_1_2305", "Module '{0}' has no exported member '{1}'."), File_0_is_not_a_module: i2(2306, 1, "File_0_is_not_a_module_2306", "File '{0}' is not a module."), Cannot_find_module_0_or_its_corresponding_type_declarations: i2(2307, 1, "Cannot_find_module_0_or_its_corresponding_type_declarations_2307", "Cannot find module '{0}' or its corresponding type declarations."), Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: i2(2308, 1, "Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308", "Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity."), An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: i2(2309, 1, "An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309", "An export assignment cannot be used in a module with other exported elements."), Type_0_recursively_references_itself_as_a_base_type: i2(2310, 1, "Type_0_recursively_references_itself_as_a_base_type_2310", "Type '{0}' recursively references itself as a base type."), Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function: i2(2311, 1, "Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function_2311", "Cannot find name '{0}'. Did you mean to write this in an async function?"), An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members: i2(2312, 1, "An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312", "An interface can only extend an object type or intersection of object types with statically known members."), Type_parameter_0_has_a_circular_constraint: i2(2313, 1, "Type_parameter_0_has_a_circular_constraint_2313", "Type parameter '{0}' has a circular constraint."), Generic_type_0_requires_1_type_argument_s: i2(2314, 1, "Generic_type_0_requires_1_type_argument_s_2314", "Generic type '{0}' requires {1} type argument(s)."), Type_0_is_not_generic: i2(2315, 1, "Type_0_is_not_generic_2315", "Type '{0}' is not generic."), Global_type_0_must_be_a_class_or_interface_type: i2(2316, 1, "Global_type_0_must_be_a_class_or_interface_type_2316", "Global type '{0}' must be a class or interface type."), Global_type_0_must_have_1_type_parameter_s: i2(2317, 1, "Global_type_0_must_have_1_type_parameter_s_2317", "Global type '{0}' must have {1} type parameter(s)."), Cannot_find_global_type_0: i2(2318, 1, "Cannot_find_global_type_0_2318", "Cannot find global type '{0}'."), Named_property_0_of_types_1_and_2_are_not_identical: i2(2319, 1, "Named_property_0_of_types_1_and_2_are_not_identical_2319", "Named property '{0}' of types '{1}' and '{2}' are not identical."), Interface_0_cannot_simultaneously_extend_types_1_and_2: i2(2320, 1, "Interface_0_cannot_simultaneously_extend_types_1_and_2_2320", "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'."), Excessive_stack_depth_comparing_types_0_and_1: i2(2321, 1, "Excessive_stack_depth_comparing_types_0_and_1_2321", "Excessive stack depth comparing types '{0}' and '{1}'."), Type_0_is_not_assignable_to_type_1: i2(2322, 1, "Type_0_is_not_assignable_to_type_1_2322", "Type '{0}' is not assignable to type '{1}'."), Cannot_redeclare_exported_variable_0: i2(2323, 1, "Cannot_redeclare_exported_variable_0_2323", "Cannot redeclare exported variable '{0}'."), Property_0_is_missing_in_type_1: i2(2324, 1, "Property_0_is_missing_in_type_1_2324", "Property '{0}' is missing in type '{1}'."), Property_0_is_private_in_type_1_but_not_in_type_2: i2(2325, 1, "Property_0_is_private_in_type_1_but_not_in_type_2_2325", "Property '{0}' is private in type '{1}' but not in type '{2}'."), Types_of_property_0_are_incompatible: i2(2326, 1, "Types_of_property_0_are_incompatible_2326", "Types of property '{0}' are incompatible."), Property_0_is_optional_in_type_1_but_required_in_type_2: i2(2327, 1, "Property_0_is_optional_in_type_1_but_required_in_type_2_2327", "Property '{0}' is optional in type '{1}' but required in type '{2}'."), Types_of_parameters_0_and_1_are_incompatible: i2(2328, 1, "Types_of_parameters_0_and_1_are_incompatible_2328", "Types of parameters '{0}' and '{1}' are incompatible."), Index_signature_for_type_0_is_missing_in_type_1: i2(2329, 1, "Index_signature_for_type_0_is_missing_in_type_1_2329", "Index signature for type '{0}' is missing in type '{1}'."), _0_and_1_index_signatures_are_incompatible: i2(2330, 1, "_0_and_1_index_signatures_are_incompatible_2330", "'{0}' and '{1}' index signatures are incompatible."), this_cannot_be_referenced_in_a_module_or_namespace_body: i2(2331, 1, "this_cannot_be_referenced_in_a_module_or_namespace_body_2331", "'this' cannot be referenced in a module or namespace body."), this_cannot_be_referenced_in_current_location: i2(2332, 1, "this_cannot_be_referenced_in_current_location_2332", "'this' cannot be referenced in current location."), this_cannot_be_referenced_in_constructor_arguments: i2(2333, 1, "this_cannot_be_referenced_in_constructor_arguments_2333", "'this' cannot be referenced in constructor arguments."), this_cannot_be_referenced_in_a_static_property_initializer: i2(2334, 1, "this_cannot_be_referenced_in_a_static_property_initializer_2334", "'this' cannot be referenced in a static property initializer."), super_can_only_be_referenced_in_a_derived_class: i2(2335, 1, "super_can_only_be_referenced_in_a_derived_class_2335", "'super' can only be referenced in a derived class."), super_cannot_be_referenced_in_constructor_arguments: i2(2336, 1, "super_cannot_be_referenced_in_constructor_arguments_2336", "'super' cannot be referenced in constructor arguments."), Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: i2(2337, 1, "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337", "Super calls are not permitted outside constructors or in nested functions inside constructors."), super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: i2(2338, 1, "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338", "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class."), Property_0_does_not_exist_on_type_1: i2(2339, 1, "Property_0_does_not_exist_on_type_1_2339", "Property '{0}' does not exist on type '{1}'."), Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: i2(2340, 1, "Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340", "Only public and protected methods of the base class are accessible via the 'super' keyword."), Property_0_is_private_and_only_accessible_within_class_1: i2(2341, 1, "Property_0_is_private_and_only_accessible_within_class_1_2341", "Property '{0}' is private and only accessible within class '{1}'."), This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0: i2(2343, 1, "This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343", "This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'."), Type_0_does_not_satisfy_the_constraint_1: i2(2344, 1, "Type_0_does_not_satisfy_the_constraint_1_2344", "Type '{0}' does not satisfy the constraint '{1}'."), Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: i2(2345, 1, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345", "Argument of type '{0}' is not assignable to parameter of type '{1}'."), Call_target_does_not_contain_any_signatures: i2(2346, 1, "Call_target_does_not_contain_any_signatures_2346", "Call target does not contain any signatures."), Untyped_function_calls_may_not_accept_type_arguments: i2(2347, 1, "Untyped_function_calls_may_not_accept_type_arguments_2347", "Untyped function calls may not accept type arguments."), Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: i2(2348, 1, "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348", "Value of type '{0}' is not callable. Did you mean to include 'new'?"), This_expression_is_not_callable: i2(2349, 1, "This_expression_is_not_callable_2349", "This expression is not callable."), Only_a_void_function_can_be_called_with_the_new_keyword: i2(2350, 1, "Only_a_void_function_can_be_called_with_the_new_keyword_2350", "Only a void function can be called with the 'new' keyword."), This_expression_is_not_constructable: i2(2351, 1, "This_expression_is_not_constructable_2351", "This expression is not constructable."), Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first: i2(2352, 1, "Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352", "Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first."), Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: i2(2353, 1, "Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353", "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'."), This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: i2(2354, 1, "This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354", "This syntax requires an imported helper but module '{0}' cannot be found."), A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: i2(2355, 1, "A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355", "A function whose declared type is neither 'void' nor 'any' must return a value."), An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type: i2(2356, 1, "An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356", "An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type."), The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: i2(2357, 1, "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357", "The operand of an increment or decrement operator must be a variable or a property access."), The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: i2(2358, 1, "The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358", "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter."), The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: i2(2359, 1, "The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359", "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type."), The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: i2(2362, 1, "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362", "The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."), The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: i2(2363, 1, "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363", "The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."), The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: i2(2364, 1, "The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364", "The left-hand side of an assignment expression must be a variable or a property access."), Operator_0_cannot_be_applied_to_types_1_and_2: i2(2365, 1, "Operator_0_cannot_be_applied_to_types_1_and_2_2365", "Operator '{0}' cannot be applied to types '{1}' and '{2}'."), Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: i2(2366, 1, "Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366", "Function lacks ending return statement and return type does not include 'undefined'."), This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap: i2(2367, 1, "This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap_2367", "This comparison appears to be unintentional because the types '{0}' and '{1}' have no overlap."), Type_parameter_name_cannot_be_0: i2(2368, 1, "Type_parameter_name_cannot_be_0_2368", "Type parameter name cannot be '{0}'."), A_parameter_property_is_only_allowed_in_a_constructor_implementation: i2(2369, 1, "A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369", "A parameter property is only allowed in a constructor implementation."), A_rest_parameter_must_be_of_an_array_type: i2(2370, 1, "A_rest_parameter_must_be_of_an_array_type_2370", "A rest parameter must be of an array type."), A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: i2(2371, 1, "A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371", "A parameter initializer is only allowed in a function or constructor implementation."), Parameter_0_cannot_reference_itself: i2(2372, 1, "Parameter_0_cannot_reference_itself_2372", "Parameter '{0}' cannot reference itself."), Parameter_0_cannot_reference_identifier_1_declared_after_it: i2(2373, 1, "Parameter_0_cannot_reference_identifier_1_declared_after_it_2373", "Parameter '{0}' cannot reference identifier '{1}' declared after it."), Duplicate_index_signature_for_type_0: i2(2374, 1, "Duplicate_index_signature_for_type_0_2374", "Duplicate index signature for type '{0}'."), Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: i2(2375, 1, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2375", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."), A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers: i2(2376, 1, "A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_2376", "A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers."), Constructors_for_derived_classes_must_contain_a_super_call: i2(2377, 1, "Constructors_for_derived_classes_must_contain_a_super_call_2377", "Constructors for derived classes must contain a 'super' call."), A_get_accessor_must_return_a_value: i2(2378, 1, "A_get_accessor_must_return_a_value_2378", "A 'get' accessor must return a value."), Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: i2(2379, 1, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_tr_2379", "Argument of type '{0}' is not assignable to parameter of type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."), The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type: i2(2380, 1, "The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type_2380", "The return type of a 'get' accessor must be assignable to its 'set' accessor type"), Overload_signatures_must_all_be_exported_or_non_exported: i2(2383, 1, "Overload_signatures_must_all_be_exported_or_non_exported_2383", "Overload signatures must all be exported or non-exported."), Overload_signatures_must_all_be_ambient_or_non_ambient: i2(2384, 1, "Overload_signatures_must_all_be_ambient_or_non_ambient_2384", "Overload signatures must all be ambient or non-ambient."), Overload_signatures_must_all_be_public_private_or_protected: i2(2385, 1, "Overload_signatures_must_all_be_public_private_or_protected_2385", "Overload signatures must all be public, private or protected."), Overload_signatures_must_all_be_optional_or_required: i2(2386, 1, "Overload_signatures_must_all_be_optional_or_required_2386", "Overload signatures must all be optional or required."), Function_overload_must_be_static: i2(2387, 1, "Function_overload_must_be_static_2387", "Function overload must be static."), Function_overload_must_not_be_static: i2(2388, 1, "Function_overload_must_not_be_static_2388", "Function overload must not be static."), Function_implementation_name_must_be_0: i2(2389, 1, "Function_implementation_name_must_be_0_2389", "Function implementation name must be '{0}'."), Constructor_implementation_is_missing: i2(2390, 1, "Constructor_implementation_is_missing_2390", "Constructor implementation is missing."), Function_implementation_is_missing_or_not_immediately_following_the_declaration: i2(2391, 1, "Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391", "Function implementation is missing or not immediately following the declaration."), Multiple_constructor_implementations_are_not_allowed: i2(2392, 1, "Multiple_constructor_implementations_are_not_allowed_2392", "Multiple constructor implementations are not allowed."), Duplicate_function_implementation: i2(2393, 1, "Duplicate_function_implementation_2393", "Duplicate function implementation."), This_overload_signature_is_not_compatible_with_its_implementation_signature: i2(2394, 1, "This_overload_signature_is_not_compatible_with_its_implementation_signature_2394", "This overload signature is not compatible with its implementation signature."), Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: i2(2395, 1, "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395", "Individual declarations in merged declaration '{0}' must be all exported or all local."), Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: i2(2396, 1, "Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396", "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters."), Declaration_name_conflicts_with_built_in_global_identifier_0: i2(2397, 1, "Declaration_name_conflicts_with_built_in_global_identifier_0_2397", "Declaration name conflicts with built-in global identifier '{0}'."), constructor_cannot_be_used_as_a_parameter_property_name: i2(2398, 1, "constructor_cannot_be_used_as_a_parameter_property_name_2398", "'constructor' cannot be used as a parameter property name."), Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: i2(2399, 1, "Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399", "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference."), Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: i2(2400, 1, "Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400", "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference."), A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers: i2(2401, 1, "A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_in_2401", "A 'super' call must be a root-level statement within a constructor of a derived class that contains initialized properties, parameter properties, or private identifiers."), Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: i2(2402, 1, "Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402", "Expression resolves to '_super' that compiler uses to capture base class reference."), Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: i2(2403, 1, "Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403", "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'."), The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: i2(2404, 1, "The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404", "The left-hand side of a 'for...in' statement cannot use a type annotation."), The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: i2(2405, 1, "The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405", "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'."), The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: i2(2406, 1, "The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406", "The left-hand side of a 'for...in' statement must be a variable or a property access."), The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: i2(2407, 1, "The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407", "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'."), Setters_cannot_return_a_value: i2(2408, 1, "Setters_cannot_return_a_value_2408", "Setters cannot return a value."), Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: i2(2409, 1, "Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409", "Return type of constructor signature must be assignable to the instance type of the class."), The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: i2(2410, 1, "The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410", "The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'."), Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target: i2(2412, 1, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2412", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target."), Property_0_of_type_1_is_not_assignable_to_2_index_type_3: i2(2411, 1, "Property_0_of_type_1_is_not_assignable_to_2_index_type_3_2411", "Property '{0}' of type '{1}' is not assignable to '{2}' index type '{3}'."), _0_index_type_1_is_not_assignable_to_2_index_type_3: i2(2413, 1, "_0_index_type_1_is_not_assignable_to_2_index_type_3_2413", "'{0}' index type '{1}' is not assignable to '{2}' index type '{3}'."), Class_name_cannot_be_0: i2(2414, 1, "Class_name_cannot_be_0_2414", "Class name cannot be '{0}'."), Class_0_incorrectly_extends_base_class_1: i2(2415, 1, "Class_0_incorrectly_extends_base_class_1_2415", "Class '{0}' incorrectly extends base class '{1}'."), Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: i2(2416, 1, "Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416", "Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'."), Class_static_side_0_incorrectly_extends_base_class_static_side_1: i2(2417, 1, "Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417", "Class static side '{0}' incorrectly extends base class static side '{1}'."), Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1: i2(2418, 1, "Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418", "Type of computed property's value is '{0}', which is not assignable to type '{1}'."), Types_of_construct_signatures_are_incompatible: i2(2419, 1, "Types_of_construct_signatures_are_incompatible_2419", "Types of construct signatures are incompatible."), Class_0_incorrectly_implements_interface_1: i2(2420, 1, "Class_0_incorrectly_implements_interface_1_2420", "Class '{0}' incorrectly implements interface '{1}'."), A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members: i2(2422, 1, "A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422", "A class can only implement an object type or intersection of object types with statically known members."), Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: i2(2423, 1, "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423", "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor."), Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: i2(2425, 1, "Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425", "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function."), Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: i2(2426, 1, "Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426", "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function."), Interface_name_cannot_be_0: i2(2427, 1, "Interface_name_cannot_be_0_2427", "Interface name cannot be '{0}'."), All_declarations_of_0_must_have_identical_type_parameters: i2(2428, 1, "All_declarations_of_0_must_have_identical_type_parameters_2428", "All declarations of '{0}' must have identical type parameters."), Interface_0_incorrectly_extends_interface_1: i2(2430, 1, "Interface_0_incorrectly_extends_interface_1_2430", "Interface '{0}' incorrectly extends interface '{1}'."), Enum_name_cannot_be_0: i2(2431, 1, "Enum_name_cannot_be_0_2431", "Enum name cannot be '{0}'."), In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: i2(2432, 1, "In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432", "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element."), A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: i2(2433, 1, "A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433", "A namespace declaration cannot be in a different file from a class or function with which it is merged."), A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: i2(2434, 1, "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434", "A namespace declaration cannot be located prior to a class or function with which it is merged."), Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: i2(2435, 1, "Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435", "Ambient modules cannot be nested in other modules or namespaces."), Ambient_module_declaration_cannot_specify_relative_module_name: i2(2436, 1, "Ambient_module_declaration_cannot_specify_relative_module_name_2436", "Ambient module declaration cannot specify relative module name."), Module_0_is_hidden_by_a_local_declaration_with_the_same_name: i2(2437, 1, "Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437", "Module '{0}' is hidden by a local declaration with the same name."), Import_name_cannot_be_0: i2(2438, 1, "Import_name_cannot_be_0_2438", "Import name cannot be '{0}'."), Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: i2(2439, 1, "Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439", "Import or export declaration in an ambient module declaration cannot reference module through relative module name."), Import_declaration_conflicts_with_local_declaration_of_0: i2(2440, 1, "Import_declaration_conflicts_with_local_declaration_of_0_2440", "Import declaration conflicts with local declaration of '{0}'."), Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: i2(2441, 1, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module."), Types_have_separate_declarations_of_a_private_property_0: i2(2442, 1, "Types_have_separate_declarations_of_a_private_property_0_2442", "Types have separate declarations of a private property '{0}'."), Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: i2(2443, 1, "Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443", "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'."), Property_0_is_protected_in_type_1_but_public_in_type_2: i2(2444, 1, "Property_0_is_protected_in_type_1_but_public_in_type_2_2444", "Property '{0}' is protected in type '{1}' but public in type '{2}'."), Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: i2(2445, 1, "Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445", "Property '{0}' is protected and only accessible within class '{1}' and its subclasses."), Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2: i2(2446, 1, "Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_cl_2446", "Property '{0}' is protected and only accessible through an instance of class '{1}'. This is an instance of class '{2}'."), The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: i2(2447, 1, "The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447", "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead."), Block_scoped_variable_0_used_before_its_declaration: i2(2448, 1, "Block_scoped_variable_0_used_before_its_declaration_2448", "Block-scoped variable '{0}' used before its declaration."), Class_0_used_before_its_declaration: i2(2449, 1, "Class_0_used_before_its_declaration_2449", "Class '{0}' used before its declaration."), Enum_0_used_before_its_declaration: i2(2450, 1, "Enum_0_used_before_its_declaration_2450", "Enum '{0}' used before its declaration."), Cannot_redeclare_block_scoped_variable_0: i2(2451, 1, "Cannot_redeclare_block_scoped_variable_0_2451", "Cannot redeclare block-scoped variable '{0}'."), An_enum_member_cannot_have_a_numeric_name: i2(2452, 1, "An_enum_member_cannot_have_a_numeric_name_2452", "An enum member cannot have a numeric name."), Variable_0_is_used_before_being_assigned: i2(2454, 1, "Variable_0_is_used_before_being_assigned_2454", "Variable '{0}' is used before being assigned."), Type_alias_0_circularly_references_itself: i2(2456, 1, "Type_alias_0_circularly_references_itself_2456", "Type alias '{0}' circularly references itself."), Type_alias_name_cannot_be_0: i2(2457, 1, "Type_alias_name_cannot_be_0_2457", "Type alias name cannot be '{0}'."), An_AMD_module_cannot_have_multiple_name_assignments: i2(2458, 1, "An_AMD_module_cannot_have_multiple_name_assignments_2458", "An AMD module cannot have multiple name assignments."), Module_0_declares_1_locally_but_it_is_not_exported: i2(2459, 1, "Module_0_declares_1_locally_but_it_is_not_exported_2459", "Module '{0}' declares '{1}' locally, but it is not exported."), Module_0_declares_1_locally_but_it_is_exported_as_2: i2(2460, 1, "Module_0_declares_1_locally_but_it_is_exported_as_2_2460", "Module '{0}' declares '{1}' locally, but it is exported as '{2}'."), Type_0_is_not_an_array_type: i2(2461, 1, "Type_0_is_not_an_array_type_2461", "Type '{0}' is not an array type."), A_rest_element_must_be_last_in_a_destructuring_pattern: i2(2462, 1, "A_rest_element_must_be_last_in_a_destructuring_pattern_2462", "A rest element must be last in a destructuring pattern."), A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: i2(2463, 1, "A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463", "A binding pattern parameter cannot be optional in an implementation signature."), A_computed_property_name_must_be_of_type_string_number_symbol_or_any: i2(2464, 1, "A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464", "A computed property name must be of type 'string', 'number', 'symbol', or 'any'."), this_cannot_be_referenced_in_a_computed_property_name: i2(2465, 1, "this_cannot_be_referenced_in_a_computed_property_name_2465", "'this' cannot be referenced in a computed property name."), super_cannot_be_referenced_in_a_computed_property_name: i2(2466, 1, "super_cannot_be_referenced_in_a_computed_property_name_2466", "'super' cannot be referenced in a computed property name."), A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: i2(2467, 1, "A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467", "A computed property name cannot reference a type parameter from its containing type."), Cannot_find_global_value_0: i2(2468, 1, "Cannot_find_global_value_0_2468", "Cannot find global value '{0}'."), The_0_operator_cannot_be_applied_to_type_symbol: i2(2469, 1, "The_0_operator_cannot_be_applied_to_type_symbol_2469", "The '{0}' operator cannot be applied to type 'symbol'."), Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: i2(2472, 1, "Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472", "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher."), Enum_declarations_must_all_be_const_or_non_const: i2(2473, 1, "Enum_declarations_must_all_be_const_or_non_const_2473", "Enum declarations must all be const or non-const."), const_enum_member_initializers_must_be_constant_expressions: i2(2474, 1, "const_enum_member_initializers_must_be_constant_expressions_2474", "const enum member initializers must be constant expressions."), const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: i2(2475, 1, "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475", "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query."), A_const_enum_member_can_only_be_accessed_using_a_string_literal: i2(2476, 1, "A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476", "A const enum member can only be accessed using a string literal."), const_enum_member_initializer_was_evaluated_to_a_non_finite_value: i2(2477, 1, "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477", "'const' enum member initializer was evaluated to a non-finite value."), const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: i2(2478, 1, "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478", "'const' enum member initializer was evaluated to disallowed value 'NaN'."), let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: i2(2480, 1, "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480", "'let' is not allowed to be used as a name in 'let' or 'const' declarations."), Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: i2(2481, 1, "Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481", "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'."), The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: i2(2483, 1, "The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483", "The left-hand side of a 'for...of' statement cannot use a type annotation."), Export_declaration_conflicts_with_exported_declaration_of_0: i2(2484, 1, "Export_declaration_conflicts_with_exported_declaration_of_0_2484", "Export declaration conflicts with exported declaration of '{0}'."), The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: i2(2487, 1, "The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487", "The left-hand side of a 'for...of' statement must be a variable or a property access."), Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: i2(2488, 1, "Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488", "Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator."), An_iterator_must_have_a_next_method: i2(2489, 1, "An_iterator_must_have_a_next_method_2489", "An iterator must have a 'next()' method."), The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property: i2(2490, 1, "The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490", "The type returned by the '{0}()' method of an iterator must have a 'value' property."), The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: i2(2491, 1, "The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491", "The left-hand side of a 'for...in' statement cannot be a destructuring pattern."), Cannot_redeclare_identifier_0_in_catch_clause: i2(2492, 1, "Cannot_redeclare_identifier_0_in_catch_clause_2492", "Cannot redeclare identifier '{0}' in catch clause."), Tuple_type_0_of_length_1_has_no_element_at_index_2: i2(2493, 1, "Tuple_type_0_of_length_1_has_no_element_at_index_2_2493", "Tuple type '{0}' of length '{1}' has no element at index '{2}'."), Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: i2(2494, 1, "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494", "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher."), Type_0_is_not_an_array_type_or_a_string_type: i2(2495, 1, "Type_0_is_not_an_array_type_or_a_string_type_2495", "Type '{0}' is not an array type or a string type."), The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: i2(2496, 1, "The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496", "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression."), This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export: i2(2497, 1, "This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_2497", "This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export."), Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: i2(2498, 1, "Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498", "Module '{0}' uses 'export =' and cannot be used with 'export *'."), An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: i2(2499, 1, "An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499", "An interface can only extend an identifier/qualified-name with optional type arguments."), A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: i2(2500, 1, "A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500", "A class can only implement an identifier/qualified-name with optional type arguments."), A_rest_element_cannot_contain_a_binding_pattern: i2(2501, 1, "A_rest_element_cannot_contain_a_binding_pattern_2501", "A rest element cannot contain a binding pattern."), _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: i2(2502, 1, "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502", "'{0}' is referenced directly or indirectly in its own type annotation."), Cannot_find_namespace_0: i2(2503, 1, "Cannot_find_namespace_0_2503", "Cannot find namespace '{0}'."), Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: i2(2504, 1, "Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504", "Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator."), A_generator_cannot_have_a_void_type_annotation: i2(2505, 1, "A_generator_cannot_have_a_void_type_annotation_2505", "A generator cannot have a 'void' type annotation."), _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: i2(2506, 1, "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506", "'{0}' is referenced directly or indirectly in its own base expression."), Type_0_is_not_a_constructor_function_type: i2(2507, 1, "Type_0_is_not_a_constructor_function_type_2507", "Type '{0}' is not a constructor function type."), No_base_constructor_has_the_specified_number_of_type_arguments: i2(2508, 1, "No_base_constructor_has_the_specified_number_of_type_arguments_2508", "No base constructor has the specified number of type arguments."), Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members: i2(2509, 1, "Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509", "Base constructor return type '{0}' is not an object type or intersection of object types with statically known members."), Base_constructors_must_all_have_the_same_return_type: i2(2510, 1, "Base_constructors_must_all_have_the_same_return_type_2510", "Base constructors must all have the same return type."), Cannot_create_an_instance_of_an_abstract_class: i2(2511, 1, "Cannot_create_an_instance_of_an_abstract_class_2511", "Cannot create an instance of an abstract class."), Overload_signatures_must_all_be_abstract_or_non_abstract: i2(2512, 1, "Overload_signatures_must_all_be_abstract_or_non_abstract_2512", "Overload signatures must all be abstract or non-abstract."), Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: i2(2513, 1, "Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513", "Abstract method '{0}' in class '{1}' cannot be accessed via super expression."), A_tuple_type_cannot_be_indexed_with_a_negative_value: i2(2514, 1, "A_tuple_type_cannot_be_indexed_with_a_negative_value_2514", "A tuple type cannot be indexed with a negative value."), Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: i2(2515, 1, "Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515", "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'."), All_declarations_of_an_abstract_method_must_be_consecutive: i2(2516, 1, "All_declarations_of_an_abstract_method_must_be_consecutive_2516", "All declarations of an abstract method must be consecutive."), Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: i2(2517, 1, "Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517", "Cannot assign an abstract constructor type to a non-abstract constructor type."), A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: i2(2518, 1, "A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518", "A 'this'-based type guard is not compatible with a parameter-based type guard."), An_async_iterator_must_have_a_next_method: i2(2519, 1, "An_async_iterator_must_have_a_next_method_2519", "An async iterator must have a 'next()' method."), Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: i2(2520, 1, "Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520", "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions."), The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: i2(2522, 1, "The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522", "The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method."), yield_expressions_cannot_be_used_in_a_parameter_initializer: i2(2523, 1, "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523", "'yield' expressions cannot be used in a parameter initializer."), await_expressions_cannot_be_used_in_a_parameter_initializer: i2(2524, 1, "await_expressions_cannot_be_used_in_a_parameter_initializer_2524", "'await' expressions cannot be used in a parameter initializer."), Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: i2(2525, 1, "Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525", "Initializer provides no value for this binding element and the binding element has no default value."), A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: i2(2526, 1, "A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526", "A 'this' type is available only in a non-static member of a class or interface."), The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: i2(2527, 1, "The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527", "The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary."), A_module_cannot_have_multiple_default_exports: i2(2528, 1, "A_module_cannot_have_multiple_default_exports_2528", "A module cannot have multiple default exports."), Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: i2(2529, 1, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions."), Property_0_is_incompatible_with_index_signature: i2(2530, 1, "Property_0_is_incompatible_with_index_signature_2530", "Property '{0}' is incompatible with index signature."), Object_is_possibly_null: i2(2531, 1, "Object_is_possibly_null_2531", "Object is possibly 'null'."), Object_is_possibly_undefined: i2(2532, 1, "Object_is_possibly_undefined_2532", "Object is possibly 'undefined'."), Object_is_possibly_null_or_undefined: i2(2533, 1, "Object_is_possibly_null_or_undefined_2533", "Object is possibly 'null' or 'undefined'."), A_function_returning_never_cannot_have_a_reachable_end_point: i2(2534, 1, "A_function_returning_never_cannot_have_a_reachable_end_point_2534", "A function returning 'never' cannot have a reachable end point."), Type_0_cannot_be_used_to_index_type_1: i2(2536, 1, "Type_0_cannot_be_used_to_index_type_1_2536", "Type '{0}' cannot be used to index type '{1}'."), Type_0_has_no_matching_index_signature_for_type_1: i2(2537, 1, "Type_0_has_no_matching_index_signature_for_type_1_2537", "Type '{0}' has no matching index signature for type '{1}'."), Type_0_cannot_be_used_as_an_index_type: i2(2538, 1, "Type_0_cannot_be_used_as_an_index_type_2538", "Type '{0}' cannot be used as an index type."), Cannot_assign_to_0_because_it_is_not_a_variable: i2(2539, 1, "Cannot_assign_to_0_because_it_is_not_a_variable_2539", "Cannot assign to '{0}' because it is not a variable."), Cannot_assign_to_0_because_it_is_a_read_only_property: i2(2540, 1, "Cannot_assign_to_0_because_it_is_a_read_only_property_2540", "Cannot assign to '{0}' because it is a read-only property."), Index_signature_in_type_0_only_permits_reading: i2(2542, 1, "Index_signature_in_type_0_only_permits_reading_2542", "Index signature in type '{0}' only permits reading."), Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: i2(2543, 1, "Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543", "Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference."), Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: i2(2544, 1, "Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544", "Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference."), A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: i2(2545, 1, "A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545", "A mixin class must have a constructor with a single rest parameter of type 'any[]'."), The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: i2(2547, 1, "The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547", "The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property."), Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: i2(2548, 1, "Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548", "Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator."), Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: i2(2549, 1, "Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549", "Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator."), Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later: i2(2550, 1, "Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550", "Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{2}' or later."), Property_0_does_not_exist_on_type_1_Did_you_mean_2: i2(2551, 1, "Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551", "Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?"), Cannot_find_name_0_Did_you_mean_1: i2(2552, 1, "Cannot_find_name_0_Did_you_mean_1_2552", "Cannot find name '{0}'. Did you mean '{1}'?"), Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: i2(2553, 1, "Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553", "Computed values are not permitted in an enum with string valued members."), Expected_0_arguments_but_got_1: i2(2554, 1, "Expected_0_arguments_but_got_1_2554", "Expected {0} arguments, but got {1}."), Expected_at_least_0_arguments_but_got_1: i2(2555, 1, "Expected_at_least_0_arguments_but_got_1_2555", "Expected at least {0} arguments, but got {1}."), A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter: i2(2556, 1, "A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter_2556", "A spread argument must either have a tuple type or be passed to a rest parameter."), Expected_0_type_arguments_but_got_1: i2(2558, 1, "Expected_0_type_arguments_but_got_1_2558", "Expected {0} type arguments, but got {1}."), Type_0_has_no_properties_in_common_with_type_1: i2(2559, 1, "Type_0_has_no_properties_in_common_with_type_1_2559", "Type '{0}' has no properties in common with type '{1}'."), Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: i2(2560, 1, "Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560", "Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?"), Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: i2(2561, 1, "Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561", "Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?"), Base_class_expressions_cannot_reference_class_type_parameters: i2(2562, 1, "Base_class_expressions_cannot_reference_class_type_parameters_2562", "Base class expressions cannot reference class type parameters."), The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: i2(2563, 1, "The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563", "The containing function or module body is too large for control flow analysis."), Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: i2(2564, 1, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564", "Property '{0}' has no initializer and is not definitely assigned in the constructor."), Property_0_is_used_before_being_assigned: i2(2565, 1, "Property_0_is_used_before_being_assigned_2565", "Property '{0}' is used before being assigned."), A_rest_element_cannot_have_a_property_name: i2(2566, 1, "A_rest_element_cannot_have_a_property_name_2566", "A rest element cannot have a property name."), Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: i2(2567, 1, "Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567", "Enum declarations can only merge with namespace or other enum declarations."), Property_0_may_not_exist_on_type_1_Did_you_mean_2: i2(2568, 1, "Property_0_may_not_exist_on_type_1_Did_you_mean_2_2568", "Property '{0}' may not exist on type '{1}'. Did you mean '{2}'?"), Could_not_find_name_0_Did_you_mean_1: i2(2570, 1, "Could_not_find_name_0_Did_you_mean_1_2570", "Could not find name '{0}'. Did you mean '{1}'?"), Object_is_of_type_unknown: i2(2571, 1, "Object_is_of_type_unknown_2571", "Object is of type 'unknown'."), A_rest_element_type_must_be_an_array_type: i2(2574, 1, "A_rest_element_type_must_be_an_array_type_2574", "A rest element type must be an array type."), No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments: i2(2575, 1, "No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575", "No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments."), Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead: i2(2576, 1, "Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576", "Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?"), Return_type_annotation_circularly_references_itself: i2(2577, 1, "Return_type_annotation_circularly_references_itself_2577", "Return type annotation circularly references itself."), Unused_ts_expect_error_directive: i2(2578, 1, "Unused_ts_expect_error_directive_2578", "Unused '@ts-expect-error' directive."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode: i2(2580, 1, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2580", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery: i2(2581, 1, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2581", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha: i2(2582, 1, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`."), Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later: i2(2583, 1, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{1}' or later."), Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom: i2(2584, 1, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'."), _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later: i2(2585, 1, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585", "'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later."), Cannot_assign_to_0_because_it_is_a_constant: i2(2588, 1, "Cannot_assign_to_0_because_it_is_a_constant_2588", "Cannot assign to '{0}' because it is a constant."), Type_instantiation_is_excessively_deep_and_possibly_infinite: i2(2589, 1, "Type_instantiation_is_excessively_deep_and_possibly_infinite_2589", "Type instantiation is excessively deep and possibly infinite."), Expression_produces_a_union_type_that_is_too_complex_to_represent: i2(2590, 1, "Expression_produces_a_union_type_that_is_too_complex_to_represent_2590", "Expression produces a union type that is too complex to represent."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig: i2(2591, 1, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2591", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig: i2(2592, 1, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2592", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add 'jquery' to the types field in your tsconfig."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig: i2(2593, 1, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig."), This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag: i2(2594, 1, "This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag_2594", "This module is declared with 'export =', and can only be used with a default import when using the '{0}' flag."), _0_can_only_be_imported_by_using_a_default_import: i2(2595, 1, "_0_can_only_be_imported_by_using_a_default_import_2595", "'{0}' can only be imported by using a default import."), _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: i2(2596, 1, "_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596", "'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import."), _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import: i2(2597, 1, "_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597", "'{0}' can only be imported by using a 'require' call or by using a default import."), _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: i2(2598, 1, "_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598", "'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import."), JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: i2(2602, 1, "JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602", "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist."), Property_0_in_type_1_is_not_assignable_to_type_2: i2(2603, 1, "Property_0_in_type_1_is_not_assignable_to_type_2_2603", "Property '{0}' in type '{1}' is not assignable to type '{2}'."), JSX_element_type_0_does_not_have_any_construct_or_call_signatures: i2(2604, 1, "JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604", "JSX element type '{0}' does not have any construct or call signatures."), Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: i2(2606, 1, "Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606", "Property '{0}' of JSX spread attribute is not assignable to target property."), JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: i2(2607, 1, "JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607", "JSX element class does not support attributes because it does not have a '{0}' property."), The_global_type_JSX_0_may_not_have_more_than_one_property: i2(2608, 1, "The_global_type_JSX_0_may_not_have_more_than_one_property_2608", "The global type 'JSX.{0}' may not have more than one property."), JSX_spread_child_must_be_an_array_type: i2(2609, 1, "JSX_spread_child_must_be_an_array_type_2609", "JSX spread child must be an array type."), _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property: i2(2610, 1, "_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610", "'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property."), _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor: i2(2611, 1, "_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611", "'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor."), Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration: i2(2612, 1, "Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612", "Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration."), Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead: i2(2613, 1, "Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613", "Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?"), Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead: i2(2614, 1, "Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614", "Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?"), Type_of_property_0_circularly_references_itself_in_mapped_type_1: i2(2615, 1, "Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615", "Type of property '{0}' circularly references itself in mapped type '{1}'."), _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import: i2(2616, 1, "_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616", "'{0}' can only be imported by using 'import {1} = require({2})' or a default import."), _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: i2(2617, 1, "_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617", "'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import."), Source_has_0_element_s_but_target_requires_1: i2(2618, 1, "Source_has_0_element_s_but_target_requires_1_2618", "Source has {0} element(s) but target requires {1}."), Source_has_0_element_s_but_target_allows_only_1: i2(2619, 1, "Source_has_0_element_s_but_target_allows_only_1_2619", "Source has {0} element(s) but target allows only {1}."), Target_requires_0_element_s_but_source_may_have_fewer: i2(2620, 1, "Target_requires_0_element_s_but_source_may_have_fewer_2620", "Target requires {0} element(s) but source may have fewer."), Target_allows_only_0_element_s_but_source_may_have_more: i2(2621, 1, "Target_allows_only_0_element_s_but_source_may_have_more_2621", "Target allows only {0} element(s) but source may have more."), Source_provides_no_match_for_required_element_at_position_0_in_target: i2(2623, 1, "Source_provides_no_match_for_required_element_at_position_0_in_target_2623", "Source provides no match for required element at position {0} in target."), Source_provides_no_match_for_variadic_element_at_position_0_in_target: i2(2624, 1, "Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624", "Source provides no match for variadic element at position {0} in target."), Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target: i2(2625, 1, "Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625", "Variadic element at position {0} in source does not match element at position {1} in target."), Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target: i2(2626, 1, "Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626", "Type at position {0} in source is not compatible with type at position {1} in target."), Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target: i2(2627, 1, "Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627", "Type at positions {0} through {1} in source is not compatible with type at position {2} in target."), Cannot_assign_to_0_because_it_is_an_enum: i2(2628, 1, "Cannot_assign_to_0_because_it_is_an_enum_2628", "Cannot assign to '{0}' because it is an enum."), Cannot_assign_to_0_because_it_is_a_class: i2(2629, 1, "Cannot_assign_to_0_because_it_is_a_class_2629", "Cannot assign to '{0}' because it is a class."), Cannot_assign_to_0_because_it_is_a_function: i2(2630, 1, "Cannot_assign_to_0_because_it_is_a_function_2630", "Cannot assign to '{0}' because it is a function."), Cannot_assign_to_0_because_it_is_a_namespace: i2(2631, 1, "Cannot_assign_to_0_because_it_is_a_namespace_2631", "Cannot assign to '{0}' because it is a namespace."), Cannot_assign_to_0_because_it_is_an_import: i2(2632, 1, "Cannot_assign_to_0_because_it_is_an_import_2632", "Cannot assign to '{0}' because it is an import."), JSX_property_access_expressions_cannot_include_JSX_namespace_names: i2(2633, 1, "JSX_property_access_expressions_cannot_include_JSX_namespace_names_2633", "JSX property access expressions cannot include JSX namespace names"), _0_index_signatures_are_incompatible: i2(2634, 1, "_0_index_signatures_are_incompatible_2634", "'{0}' index signatures are incompatible."), Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable: i2(2635, 1, "Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable_2635", "Type '{0}' has no signatures for which the type argument list is applicable."), Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation: i2(2636, 1, "Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation_2636", "Type '{0}' is not assignable to type '{1}' as implied by variance annotation."), Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types: i2(2637, 1, "Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637", "Variance annotations are only supported in type aliases for object, function, constructor, and mapped types."), Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator: i2(2638, 1, "Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operato_2638", "Type '{0}' may represent a primitive value, which is not permitted as the right operand of the 'in' operator."), Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: i2(2649, 1, "Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649", "Cannot augment module '{0}' with value exports because it resolves to a non-module entity."), A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: i2(2651, 1, "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651", "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums."), Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: i2(2652, 1, "Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652", "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead."), Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: i2(2653, 1, "Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653", "Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'."), JSX_expressions_must_have_one_parent_element: i2(2657, 1, "JSX_expressions_must_have_one_parent_element_2657", "JSX expressions must have one parent element."), Type_0_provides_no_match_for_the_signature_1: i2(2658, 1, "Type_0_provides_no_match_for_the_signature_1_2658", "Type '{0}' provides no match for the signature '{1}'."), super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: i2(2659, 1, "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659", "'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher."), super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: i2(2660, 1, "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660", "'super' can only be referenced in members of derived classes or object literal expressions."), Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: i2(2661, 1, "Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661", "Cannot export '{0}'. Only local declarations can be exported from a module."), Cannot_find_name_0_Did_you_mean_the_static_member_1_0: i2(2662, 1, "Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662", "Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?"), Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: i2(2663, 1, "Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663", "Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?"), Invalid_module_name_in_augmentation_module_0_cannot_be_found: i2(2664, 1, "Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664", "Invalid module name in augmentation, module '{0}' cannot be found."), Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: i2(2665, 1, "Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665", "Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented."), Exports_and_export_assignments_are_not_permitted_in_module_augmentations: i2(2666, 1, "Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666", "Exports and export assignments are not permitted in module augmentations."), Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: i2(2667, 1, "Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667", "Imports are not permitted in module augmentations. Consider moving them to the enclosing external module."), export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: i2(2668, 1, "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668", "'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible."), Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: i2(2669, 1, "Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669", "Augmentations for the global scope can only be directly nested in external modules or ambient module declarations."), Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: i2(2670, 1, "Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670", "Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context."), Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: i2(2671, 1, "Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671", "Cannot augment module '{0}' because it resolves to a non-module entity."), Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: i2(2672, 1, "Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672", "Cannot assign a '{0}' constructor type to a '{1}' constructor type."), Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: i2(2673, 1, "Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673", "Constructor of class '{0}' is private and only accessible within the class declaration."), Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: i2(2674, 1, "Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674", "Constructor of class '{0}' is protected and only accessible within the class declaration."), Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: i2(2675, 1, "Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675", "Cannot extend a class '{0}'. Class constructor is marked as private."), Accessors_must_both_be_abstract_or_non_abstract: i2(2676, 1, "Accessors_must_both_be_abstract_or_non_abstract_2676", "Accessors must both be abstract or non-abstract."), A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: i2(2677, 1, "A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677", "A type predicate's type must be assignable to its parameter's type."), Type_0_is_not_comparable_to_type_1: i2(2678, 1, "Type_0_is_not_comparable_to_type_1_2678", "Type '{0}' is not comparable to type '{1}'."), A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: i2(2679, 1, "A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679", "A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'."), A_0_parameter_must_be_the_first_parameter: i2(2680, 1, "A_0_parameter_must_be_the_first_parameter_2680", "A '{0}' parameter must be the first parameter."), A_constructor_cannot_have_a_this_parameter: i2(2681, 1, "A_constructor_cannot_have_a_this_parameter_2681", "A constructor cannot have a 'this' parameter."), this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: i2(2683, 1, "this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683", "'this' implicitly has type 'any' because it does not have a type annotation."), The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: i2(2684, 1, "The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684", "The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'."), The_this_types_of_each_signature_are_incompatible: i2(2685, 1, "The_this_types_of_each_signature_are_incompatible_2685", "The 'this' types of each signature are incompatible."), _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: i2(2686, 1, "_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686", "'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead."), All_declarations_of_0_must_have_identical_modifiers: i2(2687, 1, "All_declarations_of_0_must_have_identical_modifiers_2687", "All declarations of '{0}' must have identical modifiers."), Cannot_find_type_definition_file_for_0: i2(2688, 1, "Cannot_find_type_definition_file_for_0_2688", "Cannot find type definition file for '{0}'."), Cannot_extend_an_interface_0_Did_you_mean_implements: i2(2689, 1, "Cannot_extend_an_interface_0_Did_you_mean_implements_2689", "Cannot extend an interface '{0}'. Did you mean 'implements'?"), _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0: i2(2690, 1, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690", "'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?"), _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: i2(2692, 1, "_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692", "'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible."), _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: i2(2693, 1, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693", "'{0}' only refers to a type, but is being used as a value here."), Namespace_0_has_no_exported_member_1: i2(2694, 1, "Namespace_0_has_no_exported_member_1_2694", "Namespace '{0}' has no exported member '{1}'."), Left_side_of_comma_operator_is_unused_and_has_no_side_effects: i2(2695, 1, "Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695", "Left side of comma operator is unused and has no side effects.", true), The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: i2(2696, 1, "The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696", "The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?"), An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: i2(2697, 1, "An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697", "An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."), Spread_types_may_only_be_created_from_object_types: i2(2698, 1, "Spread_types_may_only_be_created_from_object_types_2698", "Spread types may only be created from object types."), Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: i2(2699, 1, "Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699", "Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'."), Rest_types_may_only_be_created_from_object_types: i2(2700, 1, "Rest_types_may_only_be_created_from_object_types_2700", "Rest types may only be created from object types."), The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: i2(2701, 1, "The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701", "The target of an object rest assignment must be a variable or a property access."), _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: i2(2702, 1, "_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702", "'{0}' only refers to a type, but is being used as a namespace here."), The_operand_of_a_delete_operator_must_be_a_property_reference: i2(2703, 1, "The_operand_of_a_delete_operator_must_be_a_property_reference_2703", "The operand of a 'delete' operator must be a property reference."), The_operand_of_a_delete_operator_cannot_be_a_read_only_property: i2(2704, 1, "The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704", "The operand of a 'delete' operator cannot be a read-only property."), An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: i2(2705, 1, "An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705", "An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."), Required_type_parameters_may_not_follow_optional_type_parameters: i2(2706, 1, "Required_type_parameters_may_not_follow_optional_type_parameters_2706", "Required type parameters may not follow optional type parameters."), Generic_type_0_requires_between_1_and_2_type_arguments: i2(2707, 1, "Generic_type_0_requires_between_1_and_2_type_arguments_2707", "Generic type '{0}' requires between {1} and {2} type arguments."), Cannot_use_namespace_0_as_a_value: i2(2708, 1, "Cannot_use_namespace_0_as_a_value_2708", "Cannot use namespace '{0}' as a value."), Cannot_use_namespace_0_as_a_type: i2(2709, 1, "Cannot_use_namespace_0_as_a_type_2709", "Cannot use namespace '{0}' as a type."), _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: i2(2710, 1, "_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710", "'{0}' are specified twice. The attribute named '{0}' will be overwritten."), A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: i2(2711, 1, "A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711", "A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."), A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: i2(2712, 1, "A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712", "A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."), Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: i2(2713, 1, "Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713", `Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}["{1}"]'?`), The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: i2(2714, 1, "The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714", "The expression of an export assignment must be an identifier or qualified name in an ambient context."), Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: i2(2715, 1, "Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715", "Abstract property '{0}' in class '{1}' cannot be accessed in the constructor."), Type_parameter_0_has_a_circular_default: i2(2716, 1, "Type_parameter_0_has_a_circular_default_2716", "Type parameter '{0}' has a circular default."), Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: i2(2717, 1, "Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717", "Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'."), Duplicate_property_0: i2(2718, 1, "Duplicate_property_0_2718", "Duplicate property '{0}'."), Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: i2(2719, 1, "Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719", "Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated."), Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: i2(2720, 1, "Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720", "Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?"), Cannot_invoke_an_object_which_is_possibly_null: i2(2721, 1, "Cannot_invoke_an_object_which_is_possibly_null_2721", "Cannot invoke an object which is possibly 'null'."), Cannot_invoke_an_object_which_is_possibly_undefined: i2(2722, 1, "Cannot_invoke_an_object_which_is_possibly_undefined_2722", "Cannot invoke an object which is possibly 'undefined'."), Cannot_invoke_an_object_which_is_possibly_null_or_undefined: i2(2723, 1, "Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723", "Cannot invoke an object which is possibly 'null' or 'undefined'."), _0_has_no_exported_member_named_1_Did_you_mean_2: i2(2724, 1, "_0_has_no_exported_member_named_1_Did_you_mean_2_2724", "'{0}' has no exported member named '{1}'. Did you mean '{2}'?"), Class_name_cannot_be_Object_when_targeting_ES5_with_module_0: i2(2725, 1, "Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725", "Class name cannot be 'Object' when targeting ES5 with module {0}."), Cannot_find_lib_definition_for_0: i2(2726, 1, "Cannot_find_lib_definition_for_0_2726", "Cannot find lib definition for '{0}'."), Cannot_find_lib_definition_for_0_Did_you_mean_1: i2(2727, 1, "Cannot_find_lib_definition_for_0_Did_you_mean_1_2727", "Cannot find lib definition for '{0}'. Did you mean '{1}'?"), _0_is_declared_here: i2(2728, 3, "_0_is_declared_here_2728", "'{0}' is declared here."), Property_0_is_used_before_its_initialization: i2(2729, 1, "Property_0_is_used_before_its_initialization_2729", "Property '{0}' is used before its initialization."), An_arrow_function_cannot_have_a_this_parameter: i2(2730, 1, "An_arrow_function_cannot_have_a_this_parameter_2730", "An arrow function cannot have a 'this' parameter."), Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String: i2(2731, 1, "Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731", "Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'."), Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension: i2(2732, 1, "Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732", "Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension."), Property_0_was_also_declared_here: i2(2733, 1, "Property_0_was_also_declared_here_2733", "Property '{0}' was also declared here."), Are_you_missing_a_semicolon: i2(2734, 1, "Are_you_missing_a_semicolon_2734", "Are you missing a semicolon?"), Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1: i2(2735, 1, "Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1_2735", "Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?"), Operator_0_cannot_be_applied_to_type_1: i2(2736, 1, "Operator_0_cannot_be_applied_to_type_1_2736", "Operator '{0}' cannot be applied to type '{1}'."), BigInt_literals_are_not_available_when_targeting_lower_than_ES2020: i2(2737, 1, "BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737", "BigInt literals are not available when targeting lower than ES2020."), An_outer_value_of_this_is_shadowed_by_this_container: i2(2738, 3, "An_outer_value_of_this_is_shadowed_by_this_container_2738", "An outer value of 'this' is shadowed by this container."), Type_0_is_missing_the_following_properties_from_type_1_Colon_2: i2(2739, 1, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_2739", "Type '{0}' is missing the following properties from type '{1}': {2}"), Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more: i2(2740, 1, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more_2740", "Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more."), Property_0_is_missing_in_type_1_but_required_in_type_2: i2(2741, 1, "Property_0_is_missing_in_type_1_but_required_in_type_2_2741", "Property '{0}' is missing in type '{1}' but required in type '{2}'."), The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary: i2(2742, 1, "The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742", "The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary."), No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments: i2(2743, 1, "No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743", "No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments."), Type_parameter_defaults_can_only_reference_previously_declared_type_parameters: i2(2744, 1, "Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744", "Type parameter defaults can only reference previously declared type parameters."), This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided: i2(2745, 1, "This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745", "This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided."), This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided: i2(2746, 1, "This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746", "This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided."), _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2: i2(2747, 1, "_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747", "'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'."), Cannot_access_ambient_const_enums_when_0_is_enabled: i2(2748, 1, "Cannot_access_ambient_const_enums_when_0_is_enabled_2748", "Cannot access ambient const enums when '{0}' is enabled."), _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0: i2(2749, 1, "_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749", "'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?"), The_implementation_signature_is_declared_here: i2(2750, 1, "The_implementation_signature_is_declared_here_2750", "The implementation signature is declared here."), Circularity_originates_in_type_at_this_location: i2(2751, 1, "Circularity_originates_in_type_at_this_location_2751", "Circularity originates in type at this location."), The_first_export_default_is_here: i2(2752, 1, "The_first_export_default_is_here_2752", "The first export default is here."), Another_export_default_is_here: i2(2753, 1, "Another_export_default_is_here_2753", "Another export default is here."), super_may_not_use_type_arguments: i2(2754, 1, "super_may_not_use_type_arguments_2754", "'super' may not use type arguments."), No_constituent_of_type_0_is_callable: i2(2755, 1, "No_constituent_of_type_0_is_callable_2755", "No constituent of type '{0}' is callable."), Not_all_constituents_of_type_0_are_callable: i2(2756, 1, "Not_all_constituents_of_type_0_are_callable_2756", "Not all constituents of type '{0}' are callable."), Type_0_has_no_call_signatures: i2(2757, 1, "Type_0_has_no_call_signatures_2757", "Type '{0}' has no call signatures."), Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other: i2(2758, 1, "Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758", "Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other."), No_constituent_of_type_0_is_constructable: i2(2759, 1, "No_constituent_of_type_0_is_constructable_2759", "No constituent of type '{0}' is constructable."), Not_all_constituents_of_type_0_are_constructable: i2(2760, 1, "Not_all_constituents_of_type_0_are_constructable_2760", "Not all constituents of type '{0}' are constructable."), Type_0_has_no_construct_signatures: i2(2761, 1, "Type_0_has_no_construct_signatures_2761", "Type '{0}' has no construct signatures."), Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other: i2(2762, 1, "Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762", "Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other."), Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0: i2(2763, 1, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'."), Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0: i2(2764, 1, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'."), Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0: i2(2765, 1, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'."), Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0: i2(2766, 1, "Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766", "Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'."), The_0_property_of_an_iterator_must_be_a_method: i2(2767, 1, "The_0_property_of_an_iterator_must_be_a_method_2767", "The '{0}' property of an iterator must be a method."), The_0_property_of_an_async_iterator_must_be_a_method: i2(2768, 1, "The_0_property_of_an_async_iterator_must_be_a_method_2768", "The '{0}' property of an async iterator must be a method."), No_overload_matches_this_call: i2(2769, 1, "No_overload_matches_this_call_2769", "No overload matches this call."), The_last_overload_gave_the_following_error: i2(2770, 1, "The_last_overload_gave_the_following_error_2770", "The last overload gave the following error."), The_last_overload_is_declared_here: i2(2771, 1, "The_last_overload_is_declared_here_2771", "The last overload is declared here."), Overload_0_of_1_2_gave_the_following_error: i2(2772, 1, "Overload_0_of_1_2_gave_the_following_error_2772", "Overload {0} of {1}, '{2}', gave the following error."), Did_you_forget_to_use_await: i2(2773, 1, "Did_you_forget_to_use_await_2773", "Did you forget to use 'await'?"), This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead: i2(2774, 1, "This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_2774", "This condition will always return true since this function is always defined. Did you mean to call it instead?"), Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation: i2(2775, 1, "Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775", "Assertions require every name in the call target to be declared with an explicit type annotation."), Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name: i2(2776, 1, "Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776", "Assertions require the call target to be an identifier or qualified name."), The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access: i2(2777, 1, "The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777", "The operand of an increment or decrement operator may not be an optional property access."), The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access: i2(2778, 1, "The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778", "The target of an object rest assignment may not be an optional property access."), The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access: i2(2779, 1, "The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779", "The left-hand side of an assignment expression may not be an optional property access."), The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access: i2(2780, 1, "The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780", "The left-hand side of a 'for...in' statement may not be an optional property access."), The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access: i2(2781, 1, "The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781", "The left-hand side of a 'for...of' statement may not be an optional property access."), _0_needs_an_explicit_type_annotation: i2(2782, 3, "_0_needs_an_explicit_type_annotation_2782", "'{0}' needs an explicit type annotation."), _0_is_specified_more_than_once_so_this_usage_will_be_overwritten: i2(2783, 1, "_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783", "'{0}' is specified more than once, so this usage will be overwritten."), get_and_set_accessors_cannot_declare_this_parameters: i2(2784, 1, "get_and_set_accessors_cannot_declare_this_parameters_2784", "'get' and 'set' accessors cannot declare 'this' parameters."), This_spread_always_overwrites_this_property: i2(2785, 1, "This_spread_always_overwrites_this_property_2785", "This spread always overwrites this property."), _0_cannot_be_used_as_a_JSX_component: i2(2786, 1, "_0_cannot_be_used_as_a_JSX_component_2786", "'{0}' cannot be used as a JSX component."), Its_return_type_0_is_not_a_valid_JSX_element: i2(2787, 1, "Its_return_type_0_is_not_a_valid_JSX_element_2787", "Its return type '{0}' is not a valid JSX element."), Its_instance_type_0_is_not_a_valid_JSX_element: i2(2788, 1, "Its_instance_type_0_is_not_a_valid_JSX_element_2788", "Its instance type '{0}' is not a valid JSX element."), Its_element_type_0_is_not_a_valid_JSX_element: i2(2789, 1, "Its_element_type_0_is_not_a_valid_JSX_element_2789", "Its element type '{0}' is not a valid JSX element."), The_operand_of_a_delete_operator_must_be_optional: i2(2790, 1, "The_operand_of_a_delete_operator_must_be_optional_2790", "The operand of a 'delete' operator must be optional."), Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later: i2(2791, 1, "Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791", "Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later."), Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option: i2(2792, 1, "Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_t_2792", "Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'nodenext', or to add aliases to the 'paths' option?"), The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible: i2(2793, 1, "The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793", "The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible."), Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise: i2(2794, 1, "Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794", "Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?"), The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types: i2(2795, 1, "The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795", "The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types."), It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked: i2(2796, 1, "It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796", "It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked."), A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract: i2(2797, 1, "A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797", "A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'."), The_declaration_was_marked_as_deprecated_here: i2(2798, 1, "The_declaration_was_marked_as_deprecated_here_2798", "The declaration was marked as deprecated here."), Type_produces_a_tuple_type_that_is_too_large_to_represent: i2(2799, 1, "Type_produces_a_tuple_type_that_is_too_large_to_represent_2799", "Type produces a tuple type that is too large to represent."), Expression_produces_a_tuple_type_that_is_too_large_to_represent: i2(2800, 1, "Expression_produces_a_tuple_type_that_is_too_large_to_represent_2800", "Expression produces a tuple type that is too large to represent."), This_condition_will_always_return_true_since_this_0_is_always_defined: i2(2801, 1, "This_condition_will_always_return_true_since_this_0_is_always_defined_2801", "This condition will always return true since this '{0}' is always defined."), Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher: i2(2802, 1, "Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es201_2802", "Type '{0}' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher."), Cannot_assign_to_private_method_0_Private_methods_are_not_writable: i2(2803, 1, "Cannot_assign_to_private_method_0_Private_methods_are_not_writable_2803", "Cannot assign to private method '{0}'. Private methods are not writable."), Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name: i2(2804, 1, "Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name_2804", "Duplicate identifier '{0}'. Static and instance elements cannot share the same private name."), Private_accessor_was_defined_without_a_getter: i2(2806, 1, "Private_accessor_was_defined_without_a_getter_2806", "Private accessor was defined without a getter."), This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0: i2(2807, 1, "This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_o_2807", "This syntax requires an imported helper named '{1}' with {2} parameters, which is not compatible with the one in '{0}'. Consider upgrading your version of '{0}'."), A_get_accessor_must_be_at_least_as_accessible_as_the_setter: i2(2808, 1, "A_get_accessor_must_be_at_least_as_accessible_as_the_setter_2808", "A get accessor must be at least as accessible as the setter"), Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses: i2(2809, 1, "Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_d_2809", "Declaration or statement expected. This '=' follows a block of statements, so if you intended to write a destructuring assignment, you might need to wrap the whole assignment in parentheses."), Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments: i2(2810, 1, "Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_2810", "Expected 1 argument, but got 0. 'new Promise()' needs a JSDoc hint to produce a 'resolve' that can be called without arguments."), Initializer_for_property_0: i2(2811, 1, "Initializer_for_property_0_2811", "Initializer for property '{0}'"), Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom: i2(2812, 1, "Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom_2812", "Property '{0}' does not exist on type '{1}'. Try changing the 'lib' compiler option to include 'dom'."), Class_declaration_cannot_implement_overload_list_for_0: i2(2813, 1, "Class_declaration_cannot_implement_overload_list_for_0_2813", "Class declaration cannot implement overload list for '{0}'."), Function_with_bodies_can_only_merge_with_classes_that_are_ambient: i2(2814, 1, "Function_with_bodies_can_only_merge_with_classes_that_are_ambient_2814", "Function with bodies can only merge with classes that are ambient."), arguments_cannot_be_referenced_in_property_initializers: i2(2815, 1, "arguments_cannot_be_referenced_in_property_initializers_2815", "'arguments' cannot be referenced in property initializers."), Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class: i2(2816, 1, "Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class_2816", "Cannot use 'this' in a static property initializer of a decorated class."), Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block: i2(2817, 1, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block_2817", "Property '{0}' has no initializer and is not definitely assigned in a class static block."), Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers: i2(2818, 1, "Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializer_2818", "Duplicate identifier '{0}'. Compiler reserves name '{1}' when emitting 'super' references in static initializers."), Namespace_name_cannot_be_0: i2(2819, 1, "Namespace_name_cannot_be_0_2819", "Namespace name cannot be '{0}'."), Type_0_is_not_assignable_to_type_1_Did_you_mean_2: i2(2820, 1, "Type_0_is_not_assignable_to_type_1_Did_you_mean_2_2820", "Type '{0}' is not assignable to type '{1}'. Did you mean '{2}'?"), Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext: i2(2821, 1, "Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext_2821", "Import assertions are only supported when the '--module' option is set to 'esnext' or 'nodenext'."), Import_assertions_cannot_be_used_with_type_only_imports_or_exports: i2(2822, 1, "Import_assertions_cannot_be_used_with_type_only_imports_or_exports_2822", "Import assertions cannot be used with type-only imports or exports."), Cannot_find_namespace_0_Did_you_mean_1: i2(2833, 1, "Cannot_find_namespace_0_Did_you_mean_1_2833", "Cannot find namespace '{0}'. Did you mean '{1}'?"), Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path: i2(2834, 1, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2834", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path."), Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0: i2(2835, 1, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2835", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean '{0}'?"), Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls: i2(2836, 1, "Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls_2836", "Import assertions are not allowed on statements that transpile to commonjs 'require' calls."), Import_assertion_values_must_be_string_literal_expressions: i2(2837, 1, "Import_assertion_values_must_be_string_literal_expressions_2837", "Import assertion values must be string literal expressions."), All_declarations_of_0_must_have_identical_constraints: i2(2838, 1, "All_declarations_of_0_must_have_identical_constraints_2838", "All declarations of '{0}' must have identical constraints."), This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value: i2(2839, 1, "This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value_2839", "This condition will always return '{0}' since JavaScript compares objects by reference, not value."), An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_classes: i2(2840, 1, "An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_clas_2840", "An interface cannot extend a primitive type like '{0}'; an interface can only extend named types and classes"), The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_feature_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: i2(2841, 1, "The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_2841", "The type of this expression cannot be named without a 'resolution-mode' assertion, which is an unstable feature. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), _0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation: i2(2842, 1, "_0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation_2842", "'{0}' is an unused renaming of '{1}'. Did you intend to use it as a type annotation?"), We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here: i2(2843, 1, "We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here_2843", "We can only write a type for '{0}' by adding a type for the entire parameter here."), Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: i2(2844, 1, "Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2844", "Type of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."), This_condition_will_always_return_0: i2(2845, 1, "This_condition_will_always_return_0_2845", "This condition will always return '{0}'."), A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead: i2(2846, 1, "A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_f_2846", "A declaration file cannot be imported without 'import type'. Did you mean to import an implementation file '{0}' instead?"), Import_declaration_0_is_using_private_name_1: i2(4e3, 1, "Import_declaration_0_is_using_private_name_1_4000", "Import declaration '{0}' is using private name '{1}'."), Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: i2(4002, 1, "Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002", "Type parameter '{0}' of exported class has or is using private name '{1}'."), Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: i2(4004, 1, "Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004", "Type parameter '{0}' of exported interface has or is using private name '{1}'."), Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: i2(4006, 1, "Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006", "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."), Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: i2(4008, 1, "Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008", "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'."), Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: i2(4010, 1, "Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010", "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'."), Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: i2(4012, 1, "Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012", "Type parameter '{0}' of public method from exported class has or is using private name '{1}'."), Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: i2(4014, 1, "Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014", "Type parameter '{0}' of method from exported interface has or is using private name '{1}'."), Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: i2(4016, 1, "Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016", "Type parameter '{0}' of exported function has or is using private name '{1}'."), Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: i2(4019, 1, "Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019", "Implements clause of exported class '{0}' has or is using private name '{1}'."), extends_clause_of_exported_class_0_has_or_is_using_private_name_1: i2(4020, 1, "extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020", "'extends' clause of exported class '{0}' has or is using private name '{1}'."), extends_clause_of_exported_class_has_or_is_using_private_name_0: i2(4021, 1, "extends_clause_of_exported_class_has_or_is_using_private_name_0_4021", "'extends' clause of exported class has or is using private name '{0}'."), extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: i2(4022, 1, "extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022", "'extends' clause of exported interface '{0}' has or is using private name '{1}'."), Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4023, 1, "Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023", "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named."), Exported_variable_0_has_or_is_using_name_1_from_private_module_2: i2(4024, 1, "Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024", "Exported variable '{0}' has or is using name '{1}' from private module '{2}'."), Exported_variable_0_has_or_is_using_private_name_1: i2(4025, 1, "Exported_variable_0_has_or_is_using_private_name_1_4025", "Exported variable '{0}' has or is using private name '{1}'."), Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4026, 1, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026", "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4027, 1, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027", "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: i2(4028, 1, "Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028", "Public static property '{0}' of exported class has or is using private name '{1}'."), Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4029, 1, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029", "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4030, 1, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030", "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_property_0_of_exported_class_has_or_is_using_private_name_1: i2(4031, 1, "Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031", "Public property '{0}' of exported class has or is using private name '{1}'."), Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: i2(4032, 1, "Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032", "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'."), Property_0_of_exported_interface_has_or_is_using_private_name_1: i2(4033, 1, "Property_0_of_exported_interface_has_or_is_using_private_name_1_4033", "Property '{0}' of exported interface has or is using private name '{1}'."), Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4034, 1, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034", "Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: i2(4035, 1, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035", "Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'."), Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4036, 1, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036", "Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: i2(4037, 1, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037", "Parameter type of public setter '{0}' from exported class has or is using private name '{1}'."), Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4038, 1, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."), Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4039, 1, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: i2(4040, 1, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040", "Return type of public static getter '{0}' from exported class has or is using private name '{1}'."), Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4041, 1, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041", "Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."), Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4042, 1, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042", "Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: i2(4043, 1, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043", "Return type of public getter '{0}' from exported class has or is using private name '{1}'."), Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: i2(4044, 1, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044", "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: i2(4045, 1, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045", "Return type of constructor signature from exported interface has or is using private name '{0}'."), Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: i2(4046, 1, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046", "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: i2(4047, 1, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047", "Return type of call signature from exported interface has or is using private name '{0}'."), Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: i2(4048, 1, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048", "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: i2(4049, 1, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049", "Return type of index signature from exported interface has or is using private name '{0}'."), Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: i2(4050, 1, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050", "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named."), Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: i2(4051, 1, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051", "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'."), Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: i2(4052, 1, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052", "Return type of public static method from exported class has or is using private name '{0}'."), Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: i2(4053, 1, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053", "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named."), Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: i2(4054, 1, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054", "Return type of public method from exported class has or is using name '{0}' from private module '{1}'."), Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: i2(4055, 1, "Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055", "Return type of public method from exported class has or is using private name '{0}'."), Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: i2(4056, 1, "Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056", "Return type of method from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: i2(4057, 1, "Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057", "Return type of method from exported interface has or is using private name '{0}'."), Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: i2(4058, 1, "Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058", "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named."), Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: i2(4059, 1, "Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059", "Return type of exported function has or is using name '{0}' from private module '{1}'."), Return_type_of_exported_function_has_or_is_using_private_name_0: i2(4060, 1, "Return_type_of_exported_function_has_or_is_using_private_name_0_4060", "Return type of exported function has or is using private name '{0}'."), Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4061, 1, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4062, 1, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'."), Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: i2(4063, 1, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063", "Parameter '{0}' of constructor from exported class has or is using private name '{1}'."), Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: i2(4064, 1, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064", "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: i2(4065, 1, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065", "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."), Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: i2(4066, 1, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066", "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: i2(4067, 1, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067", "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'."), Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4068, 1, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4069, 1, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'."), Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: i2(4070, 1, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070", "Parameter '{0}' of public static method from exported class has or is using private name '{1}'."), Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4071, 1, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071", "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4072, 1, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072", "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'."), Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: i2(4073, 1, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073", "Parameter '{0}' of public method from exported class has or is using private name '{1}'."), Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: i2(4074, 1, "Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074", "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: i2(4075, 1, "Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075", "Parameter '{0}' of method from exported interface has or is using private name '{1}'."), Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4076, 1, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076", "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: i2(4077, 1, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077", "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'."), Parameter_0_of_exported_function_has_or_is_using_private_name_1: i2(4078, 1, "Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078", "Parameter '{0}' of exported function has or is using private name '{1}'."), Exported_type_alias_0_has_or_is_using_private_name_1: i2(4081, 1, "Exported_type_alias_0_has_or_is_using_private_name_1_4081", "Exported type alias '{0}' has or is using private name '{1}'."), Default_export_of_the_module_has_or_is_using_private_name_0: i2(4082, 1, "Default_export_of_the_module_has_or_is_using_private_name_0_4082", "Default export of the module has or is using private name '{0}'."), Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: i2(4083, 1, "Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083", "Type parameter '{0}' of exported type alias has or is using private name '{1}'."), Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2: i2(4084, 1, "Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2_4084", "Exported type alias '{0}' has or is using private name '{1}' from module {2}."), Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1: i2(4085, 1, "Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1_4085", "Extends clause for inferred type '{0}' has or is using private name '{1}'."), Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: i2(4090, 1, "Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090", "Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict."), Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: i2(4091, 1, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091", "Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: i2(4092, 1, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092", "Parameter '{0}' of index signature from exported interface has or is using private name '{1}'."), Property_0_of_exported_class_expression_may_not_be_private_or_protected: i2(4094, 1, "Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094", "Property '{0}' of exported class expression may not be private or protected."), Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4095, 1, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095", "Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4096, 1, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096", "Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: i2(4097, 1, "Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097", "Public static method '{0}' of exported class has or is using private name '{1}'."), Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4098, 1, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098", "Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: i2(4099, 1, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099", "Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_method_0_of_exported_class_has_or_is_using_private_name_1: i2(4100, 1, "Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100", "Public method '{0}' of exported class has or is using private name '{1}'."), Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: i2(4101, 1, "Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101", "Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'."), Method_0_of_exported_interface_has_or_is_using_private_name_1: i2(4102, 1, "Method_0_of_exported_interface_has_or_is_using_private_name_1_4102", "Method '{0}' of exported interface has or is using private name '{1}'."), Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1: i2(4103, 1, "Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103", "Type parameter '{0}' of exported mapped object type is using private name '{1}'."), The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1: i2(4104, 1, "The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104", "The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'."), Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter: i2(4105, 1, "Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105", "Private or protected member '{0}' cannot be accessed on a type parameter."), Parameter_0_of_accessor_has_or_is_using_private_name_1: i2(4106, 1, "Parameter_0_of_accessor_has_or_is_using_private_name_1_4106", "Parameter '{0}' of accessor has or is using private name '{1}'."), Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2: i2(4107, 1, "Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107", "Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'."), Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: i2(4108, 1, "Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108", "Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named."), Type_arguments_for_0_circularly_reference_themselves: i2(4109, 1, "Type_arguments_for_0_circularly_reference_themselves_4109", "Type arguments for '{0}' circularly reference themselves."), Tuple_type_arguments_circularly_reference_themselves: i2(4110, 1, "Tuple_type_arguments_circularly_reference_themselves_4110", "Tuple type arguments circularly reference themselves."), Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0: i2(4111, 1, "Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111", "Property '{0}' comes from an index signature, so it must be accessed with ['{0}']."), This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class: i2(4112, 1, "This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another__4112", "This member cannot have an 'override' modifier because its containing class '{0}' does not extend another class."), This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0: i2(4113, 1, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_4113", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'."), This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0: i2(4114, 1, "This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0_4114", "This member must have an 'override' modifier because it overrides a member in the base class '{0}'."), This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0: i2(4115, 1, "This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0_4115", "This parameter property must have an 'override' modifier because it overrides a member in base class '{0}'."), This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0: i2(4116, 1, "This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared__4116", "This member must have an 'override' modifier because it overrides an abstract method that is declared in the base class '{0}'."), This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: i2(4117, 1, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you__4117", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'. Did you mean '{1}'?"), The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized: i2(4118, 1, "The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized_4118", "The type of this node cannot be serialized because its property '{0}' cannot be serialized."), This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: i2(4119, 1, "This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_4119", "This member must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."), This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: i2(4120, 1, "This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_4120", "This parameter property must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."), This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class: i2(4121, 1, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_4121", "This member cannot have a JSDoc comment with an '@override' tag because its containing class '{0}' does not extend another class."), This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0: i2(4122, 1, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4122", "This member cannot have a JSDoc comment with an '@override' tag because it is not declared in the base class '{0}'."), This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: i2(4123, 1, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4123", "This member cannot have a JSDoc comment with an 'override' tag because it is not declared in the base class '{0}'. Did you mean '{1}'?"), Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: i2(4124, 1, "Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_w_4124", "Compiler option '{0}' of value '{1}' is unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: i2(4125, 1, "resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_wi_4125", "'resolution-mode' assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), The_current_host_does_not_support_the_0_option: i2(5001, 1, "The_current_host_does_not_support_the_0_option_5001", "The current host does not support the '{0}' option."), Cannot_find_the_common_subdirectory_path_for_the_input_files: i2(5009, 1, "Cannot_find_the_common_subdirectory_path_for_the_input_files_5009", "Cannot find the common subdirectory path for the input files."), File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: i2(5010, 1, "File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010", "File specification cannot end in a recursive directory wildcard ('**'): '{0}'."), Cannot_read_file_0_Colon_1: i2(5012, 1, "Cannot_read_file_0_Colon_1_5012", "Cannot read file '{0}': {1}."), Failed_to_parse_file_0_Colon_1: i2(5014, 1, "Failed_to_parse_file_0_Colon_1_5014", "Failed to parse file '{0}': {1}."), Unknown_compiler_option_0: i2(5023, 1, "Unknown_compiler_option_0_5023", "Unknown compiler option '{0}'."), Compiler_option_0_requires_a_value_of_type_1: i2(5024, 1, "Compiler_option_0_requires_a_value_of_type_1_5024", "Compiler option '{0}' requires a value of type {1}."), Unknown_compiler_option_0_Did_you_mean_1: i2(5025, 1, "Unknown_compiler_option_0_Did_you_mean_1_5025", "Unknown compiler option '{0}'. Did you mean '{1}'?"), Could_not_write_file_0_Colon_1: i2(5033, 1, "Could_not_write_file_0_Colon_1_5033", "Could not write file '{0}': {1}."), Option_project_cannot_be_mixed_with_source_files_on_a_command_line: i2(5042, 1, "Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042", "Option 'project' cannot be mixed with source files on a command line."), Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: i2(5047, 1, "Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047", "Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher."), Option_0_cannot_be_specified_when_option_target_is_ES3: i2(5048, 1, "Option_0_cannot_be_specified_when_option_target_is_ES3_5048", "Option '{0}' cannot be specified when option 'target' is 'ES3'."), Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: i2(5051, 1, "Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051", "Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided."), Option_0_cannot_be_specified_without_specifying_option_1: i2(5052, 1, "Option_0_cannot_be_specified_without_specifying_option_1_5052", "Option '{0}' cannot be specified without specifying option '{1}'."), Option_0_cannot_be_specified_with_option_1: i2(5053, 1, "Option_0_cannot_be_specified_with_option_1_5053", "Option '{0}' cannot be specified with option '{1}'."), A_tsconfig_json_file_is_already_defined_at_Colon_0: i2(5054, 1, "A_tsconfig_json_file_is_already_defined_at_Colon_0_5054", "A 'tsconfig.json' file is already defined at: '{0}'."), Cannot_write_file_0_because_it_would_overwrite_input_file: i2(5055, 1, "Cannot_write_file_0_because_it_would_overwrite_input_file_5055", "Cannot write file '{0}' because it would overwrite input file."), Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: i2(5056, 1, "Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056", "Cannot write file '{0}' because it would be overwritten by multiple input files."), Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: i2(5057, 1, "Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057", "Cannot find a tsconfig.json file at the specified directory: '{0}'."), The_specified_path_does_not_exist_Colon_0: i2(5058, 1, "The_specified_path_does_not_exist_Colon_0_5058", "The specified path does not exist: '{0}'."), Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: i2(5059, 1, "Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059", "Invalid value for '--reactNamespace'. '{0}' is not a valid identifier."), Pattern_0_can_have_at_most_one_Asterisk_character: i2(5061, 1, "Pattern_0_can_have_at_most_one_Asterisk_character_5061", "Pattern '{0}' can have at most one '*' character."), Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character: i2(5062, 1, "Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character_5062", "Substitution '{0}' in pattern '{1}' can have at most one '*' character."), Substitutions_for_pattern_0_should_be_an_array: i2(5063, 1, "Substitutions_for_pattern_0_should_be_an_array_5063", "Substitutions for pattern '{0}' should be an array."), Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: i2(5064, 1, "Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064", "Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'."), File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: i2(5065, 1, "File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065", "File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'."), Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: i2(5066, 1, "Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066", "Substitutions for pattern '{0}' shouldn't be an empty array."), Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: i2(5067, 1, "Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067", "Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name."), Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: i2(5068, 1, "Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068", "Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig."), Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: i2(5069, 1, "Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069", "Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'."), Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic: i2(5070, 1, "Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic_5070", "Option '--resolveJsonModule' cannot be specified when 'moduleResolution' is set to 'classic'."), Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext: i2(5071, 1, "Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_5071", "Option '--resolveJsonModule' can only be specified when module code generation is 'commonjs', 'amd', 'es2015' or 'esNext'."), Unknown_build_option_0: i2(5072, 1, "Unknown_build_option_0_5072", "Unknown build option '{0}'."), Build_option_0_requires_a_value_of_type_1: i2(5073, 1, "Build_option_0_requires_a_value_of_type_1_5073", "Build option '{0}' requires a value of type {1}."), Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified: i2(5074, 1, "Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074", "Option '--incremental' can only be specified using tsconfig, emitting to single file or when option '--tsBuildInfoFile' is specified."), _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2: i2(5075, 1, "_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075", "'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'."), _0_and_1_operations_cannot_be_mixed_without_parentheses: i2(5076, 1, "_0_and_1_operations_cannot_be_mixed_without_parentheses_5076", "'{0}' and '{1}' operations cannot be mixed without parentheses."), Unknown_build_option_0_Did_you_mean_1: i2(5077, 1, "Unknown_build_option_0_Did_you_mean_1_5077", "Unknown build option '{0}'. Did you mean '{1}'?"), Unknown_watch_option_0: i2(5078, 1, "Unknown_watch_option_0_5078", "Unknown watch option '{0}'."), Unknown_watch_option_0_Did_you_mean_1: i2(5079, 1, "Unknown_watch_option_0_Did_you_mean_1_5079", "Unknown watch option '{0}'. Did you mean '{1}'?"), Watch_option_0_requires_a_value_of_type_1: i2(5080, 1, "Watch_option_0_requires_a_value_of_type_1_5080", "Watch option '{0}' requires a value of type {1}."), Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0: i2(5081, 1, "Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0_5081", "Cannot find a tsconfig.json file at the current directory: {0}."), _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1: i2(5082, 1, "_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082", "'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'."), Cannot_read_file_0: i2(5083, 1, "Cannot_read_file_0_5083", "Cannot read file '{0}'."), Tuple_members_must_all_have_names_or_all_not_have_names: i2(5084, 1, "Tuple_members_must_all_have_names_or_all_not_have_names_5084", "Tuple members must all have names or all not have names."), A_tuple_member_cannot_be_both_optional_and_rest: i2(5085, 1, "A_tuple_member_cannot_be_both_optional_and_rest_5085", "A tuple member cannot be both optional and rest."), A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type: i2(5086, 1, "A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086", "A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type."), A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type: i2(5087, 1, "A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087", "A labeled tuple element is declared as rest with a '...' before the name, rather than before the type."), The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary: i2(5088, 1, "The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088", "The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary."), Option_0_cannot_be_specified_when_option_jsx_is_1: i2(5089, 1, "Option_0_cannot_be_specified_when_option_jsx_is_1_5089", "Option '{0}' cannot be specified when option 'jsx' is '{1}'."), Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash: i2(5090, 1, "Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash_5090", "Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?"), Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled: i2(5091, 1, "Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled_5091", "Option 'preserveConstEnums' cannot be disabled when '{0}' is enabled."), The_root_value_of_a_0_file_must_be_an_object: i2(5092, 1, "The_root_value_of_a_0_file_must_be_an_object_5092", "The root value of a '{0}' file must be an object."), Compiler_option_0_may_only_be_used_with_build: i2(5093, 1, "Compiler_option_0_may_only_be_used_with_build_5093", "Compiler option '--{0}' may only be used with '--build'."), Compiler_option_0_may_not_be_used_with_build: i2(5094, 1, "Compiler_option_0_may_not_be_used_with_build_5094", "Compiler option '--{0}' may not be used with '--build'."), Option_0_can_only_be_used_when_module_is_set_to_es2015_or_later: i2(5095, 1, "Option_0_can_only_be_used_when_module_is_set_to_es2015_or_later_5095", "Option '{0}' can only be used when 'module' is set to 'es2015' or later."), Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set: i2(5096, 1, "Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set_5096", "Option 'allowImportingTsExtensions' can only be used when either 'noEmit' or 'emitDeclarationOnly' is set."), An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled: i2(5097, 1, "An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled_5097", "An import path can only end with a '{0}' extension when 'allowImportingTsExtensions' is enabled."), Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler: i2(5098, 1, "Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler_5098", "Option '{0}' can only be used when 'moduleResolution' is set to 'node16', 'nodenext', or 'bundler'."), Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprecations_Colon_2_to_silence_this_error: i2(5101, 1, "Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprec_5101", `Option '{0}' is deprecated and will stop functioning in TypeScript {1}. Specify compilerOption '"ignoreDeprecations": "{2}"' to silence this error.`), Option_0_has_been_removed_Please_remove_it_from_your_configuration: i2(5102, 1, "Option_0_has_been_removed_Please_remove_it_from_your_configuration_5102", "Option '{0}' has been removed. Please remove it from your configuration."), Invalid_value_for_ignoreDeprecations: i2(5103, 1, "Invalid_value_for_ignoreDeprecations_5103", "Invalid value for '--ignoreDeprecations'."), Option_0_is_redundant_and_cannot_be_specified_with_option_1: i2(5104, 1, "Option_0_is_redundant_and_cannot_be_specified_with_option_1_5104", "Option '{0}' is redundant and cannot be specified with option '{1}'."), Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System: i2(5105, 1, "Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System_5105", "Option 'verbatimModuleSyntax' cannot be used when 'module' is set to 'UMD', 'AMD', or 'System'."), Use_0_instead: i2(5106, 3, "Use_0_instead_5106", "Use '{0}' instead."), Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDeprecations_Colon_3_to_silence_this_error: i2(5107, 1, "Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDepr_5107", `Option '{0}={1}' is deprecated and will stop functioning in TypeScript {2}. Specify compilerOption '"ignoreDeprecations": "{3}"' to silence this error.`), Option_0_1_has_been_removed_Please_remove_it_from_your_configuration: i2(5108, 1, "Option_0_1_has_been_removed_Please_remove_it_from_your_configuration_5108", "Option '{0}={1}' has been removed. Please remove it from your configuration."), Generates_a_sourcemap_for_each_corresponding_d_ts_file: i2(6e3, 3, "Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000", "Generates a sourcemap for each corresponding '.d.ts' file."), Concatenate_and_emit_output_to_single_file: i2(6001, 3, "Concatenate_and_emit_output_to_single_file_6001", "Concatenate and emit output to single file."), Generates_corresponding_d_ts_file: i2(6002, 3, "Generates_corresponding_d_ts_file_6002", "Generates corresponding '.d.ts' file."), Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: i2(6004, 3, "Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004", "Specify the location where debugger should locate TypeScript files instead of source locations."), Watch_input_files: i2(6005, 3, "Watch_input_files_6005", "Watch input files."), Redirect_output_structure_to_the_directory: i2(6006, 3, "Redirect_output_structure_to_the_directory_6006", "Redirect output structure to the directory."), Do_not_erase_const_enum_declarations_in_generated_code: i2(6007, 3, "Do_not_erase_const_enum_declarations_in_generated_code_6007", "Do not erase const enum declarations in generated code."), Do_not_emit_outputs_if_any_errors_were_reported: i2(6008, 3, "Do_not_emit_outputs_if_any_errors_were_reported_6008", "Do not emit outputs if any errors were reported."), Do_not_emit_comments_to_output: i2(6009, 3, "Do_not_emit_comments_to_output_6009", "Do not emit comments to output."), Do_not_emit_outputs: i2(6010, 3, "Do_not_emit_outputs_6010", "Do not emit outputs."), Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: i2(6011, 3, "Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011", "Allow default imports from modules with no default export. This does not affect code emit, just typechecking."), Skip_type_checking_of_declaration_files: i2(6012, 3, "Skip_type_checking_of_declaration_files_6012", "Skip type checking of declaration files."), Do_not_resolve_the_real_path_of_symlinks: i2(6013, 3, "Do_not_resolve_the_real_path_of_symlinks_6013", "Do not resolve the real path of symlinks."), Only_emit_d_ts_declaration_files: i2(6014, 3, "Only_emit_d_ts_declaration_files_6014", "Only emit '.d.ts' declaration files."), Specify_ECMAScript_target_version: i2(6015, 3, "Specify_ECMAScript_target_version_6015", "Specify ECMAScript target version."), Specify_module_code_generation: i2(6016, 3, "Specify_module_code_generation_6016", "Specify module code generation."), Print_this_message: i2(6017, 3, "Print_this_message_6017", "Print this message."), Print_the_compiler_s_version: i2(6019, 3, "Print_the_compiler_s_version_6019", "Print the compiler's version."), Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: i2(6020, 3, "Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020", "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."), Syntax_Colon_0: i2(6023, 3, "Syntax_Colon_0_6023", "Syntax: {0}"), options: i2(6024, 3, "options_6024", "options"), file: i2(6025, 3, "file_6025", "file"), Examples_Colon_0: i2(6026, 3, "Examples_Colon_0_6026", "Examples: {0}"), Options_Colon: i2(6027, 3, "Options_Colon_6027", "Options:"), Version_0: i2(6029, 3, "Version_0_6029", "Version {0}"), Insert_command_line_options_and_files_from_a_file: i2(6030, 3, "Insert_command_line_options_and_files_from_a_file_6030", "Insert command line options and files from a file."), Starting_compilation_in_watch_mode: i2(6031, 3, "Starting_compilation_in_watch_mode_6031", "Starting compilation in watch mode..."), File_change_detected_Starting_incremental_compilation: i2(6032, 3, "File_change_detected_Starting_incremental_compilation_6032", "File change detected. Starting incremental compilation..."), KIND: i2(6034, 3, "KIND_6034", "KIND"), FILE: i2(6035, 3, "FILE_6035", "FILE"), VERSION: i2(6036, 3, "VERSION_6036", "VERSION"), LOCATION: i2(6037, 3, "LOCATION_6037", "LOCATION"), DIRECTORY: i2(6038, 3, "DIRECTORY_6038", "DIRECTORY"), STRATEGY: i2(6039, 3, "STRATEGY_6039", "STRATEGY"), FILE_OR_DIRECTORY: i2(6040, 3, "FILE_OR_DIRECTORY_6040", "FILE OR DIRECTORY"), Errors_Files: i2(6041, 3, "Errors_Files_6041", "Errors  Files"), Generates_corresponding_map_file: i2(6043, 3, "Generates_corresponding_map_file_6043", "Generates corresponding '.map' file."), Compiler_option_0_expects_an_argument: i2(6044, 1, "Compiler_option_0_expects_an_argument_6044", "Compiler option '{0}' expects an argument."), Unterminated_quoted_string_in_response_file_0: i2(6045, 1, "Unterminated_quoted_string_in_response_file_0_6045", "Unterminated quoted string in response file '{0}'."), Argument_for_0_option_must_be_Colon_1: i2(6046, 1, "Argument_for_0_option_must_be_Colon_1_6046", "Argument for '{0}' option must be: {1}."), Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: i2(6048, 1, "Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048", "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'."), Unable_to_open_file_0: i2(6050, 1, "Unable_to_open_file_0_6050", "Unable to open file '{0}'."), Corrupted_locale_file_0: i2(6051, 1, "Corrupted_locale_file_0_6051", "Corrupted locale file {0}."), Raise_error_on_expressions_and_declarations_with_an_implied_any_type: i2(6052, 3, "Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052", "Raise error on expressions and declarations with an implied 'any' type."), File_0_not_found: i2(6053, 1, "File_0_not_found_6053", "File '{0}' not found."), File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1: i2(6054, 1, "File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054", "File '{0}' has an unsupported extension. The only supported extensions are {1}."), Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: i2(6055, 3, "Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055", "Suppress noImplicitAny errors for indexing objects lacking index signatures."), Do_not_emit_declarations_for_code_that_has_an_internal_annotation: i2(6056, 3, "Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056", "Do not emit declarations for code that has an '@internal' annotation."), Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: i2(6058, 3, "Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058", "Specify the root directory of input files. Use to control the output directory structure with --outDir."), File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: i2(6059, 1, "File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059", "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files."), Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: i2(6060, 3, "Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060", "Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix)."), NEWLINE: i2(6061, 3, "NEWLINE_6061", "NEWLINE"), Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line: i2(6064, 1, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line."), Enables_experimental_support_for_ES7_decorators: i2(6065, 3, "Enables_experimental_support_for_ES7_decorators_6065", "Enables experimental support for ES7 decorators."), Enables_experimental_support_for_emitting_type_metadata_for_decorators: i2(6066, 3, "Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066", "Enables experimental support for emitting type metadata for decorators."), Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: i2(6070, 3, "Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070", "Initializes a TypeScript project and creates a tsconfig.json file."), Successfully_created_a_tsconfig_json_file: i2(6071, 3, "Successfully_created_a_tsconfig_json_file_6071", "Successfully created a tsconfig.json file."), Suppress_excess_property_checks_for_object_literals: i2(6072, 3, "Suppress_excess_property_checks_for_object_literals_6072", "Suppress excess property checks for object literals."), Stylize_errors_and_messages_using_color_and_context_experimental: i2(6073, 3, "Stylize_errors_and_messages_using_color_and_context_experimental_6073", "Stylize errors and messages using color and context (experimental)."), Do_not_report_errors_on_unused_labels: i2(6074, 3, "Do_not_report_errors_on_unused_labels_6074", "Do not report errors on unused labels."), Report_error_when_not_all_code_paths_in_function_return_a_value: i2(6075, 3, "Report_error_when_not_all_code_paths_in_function_return_a_value_6075", "Report error when not all code paths in function return a value."), Report_errors_for_fallthrough_cases_in_switch_statement: i2(6076, 3, "Report_errors_for_fallthrough_cases_in_switch_statement_6076", "Report errors for fallthrough cases in switch statement."), Do_not_report_errors_on_unreachable_code: i2(6077, 3, "Do_not_report_errors_on_unreachable_code_6077", "Do not report errors on unreachable code."), Disallow_inconsistently_cased_references_to_the_same_file: i2(6078, 3, "Disallow_inconsistently_cased_references_to_the_same_file_6078", "Disallow inconsistently-cased references to the same file."), Specify_library_files_to_be_included_in_the_compilation: i2(6079, 3, "Specify_library_files_to_be_included_in_the_compilation_6079", "Specify library files to be included in the compilation."), Specify_JSX_code_generation: i2(6080, 3, "Specify_JSX_code_generation_6080", "Specify JSX code generation."), File_0_has_an_unsupported_extension_so_skipping_it: i2(6081, 3, "File_0_has_an_unsupported_extension_so_skipping_it_6081", "File '{0}' has an unsupported extension, so skipping it."), Only_amd_and_system_modules_are_supported_alongside_0: i2(6082, 1, "Only_amd_and_system_modules_are_supported_alongside_0_6082", "Only 'amd' and 'system' modules are supported alongside --{0}."), Base_directory_to_resolve_non_absolute_module_names: i2(6083, 3, "Base_directory_to_resolve_non_absolute_module_names_6083", "Base directory to resolve non-absolute module names."), Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: i2(6084, 3, "Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084", "[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit"), Enable_tracing_of_the_name_resolution_process: i2(6085, 3, "Enable_tracing_of_the_name_resolution_process_6085", "Enable tracing of the name resolution process."), Resolving_module_0_from_1: i2(6086, 3, "Resolving_module_0_from_1_6086", "======== Resolving module '{0}' from '{1}'. ========"), Explicitly_specified_module_resolution_kind_Colon_0: i2(6087, 3, "Explicitly_specified_module_resolution_kind_Colon_0_6087", "Explicitly specified module resolution kind: '{0}'."), Module_resolution_kind_is_not_specified_using_0: i2(6088, 3, "Module_resolution_kind_is_not_specified_using_0_6088", "Module resolution kind is not specified, using '{0}'."), Module_name_0_was_successfully_resolved_to_1: i2(6089, 3, "Module_name_0_was_successfully_resolved_to_1_6089", "======== Module name '{0}' was successfully resolved to '{1}'. ========"), Module_name_0_was_not_resolved: i2(6090, 3, "Module_name_0_was_not_resolved_6090", "======== Module name '{0}' was not resolved. ========"), paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: i2(6091, 3, "paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091", "'paths' option is specified, looking for a pattern to match module name '{0}'."), Module_name_0_matched_pattern_1: i2(6092, 3, "Module_name_0_matched_pattern_1_6092", "Module name '{0}', matched pattern '{1}'."), Trying_substitution_0_candidate_module_location_Colon_1: i2(6093, 3, "Trying_substitution_0_candidate_module_location_Colon_1_6093", "Trying substitution '{0}', candidate module location: '{1}'."), Resolving_module_name_0_relative_to_base_url_1_2: i2(6094, 3, "Resolving_module_name_0_relative_to_base_url_1_2_6094", "Resolving module name '{0}' relative to base url '{1}' - '{2}'."), Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_types_Colon_1: i2(6095, 3, "Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_types_Colon_1_6095", "Loading module as file / folder, candidate module location '{0}', target file types: {1}."), File_0_does_not_exist: i2(6096, 3, "File_0_does_not_exist_6096", "File '{0}' does not exist."), File_0_exists_use_it_as_a_name_resolution_result: i2(6097, 3, "File_0_exists_use_it_as_a_name_resolution_result_6097", "File '{0}' exists - use it as a name resolution result."), Loading_module_0_from_node_modules_folder_target_file_types_Colon_1: i2(6098, 3, "Loading_module_0_from_node_modules_folder_target_file_types_Colon_1_6098", "Loading module '{0}' from 'node_modules' folder, target file types: {1}."), Found_package_json_at_0: i2(6099, 3, "Found_package_json_at_0_6099", "Found 'package.json' at '{0}'."), package_json_does_not_have_a_0_field: i2(6100, 3, "package_json_does_not_have_a_0_field_6100", "'package.json' does not have a '{0}' field."), package_json_has_0_field_1_that_references_2: i2(6101, 3, "package_json_has_0_field_1_that_references_2_6101", "'package.json' has '{0}' field '{1}' that references '{2}'."), Allow_javascript_files_to_be_compiled: i2(6102, 3, "Allow_javascript_files_to_be_compiled_6102", "Allow javascript files to be compiled."), Checking_if_0_is_the_longest_matching_prefix_for_1_2: i2(6104, 3, "Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104", "Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'."), Expected_type_of_0_field_in_package_json_to_be_1_got_2: i2(6105, 3, "Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105", "Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'."), baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: i2(6106, 3, "baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106", "'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'."), rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: i2(6107, 3, "rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107", "'rootDirs' option is set, using it to resolve relative module name '{0}'."), Longest_matching_prefix_for_0_is_1: i2(6108, 3, "Longest_matching_prefix_for_0_is_1_6108", "Longest matching prefix for '{0}' is '{1}'."), Loading_0_from_the_root_dir_1_candidate_location_2: i2(6109, 3, "Loading_0_from_the_root_dir_1_candidate_location_2_6109", "Loading '{0}' from the root dir '{1}', candidate location '{2}'."), Trying_other_entries_in_rootDirs: i2(6110, 3, "Trying_other_entries_in_rootDirs_6110", "Trying other entries in 'rootDirs'."), Module_resolution_using_rootDirs_has_failed: i2(6111, 3, "Module_resolution_using_rootDirs_has_failed_6111", "Module resolution using 'rootDirs' has failed."), Do_not_emit_use_strict_directives_in_module_output: i2(6112, 3, "Do_not_emit_use_strict_directives_in_module_output_6112", "Do not emit 'use strict' directives in module output."), Enable_strict_null_checks: i2(6113, 3, "Enable_strict_null_checks_6113", "Enable strict null checks."), Unknown_option_excludes_Did_you_mean_exclude: i2(6114, 1, "Unknown_option_excludes_Did_you_mean_exclude_6114", "Unknown option 'excludes'. Did you mean 'exclude'?"), Raise_error_on_this_expressions_with_an_implied_any_type: i2(6115, 3, "Raise_error_on_this_expressions_with_an_implied_any_type_6115", "Raise error on 'this' expressions with an implied 'any' type."), Resolving_type_reference_directive_0_containing_file_1_root_directory_2: i2(6116, 3, "Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116", "======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========"), Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: i2(6119, 3, "Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119", "======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========"), Type_reference_directive_0_was_not_resolved: i2(6120, 3, "Type_reference_directive_0_was_not_resolved_6120", "======== Type reference directive '{0}' was not resolved. ========"), Resolving_with_primary_search_path_0: i2(6121, 3, "Resolving_with_primary_search_path_0_6121", "Resolving with primary search path '{0}'."), Root_directory_cannot_be_determined_skipping_primary_search_paths: i2(6122, 3, "Root_directory_cannot_be_determined_skipping_primary_search_paths_6122", "Root directory cannot be determined, skipping primary search paths."), Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: i2(6123, 3, "Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123", "======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========"), Type_declaration_files_to_be_included_in_compilation: i2(6124, 3, "Type_declaration_files_to_be_included_in_compilation_6124", "Type declaration files to be included in compilation."), Looking_up_in_node_modules_folder_initial_location_0: i2(6125, 3, "Looking_up_in_node_modules_folder_initial_location_0_6125", "Looking up in 'node_modules' folder, initial location '{0}'."), Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: i2(6126, 3, "Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126", "Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder."), Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: i2(6127, 3, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127", "======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========"), Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: i2(6128, 3, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128", "======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========"), Resolving_real_path_for_0_result_1: i2(6130, 3, "Resolving_real_path_for_0_result_1_6130", "Resolving real path for '{0}', result '{1}'."), Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: i2(6131, 1, "Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131", "Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'."), File_name_0_has_a_1_extension_stripping_it: i2(6132, 3, "File_name_0_has_a_1_extension_stripping_it_6132", "File name '{0}' has a '{1}' extension - stripping it."), _0_is_declared_but_its_value_is_never_read: i2(6133, 1, "_0_is_declared_but_its_value_is_never_read_6133", "'{0}' is declared but its value is never read.", true), Report_errors_on_unused_locals: i2(6134, 3, "Report_errors_on_unused_locals_6134", "Report errors on unused locals."), Report_errors_on_unused_parameters: i2(6135, 3, "Report_errors_on_unused_parameters_6135", "Report errors on unused parameters."), The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: i2(6136, 3, "The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136", "The maximum dependency depth to search under node_modules and load JavaScript files."), Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: i2(6137, 1, "Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137", "Cannot import type declaration files. Consider importing '{0}' instead of '{1}'."), Property_0_is_declared_but_its_value_is_never_read: i2(6138, 1, "Property_0_is_declared_but_its_value_is_never_read_6138", "Property '{0}' is declared but its value is never read.", true), Import_emit_helpers_from_tslib: i2(6139, 3, "Import_emit_helpers_from_tslib_6139", "Import emit helpers from 'tslib'."), Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: i2(6140, 1, "Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140", "Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'."), Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: i2(6141, 3, "Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141", 'Parse in strict mode and emit "use strict" for each source file.'), Module_0_was_resolved_to_1_but_jsx_is_not_set: i2(6142, 1, "Module_0_was_resolved_to_1_but_jsx_is_not_set_6142", "Module '{0}' was resolved to '{1}', but '--jsx' is not set."), Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: i2(6144, 3, "Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144", "Module '{0}' was resolved as locally declared ambient module in file '{1}'."), Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: i2(6145, 3, "Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145", "Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified."), Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: i2(6146, 3, "Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146", "Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'."), Resolution_for_module_0_was_found_in_cache_from_location_1: i2(6147, 3, "Resolution_for_module_0_was_found_in_cache_from_location_1_6147", "Resolution for module '{0}' was found in cache from location '{1}'."), Directory_0_does_not_exist_skipping_all_lookups_in_it: i2(6148, 3, "Directory_0_does_not_exist_skipping_all_lookups_in_it_6148", "Directory '{0}' does not exist, skipping all lookups in it."), Show_diagnostic_information: i2(6149, 3, "Show_diagnostic_information_6149", "Show diagnostic information."), Show_verbose_diagnostic_information: i2(6150, 3, "Show_verbose_diagnostic_information_6150", "Show verbose diagnostic information."), Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: i2(6151, 3, "Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151", "Emit a single file with source maps instead of having a separate file."), Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: i2(6152, 3, "Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152", "Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set."), Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: i2(6153, 3, "Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153", "Transpile each file as a separate module (similar to 'ts.transpileModule')."), Print_names_of_generated_files_part_of_the_compilation: i2(6154, 3, "Print_names_of_generated_files_part_of_the_compilation_6154", "Print names of generated files part of the compilation."), Print_names_of_files_part_of_the_compilation: i2(6155, 3, "Print_names_of_files_part_of_the_compilation_6155", "Print names of files part of the compilation."), The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: i2(6156, 3, "The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156", "The locale used when displaying messages to the user (e.g. 'en-us')"), Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: i2(6157, 3, "Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157", "Do not generate custom helper functions like '__extends' in compiled output."), Do_not_include_the_default_library_file_lib_d_ts: i2(6158, 3, "Do_not_include_the_default_library_file_lib_d_ts_6158", "Do not include the default library file (lib.d.ts)."), Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: i2(6159, 3, "Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159", "Do not add triple-slash references or imported modules to the list of compiled files."), Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: i2(6160, 3, "Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160", "[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files."), List_of_folders_to_include_type_definitions_from: i2(6161, 3, "List_of_folders_to_include_type_definitions_from_6161", "List of folders to include type definitions from."), Disable_size_limitations_on_JavaScript_projects: i2(6162, 3, "Disable_size_limitations_on_JavaScript_projects_6162", "Disable size limitations on JavaScript projects."), The_character_set_of_the_input_files: i2(6163, 3, "The_character_set_of_the_input_files_6163", "The character set of the input files."), Do_not_truncate_error_messages: i2(6165, 3, "Do_not_truncate_error_messages_6165", "Do not truncate error messages."), Output_directory_for_generated_declaration_files: i2(6166, 3, "Output_directory_for_generated_declaration_files_6166", "Output directory for generated declaration files."), A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: i2(6167, 3, "A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167", "A series of entries which re-map imports to lookup locations relative to the 'baseUrl'."), List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: i2(6168, 3, "List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168", "List of root folders whose combined content represents the structure of the project at runtime."), Show_all_compiler_options: i2(6169, 3, "Show_all_compiler_options_6169", "Show all compiler options."), Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: i2(6170, 3, "Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170", "[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file"), Command_line_Options: i2(6171, 3, "Command_line_Options_6171", "Command-line Options"), Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: i2(6179, 3, "Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179", "Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'."), Enable_all_strict_type_checking_options: i2(6180, 3, "Enable_all_strict_type_checking_options_6180", "Enable all strict type-checking options."), Scoped_package_detected_looking_in_0: i2(6182, 3, "Scoped_package_detected_looking_in_0_6182", "Scoped package detected, looking in '{0}'"), Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2: i2(6183, 3, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_6183", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."), Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: i2(6184, 3, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package__6184", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."), Enable_strict_checking_of_function_types: i2(6186, 3, "Enable_strict_checking_of_function_types_6186", "Enable strict checking of function types."), Enable_strict_checking_of_property_initialization_in_classes: i2(6187, 3, "Enable_strict_checking_of_property_initialization_in_classes_6187", "Enable strict checking of property initialization in classes."), Numeric_separators_are_not_allowed_here: i2(6188, 1, "Numeric_separators_are_not_allowed_here_6188", "Numeric separators are not allowed here."), Multiple_consecutive_numeric_separators_are_not_permitted: i2(6189, 1, "Multiple_consecutive_numeric_separators_are_not_permitted_6189", "Multiple consecutive numeric separators are not permitted."), Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: i2(6191, 3, "Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191", "Whether to keep outdated console output in watch mode instead of clearing the screen."), All_imports_in_import_declaration_are_unused: i2(6192, 1, "All_imports_in_import_declaration_are_unused_6192", "All imports in import declaration are unused.", true), Found_1_error_Watching_for_file_changes: i2(6193, 3, "Found_1_error_Watching_for_file_changes_6193", "Found 1 error. Watching for file changes."), Found_0_errors_Watching_for_file_changes: i2(6194, 3, "Found_0_errors_Watching_for_file_changes_6194", "Found {0} errors. Watching for file changes."), Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: i2(6195, 3, "Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195", "Resolve 'keyof' to string valued property names only (no numbers or symbols)."), _0_is_declared_but_never_used: i2(6196, 1, "_0_is_declared_but_never_used_6196", "'{0}' is declared but never used.", true), Include_modules_imported_with_json_extension: i2(6197, 3, "Include_modules_imported_with_json_extension_6197", "Include modules imported with '.json' extension"), All_destructured_elements_are_unused: i2(6198, 1, "All_destructured_elements_are_unused_6198", "All destructured elements are unused.", true), All_variables_are_unused: i2(6199, 1, "All_variables_are_unused_6199", "All variables are unused.", true), Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0: i2(6200, 1, "Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0_6200", "Definitions of the following identifiers conflict with those in another file: {0}"), Conflicts_are_in_this_file: i2(6201, 3, "Conflicts_are_in_this_file_6201", "Conflicts are in this file."), Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0: i2(6202, 1, "Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0_6202", "Project references may not form a circular graph. Cycle detected: {0}"), _0_was_also_declared_here: i2(6203, 3, "_0_was_also_declared_here_6203", "'{0}' was also declared here."), and_here: i2(6204, 3, "and_here_6204", "and here."), All_type_parameters_are_unused: i2(6205, 1, "All_type_parameters_are_unused_6205", "All type parameters are unused."), package_json_has_a_typesVersions_field_with_version_specific_path_mappings: i2(6206, 3, "package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206", "'package.json' has a 'typesVersions' field with version-specific path mappings."), package_json_does_not_have_a_typesVersions_entry_that_matches_version_0: i2(6207, 3, "package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207", "'package.json' does not have a 'typesVersions' entry that matches version '{0}'."), package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2: i2(6208, 3, "package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208", "'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'."), package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range: i2(6209, 3, "package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209", "'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range."), An_argument_for_0_was_not_provided: i2(6210, 3, "An_argument_for_0_was_not_provided_6210", "An argument for '{0}' was not provided."), An_argument_matching_this_binding_pattern_was_not_provided: i2(6211, 3, "An_argument_matching_this_binding_pattern_was_not_provided_6211", "An argument matching this binding pattern was not provided."), Did_you_mean_to_call_this_expression: i2(6212, 3, "Did_you_mean_to_call_this_expression_6212", "Did you mean to call this expression?"), Did_you_mean_to_use_new_with_this_expression: i2(6213, 3, "Did_you_mean_to_use_new_with_this_expression_6213", "Did you mean to use 'new' with this expression?"), Enable_strict_bind_call_and_apply_methods_on_functions: i2(6214, 3, "Enable_strict_bind_call_and_apply_methods_on_functions_6214", "Enable strict 'bind', 'call', and 'apply' methods on functions."), Using_compiler_options_of_project_reference_redirect_0: i2(6215, 3, "Using_compiler_options_of_project_reference_redirect_0_6215", "Using compiler options of project reference redirect '{0}'."), Found_1_error: i2(6216, 3, "Found_1_error_6216", "Found 1 error."), Found_0_errors: i2(6217, 3, "Found_0_errors_6217", "Found {0} errors."), Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2: i2(6218, 3, "Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218", "======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========"), Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3: i2(6219, 3, "Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219", "======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========"), package_json_had_a_falsy_0_field: i2(6220, 3, "package_json_had_a_falsy_0_field_6220", "'package.json' had a falsy '{0}' field."), Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects: i2(6221, 3, "Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221", "Disable use of source files instead of declaration files from referenced projects."), Emit_class_fields_with_Define_instead_of_Set: i2(6222, 3, "Emit_class_fields_with_Define_instead_of_Set_6222", "Emit class fields with Define instead of Set."), Generates_a_CPU_profile: i2(6223, 3, "Generates_a_CPU_profile_6223", "Generates a CPU profile."), Disable_solution_searching_for_this_project: i2(6224, 3, "Disable_solution_searching_for_this_project_6224", "Disable solution searching for this project."), Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory: i2(6225, 3, "Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225", "Specify strategy for watching file: 'FixedPollingInterval' (default), 'PriorityPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'."), Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling: i2(6226, 3, "Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226", "Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default), 'FixedPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling'."), Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize: i2(6227, 3, "Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_6227", "Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default), 'PriorityInterval', 'DynamicPriority', 'FixedChunkSize'."), Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3: i2(6229, 1, "Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229", "Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'."), Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line: i2(6230, 1, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line."), Could_not_resolve_the_path_0_with_the_extensions_Colon_1: i2(6231, 1, "Could_not_resolve_the_path_0_with_the_extensions_Colon_1_6231", "Could not resolve the path '{0}' with the extensions: {1}."), Declaration_augments_declaration_in_another_file_This_cannot_be_serialized: i2(6232, 1, "Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232", "Declaration augments declaration in another file. This cannot be serialized."), This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file: i2(6233, 1, "This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233", "This is the declaration being augmented. Consider moving the augmenting declaration into the same file."), This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without: i2(6234, 1, "This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234", "This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?"), Disable_loading_referenced_projects: i2(6235, 3, "Disable_loading_referenced_projects_6235", "Disable loading referenced projects."), Arguments_for_the_rest_parameter_0_were_not_provided: i2(6236, 1, "Arguments_for_the_rest_parameter_0_were_not_provided_6236", "Arguments for the rest parameter '{0}' were not provided."), Generates_an_event_trace_and_a_list_of_types: i2(6237, 3, "Generates_an_event_trace_and_a_list_of_types_6237", "Generates an event trace and a list of types."), Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react: i2(6238, 1, "Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238", "Specify the module specifier to be used to import the 'jsx' and 'jsxs' factory functions from. eg, react"), File_0_exists_according_to_earlier_cached_lookups: i2(6239, 3, "File_0_exists_according_to_earlier_cached_lookups_6239", "File '{0}' exists according to earlier cached lookups."), File_0_does_not_exist_according_to_earlier_cached_lookups: i2(6240, 3, "File_0_does_not_exist_according_to_earlier_cached_lookups_6240", "File '{0}' does not exist according to earlier cached lookups."), Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1: i2(6241, 3, "Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1_6241", "Resolution for type reference directive '{0}' was found in cache from location '{1}'."), Resolving_type_reference_directive_0_containing_file_1: i2(6242, 3, "Resolving_type_reference_directive_0_containing_file_1_6242", "======== Resolving type reference directive '{0}', containing file '{1}'. ========"), Interpret_optional_property_types_as_written_rather_than_adding_undefined: i2(6243, 3, "Interpret_optional_property_types_as_written_rather_than_adding_undefined_6243", "Interpret optional property types as written, rather than adding 'undefined'."), Modules: i2(6244, 3, "Modules_6244", "Modules"), File_Management: i2(6245, 3, "File_Management_6245", "File Management"), Emit: i2(6246, 3, "Emit_6246", "Emit"), JavaScript_Support: i2(6247, 3, "JavaScript_Support_6247", "JavaScript Support"), Type_Checking: i2(6248, 3, "Type_Checking_6248", "Type Checking"), Editor_Support: i2(6249, 3, "Editor_Support_6249", "Editor Support"), Watch_and_Build_Modes: i2(6250, 3, "Watch_and_Build_Modes_6250", "Watch and Build Modes"), Compiler_Diagnostics: i2(6251, 3, "Compiler_Diagnostics_6251", "Compiler Diagnostics"), Interop_Constraints: i2(6252, 3, "Interop_Constraints_6252", "Interop Constraints"), Backwards_Compatibility: i2(6253, 3, "Backwards_Compatibility_6253", "Backwards Compatibility"), Language_and_Environment: i2(6254, 3, "Language_and_Environment_6254", "Language and Environment"), Projects: i2(6255, 3, "Projects_6255", "Projects"), Output_Formatting: i2(6256, 3, "Output_Formatting_6256", "Output Formatting"), Completeness: i2(6257, 3, "Completeness_6257", "Completeness"), _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file: i2(6258, 1, "_0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file_6258", "'{0}' should be set inside the 'compilerOptions' object of the config json file"), Found_1_error_in_1: i2(6259, 3, "Found_1_error_in_1_6259", "Found 1 error in {1}"), Found_0_errors_in_the_same_file_starting_at_Colon_1: i2(6260, 3, "Found_0_errors_in_the_same_file_starting_at_Colon_1_6260", "Found {0} errors in the same file, starting at: {1}"), Found_0_errors_in_1_files: i2(6261, 3, "Found_0_errors_in_1_files_6261", "Found {0} errors in {1} files."), File_name_0_has_a_1_extension_looking_up_2_instead: i2(6262, 3, "File_name_0_has_a_1_extension_looking_up_2_instead_6262", "File name '{0}' has a '{1}' extension - looking up '{2}' instead."), Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set: i2(6263, 1, "Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set_6263", "Module '{0}' was resolved to '{1}', but '--allowArbitraryExtensions' is not set."), Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present: i2(6264, 3, "Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present_6264", "Enable importing files with any extension, provided a declaration file is present."), Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve: i2(6270, 3, "Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve_6270", "Directory '{0}' has no containing package.json scope. Imports will not resolve."), Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1: i2(6271, 3, "Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6271", "Import specifier '{0}' does not exist in package.json scope at path '{1}'."), Invalid_import_specifier_0_has_no_possible_resolutions: i2(6272, 3, "Invalid_import_specifier_0_has_no_possible_resolutions_6272", "Invalid import specifier '{0}' has no possible resolutions."), package_json_scope_0_has_no_imports_defined: i2(6273, 3, "package_json_scope_0_has_no_imports_defined_6273", "package.json scope '{0}' has no imports defined."), package_json_scope_0_explicitly_maps_specifier_1_to_null: i2(6274, 3, "package_json_scope_0_explicitly_maps_specifier_1_to_null_6274", "package.json scope '{0}' explicitly maps specifier '{1}' to null."), package_json_scope_0_has_invalid_type_for_target_of_specifier_1: i2(6275, 3, "package_json_scope_0_has_invalid_type_for_target_of_specifier_1_6275", "package.json scope '{0}' has invalid type for target of specifier '{1}'"), Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1: i2(6276, 3, "Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6276", "Export specifier '{0}' does not exist in package.json scope at path '{1}'."), Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_if_npm_library_needs_configuration_update: i2(6277, 3, "Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_i_6277", "Resolution of non-relative name failed; trying with modern Node resolution features disabled to see if npm library needs configuration update."), There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The_1_library_may_need_to_update_its_package_json_or_typings: i2(6278, 3, "There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The__6278", `There are types at '{0}', but this result could not be resolved when respecting package.json "exports". The '{1}' library may need to update its package.json or typings.`), Enable_project_compilation: i2(6302, 3, "Enable_project_compilation_6302", "Enable project compilation"), Composite_projects_may_not_disable_declaration_emit: i2(6304, 1, "Composite_projects_may_not_disable_declaration_emit_6304", "Composite projects may not disable declaration emit."), Output_file_0_has_not_been_built_from_source_file_1: i2(6305, 1, "Output_file_0_has_not_been_built_from_source_file_1_6305", "Output file '{0}' has not been built from source file '{1}'."), Referenced_project_0_must_have_setting_composite_Colon_true: i2(6306, 1, "Referenced_project_0_must_have_setting_composite_Colon_true_6306", `Referenced project '{0}' must have setting "composite": true.`), File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern: i2(6307, 1, "File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307", "File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern."), Cannot_prepend_project_0_because_it_does_not_have_outFile_set: i2(6308, 1, "Cannot_prepend_project_0_because_it_does_not_have_outFile_set_6308", "Cannot prepend project '{0}' because it does not have 'outFile' set"), Output_file_0_from_project_1_does_not_exist: i2(6309, 1, "Output_file_0_from_project_1_does_not_exist_6309", "Output file '{0}' from project '{1}' does not exist"), Referenced_project_0_may_not_disable_emit: i2(6310, 1, "Referenced_project_0_may_not_disable_emit_6310", "Referenced project '{0}' may not disable emit."), Project_0_is_out_of_date_because_output_1_is_older_than_input_2: i2(6350, 3, "Project_0_is_out_of_date_because_output_1_is_older_than_input_2_6350", "Project '{0}' is out of date because output '{1}' is older than input '{2}'"), Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2: i2(6351, 3, "Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2_6351", "Project '{0}' is up to date because newest input '{1}' is older than output '{2}'"), Project_0_is_out_of_date_because_output_file_1_does_not_exist: i2(6352, 3, "Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352", "Project '{0}' is out of date because output file '{1}' does not exist"), Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date: i2(6353, 3, "Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353", "Project '{0}' is out of date because its dependency '{1}' is out of date"), Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies: i2(6354, 3, "Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354", "Project '{0}' is up to date with .d.ts files from its dependencies"), Projects_in_this_build_Colon_0: i2(6355, 3, "Projects_in_this_build_Colon_0_6355", "Projects in this build: {0}"), A_non_dry_build_would_delete_the_following_files_Colon_0: i2(6356, 3, "A_non_dry_build_would_delete_the_following_files_Colon_0_6356", "A non-dry build would delete the following files: {0}"), A_non_dry_build_would_build_project_0: i2(6357, 3, "A_non_dry_build_would_build_project_0_6357", "A non-dry build would build project '{0}'"), Building_project_0: i2(6358, 3, "Building_project_0_6358", "Building project '{0}'..."), Updating_output_timestamps_of_project_0: i2(6359, 3, "Updating_output_timestamps_of_project_0_6359", "Updating output timestamps of project '{0}'..."), Project_0_is_up_to_date: i2(6361, 3, "Project_0_is_up_to_date_6361", "Project '{0}' is up to date"), Skipping_build_of_project_0_because_its_dependency_1_has_errors: i2(6362, 3, "Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362", "Skipping build of project '{0}' because its dependency '{1}' has errors"), Project_0_can_t_be_built_because_its_dependency_1_has_errors: i2(6363, 3, "Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363", "Project '{0}' can't be built because its dependency '{1}' has errors"), Build_one_or_more_projects_and_their_dependencies_if_out_of_date: i2(6364, 3, "Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364", "Build one or more projects and their dependencies, if out of date"), Delete_the_outputs_of_all_projects: i2(6365, 3, "Delete_the_outputs_of_all_projects_6365", "Delete the outputs of all projects."), Show_what_would_be_built_or_deleted_if_specified_with_clean: i2(6367, 3, "Show_what_would_be_built_or_deleted_if_specified_with_clean_6367", "Show what would be built (or deleted, if specified with '--clean')"), Option_build_must_be_the_first_command_line_argument: i2(6369, 1, "Option_build_must_be_the_first_command_line_argument_6369", "Option '--build' must be the first command line argument."), Options_0_and_1_cannot_be_combined: i2(6370, 1, "Options_0_and_1_cannot_be_combined_6370", "Options '{0}' and '{1}' cannot be combined."), Updating_unchanged_output_timestamps_of_project_0: i2(6371, 3, "Updating_unchanged_output_timestamps_of_project_0_6371", "Updating unchanged output timestamps of project '{0}'..."), Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed: i2(6372, 3, "Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed_6372", "Project '{0}' is out of date because output of its dependency '{1}' has changed"), Updating_output_of_project_0: i2(6373, 3, "Updating_output_of_project_0_6373", "Updating output of project '{0}'..."), A_non_dry_build_would_update_timestamps_for_output_of_project_0: i2(6374, 3, "A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374", "A non-dry build would update timestamps for output of project '{0}'"), A_non_dry_build_would_update_output_of_project_0: i2(6375, 3, "A_non_dry_build_would_update_output_of_project_0_6375", "A non-dry build would update output of project '{0}'"), Cannot_update_output_of_project_0_because_there_was_error_reading_file_1: i2(6376, 3, "Cannot_update_output_of_project_0_because_there_was_error_reading_file_1_6376", "Cannot update output of project '{0}' because there was error reading file '{1}'"), Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1: i2(6377, 1, "Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377", "Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'"), Composite_projects_may_not_disable_incremental_compilation: i2(6379, 1, "Composite_projects_may_not_disable_incremental_compilation_6379", "Composite projects may not disable incremental compilation."), Specify_file_to_store_incremental_compilation_information: i2(6380, 3, "Specify_file_to_store_incremental_compilation_information_6380", "Specify file to store incremental compilation information"), Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2: i2(6381, 3, "Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381", "Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'"), Skipping_build_of_project_0_because_its_dependency_1_was_not_built: i2(6382, 3, "Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382", "Skipping build of project '{0}' because its dependency '{1}' was not built"), Project_0_can_t_be_built_because_its_dependency_1_was_not_built: i2(6383, 3, "Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383", "Project '{0}' can't be built because its dependency '{1}' was not built"), Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: i2(6384, 3, "Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384", "Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it."), _0_is_deprecated: i2(6385, 2, "_0_is_deprecated_6385", "'{0}' is deprecated.", void 0, void 0, true), Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found: i2(6386, 3, "Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386", "Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found."), The_signature_0_of_1_is_deprecated: i2(6387, 2, "The_signature_0_of_1_is_deprecated_6387", "The signature '{0}' of '{1}' is deprecated.", void 0, void 0, true), Project_0_is_being_forcibly_rebuilt: i2(6388, 3, "Project_0_is_being_forcibly_rebuilt_6388", "Project '{0}' is being forcibly rebuilt"), Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved: i2(6389, 3, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved_6389", "Reusing resolution of module '{0}' from '{1}' of old program, it was not resolved."), Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2: i2(6390, 3, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6390", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."), Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: i2(6391, 3, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6391", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."), Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved: i2(6392, 3, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved_6392", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was not resolved."), Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: i2(6393, 3, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6393", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."), Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: i2(6394, 3, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6394", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."), Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: i2(6395, 3, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved_6395", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was not resolved."), Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: i2(6396, 3, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6396", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."), Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: i2(6397, 3, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6397", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."), Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: i2(6398, 3, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_re_6398", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was not resolved."), Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted: i2(6399, 3, "Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitte_6399", "Project '{0}' is out of date because buildinfo file '{1}' indicates that some of the changes were not emitted"), Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files: i2(6400, 3, "Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_fil_6400", "Project '{0}' is up to date but needs to update timestamps of output files that are older than input files"), Project_0_is_out_of_date_because_there_was_error_reading_file_1: i2(6401, 3, "Project_0_is_out_of_date_because_there_was_error_reading_file_1_6401", "Project '{0}' is out of date because there was error reading file '{1}'"), Resolving_in_0_mode_with_conditions_1: i2(6402, 3, "Resolving_in_0_mode_with_conditions_1_6402", "Resolving in {0} mode with conditions {1}."), Matched_0_condition_1: i2(6403, 3, "Matched_0_condition_1_6403", "Matched '{0}' condition '{1}'."), Using_0_subpath_1_with_target_2: i2(6404, 3, "Using_0_subpath_1_with_target_2_6404", "Using '{0}' subpath '{1}' with target '{2}'."), Saw_non_matching_condition_0: i2(6405, 3, "Saw_non_matching_condition_0_6405", "Saw non-matching condition '{0}'."), Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions: i2(6406, 3, "Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions_6406", "Project '{0}' is out of date because buildinfo file '{1}' indicates there is change in compilerOptions"), Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noEmit_or_emitDeclarationOnly_to_be_set: i2(6407, 3, "Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noE_6407", "Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set."), Use_the_package_json_exports_field_when_resolving_package_imports: i2(6408, 3, "Use_the_package_json_exports_field_when_resolving_package_imports_6408", "Use the package.json 'exports' field when resolving package imports."), Use_the_package_json_imports_field_when_resolving_imports: i2(6409, 3, "Use_the_package_json_imports_field_when_resolving_imports_6409", "Use the package.json 'imports' field when resolving imports."), Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports: i2(6410, 3, "Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports_6410", "Conditions to set in addition to the resolver-specific defaults when resolving imports."), true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false: i2(6411, 3, "true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false_6411", "`true` when 'moduleResolution' is 'node16', 'nodenext', or 'bundler'; otherwise `false`."), Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_but_not_any_more: i2(6412, 3, "Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_6412", "Project '{0}' is out of date because buildinfo file '{1}' indicates that file '{2}' was root file of compilation but not any more."), Entering_conditional_exports: i2(6413, 3, "Entering_conditional_exports_6413", "Entering conditional exports."), Resolved_under_condition_0: i2(6414, 3, "Resolved_under_condition_0_6414", "Resolved under condition '{0}'."), Failed_to_resolve_under_condition_0: i2(6415, 3, "Failed_to_resolve_under_condition_0_6415", "Failed to resolve under condition '{0}'."), Exiting_conditional_exports: i2(6416, 3, "Exiting_conditional_exports_6416", "Exiting conditional exports."), The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1: i2(6500, 3, "The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500", "The expected type comes from property '{0}' which is declared here on type '{1}'"), The_expected_type_comes_from_this_index_signature: i2(6501, 3, "The_expected_type_comes_from_this_index_signature_6501", "The expected type comes from this index signature."), The_expected_type_comes_from_the_return_type_of_this_signature: i2(6502, 3, "The_expected_type_comes_from_the_return_type_of_this_signature_6502", "The expected type comes from the return type of this signature."), Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing: i2(6503, 3, "Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503", "Print names of files that are part of the compilation and then stop processing."), File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option: i2(6504, 1, "File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504", "File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?"), Print_names_of_files_and_the_reason_they_are_part_of_the_compilation: i2(6505, 3, "Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505", "Print names of files and the reason they are part of the compilation."), Consider_adding_a_declare_modifier_to_this_class: i2(6506, 3, "Consider_adding_a_declare_modifier_to_this_class_6506", "Consider adding a 'declare' modifier to this class."), Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files: i2(6600, 3, "Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these__6600", "Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files."), Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export: i2(6601, 3, "Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export_6601", "Allow 'import x from y' when a module doesn't have a default export."), Allow_accessing_UMD_globals_from_modules: i2(6602, 3, "Allow_accessing_UMD_globals_from_modules_6602", "Allow accessing UMD globals from modules."), Disable_error_reporting_for_unreachable_code: i2(6603, 3, "Disable_error_reporting_for_unreachable_code_6603", "Disable error reporting for unreachable code."), Disable_error_reporting_for_unused_labels: i2(6604, 3, "Disable_error_reporting_for_unused_labels_6604", "Disable error reporting for unused labels."), Ensure_use_strict_is_always_emitted: i2(6605, 3, "Ensure_use_strict_is_always_emitted_6605", "Ensure 'use strict' is always emitted."), Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: i2(6606, 3, "Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_wi_6606", "Have recompiles in projects that use 'incremental' and 'watch' mode assume that changes within a file will only affect files directly depending on it."), Specify_the_base_directory_to_resolve_non_relative_module_names: i2(6607, 3, "Specify_the_base_directory_to_resolve_non_relative_module_names_6607", "Specify the base directory to resolve non-relative module names."), No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files: i2(6608, 3, "No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files_6608", "No longer supported. In early versions, manually set the text encoding for reading files."), Enable_error_reporting_in_type_checked_JavaScript_files: i2(6609, 3, "Enable_error_reporting_in_type_checked_JavaScript_files_6609", "Enable error reporting in type-checked JavaScript files."), Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references: i2(6611, 3, "Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references_6611", "Enable constraints that allow a TypeScript project to be used with project references."), Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project: i2(6612, 3, "Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project_6612", "Generate .d.ts files from TypeScript and JavaScript files in your project."), Specify_the_output_directory_for_generated_declaration_files: i2(6613, 3, "Specify_the_output_directory_for_generated_declaration_files_6613", "Specify the output directory for generated declaration files."), Create_sourcemaps_for_d_ts_files: i2(6614, 3, "Create_sourcemaps_for_d_ts_files_6614", "Create sourcemaps for d.ts files."), Output_compiler_performance_information_after_building: i2(6615, 3, "Output_compiler_performance_information_after_building_6615", "Output compiler performance information after building."), Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project: i2(6616, 3, "Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project_6616", "Disables inference for type acquisition by looking at filenames in a project."), Reduce_the_number_of_projects_loaded_automatically_by_TypeScript: i2(6617, 3, "Reduce_the_number_of_projects_loaded_automatically_by_TypeScript_6617", "Reduce the number of projects loaded automatically by TypeScript."), Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server: i2(6618, 3, "Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server_6618", "Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."), Opt_a_project_out_of_multi_project_reference_checking_when_editing: i2(6619, 3, "Opt_a_project_out_of_multi_project_reference_checking_when_editing_6619", "Opt a project out of multi-project reference checking when editing."), Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects: i2(6620, 3, "Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects_6620", "Disable preferring source files instead of declaration files when referencing composite projects."), Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration: i2(6621, 3, "Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration_6621", "Emit more compliant, but verbose and less performant JavaScript for iteration."), Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: i2(6622, 3, "Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6622", "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."), Only_output_d_ts_files_and_not_JavaScript_files: i2(6623, 3, "Only_output_d_ts_files_and_not_JavaScript_files_6623", "Only output d.ts files and not JavaScript files."), Emit_design_type_metadata_for_decorated_declarations_in_source_files: i2(6624, 3, "Emit_design_type_metadata_for_decorated_declarations_in_source_files_6624", "Emit design-type metadata for decorated declarations in source files."), Disable_the_type_acquisition_for_JavaScript_projects: i2(6625, 3, "Disable_the_type_acquisition_for_JavaScript_projects_6625", "Disable the type acquisition for JavaScript projects"), Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility: i2(6626, 3, "Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheti_6626", "Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility."), Filters_results_from_the_include_option: i2(6627, 3, "Filters_results_from_the_include_option_6627", "Filters results from the `include` option."), Remove_a_list_of_directories_from_the_watch_process: i2(6628, 3, "Remove_a_list_of_directories_from_the_watch_process_6628", "Remove a list of directories from the watch process."), Remove_a_list_of_files_from_the_watch_mode_s_processing: i2(6629, 3, "Remove_a_list_of_files_from_the_watch_mode_s_processing_6629", "Remove a list of files from the watch mode's processing."), Enable_experimental_support_for_legacy_experimental_decorators: i2(6630, 3, "Enable_experimental_support_for_legacy_experimental_decorators_6630", "Enable experimental support for legacy experimental decorators."), Print_files_read_during_the_compilation_including_why_it_was_included: i2(6631, 3, "Print_files_read_during_the_compilation_including_why_it_was_included_6631", "Print files read during the compilation including why it was included."), Output_more_detailed_compiler_performance_information_after_building: i2(6632, 3, "Output_more_detailed_compiler_performance_information_after_building_6632", "Output more detailed compiler performance information after building."), Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited: i2(6633, 3, "Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_a_6633", "Specify one or more path or node module references to base configuration files from which settings are inherited."), Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers: i2(6634, 3, "Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers_6634", "Specify what approach the watcher should use if the system runs out of native file watchers."), Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include: i2(6635, 3, "Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include_6635", "Include a list of files. This does not support glob patterns, as opposed to `include`."), Build_all_projects_including_those_that_appear_to_be_up_to_date: i2(6636, 3, "Build_all_projects_including_those_that_appear_to_be_up_to_date_6636", "Build all projects, including those that appear to be up to date."), Ensure_that_casing_is_correct_in_imports: i2(6637, 3, "Ensure_that_casing_is_correct_in_imports_6637", "Ensure that casing is correct in imports."), Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging: i2(6638, 3, "Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging_6638", "Emit a v8 CPU profile of the compiler run for debugging."), Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file: i2(6639, 3, "Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file_6639", "Allow importing helper functions from tslib once per project, instead of including them per-file."), Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation: i2(6641, 3, "Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation_6641", "Specify a list of glob patterns that match files to be included in compilation."), Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects: i2(6642, 3, "Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects_6642", "Save .tsbuildinfo files to allow for incremental compilation of projects."), Include_sourcemap_files_inside_the_emitted_JavaScript: i2(6643, 3, "Include_sourcemap_files_inside_the_emitted_JavaScript_6643", "Include sourcemap files inside the emitted JavaScript."), Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript: i2(6644, 3, "Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript_6644", "Include source code in the sourcemaps inside the emitted JavaScript."), Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports: i2(6645, 3, "Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports_6645", "Ensure that each file can be safely transpiled without relying on other imports."), Specify_what_JSX_code_is_generated: i2(6646, 3, "Specify_what_JSX_code_is_generated_6646", "Specify what JSX code is generated."), Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h: i2(6647, 3, "Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h_6647", "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."), Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment: i2(6648, 3, "Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragme_6648", "Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."), Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk: i2(6649, 3, "Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Ast_6649", "Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'."), Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option: i2(6650, 3, "Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option_6650", "Make keyof only return strings instead of string, numbers or symbols. Legacy option."), Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment: i2(6651, 3, "Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment_6651", "Specify a set of bundled library declaration files that describe the target runtime environment."), Print_the_names_of_emitted_files_after_a_compilation: i2(6652, 3, "Print_the_names_of_emitted_files_after_a_compilation_6652", "Print the names of emitted files after a compilation."), Print_all_of_the_files_read_during_the_compilation: i2(6653, 3, "Print_all_of_the_files_read_during_the_compilation_6653", "Print all of the files read during the compilation."), Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit: i2(6654, 3, "Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit_6654", "Set the language of the messaging from TypeScript. This does not affect emit."), Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: i2(6655, 3, "Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6655", "Specify the location where debugger should locate map files instead of generated locations."), Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs: i2(6656, 3, "Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicabl_6656", "Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'."), Specify_what_module_code_is_generated: i2(6657, 3, "Specify_what_module_code_is_generated_6657", "Specify what module code is generated."), Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier: i2(6658, 3, "Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier_6658", "Specify how TypeScript looks up a file from a given module specifier."), Set_the_newline_character_for_emitting_files: i2(6659, 3, "Set_the_newline_character_for_emitting_files_6659", "Set the newline character for emitting files."), Disable_emitting_files_from_a_compilation: i2(6660, 3, "Disable_emitting_files_from_a_compilation_6660", "Disable emitting files from a compilation."), Disable_generating_custom_helper_functions_like_extends_in_compiled_output: i2(6661, 3, "Disable_generating_custom_helper_functions_like_extends_in_compiled_output_6661", "Disable generating custom helper functions like '__extends' in compiled output."), Disable_emitting_files_if_any_type_checking_errors_are_reported: i2(6662, 3, "Disable_emitting_files_if_any_type_checking_errors_are_reported_6662", "Disable emitting files if any type checking errors are reported."), Disable_truncating_types_in_error_messages: i2(6663, 3, "Disable_truncating_types_in_error_messages_6663", "Disable truncating types in error messages."), Enable_error_reporting_for_fallthrough_cases_in_switch_statements: i2(6664, 3, "Enable_error_reporting_for_fallthrough_cases_in_switch_statements_6664", "Enable error reporting for fallthrough cases in switch statements."), Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type: i2(6665, 3, "Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type_6665", "Enable error reporting for expressions and declarations with an implied 'any' type."), Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier: i2(6666, 3, "Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier_6666", "Ensure overriding members in derived classes are marked with an override modifier."), Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function: i2(6667, 3, "Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function_6667", "Enable error reporting for codepaths that do not explicitly return in a function."), Enable_error_reporting_when_this_is_given_the_type_any: i2(6668, 3, "Enable_error_reporting_when_this_is_given_the_type_any_6668", "Enable error reporting when 'this' is given the type 'any'."), Disable_adding_use_strict_directives_in_emitted_JavaScript_files: i2(6669, 3, "Disable_adding_use_strict_directives_in_emitted_JavaScript_files_6669", "Disable adding 'use strict' directives in emitted JavaScript files."), Disable_including_any_library_files_including_the_default_lib_d_ts: i2(6670, 3, "Disable_including_any_library_files_including_the_default_lib_d_ts_6670", "Disable including any library files, including the default lib.d.ts."), Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type: i2(6671, 3, "Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type_6671", "Enforces using indexed accessors for keys declared using an indexed type."), Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project: i2(6672, 3, "Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add__6672", "Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project."), Disable_strict_checking_of_generic_signatures_in_function_types: i2(6673, 3, "Disable_strict_checking_of_generic_signatures_in_function_types_6673", "Disable strict checking of generic signatures in function types."), Add_undefined_to_a_type_when_accessed_using_an_index: i2(6674, 3, "Add_undefined_to_a_type_when_accessed_using_an_index_6674", "Add 'undefined' to a type when accessed using an index."), Enable_error_reporting_when_local_variables_aren_t_read: i2(6675, 3, "Enable_error_reporting_when_local_variables_aren_t_read_6675", "Enable error reporting when local variables aren't read."), Raise_an_error_when_a_function_parameter_isn_t_read: i2(6676, 3, "Raise_an_error_when_a_function_parameter_isn_t_read_6676", "Raise an error when a function parameter isn't read."), Deprecated_setting_Use_outFile_instead: i2(6677, 3, "Deprecated_setting_Use_outFile_instead_6677", "Deprecated setting. Use 'outFile' instead."), Specify_an_output_folder_for_all_emitted_files: i2(6678, 3, "Specify_an_output_folder_for_all_emitted_files_6678", "Specify an output folder for all emitted files."), Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output: i2(6679, 3, "Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designa_6679", "Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output."), Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations: i2(6680, 3, "Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations_6680", "Specify a set of entries that re-map imports to additional lookup locations."), Specify_a_list_of_language_service_plugins_to_include: i2(6681, 3, "Specify_a_list_of_language_service_plugins_to_include_6681", "Specify a list of language service plugins to include."), Disable_erasing_const_enum_declarations_in_generated_code: i2(6682, 3, "Disable_erasing_const_enum_declarations_in_generated_code_6682", "Disable erasing 'const enum' declarations in generated code."), Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node: i2(6683, 3, "Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node_6683", "Disable resolving symlinks to their realpath. This correlates to the same flag in node."), Disable_wiping_the_console_in_watch_mode: i2(6684, 3, "Disable_wiping_the_console_in_watch_mode_6684", "Disable wiping the console in watch mode."), Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read: i2(6685, 3, "Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read_6685", "Enable color and formatting in TypeScript's output to make compiler errors easier to read."), Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit: i2(6686, 3, "Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit_6686", "Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit."), Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references: i2(6687, 3, "Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references_6687", "Specify an array of objects that specify paths for projects. Used in project references."), Disable_emitting_comments: i2(6688, 3, "Disable_emitting_comments_6688", "Disable emitting comments."), Enable_importing_json_files: i2(6689, 3, "Enable_importing_json_files_6689", "Enable importing .json files."), Specify_the_root_folder_within_your_source_files: i2(6690, 3, "Specify_the_root_folder_within_your_source_files_6690", "Specify the root folder within your source files."), Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules: i2(6691, 3, "Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules_6691", "Allow multiple folders to be treated as one when resolving modules."), Skip_type_checking_d_ts_files_that_are_included_with_TypeScript: i2(6692, 3, "Skip_type_checking_d_ts_files_that_are_included_with_TypeScript_6692", "Skip type checking .d.ts files that are included with TypeScript."), Skip_type_checking_all_d_ts_files: i2(6693, 3, "Skip_type_checking_all_d_ts_files_6693", "Skip type checking all .d.ts files."), Create_source_map_files_for_emitted_JavaScript_files: i2(6694, 3, "Create_source_map_files_for_emitted_JavaScript_files_6694", "Create source map files for emitted JavaScript files."), Specify_the_root_path_for_debuggers_to_find_the_reference_source_code: i2(6695, 3, "Specify_the_root_path_for_debuggers_to_find_the_reference_source_code_6695", "Specify the root path for debuggers to find the reference source code."), Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function: i2(6697, 3, "Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function_6697", "Check that the arguments for 'bind', 'call', and 'apply' methods match the original function."), When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible: i2(6698, 3, "When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698", "When assigning functions, check to ensure parameters and the return values are subtype-compatible."), When_type_checking_take_into_account_null_and_undefined: i2(6699, 3, "When_type_checking_take_into_account_null_and_undefined_6699", "When type checking, take into account 'null' and 'undefined'."), Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor: i2(6700, 3, "Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor_6700", "Check for class properties that are declared but not set in the constructor."), Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments: i2(6701, 3, "Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments_6701", "Disable emitting declarations that have '@internal' in their JSDoc comments."), Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals: i2(6702, 3, "Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals_6702", "Disable reporting of excess property errors during the creation of object literals."), Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures: i2(6703, 3, "Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures_6703", "Suppress 'noImplicitAny' errors when indexing objects that lack index signatures."), Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively: i2(6704, 3, "Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6704", "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."), Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations: i2(6705, 3, "Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declaratio_6705", "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."), Log_paths_used_during_the_moduleResolution_process: i2(6706, 3, "Log_paths_used_during_the_moduleResolution_process_6706", "Log paths used during the 'moduleResolution' process."), Specify_the_path_to_tsbuildinfo_incremental_compilation_file: i2(6707, 3, "Specify_the_path_to_tsbuildinfo_incremental_compilation_file_6707", "Specify the path to .tsbuildinfo incremental compilation file."), Specify_options_for_automatic_acquisition_of_declaration_files: i2(6709, 3, "Specify_options_for_automatic_acquisition_of_declaration_files_6709", "Specify options for automatic acquisition of declaration files."), Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types: i2(6710, 3, "Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types_6710", "Specify multiple folders that act like './node_modules/@types'."), Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file: i2(6711, 3, "Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file_6711", "Specify type package names to be included without being referenced in a source file."), Emit_ECMAScript_standard_compliant_class_fields: i2(6712, 3, "Emit_ECMAScript_standard_compliant_class_fields_6712", "Emit ECMAScript-standard-compliant class fields."), Enable_verbose_logging: i2(6713, 3, "Enable_verbose_logging_6713", "Enable verbose logging."), Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality: i2(6714, 3, "Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality_6714", "Specify how directories are watched on systems that lack recursive file-watching functionality."), Specify_how_the_TypeScript_watch_mode_works: i2(6715, 3, "Specify_how_the_TypeScript_watch_mode_works_6715", "Specify how the TypeScript watch mode works."), Require_undeclared_properties_from_index_signatures_to_use_element_accesses: i2(6717, 3, "Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6717", "Require undeclared properties from index signatures to use element accesses."), Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types: i2(6718, 3, "Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types_6718", "Specify emit/checking behavior for imports that are only used for types."), Default_catch_clause_variables_as_unknown_instead_of_any: i2(6803, 3, "Default_catch_clause_variables_as_unknown_instead_of_any_6803", "Default catch clause variables as 'unknown' instead of 'any'."), Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_in_the_output_file_s_format_based_on_the_module_setting: i2(6804, 3, "Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_i_6804", "Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting."), one_of_Colon: i2(6900, 3, "one_of_Colon_6900", "one of:"), one_or_more_Colon: i2(6901, 3, "one_or_more_Colon_6901", "one or more:"), type_Colon: i2(6902, 3, "type_Colon_6902", "type:"), default_Colon: i2(6903, 3, "default_Colon_6903", "default:"), module_system_or_esModuleInterop: i2(6904, 3, "module_system_or_esModuleInterop_6904", 'module === "system" or esModuleInterop'), false_unless_strict_is_set: i2(6905, 3, "false_unless_strict_is_set_6905", "`false`, unless `strict` is set"), false_unless_composite_is_set: i2(6906, 3, "false_unless_composite_is_set_6906", "`false`, unless `composite` is set"), node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified: i2(6907, 3, "node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified_6907", '`["node_modules", "bower_components", "jspm_packages"]`, plus the value of `outDir` if one is specified.'), if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk: i2(6908, 3, "if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk_6908", '`[]` if `files` is specified, otherwise `["**/*"]`'), true_if_composite_false_otherwise: i2(6909, 3, "true_if_composite_false_otherwise_6909", "`true` if `composite`, `false` otherwise"), module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node: i2(69010, 3, "module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node_69010", "module === `AMD` or `UMD` or `System` or `ES6`, then `Classic`, Otherwise `Node`"), Computed_from_the_list_of_input_files: i2(6911, 3, "Computed_from_the_list_of_input_files_6911", "Computed from the list of input files"), Platform_specific: i2(6912, 3, "Platform_specific_6912", "Platform specific"), You_can_learn_about_all_of_the_compiler_options_at_0: i2(6913, 3, "You_can_learn_about_all_of_the_compiler_options_at_0_6913", "You can learn about all of the compiler options at {0}"), Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon: i2(6914, 3, "Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_conf_6914", "Including --watch, -w will start watching the current project for the file changes. Once set, you can config watch mode with:"), Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0: i2(6915, 3, "Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915", "Using --build, -b will make tsc behave more like a build orchestrator than a compiler. This is used to trigger building composite projects which you can learn more about at {0}"), COMMON_COMMANDS: i2(6916, 3, "COMMON_COMMANDS_6916", "COMMON COMMANDS"), ALL_COMPILER_OPTIONS: i2(6917, 3, "ALL_COMPILER_OPTIONS_6917", "ALL COMPILER OPTIONS"), WATCH_OPTIONS: i2(6918, 3, "WATCH_OPTIONS_6918", "WATCH OPTIONS"), BUILD_OPTIONS: i2(6919, 3, "BUILD_OPTIONS_6919", "BUILD OPTIONS"), COMMON_COMPILER_OPTIONS: i2(6920, 3, "COMMON_COMPILER_OPTIONS_6920", "COMMON COMPILER OPTIONS"), COMMAND_LINE_FLAGS: i2(6921, 3, "COMMAND_LINE_FLAGS_6921", "COMMAND LINE FLAGS"), tsc_Colon_The_TypeScript_Compiler: i2(6922, 3, "tsc_Colon_The_TypeScript_Compiler_6922", "tsc: The TypeScript Compiler"), Compiles_the_current_project_tsconfig_json_in_the_working_directory: i2(6923, 3, "Compiles_the_current_project_tsconfig_json_in_the_working_directory_6923", "Compiles the current project (tsconfig.json in the working directory.)"), Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options: i2(6924, 3, "Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options_6924", "Ignoring tsconfig.json, compiles the specified files with default compiler options."), Build_a_composite_project_in_the_working_directory: i2(6925, 3, "Build_a_composite_project_in_the_working_directory_6925", "Build a composite project in the working directory."), Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory: i2(6926, 3, "Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory_6926", "Creates a tsconfig.json with the recommended settings in the working directory."), Compiles_the_TypeScript_project_located_at_the_specified_path: i2(6927, 3, "Compiles_the_TypeScript_project_located_at_the_specified_path_6927", "Compiles the TypeScript project located at the specified path."), An_expanded_version_of_this_information_showing_all_possible_compiler_options: i2(6928, 3, "An_expanded_version_of_this_information_showing_all_possible_compiler_options_6928", "An expanded version of this information, showing all possible compiler options"), Compiles_the_current_project_with_additional_settings: i2(6929, 3, "Compiles_the_current_project_with_additional_settings_6929", "Compiles the current project, with additional settings."), true_for_ES2022_and_above_including_ESNext: i2(6930, 3, "true_for_ES2022_and_above_including_ESNext_6930", "`true` for ES2022 and above, including ESNext."), List_of_file_name_suffixes_to_search_when_resolving_a_module: i2(6931, 1, "List_of_file_name_suffixes_to_search_when_resolving_a_module_6931", "List of file name suffixes to search when resolving a module."), Variable_0_implicitly_has_an_1_type: i2(7005, 1, "Variable_0_implicitly_has_an_1_type_7005", "Variable '{0}' implicitly has an '{1}' type."), Parameter_0_implicitly_has_an_1_type: i2(7006, 1, "Parameter_0_implicitly_has_an_1_type_7006", "Parameter '{0}' implicitly has an '{1}' type."), Member_0_implicitly_has_an_1_type: i2(7008, 1, "Member_0_implicitly_has_an_1_type_7008", "Member '{0}' implicitly has an '{1}' type."), new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: i2(7009, 1, "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009", "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type."), _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: i2(7010, 1, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010", "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type."), Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: i2(7011, 1, "Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011", "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type."), This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation: i2(7012, 1, "This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation_7012", "This overload implicitly returns the type '{0}' because it lacks a return type annotation."), Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: i2(7013, 1, "Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013", "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type."), Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: i2(7014, 1, "Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014", "Function type, which lacks return-type annotation, implicitly has an '{0}' return type."), Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: i2(7015, 1, "Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015", "Element implicitly has an 'any' type because index expression is not of type 'number'."), Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: i2(7016, 1, "Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016", "Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type."), Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: i2(7017, 1, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017", "Element implicitly has an 'any' type because type '{0}' has no index signature."), Object_literal_s_property_0_implicitly_has_an_1_type: i2(7018, 1, "Object_literal_s_property_0_implicitly_has_an_1_type_7018", "Object literal's property '{0}' implicitly has an '{1}' type."), Rest_parameter_0_implicitly_has_an_any_type: i2(7019, 1, "Rest_parameter_0_implicitly_has_an_any_type_7019", "Rest parameter '{0}' implicitly has an 'any[]' type."), Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: i2(7020, 1, "Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020", "Call signature, which lacks return-type annotation, implicitly has an 'any' return type."), _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: i2(7022, 1, "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022", "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer."), _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: i2(7023, 1, "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023", "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."), Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: i2(7024, 1, "Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024", "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."), Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation: i2(7025, 1, "Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025", "Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation."), JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: i2(7026, 1, "JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026", "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists."), Unreachable_code_detected: i2(7027, 1, "Unreachable_code_detected_7027", "Unreachable code detected.", true), Unused_label: i2(7028, 1, "Unused_label_7028", "Unused label.", true), Fallthrough_case_in_switch: i2(7029, 1, "Fallthrough_case_in_switch_7029", "Fallthrough case in switch."), Not_all_code_paths_return_a_value: i2(7030, 1, "Not_all_code_paths_return_a_value_7030", "Not all code paths return a value."), Binding_element_0_implicitly_has_an_1_type: i2(7031, 1, "Binding_element_0_implicitly_has_an_1_type_7031", "Binding element '{0}' implicitly has an '{1}' type."), Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: i2(7032, 1, "Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032", "Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation."), Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: i2(7033, 1, "Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033", "Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation."), Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: i2(7034, 1, "Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034", "Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined."), Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: i2(7035, 1, "Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035", "Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`"), Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: i2(7036, 1, "Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036", "Dynamic import's specifier must be of type 'string', but here has type '{0}'."), Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: i2(7037, 3, "Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037", "Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'."), Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead: i2(7038, 3, "Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038", "Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead."), Mapped_object_type_implicitly_has_an_any_template_type: i2(7039, 1, "Mapped_object_type_implicitly_has_an_any_template_type_7039", "Mapped object type implicitly has an 'any' template type."), If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1: i2(7040, 1, "If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_S_7040", "If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}'"), The_containing_arrow_function_captures_the_global_value_of_this: i2(7041, 1, "The_containing_arrow_function_captures_the_global_value_of_this_7041", "The containing arrow function captures the global value of 'this'."), Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used: i2(7042, 1, "Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042", "Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used."), Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: i2(7043, 2, "Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043", "Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: i2(7044, 2, "Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044", "Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: i2(7045, 2, "Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045", "Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage: i2(7046, 2, "Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046", "Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage."), Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage: i2(7047, 2, "Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047", "Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage."), Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage: i2(7048, 2, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048", "Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage."), Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage: i2(7049, 2, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049", "Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage."), _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage: i2(7050, 2, "_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050", "'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage."), Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1: i2(7051, 1, "Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1_7051", "Parameter has a name but no type. Did you mean '{0}: {1}'?"), Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1: i2(7052, 1, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052", "Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?"), Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1: i2(7053, 1, "Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053", "Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'."), No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1: i2(7054, 1, "No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054", "No index signature with a parameter of type '{0}' was found on type '{1}'."), _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type: i2(7055, 1, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055", "'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type."), The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed: i2(7056, 1, "The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056", "The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed."), yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation: i2(7057, 1, "yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057", "'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation."), If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1: i2(7058, 1, "If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_decl_7058", "If the '{0}' package actually exposes this module, try adding a new declaration (.d.ts) file containing `declare module '{1}';`"), This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead: i2(7059, 1, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead_7059", "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."), This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint: i2(7060, 1, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_cons_7060", "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma or explicit constraint."), A_mapped_type_may_not_declare_properties_or_methods: i2(7061, 1, "A_mapped_type_may_not_declare_properties_or_methods_7061", "A mapped type may not declare properties or methods."), You_cannot_rename_this_element: i2(8e3, 1, "You_cannot_rename_this_element_8000", "You cannot rename this element."), You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: i2(8001, 1, "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001", "You cannot rename elements that are defined in the standard TypeScript library."), import_can_only_be_used_in_TypeScript_files: i2(8002, 1, "import_can_only_be_used_in_TypeScript_files_8002", "'import ... =' can only be used in TypeScript files."), export_can_only_be_used_in_TypeScript_files: i2(8003, 1, "export_can_only_be_used_in_TypeScript_files_8003", "'export =' can only be used in TypeScript files."), Type_parameter_declarations_can_only_be_used_in_TypeScript_files: i2(8004, 1, "Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004", "Type parameter declarations can only be used in TypeScript files."), implements_clauses_can_only_be_used_in_TypeScript_files: i2(8005, 1, "implements_clauses_can_only_be_used_in_TypeScript_files_8005", "'implements' clauses can only be used in TypeScript files."), _0_declarations_can_only_be_used_in_TypeScript_files: i2(8006, 1, "_0_declarations_can_only_be_used_in_TypeScript_files_8006", "'{0}' declarations can only be used in TypeScript files."), Type_aliases_can_only_be_used_in_TypeScript_files: i2(8008, 1, "Type_aliases_can_only_be_used_in_TypeScript_files_8008", "Type aliases can only be used in TypeScript files."), The_0_modifier_can_only_be_used_in_TypeScript_files: i2(8009, 1, "The_0_modifier_can_only_be_used_in_TypeScript_files_8009", "The '{0}' modifier can only be used in TypeScript files."), Type_annotations_can_only_be_used_in_TypeScript_files: i2(8010, 1, "Type_annotations_can_only_be_used_in_TypeScript_files_8010", "Type annotations can only be used in TypeScript files."), Type_arguments_can_only_be_used_in_TypeScript_files: i2(8011, 1, "Type_arguments_can_only_be_used_in_TypeScript_files_8011", "Type arguments can only be used in TypeScript files."), Parameter_modifiers_can_only_be_used_in_TypeScript_files: i2(8012, 1, "Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012", "Parameter modifiers can only be used in TypeScript files."), Non_null_assertions_can_only_be_used_in_TypeScript_files: i2(8013, 1, "Non_null_assertions_can_only_be_used_in_TypeScript_files_8013", "Non-null assertions can only be used in TypeScript files."), Type_assertion_expressions_can_only_be_used_in_TypeScript_files: i2(8016, 1, "Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016", "Type assertion expressions can only be used in TypeScript files."), Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: i2(8017, 1, "Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017", "Octal literal types must use ES2015 syntax. Use the syntax '{0}'."), Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: i2(8018, 1, "Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018", "Octal literals are not allowed in enums members initializer. Use the syntax '{0}'."), Report_errors_in_js_files: i2(8019, 3, "Report_errors_in_js_files_8019", "Report errors in .js files."), JSDoc_types_can_only_be_used_inside_documentation_comments: i2(8020, 1, "JSDoc_types_can_only_be_used_inside_documentation_comments_8020", "JSDoc types can only be used inside documentation comments."), JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: i2(8021, 1, "JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021", "JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags."), JSDoc_0_is_not_attached_to_a_class: i2(8022, 1, "JSDoc_0_is_not_attached_to_a_class_8022", "JSDoc '@{0}' is not attached to a class."), JSDoc_0_1_does_not_match_the_extends_2_clause: i2(8023, 1, "JSDoc_0_1_does_not_match_the_extends_2_clause_8023", "JSDoc '@{0} {1}' does not match the 'extends {2}' clause."), JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: i2(8024, 1, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name."), Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: i2(8025, 1, "Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025", "Class declarations cannot have more than one '@augments' or '@extends' tag."), Expected_0_type_arguments_provide_these_with_an_extends_tag: i2(8026, 1, "Expected_0_type_arguments_provide_these_with_an_extends_tag_8026", "Expected {0} type arguments; provide these with an '@extends' tag."), Expected_0_1_type_arguments_provide_these_with_an_extends_tag: i2(8027, 1, "Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027", "Expected {0}-{1} type arguments; provide these with an '@extends' tag."), JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: i2(8028, 1, "JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028", "JSDoc '...' may only appear in the last parameter of a signature."), JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: i2(8029, 1, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type."), The_type_of_a_function_declaration_must_match_the_function_s_signature: i2(8030, 1, "The_type_of_a_function_declaration_must_match_the_function_s_signature_8030", "The type of a function declaration must match the function's signature."), You_cannot_rename_a_module_via_a_global_import: i2(8031, 1, "You_cannot_rename_a_module_via_a_global_import_8031", "You cannot rename a module via a global import."), Qualified_name_0_is_not_allowed_without_a_leading_param_object_1: i2(8032, 1, "Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032", "Qualified name '{0}' is not allowed without a leading '@param {object} {1}'."), A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags: i2(8033, 1, "A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033", "A JSDoc '@typedef' comment may not contain multiple '@type' tags."), The_tag_was_first_specified_here: i2(8034, 1, "The_tag_was_first_specified_here_8034", "The tag was first specified here."), You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder: i2(8035, 1, "You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder_8035", "You cannot rename elements that are defined in a 'node_modules' folder."), You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder: i2(8036, 1, "You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder_8036", "You cannot rename elements that are defined in another 'node_modules' folder."), Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files: i2(8037, 1, "Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files_8037", "Type satisfaction expressions can only be used in TypeScript files."), Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export: i2(8038, 1, "Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export_8038", "Decorators may not appear after 'export' or 'export default' if they also appear before 'export'."), Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit: i2(9005, 1, "Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005", "Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit."), Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit: i2(9006, 1, "Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006", "Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit."), JSX_attributes_must_only_be_assigned_a_non_empty_expression: i2(17e3, 1, "JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000", "JSX attributes must only be assigned a non-empty 'expression'."), JSX_elements_cannot_have_multiple_attributes_with_the_same_name: i2(17001, 1, "JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001", "JSX elements cannot have multiple attributes with the same name."), Expected_corresponding_JSX_closing_tag_for_0: i2(17002, 1, "Expected_corresponding_JSX_closing_tag_for_0_17002", "Expected corresponding JSX closing tag for '{0}'."), Cannot_use_JSX_unless_the_jsx_flag_is_provided: i2(17004, 1, "Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004", "Cannot use JSX unless the '--jsx' flag is provided."), A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: i2(17005, 1, "A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005", "A constructor cannot contain a 'super' call when its class extends 'null'."), An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: i2(17006, 1, "An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006", "An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."), A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: i2(17007, 1, "A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007", "A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."), JSX_element_0_has_no_corresponding_closing_tag: i2(17008, 1, "JSX_element_0_has_no_corresponding_closing_tag_17008", "JSX element '{0}' has no corresponding closing tag."), super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: i2(17009, 1, "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009", "'super' must be called before accessing 'this' in the constructor of a derived class."), Unknown_type_acquisition_option_0: i2(17010, 1, "Unknown_type_acquisition_option_0_17010", "Unknown type acquisition option '{0}'."), super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: i2(17011, 1, "super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011", "'super' must be called before accessing a property of 'super' in the constructor of a derived class."), _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: i2(17012, 1, "_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012", "'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?"), Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: i2(17013, 1, "Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013", "Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor."), JSX_fragment_has_no_corresponding_closing_tag: i2(17014, 1, "JSX_fragment_has_no_corresponding_closing_tag_17014", "JSX fragment has no corresponding closing tag."), Expected_corresponding_closing_tag_for_JSX_fragment: i2(17015, 1, "Expected_corresponding_closing_tag_for_JSX_fragment_17015", "Expected corresponding closing tag for JSX fragment."), The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option: i2(17016, 1, "The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016", "The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option."), An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments: i2(17017, 1, "An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017", "An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments."), Unknown_type_acquisition_option_0_Did_you_mean_1: i2(17018, 1, "Unknown_type_acquisition_option_0_Did_you_mean_1_17018", "Unknown type acquisition option '{0}'. Did you mean '{1}'?"), _0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1: i2(17019, 1, "_0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1_17019", "'{0}' at the end of a type is not valid TypeScript syntax. Did you mean to write '{1}'?"), _0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1: i2(17020, 1, "_0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1_17020", "'{0}' at the start of a type is not valid TypeScript syntax. Did you mean to write '{1}'?"), Circularity_detected_while_resolving_configuration_Colon_0: i2(18e3, 1, "Circularity_detected_while_resolving_configuration_Colon_0_18000", "Circularity detected while resolving configuration: {0}"), The_files_list_in_config_file_0_is_empty: i2(18002, 1, "The_files_list_in_config_file_0_is_empty_18002", "The 'files' list in config file '{0}' is empty."), No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: i2(18003, 1, "No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003", "No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'."), File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module: i2(80001, 2, "File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module_80001", "File is a CommonJS module; it may be converted to an ES module."), This_constructor_function_may_be_converted_to_a_class_declaration: i2(80002, 2, "This_constructor_function_may_be_converted_to_a_class_declaration_80002", "This constructor function may be converted to a class declaration."), Import_may_be_converted_to_a_default_import: i2(80003, 2, "Import_may_be_converted_to_a_default_import_80003", "Import may be converted to a default import."), JSDoc_types_may_be_moved_to_TypeScript_types: i2(80004, 2, "JSDoc_types_may_be_moved_to_TypeScript_types_80004", "JSDoc types may be moved to TypeScript types."), require_call_may_be_converted_to_an_import: i2(80005, 2, "require_call_may_be_converted_to_an_import_80005", "'require' call may be converted to an import."), This_may_be_converted_to_an_async_function: i2(80006, 2, "This_may_be_converted_to_an_async_function_80006", "This may be converted to an async function."), await_has_no_effect_on_the_type_of_this_expression: i2(80007, 2, "await_has_no_effect_on_the_type_of_this_expression_80007", "'await' has no effect on the type of this expression."), Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers: i2(80008, 2, "Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008", "Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers."), Add_missing_super_call: i2(90001, 3, "Add_missing_super_call_90001", "Add missing 'super()' call"), Make_super_call_the_first_statement_in_the_constructor: i2(90002, 3, "Make_super_call_the_first_statement_in_the_constructor_90002", "Make 'super()' call the first statement in the constructor"), Change_extends_to_implements: i2(90003, 3, "Change_extends_to_implements_90003", "Change 'extends' to 'implements'"), Remove_unused_declaration_for_Colon_0: i2(90004, 3, "Remove_unused_declaration_for_Colon_0_90004", "Remove unused declaration for: '{0}'"), Remove_import_from_0: i2(90005, 3, "Remove_import_from_0_90005", "Remove import from '{0}'"), Implement_interface_0: i2(90006, 3, "Implement_interface_0_90006", "Implement interface '{0}'"), Implement_inherited_abstract_class: i2(90007, 3, "Implement_inherited_abstract_class_90007", "Implement inherited abstract class"), Add_0_to_unresolved_variable: i2(90008, 3, "Add_0_to_unresolved_variable_90008", "Add '{0}.' to unresolved variable"), Remove_variable_statement: i2(90010, 3, "Remove_variable_statement_90010", "Remove variable statement"), Remove_template_tag: i2(90011, 3, "Remove_template_tag_90011", "Remove template tag"), Remove_type_parameters: i2(90012, 3, "Remove_type_parameters_90012", "Remove type parameters"), Import_0_from_1: i2(90013, 3, "Import_0_from_1_90013", `Import '{0}' from "{1}"`), Change_0_to_1: i2(90014, 3, "Change_0_to_1_90014", "Change '{0}' to '{1}'"), Declare_property_0: i2(90016, 3, "Declare_property_0_90016", "Declare property '{0}'"), Add_index_signature_for_property_0: i2(90017, 3, "Add_index_signature_for_property_0_90017", "Add index signature for property '{0}'"), Disable_checking_for_this_file: i2(90018, 3, "Disable_checking_for_this_file_90018", "Disable checking for this file"), Ignore_this_error_message: i2(90019, 3, "Ignore_this_error_message_90019", "Ignore this error message"), Initialize_property_0_in_the_constructor: i2(90020, 3, "Initialize_property_0_in_the_constructor_90020", "Initialize property '{0}' in the constructor"), Initialize_static_property_0: i2(90021, 3, "Initialize_static_property_0_90021", "Initialize static property '{0}'"), Change_spelling_to_0: i2(90022, 3, "Change_spelling_to_0_90022", "Change spelling to '{0}'"), Declare_method_0: i2(90023, 3, "Declare_method_0_90023", "Declare method '{0}'"), Declare_static_method_0: i2(90024, 3, "Declare_static_method_0_90024", "Declare static method '{0}'"), Prefix_0_with_an_underscore: i2(90025, 3, "Prefix_0_with_an_underscore_90025", "Prefix '{0}' with an underscore"), Rewrite_as_the_indexed_access_type_0: i2(90026, 3, "Rewrite_as_the_indexed_access_type_0_90026", "Rewrite as the indexed access type '{0}'"), Declare_static_property_0: i2(90027, 3, "Declare_static_property_0_90027", "Declare static property '{0}'"), Call_decorator_expression: i2(90028, 3, "Call_decorator_expression_90028", "Call decorator expression"), Add_async_modifier_to_containing_function: i2(90029, 3, "Add_async_modifier_to_containing_function_90029", "Add async modifier to containing function"), Replace_infer_0_with_unknown: i2(90030, 3, "Replace_infer_0_with_unknown_90030", "Replace 'infer {0}' with 'unknown'"), Replace_all_unused_infer_with_unknown: i2(90031, 3, "Replace_all_unused_infer_with_unknown_90031", "Replace all unused 'infer' with 'unknown'"), Add_parameter_name: i2(90034, 3, "Add_parameter_name_90034", "Add parameter name"), Declare_private_property_0: i2(90035, 3, "Declare_private_property_0_90035", "Declare private property '{0}'"), Replace_0_with_Promise_1: i2(90036, 3, "Replace_0_with_Promise_1_90036", "Replace '{0}' with 'Promise<{1}>'"), Fix_all_incorrect_return_type_of_an_async_functions: i2(90037, 3, "Fix_all_incorrect_return_type_of_an_async_functions_90037", "Fix all incorrect return type of an async functions"), Declare_private_method_0: i2(90038, 3, "Declare_private_method_0_90038", "Declare private method '{0}'"), Remove_unused_destructuring_declaration: i2(90039, 3, "Remove_unused_destructuring_declaration_90039", "Remove unused destructuring declaration"), Remove_unused_declarations_for_Colon_0: i2(90041, 3, "Remove_unused_declarations_for_Colon_0_90041", "Remove unused declarations for: '{0}'"), Declare_a_private_field_named_0: i2(90053, 3, "Declare_a_private_field_named_0_90053", "Declare a private field named '{0}'."), Includes_imports_of_types_referenced_by_0: i2(90054, 3, "Includes_imports_of_types_referenced_by_0_90054", "Includes imports of types referenced by '{0}'"), Remove_type_from_import_declaration_from_0: i2(90055, 3, "Remove_type_from_import_declaration_from_0_90055", `Remove 'type' from import declaration from "{0}"`), Remove_type_from_import_of_0_from_1: i2(90056, 3, "Remove_type_from_import_of_0_from_1_90056", `Remove 'type' from import of '{0}' from "{1}"`), Add_import_from_0: i2(90057, 3, "Add_import_from_0_90057", 'Add import from "{0}"'), Update_import_from_0: i2(90058, 3, "Update_import_from_0_90058", 'Update import from "{0}"'), Export_0_from_module_1: i2(90059, 3, "Export_0_from_module_1_90059", "Export '{0}' from module '{1}'"), Export_all_referenced_locals: i2(90060, 3, "Export_all_referenced_locals_90060", "Export all referenced locals"), Convert_function_to_an_ES2015_class: i2(95001, 3, "Convert_function_to_an_ES2015_class_95001", "Convert function to an ES2015 class"), Convert_0_to_1_in_0: i2(95003, 3, "Convert_0_to_1_in_0_95003", "Convert '{0}' to '{1} in {0}'"), Extract_to_0_in_1: i2(95004, 3, "Extract_to_0_in_1_95004", "Extract to {0} in {1}"), Extract_function: i2(95005, 3, "Extract_function_95005", "Extract function"), Extract_constant: i2(95006, 3, "Extract_constant_95006", "Extract constant"), Extract_to_0_in_enclosing_scope: i2(95007, 3, "Extract_to_0_in_enclosing_scope_95007", "Extract to {0} in enclosing scope"), Extract_to_0_in_1_scope: i2(95008, 3, "Extract_to_0_in_1_scope_95008", "Extract to {0} in {1} scope"), Annotate_with_type_from_JSDoc: i2(95009, 3, "Annotate_with_type_from_JSDoc_95009", "Annotate with type from JSDoc"), Infer_type_of_0_from_usage: i2(95011, 3, "Infer_type_of_0_from_usage_95011", "Infer type of '{0}' from usage"), Infer_parameter_types_from_usage: i2(95012, 3, "Infer_parameter_types_from_usage_95012", "Infer parameter types from usage"), Convert_to_default_import: i2(95013, 3, "Convert_to_default_import_95013", "Convert to default import"), Install_0: i2(95014, 3, "Install_0_95014", "Install '{0}'"), Replace_import_with_0: i2(95015, 3, "Replace_import_with_0_95015", "Replace import with '{0}'."), Use_synthetic_default_member: i2(95016, 3, "Use_synthetic_default_member_95016", "Use synthetic 'default' member."), Convert_to_ES_module: i2(95017, 3, "Convert_to_ES_module_95017", "Convert to ES module"), Add_undefined_type_to_property_0: i2(95018, 3, "Add_undefined_type_to_property_0_95018", "Add 'undefined' type to property '{0}'"), Add_initializer_to_property_0: i2(95019, 3, "Add_initializer_to_property_0_95019", "Add initializer to property '{0}'"), Add_definite_assignment_assertion_to_property_0: i2(95020, 3, "Add_definite_assignment_assertion_to_property_0_95020", "Add definite assignment assertion to property '{0}'"), Convert_all_type_literals_to_mapped_type: i2(95021, 3, "Convert_all_type_literals_to_mapped_type_95021", "Convert all type literals to mapped type"), Add_all_missing_members: i2(95022, 3, "Add_all_missing_members_95022", "Add all missing members"), Infer_all_types_from_usage: i2(95023, 3, "Infer_all_types_from_usage_95023", "Infer all types from usage"), Delete_all_unused_declarations: i2(95024, 3, "Delete_all_unused_declarations_95024", "Delete all unused declarations"), Prefix_all_unused_declarations_with_where_possible: i2(95025, 3, "Prefix_all_unused_declarations_with_where_possible_95025", "Prefix all unused declarations with '_' where possible"), Fix_all_detected_spelling_errors: i2(95026, 3, "Fix_all_detected_spelling_errors_95026", "Fix all detected spelling errors"), Add_initializers_to_all_uninitialized_properties: i2(95027, 3, "Add_initializers_to_all_uninitialized_properties_95027", "Add initializers to all uninitialized properties"), Add_definite_assignment_assertions_to_all_uninitialized_properties: i2(95028, 3, "Add_definite_assignment_assertions_to_all_uninitialized_properties_95028", "Add definite assignment assertions to all uninitialized properties"), Add_undefined_type_to_all_uninitialized_properties: i2(95029, 3, "Add_undefined_type_to_all_uninitialized_properties_95029", "Add undefined type to all uninitialized properties"), Change_all_jsdoc_style_types_to_TypeScript: i2(95030, 3, "Change_all_jsdoc_style_types_to_TypeScript_95030", "Change all jsdoc-style types to TypeScript"), Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: i2(95031, 3, "Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031", "Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)"), Implement_all_unimplemented_interfaces: i2(95032, 3, "Implement_all_unimplemented_interfaces_95032", "Implement all unimplemented interfaces"), Install_all_missing_types_packages: i2(95033, 3, "Install_all_missing_types_packages_95033", "Install all missing types packages"), Rewrite_all_as_indexed_access_types: i2(95034, 3, "Rewrite_all_as_indexed_access_types_95034", "Rewrite all as indexed access types"), Convert_all_to_default_imports: i2(95035, 3, "Convert_all_to_default_imports_95035", "Convert all to default imports"), Make_all_super_calls_the_first_statement_in_their_constructor: i2(95036, 3, "Make_all_super_calls_the_first_statement_in_their_constructor_95036", "Make all 'super()' calls the first statement in their constructor"), Add_qualifier_to_all_unresolved_variables_matching_a_member_name: i2(95037, 3, "Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037", "Add qualifier to all unresolved variables matching a member name"), Change_all_extended_interfaces_to_implements: i2(95038, 3, "Change_all_extended_interfaces_to_implements_95038", "Change all extended interfaces to 'implements'"), Add_all_missing_super_calls: i2(95039, 3, "Add_all_missing_super_calls_95039", "Add all missing super calls"), Implement_all_inherited_abstract_classes: i2(95040, 3, "Implement_all_inherited_abstract_classes_95040", "Implement all inherited abstract classes"), Add_all_missing_async_modifiers: i2(95041, 3, "Add_all_missing_async_modifiers_95041", "Add all missing 'async' modifiers"), Add_ts_ignore_to_all_error_messages: i2(95042, 3, "Add_ts_ignore_to_all_error_messages_95042", "Add '@ts-ignore' to all error messages"), Annotate_everything_with_types_from_JSDoc: i2(95043, 3, "Annotate_everything_with_types_from_JSDoc_95043", "Annotate everything with types from JSDoc"), Add_to_all_uncalled_decorators: i2(95044, 3, "Add_to_all_uncalled_decorators_95044", "Add '()' to all uncalled decorators"), Convert_all_constructor_functions_to_classes: i2(95045, 3, "Convert_all_constructor_functions_to_classes_95045", "Convert all constructor functions to classes"), Generate_get_and_set_accessors: i2(95046, 3, "Generate_get_and_set_accessors_95046", "Generate 'get' and 'set' accessors"), Convert_require_to_import: i2(95047, 3, "Convert_require_to_import_95047", "Convert 'require' to 'import'"), Convert_all_require_to_import: i2(95048, 3, "Convert_all_require_to_import_95048", "Convert all 'require' to 'import'"), Move_to_a_new_file: i2(95049, 3, "Move_to_a_new_file_95049", "Move to a new file"), Remove_unreachable_code: i2(95050, 3, "Remove_unreachable_code_95050", "Remove unreachable code"), Remove_all_unreachable_code: i2(95051, 3, "Remove_all_unreachable_code_95051", "Remove all unreachable code"), Add_missing_typeof: i2(95052, 3, "Add_missing_typeof_95052", "Add missing 'typeof'"), Remove_unused_label: i2(95053, 3, "Remove_unused_label_95053", "Remove unused label"), Remove_all_unused_labels: i2(95054, 3, "Remove_all_unused_labels_95054", "Remove all unused labels"), Convert_0_to_mapped_object_type: i2(95055, 3, "Convert_0_to_mapped_object_type_95055", "Convert '{0}' to mapped object type"), Convert_namespace_import_to_named_imports: i2(95056, 3, "Convert_namespace_import_to_named_imports_95056", "Convert namespace import to named imports"), Convert_named_imports_to_namespace_import: i2(95057, 3, "Convert_named_imports_to_namespace_import_95057", "Convert named imports to namespace import"), Add_or_remove_braces_in_an_arrow_function: i2(95058, 3, "Add_or_remove_braces_in_an_arrow_function_95058", "Add or remove braces in an arrow function"), Add_braces_to_arrow_function: i2(95059, 3, "Add_braces_to_arrow_function_95059", "Add braces to arrow function"), Remove_braces_from_arrow_function: i2(95060, 3, "Remove_braces_from_arrow_function_95060", "Remove braces from arrow function"), Convert_default_export_to_named_export: i2(95061, 3, "Convert_default_export_to_named_export_95061", "Convert default export to named export"), Convert_named_export_to_default_export: i2(95062, 3, "Convert_named_export_to_default_export_95062", "Convert named export to default export"), Add_missing_enum_member_0: i2(95063, 3, "Add_missing_enum_member_0_95063", "Add missing enum member '{0}'"), Add_all_missing_imports: i2(95064, 3, "Add_all_missing_imports_95064", "Add all missing imports"), Convert_to_async_function: i2(95065, 3, "Convert_to_async_function_95065", "Convert to async function"), Convert_all_to_async_functions: i2(95066, 3, "Convert_all_to_async_functions_95066", "Convert all to async functions"), Add_missing_call_parentheses: i2(95067, 3, "Add_missing_call_parentheses_95067", "Add missing call parentheses"), Add_all_missing_call_parentheses: i2(95068, 3, "Add_all_missing_call_parentheses_95068", "Add all missing call parentheses"), Add_unknown_conversion_for_non_overlapping_types: i2(95069, 3, "Add_unknown_conversion_for_non_overlapping_types_95069", "Add 'unknown' conversion for non-overlapping types"), Add_unknown_to_all_conversions_of_non_overlapping_types: i2(95070, 3, "Add_unknown_to_all_conversions_of_non_overlapping_types_95070", "Add 'unknown' to all conversions of non-overlapping types"), Add_missing_new_operator_to_call: i2(95071, 3, "Add_missing_new_operator_to_call_95071", "Add missing 'new' operator to call"), Add_missing_new_operator_to_all_calls: i2(95072, 3, "Add_missing_new_operator_to_all_calls_95072", "Add missing 'new' operator to all calls"), Add_names_to_all_parameters_without_names: i2(95073, 3, "Add_names_to_all_parameters_without_names_95073", "Add names to all parameters without names"), Enable_the_experimentalDecorators_option_in_your_configuration_file: i2(95074, 3, "Enable_the_experimentalDecorators_option_in_your_configuration_file_95074", "Enable the 'experimentalDecorators' option in your configuration file"), Convert_parameters_to_destructured_object: i2(95075, 3, "Convert_parameters_to_destructured_object_95075", "Convert parameters to destructured object"), Extract_type: i2(95077, 3, "Extract_type_95077", "Extract type"), Extract_to_type_alias: i2(95078, 3, "Extract_to_type_alias_95078", "Extract to type alias"), Extract_to_typedef: i2(95079, 3, "Extract_to_typedef_95079", "Extract to typedef"), Infer_this_type_of_0_from_usage: i2(95080, 3, "Infer_this_type_of_0_from_usage_95080", "Infer 'this' type of '{0}' from usage"), Add_const_to_unresolved_variable: i2(95081, 3, "Add_const_to_unresolved_variable_95081", "Add 'const' to unresolved variable"), Add_const_to_all_unresolved_variables: i2(95082, 3, "Add_const_to_all_unresolved_variables_95082", "Add 'const' to all unresolved variables"), Add_await: i2(95083, 3, "Add_await_95083", "Add 'await'"), Add_await_to_initializer_for_0: i2(95084, 3, "Add_await_to_initializer_for_0_95084", "Add 'await' to initializer for '{0}'"), Fix_all_expressions_possibly_missing_await: i2(95085, 3, "Fix_all_expressions_possibly_missing_await_95085", "Fix all expressions possibly missing 'await'"), Remove_unnecessary_await: i2(95086, 3, "Remove_unnecessary_await_95086", "Remove unnecessary 'await'"), Remove_all_unnecessary_uses_of_await: i2(95087, 3, "Remove_all_unnecessary_uses_of_await_95087", "Remove all unnecessary uses of 'await'"), Enable_the_jsx_flag_in_your_configuration_file: i2(95088, 3, "Enable_the_jsx_flag_in_your_configuration_file_95088", "Enable the '--jsx' flag in your configuration file"), Add_await_to_initializers: i2(95089, 3, "Add_await_to_initializers_95089", "Add 'await' to initializers"), Extract_to_interface: i2(95090, 3, "Extract_to_interface_95090", "Extract to interface"), Convert_to_a_bigint_numeric_literal: i2(95091, 3, "Convert_to_a_bigint_numeric_literal_95091", "Convert to a bigint numeric literal"), Convert_all_to_bigint_numeric_literals: i2(95092, 3, "Convert_all_to_bigint_numeric_literals_95092", "Convert all to bigint numeric literals"), Convert_const_to_let: i2(95093, 3, "Convert_const_to_let_95093", "Convert 'const' to 'let'"), Prefix_with_declare: i2(95094, 3, "Prefix_with_declare_95094", "Prefix with 'declare'"), Prefix_all_incorrect_property_declarations_with_declare: i2(95095, 3, "Prefix_all_incorrect_property_declarations_with_declare_95095", "Prefix all incorrect property declarations with 'declare'"), Convert_to_template_string: i2(95096, 3, "Convert_to_template_string_95096", "Convert to template string"), Add_export_to_make_this_file_into_a_module: i2(95097, 3, "Add_export_to_make_this_file_into_a_module_95097", "Add 'export {}' to make this file into a module"), Set_the_target_option_in_your_configuration_file_to_0: i2(95098, 3, "Set_the_target_option_in_your_configuration_file_to_0_95098", "Set the 'target' option in your configuration file to '{0}'"), Set_the_module_option_in_your_configuration_file_to_0: i2(95099, 3, "Set_the_module_option_in_your_configuration_file_to_0_95099", "Set the 'module' option in your configuration file to '{0}'"), Convert_invalid_character_to_its_html_entity_code: i2(95100, 3, "Convert_invalid_character_to_its_html_entity_code_95100", "Convert invalid character to its html entity code"), Convert_all_invalid_characters_to_HTML_entity_code: i2(95101, 3, "Convert_all_invalid_characters_to_HTML_entity_code_95101", "Convert all invalid characters to HTML entity code"), Convert_all_const_to_let: i2(95102, 3, "Convert_all_const_to_let_95102", "Convert all 'const' to 'let'"), Convert_function_expression_0_to_arrow_function: i2(95105, 3, "Convert_function_expression_0_to_arrow_function_95105", "Convert function expression '{0}' to arrow function"), Convert_function_declaration_0_to_arrow_function: i2(95106, 3, "Convert_function_declaration_0_to_arrow_function_95106", "Convert function declaration '{0}' to arrow function"), Fix_all_implicit_this_errors: i2(95107, 3, "Fix_all_implicit_this_errors_95107", "Fix all implicit-'this' errors"), Wrap_invalid_character_in_an_expression_container: i2(95108, 3, "Wrap_invalid_character_in_an_expression_container_95108", "Wrap invalid character in an expression container"), Wrap_all_invalid_characters_in_an_expression_container: i2(95109, 3, "Wrap_all_invalid_characters_in_an_expression_container_95109", "Wrap all invalid characters in an expression container"), Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file: i2(95110, 3, "Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file_95110", "Visit https://aka.ms/tsconfig to read more about this file"), Add_a_return_statement: i2(95111, 3, "Add_a_return_statement_95111", "Add a return statement"), Remove_braces_from_arrow_function_body: i2(95112, 3, "Remove_braces_from_arrow_function_body_95112", "Remove braces from arrow function body"), Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal: i2(95113, 3, "Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113", "Wrap the following body with parentheses which should be an object literal"), Add_all_missing_return_statement: i2(95114, 3, "Add_all_missing_return_statement_95114", "Add all missing return statement"), Remove_braces_from_all_arrow_function_bodies_with_relevant_issues: i2(95115, 3, "Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115", "Remove braces from all arrow function bodies with relevant issues"), Wrap_all_object_literal_with_parentheses: i2(95116, 3, "Wrap_all_object_literal_with_parentheses_95116", "Wrap all object literal with parentheses"), Move_labeled_tuple_element_modifiers_to_labels: i2(95117, 3, "Move_labeled_tuple_element_modifiers_to_labels_95117", "Move labeled tuple element modifiers to labels"), Convert_overload_list_to_single_signature: i2(95118, 3, "Convert_overload_list_to_single_signature_95118", "Convert overload list to single signature"), Generate_get_and_set_accessors_for_all_overriding_properties: i2(95119, 3, "Generate_get_and_set_accessors_for_all_overriding_properties_95119", "Generate 'get' and 'set' accessors for all overriding properties"), Wrap_in_JSX_fragment: i2(95120, 3, "Wrap_in_JSX_fragment_95120", "Wrap in JSX fragment"), Wrap_all_unparented_JSX_in_JSX_fragment: i2(95121, 3, "Wrap_all_unparented_JSX_in_JSX_fragment_95121", "Wrap all unparented JSX in JSX fragment"), Convert_arrow_function_or_function_expression: i2(95122, 3, "Convert_arrow_function_or_function_expression_95122", "Convert arrow function or function expression"), Convert_to_anonymous_function: i2(95123, 3, "Convert_to_anonymous_function_95123", "Convert to anonymous function"), Convert_to_named_function: i2(95124, 3, "Convert_to_named_function_95124", "Convert to named function"), Convert_to_arrow_function: i2(95125, 3, "Convert_to_arrow_function_95125", "Convert to arrow function"), Remove_parentheses: i2(95126, 3, "Remove_parentheses_95126", "Remove parentheses"), Could_not_find_a_containing_arrow_function: i2(95127, 3, "Could_not_find_a_containing_arrow_function_95127", "Could not find a containing arrow function"), Containing_function_is_not_an_arrow_function: i2(95128, 3, "Containing_function_is_not_an_arrow_function_95128", "Containing function is not an arrow function"), Could_not_find_export_statement: i2(95129, 3, "Could_not_find_export_statement_95129", "Could not find export statement"), This_file_already_has_a_default_export: i2(95130, 3, "This_file_already_has_a_default_export_95130", "This file already has a default export"), Could_not_find_import_clause: i2(95131, 3, "Could_not_find_import_clause_95131", "Could not find import clause"), Could_not_find_namespace_import_or_named_imports: i2(95132, 3, "Could_not_find_namespace_import_or_named_imports_95132", "Could not find namespace import or named imports"), Selection_is_not_a_valid_type_node: i2(95133, 3, "Selection_is_not_a_valid_type_node_95133", "Selection is not a valid type node"), No_type_could_be_extracted_from_this_type_node: i2(95134, 3, "No_type_could_be_extracted_from_this_type_node_95134", "No type could be extracted from this type node"), Could_not_find_property_for_which_to_generate_accessor: i2(95135, 3, "Could_not_find_property_for_which_to_generate_accessor_95135", "Could not find property for which to generate accessor"), Name_is_not_valid: i2(95136, 3, "Name_is_not_valid_95136", "Name is not valid"), Can_only_convert_property_with_modifier: i2(95137, 3, "Can_only_convert_property_with_modifier_95137", "Can only convert property with modifier"), Switch_each_misused_0_to_1: i2(95138, 3, "Switch_each_misused_0_to_1_95138", "Switch each misused '{0}' to '{1}'"), Convert_to_optional_chain_expression: i2(95139, 3, "Convert_to_optional_chain_expression_95139", "Convert to optional chain expression"), Could_not_find_convertible_access_expression: i2(95140, 3, "Could_not_find_convertible_access_expression_95140", "Could not find convertible access expression"), Could_not_find_matching_access_expressions: i2(95141, 3, "Could_not_find_matching_access_expressions_95141", "Could not find matching access expressions"), Can_only_convert_logical_AND_access_chains: i2(95142, 3, "Can_only_convert_logical_AND_access_chains_95142", "Can only convert logical AND access chains"), Add_void_to_Promise_resolved_without_a_value: i2(95143, 3, "Add_void_to_Promise_resolved_without_a_value_95143", "Add 'void' to Promise resolved without a value"), Add_void_to_all_Promises_resolved_without_a_value: i2(95144, 3, "Add_void_to_all_Promises_resolved_without_a_value_95144", "Add 'void' to all Promises resolved without a value"), Use_element_access_for_0: i2(95145, 3, "Use_element_access_for_0_95145", "Use element access for '{0}'"), Use_element_access_for_all_undeclared_properties: i2(95146, 3, "Use_element_access_for_all_undeclared_properties_95146", "Use element access for all undeclared properties."), Delete_all_unused_imports: i2(95147, 3, "Delete_all_unused_imports_95147", "Delete all unused imports"), Infer_function_return_type: i2(95148, 3, "Infer_function_return_type_95148", "Infer function return type"), Return_type_must_be_inferred_from_a_function: i2(95149, 3, "Return_type_must_be_inferred_from_a_function_95149", "Return type must be inferred from a function"), Could_not_determine_function_return_type: i2(95150, 3, "Could_not_determine_function_return_type_95150", "Could not determine function return type"), Could_not_convert_to_arrow_function: i2(95151, 3, "Could_not_convert_to_arrow_function_95151", "Could not convert to arrow function"), Could_not_convert_to_named_function: i2(95152, 3, "Could_not_convert_to_named_function_95152", "Could not convert to named function"), Could_not_convert_to_anonymous_function: i2(95153, 3, "Could_not_convert_to_anonymous_function_95153", "Could not convert to anonymous function"), Can_only_convert_string_concatenation: i2(95154, 3, "Can_only_convert_string_concatenation_95154", "Can only convert string concatenation"), Selection_is_not_a_valid_statement_or_statements: i2(95155, 3, "Selection_is_not_a_valid_statement_or_statements_95155", "Selection is not a valid statement or statements"), Add_missing_function_declaration_0: i2(95156, 3, "Add_missing_function_declaration_0_95156", "Add missing function declaration '{0}'"), Add_all_missing_function_declarations: i2(95157, 3, "Add_all_missing_function_declarations_95157", "Add all missing function declarations"), Method_not_implemented: i2(95158, 3, "Method_not_implemented_95158", "Method not implemented."), Function_not_implemented: i2(95159, 3, "Function_not_implemented_95159", "Function not implemented."), Add_override_modifier: i2(95160, 3, "Add_override_modifier_95160", "Add 'override' modifier"), Remove_override_modifier: i2(95161, 3, "Remove_override_modifier_95161", "Remove 'override' modifier"), Add_all_missing_override_modifiers: i2(95162, 3, "Add_all_missing_override_modifiers_95162", "Add all missing 'override' modifiers"), Remove_all_unnecessary_override_modifiers: i2(95163, 3, "Remove_all_unnecessary_override_modifiers_95163", "Remove all unnecessary 'override' modifiers"), Can_only_convert_named_export: i2(95164, 3, "Can_only_convert_named_export_95164", "Can only convert named export"), Add_missing_properties: i2(95165, 3, "Add_missing_properties_95165", "Add missing properties"), Add_all_missing_properties: i2(95166, 3, "Add_all_missing_properties_95166", "Add all missing properties"), Add_missing_attributes: i2(95167, 3, "Add_missing_attributes_95167", "Add missing attributes"), Add_all_missing_attributes: i2(95168, 3, "Add_all_missing_attributes_95168", "Add all missing attributes"), Add_undefined_to_optional_property_type: i2(95169, 3, "Add_undefined_to_optional_property_type_95169", "Add 'undefined' to optional property type"), Convert_named_imports_to_default_import: i2(95170, 3, "Convert_named_imports_to_default_import_95170", "Convert named imports to default import"), Delete_unused_param_tag_0: i2(95171, 3, "Delete_unused_param_tag_0_95171", "Delete unused '@param' tag '{0}'"), Delete_all_unused_param_tags: i2(95172, 3, "Delete_all_unused_param_tags_95172", "Delete all unused '@param' tags"), Rename_param_tag_name_0_to_1: i2(95173, 3, "Rename_param_tag_name_0_to_1_95173", "Rename '@param' tag name '{0}' to '{1}'"), Use_0: i2(95174, 3, "Use_0_95174", "Use `{0}`."), Use_Number_isNaN_in_all_conditions: i2(95175, 3, "Use_Number_isNaN_in_all_conditions_95175", "Use `Number.isNaN` in all conditions."), No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer: i2(18004, 1, "No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004", "No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer."), Classes_may_not_have_a_field_named_constructor: i2(18006, 1, "Classes_may_not_have_a_field_named_constructor_18006", "Classes may not have a field named 'constructor'."), JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array: i2(18007, 1, "JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007", "JSX expressions may not use the comma operator. Did you mean to write an array?"), Private_identifiers_cannot_be_used_as_parameters: i2(18009, 1, "Private_identifiers_cannot_be_used_as_parameters_18009", "Private identifiers cannot be used as parameters."), An_accessibility_modifier_cannot_be_used_with_a_private_identifier: i2(18010, 1, "An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010", "An accessibility modifier cannot be used with a private identifier."), The_operand_of_a_delete_operator_cannot_be_a_private_identifier: i2(18011, 1, "The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011", "The operand of a 'delete' operator cannot be a private identifier."), constructor_is_a_reserved_word: i2(18012, 1, "constructor_is_a_reserved_word_18012", "'#constructor' is a reserved word."), Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier: i2(18013, 1, "Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013", "Property '{0}' is not accessible outside class '{1}' because it has a private identifier."), The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling: i2(18014, 1, "The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014", "The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling."), Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2: i2(18015, 1, "Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015", "Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'."), Private_identifiers_are_not_allowed_outside_class_bodies: i2(18016, 1, "Private_identifiers_are_not_allowed_outside_class_bodies_18016", "Private identifiers are not allowed outside class bodies."), The_shadowing_declaration_of_0_is_defined_here: i2(18017, 1, "The_shadowing_declaration_of_0_is_defined_here_18017", "The shadowing declaration of '{0}' is defined here"), The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here: i2(18018, 1, "The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018", "The declaration of '{0}' that you probably intended to use is defined here"), _0_modifier_cannot_be_used_with_a_private_identifier: i2(18019, 1, "_0_modifier_cannot_be_used_with_a_private_identifier_18019", "'{0}' modifier cannot be used with a private identifier."), An_enum_member_cannot_be_named_with_a_private_identifier: i2(18024, 1, "An_enum_member_cannot_be_named_with_a_private_identifier_18024", "An enum member cannot be named with a private identifier."), can_only_be_used_at_the_start_of_a_file: i2(18026, 1, "can_only_be_used_at_the_start_of_a_file_18026", "'#!' can only be used at the start of a file."), Compiler_reserves_name_0_when_emitting_private_identifier_downlevel: i2(18027, 1, "Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027", "Compiler reserves name '{0}' when emitting private identifier downlevel."), Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher: i2(18028, 1, "Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028", "Private identifiers are only available when targeting ECMAScript 2015 and higher."), Private_identifiers_are_not_allowed_in_variable_declarations: i2(18029, 1, "Private_identifiers_are_not_allowed_in_variable_declarations_18029", "Private identifiers are not allowed in variable declarations."), An_optional_chain_cannot_contain_private_identifiers: i2(18030, 1, "An_optional_chain_cannot_contain_private_identifiers_18030", "An optional chain cannot contain private identifiers."), The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents: i2(18031, 1, "The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031", "The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents."), The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some: i2(18032, 1, "The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032", "The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some."), Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values: i2(18033, 1, "Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values_18033", "Type '{0}' is not assignable to type '{1}' as required for computed enum member values."), Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment: i2(18034, 3, "Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034", "Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'."), Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name: i2(18035, 1, "Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035", "Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name."), Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator: i2(18036, 1, "Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_dec_18036", "Class decorators can't be used with static private identifier. Consider removing the experimental decorator."), Await_expression_cannot_be_used_inside_a_class_static_block: i2(18037, 1, "Await_expression_cannot_be_used_inside_a_class_static_block_18037", "Await expression cannot be used inside a class static block."), For_await_loops_cannot_be_used_inside_a_class_static_block: i2(18038, 1, "For_await_loops_cannot_be_used_inside_a_class_static_block_18038", "'For await' loops cannot be used inside a class static block."), Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block: i2(18039, 1, "Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block_18039", "Invalid use of '{0}'. It cannot be used inside a class static block."), A_return_statement_cannot_be_used_inside_a_class_static_block: i2(18041, 1, "A_return_statement_cannot_be_used_inside_a_class_static_block_18041", "A 'return' statement cannot be used inside a class static block."), _0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation: i2(18042, 1, "_0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation_18042", "'{0}' is a type and cannot be imported in JavaScript files. Use '{1}' in a JSDoc type annotation."), Types_cannot_appear_in_export_declarations_in_JavaScript_files: i2(18043, 1, "Types_cannot_appear_in_export_declarations_in_JavaScript_files_18043", "Types cannot appear in export declarations in JavaScript files."), _0_is_automatically_exported_here: i2(18044, 3, "_0_is_automatically_exported_here_18044", "'{0}' is automatically exported here."), Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher: i2(18045, 1, "Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher_18045", "Properties with the 'accessor' modifier are only available when targeting ECMAScript 2015 and higher."), _0_is_of_type_unknown: i2(18046, 1, "_0_is_of_type_unknown_18046", "'{0}' is of type 'unknown'."), _0_is_possibly_null: i2(18047, 1, "_0_is_possibly_null_18047", "'{0}' is possibly 'null'."), _0_is_possibly_undefined: i2(18048, 1, "_0_is_possibly_undefined_18048", "'{0}' is possibly 'undefined'."), _0_is_possibly_null_or_undefined: i2(18049, 1, "_0_is_possibly_null_or_undefined_18049", "'{0}' is possibly 'null' or 'undefined'."), The_value_0_cannot_be_used_here: i2(18050, 1, "The_value_0_cannot_be_used_here_18050", "The value '{0}' cannot be used here."), Compiler_option_0_cannot_be_given_an_empty_string: i2(18051, 1, "Compiler_option_0_cannot_be_given_an_empty_string_18051", "Compiler option '{0}' cannot be given an empty string.") };
          } });
          function fr2(e) {
            return e >= 79;
          }
          function qT(e) {
            return e === 31 || fr2(e);
          }
          function D_(e, t6) {
            if (e < t6[0])
              return false;
            let r = 0, s = t6.length, f10;
            for (; r + 1 < s; ) {
              if (f10 = r + (s - r) / 2, f10 -= f10 % 2, t6[f10] <= e && e <= t6[f10 + 1])
                return true;
              e < t6[f10] ? s = f10 : r = f10 + 2;
            }
            return false;
          }
          function UT(e, t6) {
            return t6 >= 2 ? D_(e, ZT) : t6 === 1 ? D_(e, YT) : D_(e, KT);
          }
          function _A(e, t6) {
            return t6 >= 2 ? D_(e, eS) : t6 === 1 ? D_(e, QT) : D_(e, XT);
          }
          function cA(e) {
            let t6 = [];
            return e.forEach((r, s) => {
              t6[r] = s;
            }), t6;
          }
          function Br2(e) {
            return nS[e];
          }
          function _l(e) {
            return Ty.get(e);
          }
          function Kp(e) {
            let t6 = [], r = 0, s = 0;
            for (; r < e.length; ) {
              let f10 = e.charCodeAt(r);
              switch (r++, f10) {
                case 13:
                  e.charCodeAt(r) === 10 && r++;
                case 10:
                  t6.push(s), s = r;
                  break;
                default:
                  f10 > 127 && un(f10) && (t6.push(s), s = r);
                  break;
              }
            }
            return t6.push(s), t6;
          }
          function lA(e, t6, r, s) {
            return e.getPositionOfLineAndCharacter ? e.getPositionOfLineAndCharacter(t6, r, s) : dy(ss(e), t6, r, e.text, s);
          }
          function dy(e, t6, r, s, f10) {
            (t6 < 0 || t6 >= e.length) && (f10 ? t6 = t6 < 0 ? 0 : t6 >= e.length ? e.length - 1 : t6 : Y3.fail(`Bad line number. Line: ${t6}, lineStarts.length: ${e.length} , line map is correct? ${s !== void 0 ? ke2(e, Kp(s)) : "unknown"}`));
            let x10 = e[t6] + r;
            return f10 ? x10 > e[t6 + 1] ? e[t6 + 1] : typeof s == "string" && x10 > s.length ? s.length : x10 : (t6 < e.length - 1 ? Y3.assert(x10 < e[t6 + 1]) : s !== void 0 && Y3.assert(x10 <= s.length), x10);
          }
          function ss(e) {
            return e.lineMap || (e.lineMap = Kp(e.text));
          }
          function my(e, t6) {
            let r = k_(e, t6);
            return { line: r, character: t6 - e[r] };
          }
          function k_(e, t6, r) {
            let s = Ya(e, t6, rr2, Vr2, r);
            return s < 0 && (s = ~s - 1, Y3.assert(s !== -1, "position cannot precede the beginning of the file")), s;
          }
          function I_(e, t6, r) {
            if (t6 === r)
              return 0;
            let s = ss(e), f10 = Math.min(t6, r), x10 = f10 === r, w6 = x10 ? t6 : r, A6 = k_(s, f10), g9 = k_(s, w6, A6);
            return x10 ? A6 - g9 : g9 - A6;
          }
          function Ls(e, t6) {
            return my(ss(e), t6);
          }
          function os(e) {
            return N_(e) || un(e);
          }
          function N_(e) {
            return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e === 133 || e === 5760 || e >= 8192 && e <= 8203 || e === 8239 || e === 8287 || e === 12288 || e === 65279;
          }
          function un(e) {
            return e === 10 || e === 13 || e === 8232 || e === 8233;
          }
          function O_(e) {
            return e >= 48 && e <= 57;
          }
          function Xp(e) {
            return O_(e) || e >= 65 && e <= 70 || e >= 97 && e <= 102;
          }
          function uA(e) {
            return e <= 1114111;
          }
          function hy(e) {
            return e >= 48 && e <= 55;
          }
          function pA(e, t6) {
            let r = e.charCodeAt(t6);
            switch (r) {
              case 13:
              case 10:
              case 9:
              case 11:
              case 12:
              case 32:
              case 47:
              case 60:
              case 124:
              case 61:
              case 62:
                return true;
              case 35:
                return t6 === 0;
              default:
                return r > 127;
            }
          }
          function Ar2(e, t6, r, s, f10) {
            if (hs(t6))
              return t6;
            let x10 = false;
            for (; ; ) {
              let w6 = e.charCodeAt(t6);
              switch (w6) {
                case 13:
                  e.charCodeAt(t6 + 1) === 10 && t6++;
                case 10:
                  if (t6++, r)
                    return t6;
                  x10 = !!f10;
                  continue;
                case 9:
                case 11:
                case 12:
                case 32:
                  t6++;
                  continue;
                case 47:
                  if (s)
                    break;
                  if (e.charCodeAt(t6 + 1) === 47) {
                    for (t6 += 2; t6 < e.length && !un(e.charCodeAt(t6)); )
                      t6++;
                    x10 = false;
                    continue;
                  }
                  if (e.charCodeAt(t6 + 1) === 42) {
                    for (t6 += 2; t6 < e.length; ) {
                      if (e.charCodeAt(t6) === 42 && e.charCodeAt(t6 + 1) === 47) {
                        t6 += 2;
                        break;
                      }
                      t6++;
                    }
                    x10 = false;
                    continue;
                  }
                  break;
                case 60:
                case 124:
                case 61:
                case 62:
                  if (Co(e, t6)) {
                    t6 = M_(e, t6), x10 = false;
                    continue;
                  }
                  break;
                case 35:
                  if (t6 === 0 && gy(e, t6)) {
                    t6 = yy(e, t6), x10 = false;
                    continue;
                  }
                  break;
                case 42:
                  if (x10) {
                    t6++, x10 = false;
                    continue;
                  }
                  break;
                default:
                  if (w6 > 127 && os(w6)) {
                    t6++;
                    continue;
                  }
                  break;
              }
              return t6;
            }
          }
          function Co(e, t6) {
            if (Y3.assert(t6 >= 0), t6 === 0 || un(e.charCodeAt(t6 - 1))) {
              let r = e.charCodeAt(t6);
              if (t6 + ll < e.length) {
                for (let s = 0; s < ll; s++)
                  if (e.charCodeAt(t6 + s) !== r)
                    return false;
                return r === 61 || e.charCodeAt(t6 + ll) === 32;
              }
            }
            return false;
          }
          function M_(e, t6, r) {
            r && r(ve.Merge_conflict_marker_encountered, t6, ll);
            let s = e.charCodeAt(t6), f10 = e.length;
            if (s === 60 || s === 62)
              for (; t6 < f10 && !un(e.charCodeAt(t6)); )
                t6++;
            else
              for (Y3.assert(s === 124 || s === 61); t6 < f10; ) {
                let x10 = e.charCodeAt(t6);
                if ((x10 === 61 || x10 === 62) && x10 !== s && Co(e, t6))
                  break;
                t6++;
              }
            return t6;
          }
          function gy(e, t6) {
            return Y3.assert(t6 === 0), Qp.test(e);
          }
          function yy(e, t6) {
            let r = Qp.exec(e)[0];
            return t6 = t6 + r.length, t6;
          }
          function Yp(e, t6, r, s, f10, x10, w6) {
            let A6, g9, B, N10, X2 = false, F2 = s, $ = w6;
            if (r === 0) {
              F2 = true;
              let ae = GT(t6);
              ae && (r = ae.length);
            }
            e:
              for (; r >= 0 && r < t6.length; ) {
                let ae = t6.charCodeAt(r);
                switch (ae) {
                  case 13:
                    t6.charCodeAt(r + 1) === 10 && r++;
                  case 10:
                    if (r++, s)
                      break e;
                    F2 = true, X2 && (N10 = true);
                    continue;
                  case 9:
                  case 11:
                  case 12:
                  case 32:
                    r++;
                    continue;
                  case 47:
                    let Te2 = t6.charCodeAt(r + 1), Se2 = false;
                    if (Te2 === 47 || Te2 === 42) {
                      let Ye2 = Te2 === 47 ? 2 : 3, Ne2 = r;
                      if (r += 2, Te2 === 47)
                        for (; r < t6.length; ) {
                          if (un(t6.charCodeAt(r))) {
                            Se2 = true;
                            break;
                          }
                          r++;
                        }
                      else
                        for (; r < t6.length; ) {
                          if (t6.charCodeAt(r) === 42 && t6.charCodeAt(r + 1) === 47) {
                            r += 2;
                            break;
                          }
                          r++;
                        }
                      if (F2) {
                        if (X2 && ($ = f10(A6, g9, B, N10, x10, $), !e && $))
                          return $;
                        A6 = Ne2, g9 = r, B = Ye2, N10 = Se2, X2 = true;
                      }
                      continue;
                    }
                    break e;
                  default:
                    if (ae > 127 && os(ae)) {
                      X2 && un(ae) && (N10 = true), r++;
                      continue;
                    }
                    break e;
                }
              }
            return X2 && ($ = f10(A6, g9, B, N10, x10, $)), $;
          }
          function fA(e, t6, r, s) {
            return Yp(false, e, t6, false, r, s);
          }
          function dA(e, t6, r, s) {
            return Yp(false, e, t6, true, r, s);
          }
          function zT(e, t6, r, s, f10) {
            return Yp(true, e, t6, false, r, s, f10);
          }
          function WT(e, t6, r, s, f10) {
            return Yp(true, e, t6, true, r, s, f10);
          }
          function VT(e, t6, r, s, f10) {
            let x10 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
            return x10.push({ kind: r, pos: e, end: t6, hasTrailingNewLine: s }), x10;
          }
          function Ao(e, t6) {
            return zT(e, t6, VT, void 0, void 0);
          }
          function HT(e, t6) {
            return WT(e, t6, VT, void 0, void 0);
          }
          function GT(e) {
            let t6 = Qp.exec(e);
            if (t6)
              return t6[0];
          }
          function Wn(e, t6) {
            return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 36 || e === 95 || e > 127 && UT(e, t6);
          }
          function Rs(e, t6, r) {
            return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 36 || e === 95 || (r === 1 ? e === 45 || e === 58 : false) || e > 127 && _A(e, t6);
          }
          function vy(e, t6, r) {
            let s = ii(e, 0);
            if (!Wn(s, t6))
              return false;
            for (let f10 = yi(s); f10 < e.length; f10 += yi(s))
              if (!Rs(s = ii(e, f10), t6, r))
                return false;
            return true;
          }
          function Po(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = arguments.length > 3 ? arguments[3] : void 0, f10 = arguments.length > 4 ? arguments[4] : void 0, x10 = arguments.length > 5 ? arguments[5] : void 0, w6 = arguments.length > 6 ? arguments[6] : void 0;
            var A6 = s, g9, B, N10, X2, F2, $, ae, Te2, Se2 = 0;
            ue2(A6, x10, w6);
            var Ye2 = { getStartPos: () => N10, getTextPos: () => g9, getToken: () => F2, getTokenPos: () => X2, getTokenText: () => A6.substring(X2, g9), getTokenValue: () => $, hasUnicodeEscape: () => (ae & 1024) !== 0, hasExtendedUnicodeEscape: () => (ae & 8) !== 0, hasPrecedingLineBreak: () => (ae & 1) !== 0, hasPrecedingJSDocComment: () => (ae & 2) !== 0, isIdentifier: () => F2 === 79 || F2 > 116, isReservedWord: () => F2 >= 81 && F2 <= 116, isUnterminated: () => (ae & 4) !== 0, getCommentDirectives: () => Te2, getNumericLiteralFlags: () => ae & 1008, getTokenFlags: () => ae, reScanGreaterToken: Sn, reScanAsteriskEqualsToken: In, reScanSlashToken: pr2, reScanTemplateToken: Nn, reScanTemplateHeadOrNoSubstitutionTemplate: ar2, scanJsxIdentifier: nr2, scanJsxAttributeValue: br2, reScanJsxAttributeValue: Kr2, reScanJsxToken: oi, reScanLessThanToken: cr2, reScanHashToken: $r2, reScanQuestionToken: hr2, reScanInvalidIdentifier: Gr2, scanJsxToken: On, scanJsDocToken: wa, scan: Ur2, getText: Ca, clearCommentDirectives: St, setText: ue2, setScriptTarget: _t, setLanguageVariant: ft, setOnError: He2, setTextPos: Kt, setInJSDocType: zt, tryScan: _i, lookAhead: Mn, scanRange: Ki };
            return Y3.isDebugging && Object.defineProperty(Ye2, "__debugShowCurrentPositionInText", { get: () => {
              let xe2 = Ye2.getText();
              return xe2.slice(0, Ye2.getStartPos()) + "â" + xe2.slice(Ye2.getStartPos());
            } }), Ye2;
            function Ne2(xe2) {
              let Le2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : g9, Re2 = arguments.length > 2 ? arguments[2] : void 0;
              if (f10) {
                let ot2 = g9;
                g9 = Le2, f10(xe2, Re2 || 0), g9 = ot2;
              }
            }
            function oe2() {
              let xe2 = g9, Le2 = false, Re2 = false, ot2 = "";
              for (; ; ) {
                let Ct = A6.charCodeAt(g9);
                if (Ct === 95) {
                  ae |= 512, Le2 ? (Le2 = false, Re2 = true, ot2 += A6.substring(xe2, g9)) : Ne2(Re2 ? ve.Multiple_consecutive_numeric_separators_are_not_permitted : ve.Numeric_separators_are_not_allowed_here, g9, 1), g9++, xe2 = g9;
                  continue;
                }
                if (O_(Ct)) {
                  Le2 = true, Re2 = false, g9++;
                  continue;
                }
                break;
              }
              return A6.charCodeAt(g9 - 1) === 95 && Ne2(ve.Numeric_separators_are_not_allowed_here, g9 - 1, 1), ot2 + A6.substring(xe2, g9);
            }
            function Ve2() {
              let xe2 = g9, Le2 = oe2(), Re2, ot2;
              A6.charCodeAt(g9) === 46 && (g9++, Re2 = oe2());
              let Ct = g9;
              if (A6.charCodeAt(g9) === 69 || A6.charCodeAt(g9) === 101) {
                g9++, ae |= 16, (A6.charCodeAt(g9) === 43 || A6.charCodeAt(g9) === 45) && g9++;
                let It = g9, Mr2 = oe2();
                Mr2 ? (ot2 = A6.substring(Ct, It) + Mr2, Ct = g9) : Ne2(ve.Digit_expected);
              }
              let Mt;
              if (ae & 512 ? (Mt = Le2, Re2 && (Mt += "." + Re2), ot2 && (Mt += ot2)) : Mt = A6.substring(xe2, Ct), Re2 !== void 0 || ae & 16)
                return pt2(xe2, Re2 === void 0 && !!(ae & 16)), { type: 8, value: "" + +Mt };
              {
                $ = Mt;
                let It = dn();
                return pt2(xe2), { type: It, value: $ };
              }
            }
            function pt2(xe2, Le2) {
              if (!Wn(ii(A6, g9), e))
                return;
              let Re2 = g9, { length: ot2 } = an();
              ot2 === 1 && A6[Re2] === "n" ? Ne2(Le2 ? ve.A_bigint_literal_cannot_use_exponential_notation : ve.A_bigint_literal_must_be_an_integer, xe2, Re2 - xe2 + 1) : (Ne2(ve.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal, Re2, ot2), g9 = Re2);
            }
            function Gt() {
              let xe2 = g9;
              for (; hy(A6.charCodeAt(g9)); )
                g9++;
              return +A6.substring(xe2, g9);
            }
            function Nt(xe2, Le2) {
              let Re2 = er2(xe2, false, Le2);
              return Re2 ? parseInt(Re2, 16) : -1;
            }
            function Xt(xe2, Le2) {
              return er2(xe2, true, Le2);
            }
            function er2(xe2, Le2, Re2) {
              let ot2 = [], Ct = false, Mt = false;
              for (; ot2.length < xe2 || Le2; ) {
                let It = A6.charCodeAt(g9);
                if (Re2 && It === 95) {
                  ae |= 512, Ct ? (Ct = false, Mt = true) : Ne2(Mt ? ve.Multiple_consecutive_numeric_separators_are_not_permitted : ve.Numeric_separators_are_not_allowed_here, g9, 1), g9++;
                  continue;
                }
                if (Ct = Re2, It >= 65 && It <= 70)
                  It += 97 - 65;
                else if (!(It >= 48 && It <= 57 || It >= 97 && It <= 102))
                  break;
                ot2.push(It), g9++, Mt = false;
              }
              return ot2.length < xe2 && (ot2 = []), A6.charCodeAt(g9 - 1) === 95 && Ne2(ve.Numeric_separators_are_not_allowed_here, g9 - 1, 1), String.fromCharCode(...ot2);
            }
            function Tn() {
              let xe2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, Le2 = A6.charCodeAt(g9);
              g9++;
              let Re2 = "", ot2 = g9;
              for (; ; ) {
                if (g9 >= B) {
                  Re2 += A6.substring(ot2, g9), ae |= 4, Ne2(ve.Unterminated_string_literal);
                  break;
                }
                let Ct = A6.charCodeAt(g9);
                if (Ct === Le2) {
                  Re2 += A6.substring(ot2, g9), g9++;
                  break;
                }
                if (Ct === 92 && !xe2) {
                  Re2 += A6.substring(ot2, g9), Re2 += Gi(), ot2 = g9;
                  continue;
                }
                if (un(Ct) && !xe2) {
                  Re2 += A6.substring(ot2, g9), ae |= 4, Ne2(ve.Unterminated_string_literal);
                  break;
                }
                g9++;
              }
              return Re2;
            }
            function Hr2(xe2) {
              let Le2 = A6.charCodeAt(g9) === 96;
              g9++;
              let Re2 = g9, ot2 = "", Ct;
              for (; ; ) {
                if (g9 >= B) {
                  ot2 += A6.substring(Re2, g9), ae |= 4, Ne2(ve.Unterminated_template_literal), Ct = Le2 ? 14 : 17;
                  break;
                }
                let Mt = A6.charCodeAt(g9);
                if (Mt === 96) {
                  ot2 += A6.substring(Re2, g9), g9++, Ct = Le2 ? 14 : 17;
                  break;
                }
                if (Mt === 36 && g9 + 1 < B && A6.charCodeAt(g9 + 1) === 123) {
                  ot2 += A6.substring(Re2, g9), g9 += 2, Ct = Le2 ? 15 : 16;
                  break;
                }
                if (Mt === 92) {
                  ot2 += A6.substring(Re2, g9), ot2 += Gi(xe2), Re2 = g9;
                  continue;
                }
                if (Mt === 13) {
                  ot2 += A6.substring(Re2, g9), g9++, g9 < B && A6.charCodeAt(g9) === 10 && g9++, ot2 += `
`, Re2 = g9;
                  continue;
                }
                g9++;
              }
              return Y3.assert(Ct !== void 0), $ = ot2, Ct;
            }
            function Gi(xe2) {
              let Le2 = g9;
              if (g9++, g9 >= B)
                return Ne2(ve.Unexpected_end_of_text), "";
              let Re2 = A6.charCodeAt(g9);
              switch (g9++, Re2) {
                case 48:
                  return xe2 && g9 < B && O_(A6.charCodeAt(g9)) ? (g9++, ae |= 2048, A6.substring(Le2, g9)) : "\0";
                case 98:
                  return "\b";
                case 116:
                  return "	";
                case 110:
                  return `
`;
                case 118:
                  return "\v";
                case 102:
                  return "\f";
                case 114:
                  return "\r";
                case 39:
                  return "'";
                case 34:
                  return '"';
                case 117:
                  if (xe2) {
                    for (let ot2 = g9; ot2 < g9 + 4; ot2++)
                      if (ot2 < B && !Xp(A6.charCodeAt(ot2)) && A6.charCodeAt(ot2) !== 123)
                        return g9 = ot2, ae |= 2048, A6.substring(Le2, g9);
                  }
                  if (g9 < B && A6.charCodeAt(g9) === 123) {
                    if (g9++, xe2 && !Xp(A6.charCodeAt(g9)))
                      return ae |= 2048, A6.substring(Le2, g9);
                    if (xe2) {
                      let ot2 = g9, Ct = Xt(1, false), Mt = Ct ? parseInt(Ct, 16) : -1;
                      if (!uA(Mt) || A6.charCodeAt(g9) !== 125)
                        return ae |= 2048, A6.substring(Le2, g9);
                      g9 = ot2;
                    }
                    return ae |= 8, fn();
                  }
                  return ae |= 1024, pn(4);
                case 120:
                  if (xe2)
                    if (Xp(A6.charCodeAt(g9))) {
                      if (!Xp(A6.charCodeAt(g9 + 1)))
                        return g9++, ae |= 2048, A6.substring(Le2, g9);
                    } else
                      return ae |= 2048, A6.substring(Le2, g9);
                  return pn(2);
                case 13:
                  g9 < B && A6.charCodeAt(g9) === 10 && g9++;
                case 10:
                case 8232:
                case 8233:
                  return "";
                default:
                  return String.fromCharCode(Re2);
              }
            }
            function pn(xe2) {
              let Le2 = Nt(xe2, false);
              return Le2 >= 0 ? String.fromCharCode(Le2) : (Ne2(ve.Hexadecimal_digit_expected), "");
            }
            function fn() {
              let xe2 = Xt(1, false), Le2 = xe2 ? parseInt(xe2, 16) : -1, Re2 = false;
              return Le2 < 0 ? (Ne2(ve.Hexadecimal_digit_expected), Re2 = true) : Le2 > 1114111 && (Ne2(ve.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive), Re2 = true), g9 >= B ? (Ne2(ve.Unexpected_end_of_text), Re2 = true) : A6.charCodeAt(g9) === 125 ? g9++ : (Ne2(ve.Unterminated_Unicode_escape_sequence), Re2 = true), Re2 ? "" : by(Le2);
            }
            function Ut() {
              if (g9 + 5 < B && A6.charCodeAt(g9 + 1) === 117) {
                let xe2 = g9;
                g9 += 2;
                let Le2 = Nt(4, false);
                return g9 = xe2, Le2;
              }
              return -1;
            }
            function kn() {
              if (ii(A6, g9 + 1) === 117 && ii(A6, g9 + 2) === 123) {
                let xe2 = g9;
                g9 += 3;
                let Le2 = Xt(1, false), Re2 = Le2 ? parseInt(Le2, 16) : -1;
                return g9 = xe2, Re2;
              }
              return -1;
            }
            function an() {
              let xe2 = "", Le2 = g9;
              for (; g9 < B; ) {
                let Re2 = ii(A6, g9);
                if (Rs(Re2, e))
                  g9 += yi(Re2);
                else if (Re2 === 92) {
                  if (Re2 = kn(), Re2 >= 0 && Rs(Re2, e)) {
                    g9 += 3, ae |= 8, xe2 += fn(), Le2 = g9;
                    continue;
                  }
                  if (Re2 = Ut(), !(Re2 >= 0 && Rs(Re2, e)))
                    break;
                  ae |= 1024, xe2 += A6.substring(Le2, g9), xe2 += by(Re2), g9 += 6, Le2 = g9;
                } else
                  break;
              }
              return xe2 += A6.substring(Le2, g9), xe2;
            }
            function mr2() {
              let xe2 = $.length;
              if (xe2 >= 2 && xe2 <= 12) {
                let Le2 = $.charCodeAt(0);
                if (Le2 >= 97 && Le2 <= 122) {
                  let Re2 = $T.get($);
                  if (Re2 !== void 0)
                    return F2 = Re2;
                }
              }
              return F2 = 79;
            }
            function $i(xe2) {
              let Le2 = "", Re2 = false, ot2 = false;
              for (; ; ) {
                let Ct = A6.charCodeAt(g9);
                if (Ct === 95) {
                  ae |= 512, Re2 ? (Re2 = false, ot2 = true) : Ne2(ot2 ? ve.Multiple_consecutive_numeric_separators_are_not_permitted : ve.Numeric_separators_are_not_allowed_here, g9, 1), g9++;
                  continue;
                }
                if (Re2 = true, !O_(Ct) || Ct - 48 >= xe2)
                  break;
                Le2 += A6[g9], g9++, ot2 = false;
              }
              return A6.charCodeAt(g9 - 1) === 95 && Ne2(ve.Numeric_separators_are_not_allowed_here, g9 - 1, 1), Le2;
            }
            function dn() {
              return A6.charCodeAt(g9) === 110 ? ($ += "n", ae & 384 && ($ = Hf($) + "n"), g9++, 9) : ($ = "" + (ae & 128 ? parseInt($.slice(2), 2) : ae & 256 ? parseInt($.slice(2), 8) : +$), 8);
            }
            function Ur2() {
              N10 = g9, ae = 0;
              let xe2 = false;
              for (; ; ) {
                if (X2 = g9, g9 >= B)
                  return F2 = 1;
                let Le2 = ii(A6, g9);
                if (Le2 === 35 && g9 === 0 && gy(A6, g9)) {
                  if (g9 = yy(A6, g9), t6)
                    continue;
                  return F2 = 6;
                }
                switch (Le2) {
                  case 10:
                  case 13:
                    if (ae |= 1, t6) {
                      g9++;
                      continue;
                    } else
                      return Le2 === 13 && g9 + 1 < B && A6.charCodeAt(g9 + 1) === 10 ? g9 += 2 : g9++, F2 = 4;
                  case 9:
                  case 11:
                  case 12:
                  case 32:
                  case 160:
                  case 5760:
                  case 8192:
                  case 8193:
                  case 8194:
                  case 8195:
                  case 8196:
                  case 8197:
                  case 8198:
                  case 8199:
                  case 8200:
                  case 8201:
                  case 8202:
                  case 8203:
                  case 8239:
                  case 8287:
                  case 12288:
                  case 65279:
                    if (t6) {
                      g9++;
                      continue;
                    } else {
                      for (; g9 < B && N_(A6.charCodeAt(g9)); )
                        g9++;
                      return F2 = 5;
                    }
                  case 33:
                    return A6.charCodeAt(g9 + 1) === 61 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 37) : (g9 += 2, F2 = 35) : (g9++, F2 = 53);
                  case 34:
                  case 39:
                    return $ = Tn(), F2 = 10;
                  case 96:
                    return F2 = Hr2(false);
                  case 37:
                    return A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 69) : (g9++, F2 = 44);
                  case 38:
                    return A6.charCodeAt(g9 + 1) === 38 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 76) : (g9 += 2, F2 = 55) : A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 73) : (g9++, F2 = 50);
                  case 40:
                    return g9++, F2 = 20;
                  case 41:
                    return g9++, F2 = 21;
                  case 42:
                    if (A6.charCodeAt(g9 + 1) === 61)
                      return g9 += 2, F2 = 66;
                    if (A6.charCodeAt(g9 + 1) === 42)
                      return A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 67) : (g9 += 2, F2 = 42);
                    if (g9++, Se2 && !xe2 && ae & 1) {
                      xe2 = true;
                      continue;
                    }
                    return F2 = 41;
                  case 43:
                    return A6.charCodeAt(g9 + 1) === 43 ? (g9 += 2, F2 = 45) : A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 64) : (g9++, F2 = 39);
                  case 44:
                    return g9++, F2 = 27;
                  case 45:
                    return A6.charCodeAt(g9 + 1) === 45 ? (g9 += 2, F2 = 46) : A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 65) : (g9++, F2 = 40);
                  case 46:
                    return O_(A6.charCodeAt(g9 + 1)) ? ($ = Ve2().value, F2 = 8) : A6.charCodeAt(g9 + 1) === 46 && A6.charCodeAt(g9 + 2) === 46 ? (g9 += 3, F2 = 25) : (g9++, F2 = 24);
                  case 47:
                    if (A6.charCodeAt(g9 + 1) === 47) {
                      for (g9 += 2; g9 < B && !un(A6.charCodeAt(g9)); )
                        g9++;
                      if (Te2 = Zt(Te2, A6.slice(X2, g9), tS, X2), t6)
                        continue;
                      return F2 = 2;
                    }
                    if (A6.charCodeAt(g9 + 1) === 42) {
                      g9 += 2, A6.charCodeAt(g9) === 42 && A6.charCodeAt(g9 + 1) !== 47 && (ae |= 2);
                      let Mr2 = false, gr2 = X2;
                      for (; g9 < B; ) {
                        let Ln = A6.charCodeAt(g9);
                        if (Ln === 42 && A6.charCodeAt(g9 + 1) === 47) {
                          g9 += 2, Mr2 = true;
                          break;
                        }
                        g9++, un(Ln) && (gr2 = g9, ae |= 1);
                      }
                      if (Te2 = Zt(Te2, A6.slice(gr2, g9), rS, gr2), Mr2 || Ne2(ve.Asterisk_Slash_expected), t6)
                        continue;
                      return Mr2 || (ae |= 4), F2 = 3;
                    }
                    return A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 68) : (g9++, F2 = 43);
                  case 48:
                    if (g9 + 2 < B && (A6.charCodeAt(g9 + 1) === 88 || A6.charCodeAt(g9 + 1) === 120))
                      return g9 += 2, $ = Xt(1, true), $ || (Ne2(ve.Hexadecimal_digit_expected), $ = "0"), $ = "0x" + $, ae |= 64, F2 = dn();
                    if (g9 + 2 < B && (A6.charCodeAt(g9 + 1) === 66 || A6.charCodeAt(g9 + 1) === 98))
                      return g9 += 2, $ = $i(2), $ || (Ne2(ve.Binary_digit_expected), $ = "0"), $ = "0b" + $, ae |= 128, F2 = dn();
                    if (g9 + 2 < B && (A6.charCodeAt(g9 + 1) === 79 || A6.charCodeAt(g9 + 1) === 111))
                      return g9 += 2, $ = $i(8), $ || (Ne2(ve.Octal_digit_expected), $ = "0"), $ = "0o" + $, ae |= 256, F2 = dn();
                    if (g9 + 1 < B && hy(A6.charCodeAt(g9 + 1)))
                      return $ = "" + Gt(), ae |= 32, F2 = 8;
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return { type: F2, value: $ } = Ve2(), F2;
                  case 58:
                    return g9++, F2 = 58;
                  case 59:
                    return g9++, F2 = 26;
                  case 60:
                    if (Co(A6, g9)) {
                      if (g9 = M_(A6, g9, Ne2), t6)
                        continue;
                      return F2 = 7;
                    }
                    return A6.charCodeAt(g9 + 1) === 60 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 70) : (g9 += 2, F2 = 47) : A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 32) : r === 1 && A6.charCodeAt(g9 + 1) === 47 && A6.charCodeAt(g9 + 2) !== 42 ? (g9 += 2, F2 = 30) : (g9++, F2 = 29);
                  case 61:
                    if (Co(A6, g9)) {
                      if (g9 = M_(A6, g9, Ne2), t6)
                        continue;
                      return F2 = 7;
                    }
                    return A6.charCodeAt(g9 + 1) === 61 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 36) : (g9 += 2, F2 = 34) : A6.charCodeAt(g9 + 1) === 62 ? (g9 += 2, F2 = 38) : (g9++, F2 = 63);
                  case 62:
                    if (Co(A6, g9)) {
                      if (g9 = M_(A6, g9, Ne2), t6)
                        continue;
                      return F2 = 7;
                    }
                    return g9++, F2 = 31;
                  case 63:
                    return A6.charCodeAt(g9 + 1) === 46 && !O_(A6.charCodeAt(g9 + 2)) ? (g9 += 2, F2 = 28) : A6.charCodeAt(g9 + 1) === 63 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 77) : (g9 += 2, F2 = 60) : (g9++, F2 = 57);
                  case 91:
                    return g9++, F2 = 22;
                  case 93:
                    return g9++, F2 = 23;
                  case 94:
                    return A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 78) : (g9++, F2 = 52);
                  case 123:
                    return g9++, F2 = 18;
                  case 124:
                    if (Co(A6, g9)) {
                      if (g9 = M_(A6, g9, Ne2), t6)
                        continue;
                      return F2 = 7;
                    }
                    return A6.charCodeAt(g9 + 1) === 124 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 75) : (g9 += 2, F2 = 56) : A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 74) : (g9++, F2 = 51);
                  case 125:
                    return g9++, F2 = 19;
                  case 126:
                    return g9++, F2 = 54;
                  case 64:
                    return g9++, F2 = 59;
                  case 92:
                    let Re2 = kn();
                    if (Re2 >= 0 && Wn(Re2, e))
                      return g9 += 3, ae |= 8, $ = fn() + an(), F2 = mr2();
                    let ot2 = Ut();
                    return ot2 >= 0 && Wn(ot2, e) ? (g9 += 6, ae |= 1024, $ = String.fromCharCode(ot2) + an(), F2 = mr2()) : (Ne2(ve.Invalid_character), g9++, F2 = 0);
                  case 35:
                    if (g9 !== 0 && A6[g9 + 1] === "!")
                      return Ne2(ve.can_only_be_used_at_the_start_of_a_file), g9++, F2 = 0;
                    let Ct = ii(A6, g9 + 1);
                    if (Ct === 92) {
                      g9++;
                      let Mr2 = kn();
                      if (Mr2 >= 0 && Wn(Mr2, e))
                        return g9 += 3, ae |= 8, $ = "#" + fn() + an(), F2 = 80;
                      let gr2 = Ut();
                      if (gr2 >= 0 && Wn(gr2, e))
                        return g9 += 6, ae |= 1024, $ = "#" + String.fromCharCode(gr2) + an(), F2 = 80;
                      g9--;
                    }
                    return Wn(Ct, e) ? (g9++, _r2(Ct, e)) : ($ = "#", Ne2(ve.Invalid_character, g9++, yi(Le2))), F2 = 80;
                  default:
                    let Mt = _r2(Le2, e);
                    if (Mt)
                      return F2 = Mt;
                    if (N_(Le2)) {
                      g9 += yi(Le2);
                      continue;
                    } else if (un(Le2)) {
                      ae |= 1, g9 += yi(Le2);
                      continue;
                    }
                    let It = yi(Le2);
                    return Ne2(ve.Invalid_character, g9, It), g9 += It, F2 = 0;
                }
              }
            }
            function Gr2() {
              Y3.assert(F2 === 0, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'."), g9 = X2 = N10, ae = 0;
              let xe2 = ii(A6, g9), Le2 = _r2(xe2, 99);
              return Le2 ? F2 = Le2 : (g9 += yi(xe2), F2);
            }
            function _r2(xe2, Le2) {
              let Re2 = xe2;
              if (Wn(Re2, Le2)) {
                for (g9 += yi(Re2); g9 < B && Rs(Re2 = ii(A6, g9), Le2); )
                  g9 += yi(Re2);
                return $ = A6.substring(X2, g9), Re2 === 92 && ($ += an()), mr2();
              }
            }
            function Sn() {
              if (F2 === 31) {
                if (A6.charCodeAt(g9) === 62)
                  return A6.charCodeAt(g9 + 1) === 62 ? A6.charCodeAt(g9 + 2) === 61 ? (g9 += 3, F2 = 72) : (g9 += 2, F2 = 49) : A6.charCodeAt(g9 + 1) === 61 ? (g9 += 2, F2 = 71) : (g9++, F2 = 48);
                if (A6.charCodeAt(g9) === 61)
                  return g9++, F2 = 33;
              }
              return F2;
            }
            function In() {
              return Y3.assert(F2 === 66, "'reScanAsteriskEqualsToken' should only be called on a '*='"), g9 = X2 + 1, F2 = 63;
            }
            function pr2() {
              if (F2 === 43 || F2 === 68) {
                let xe2 = X2 + 1, Le2 = false, Re2 = false;
                for (; ; ) {
                  if (xe2 >= B) {
                    ae |= 4, Ne2(ve.Unterminated_regular_expression_literal);
                    break;
                  }
                  let ot2 = A6.charCodeAt(xe2);
                  if (un(ot2)) {
                    ae |= 4, Ne2(ve.Unterminated_regular_expression_literal);
                    break;
                  }
                  if (Le2)
                    Le2 = false;
                  else if (ot2 === 47 && !Re2) {
                    xe2++;
                    break;
                  } else
                    ot2 === 91 ? Re2 = true : ot2 === 92 ? Le2 = true : ot2 === 93 && (Re2 = false);
                  xe2++;
                }
                for (; xe2 < B && Rs(A6.charCodeAt(xe2), e); )
                  xe2++;
                g9 = xe2, $ = A6.substring(X2, g9), F2 = 13;
              }
              return F2;
            }
            function Zt(xe2, Le2, Re2, ot2) {
              let Ct = Or2(nl(Le2), Re2);
              return Ct === void 0 ? xe2 : tr2(xe2, { range: { pos: ot2, end: g9 }, type: Ct });
            }
            function Or2(xe2, Le2) {
              let Re2 = Le2.exec(xe2);
              if (Re2)
                switch (Re2[1]) {
                  case "ts-expect-error":
                    return 0;
                  case "ts-ignore":
                    return 1;
                }
            }
            function Nn(xe2) {
              return Y3.assert(F2 === 19, "'reScanTemplateToken' should only be called on a '}'"), g9 = X2, F2 = Hr2(xe2);
            }
            function ar2() {
              return g9 = X2, F2 = Hr2(true);
            }
            function oi() {
              let xe2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              return g9 = X2 = N10, F2 = On(xe2);
            }
            function cr2() {
              return F2 === 47 ? (g9 = X2 + 1, F2 = 29) : F2;
            }
            function $r2() {
              return F2 === 80 ? (g9 = X2 + 1, F2 = 62) : F2;
            }
            function hr2() {
              return Y3.assert(F2 === 60, "'reScanQuestionToken' should only be called on a '??'"), g9 = X2 + 1, F2 = 57;
            }
            function On() {
              let xe2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              if (N10 = X2 = g9, g9 >= B)
                return F2 = 1;
              let Le2 = A6.charCodeAt(g9);
              if (Le2 === 60)
                return A6.charCodeAt(g9 + 1) === 47 ? (g9 += 2, F2 = 30) : (g9++, F2 = 29);
              if (Le2 === 123)
                return g9++, F2 = 18;
              let Re2 = 0;
              for (; g9 < B && (Le2 = A6.charCodeAt(g9), Le2 !== 123); ) {
                if (Le2 === 60) {
                  if (Co(A6, g9))
                    return g9 = M_(A6, g9, Ne2), F2 = 7;
                  break;
                }
                if (Le2 === 62 && Ne2(ve.Unexpected_token_Did_you_mean_or_gt, g9, 1), Le2 === 125 && Ne2(ve.Unexpected_token_Did_you_mean_or_rbrace, g9, 1), un(Le2) && Re2 === 0)
                  Re2 = -1;
                else {
                  if (!xe2 && un(Le2) && Re2 > 0)
                    break;
                  os(Le2) || (Re2 = g9);
                }
                g9++;
              }
              return $ = A6.substring(N10, g9), Re2 === -1 ? 12 : 11;
            }
            function nr2() {
              if (fr2(F2)) {
                let xe2 = false;
                for (; g9 < B; ) {
                  let Le2 = A6.charCodeAt(g9);
                  if (Le2 === 45) {
                    $ += "-", g9++;
                    continue;
                  } else if (Le2 === 58 && !xe2) {
                    $ += ":", g9++, xe2 = true, F2 = 79;
                    continue;
                  }
                  let Re2 = g9;
                  if ($ += an(), g9 === Re2)
                    break;
                }
                return $.slice(-1) === ":" && ($ = $.slice(0, -1), g9--), mr2();
              }
              return F2;
            }
            function br2() {
              switch (N10 = g9, A6.charCodeAt(g9)) {
                case 34:
                case 39:
                  return $ = Tn(true), F2 = 10;
                default:
                  return Ur2();
              }
            }
            function Kr2() {
              return g9 = X2 = N10, br2();
            }
            function wa() {
              if (N10 = X2 = g9, ae = 0, g9 >= B)
                return F2 = 1;
              let xe2 = ii(A6, g9);
              switch (g9 += yi(xe2), xe2) {
                case 9:
                case 11:
                case 12:
                case 32:
                  for (; g9 < B && N_(A6.charCodeAt(g9)); )
                    g9++;
                  return F2 = 5;
                case 64:
                  return F2 = 59;
                case 13:
                  A6.charCodeAt(g9) === 10 && g9++;
                case 10:
                  return ae |= 1, F2 = 4;
                case 42:
                  return F2 = 41;
                case 123:
                  return F2 = 18;
                case 125:
                  return F2 = 19;
                case 91:
                  return F2 = 22;
                case 93:
                  return F2 = 23;
                case 60:
                  return F2 = 29;
                case 62:
                  return F2 = 31;
                case 61:
                  return F2 = 63;
                case 44:
                  return F2 = 27;
                case 46:
                  return F2 = 24;
                case 96:
                  return F2 = 61;
                case 35:
                  return F2 = 62;
                case 92:
                  g9--;
                  let Le2 = kn();
                  if (Le2 >= 0 && Wn(Le2, e))
                    return g9 += 3, ae |= 8, $ = fn() + an(), F2 = mr2();
                  let Re2 = Ut();
                  return Re2 >= 0 && Wn(Re2, e) ? (g9 += 6, ae |= 1024, $ = String.fromCharCode(Re2) + an(), F2 = mr2()) : (g9++, F2 = 0);
              }
              if (Wn(xe2, e)) {
                let Le2 = xe2;
                for (; g9 < B && Rs(Le2 = ii(A6, g9), e) || A6.charCodeAt(g9) === 45; )
                  g9 += yi(Le2);
                return $ = A6.substring(X2, g9), Le2 === 92 && ($ += an()), F2 = mr2();
              } else
                return F2 = 0;
            }
            function $n(xe2, Le2) {
              let Re2 = g9, ot2 = N10, Ct = X2, Mt = F2, It = $, Mr2 = ae, gr2 = xe2();
              return (!gr2 || Le2) && (g9 = Re2, N10 = ot2, X2 = Ct, F2 = Mt, $ = It, ae = Mr2), gr2;
            }
            function Ki(xe2, Le2, Re2) {
              let ot2 = B, Ct = g9, Mt = N10, It = X2, Mr2 = F2, gr2 = $, Ln = ae, ys = Te2;
              ue2(A6, xe2, Le2);
              let ci = Re2();
              return B = ot2, g9 = Ct, N10 = Mt, X2 = It, F2 = Mr2, $ = gr2, ae = Ln, Te2 = ys, ci;
            }
            function Mn(xe2) {
              return $n(xe2, true);
            }
            function _i(xe2) {
              return $n(xe2, false);
            }
            function Ca() {
              return A6;
            }
            function St() {
              Te2 = void 0;
            }
            function ue2(xe2, Le2, Re2) {
              A6 = xe2 || "", B = Re2 === void 0 ? A6.length : Le2 + Re2, Kt(Le2 || 0);
            }
            function He2(xe2) {
              f10 = xe2;
            }
            function _t(xe2) {
              e = xe2;
            }
            function ft(xe2) {
              r = xe2;
            }
            function Kt(xe2) {
              Y3.assert(xe2 >= 0), g9 = xe2, N10 = xe2, X2 = xe2, F2 = 0, $ = void 0, ae = 0;
            }
            function zt(xe2) {
              Se2 += xe2 ? 1 : -1;
            }
          }
          function yi(e) {
            return e >= 65536 ? 2 : 1;
          }
          function mA(e) {
            if (Y3.assert(0 <= e && e <= 1114111), e <= 65535)
              return String.fromCharCode(e);
            let t6 = Math.floor((e - 65536) / 1024) + 55296, r = (e - 65536) % 1024 + 56320;
            return String.fromCharCode(t6, r);
          }
          function by(e) {
            return iS(e);
          }
          var cl, $T, Ty, KT, XT, YT, QT, ZT, eS, tS, rS, nS, ll, Qp, ii, iS, hA = D({ "src/compiler/scanner.ts"() {
            "use strict";
            nn(), cl = { abstract: 126, accessor: 127, any: 131, as: 128, asserts: 129, assert: 130, bigint: 160, boolean: 134, break: 81, case: 82, catch: 83, class: 84, continue: 86, const: 85, constructor: 135, debugger: 87, declare: 136, default: 88, delete: 89, do: 90, else: 91, enum: 92, export: 93, extends: 94, false: 95, finally: 96, for: 97, from: 158, function: 98, get: 137, if: 99, implements: 117, import: 100, in: 101, infer: 138, instanceof: 102, interface: 118, intrinsic: 139, is: 140, keyof: 141, let: 119, module: 142, namespace: 143, never: 144, new: 103, null: 104, number: 148, object: 149, package: 120, private: 121, protected: 122, public: 123, override: 161, out: 145, readonly: 146, require: 147, global: 159, return: 105, satisfies: 150, set: 151, static: 124, string: 152, super: 106, switch: 107, symbol: 153, this: 108, throw: 109, true: 110, try: 111, type: 154, typeof: 112, undefined: 155, unique: 156, unknown: 157, var: 113, void: 114, while: 115, with: 116, yield: 125, async: 132, await: 133, of: 162 }, $T = new Map(Object.entries(cl)), Ty = new Map(Object.entries(Object.assign(Object.assign({}, cl), {}, { "{": 18, "}": 19, "(": 20, ")": 21, "[": 22, "]": 23, ".": 24, "...": 25, ";": 26, ",": 27, "<": 29, ">": 31, "<=": 32, ">=": 33, "==": 34, "!=": 35, "===": 36, "!==": 37, "=>": 38, "+": 39, "-": 40, "**": 42, "*": 41, "/": 43, "%": 44, "++": 45, "--": 46, "<<": 47, "</": 30, ">>": 48, ">>>": 49, "&": 50, "|": 51, "^": 52, "!": 53, "~": 54, "&&": 55, "||": 56, "?": 57, "??": 60, "?.": 28, ":": 58, "=": 63, "+=": 64, "-=": 65, "*=": 66, "**=": 67, "/=": 68, "%=": 69, "<<=": 70, ">>=": 71, ">>>=": 72, "&=": 73, "|=": 74, "^=": 78, "||=": 75, "&&=": 76, "??=": 77, "@": 59, "#": 62, "`": 61 }))), KT = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], XT = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], YT = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43e3, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], QT = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43e3, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], ZT = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2208, 2228, 2230, 2237, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69376, 69404, 69415, 69415, 69424, 69445, 69600, 69622, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70751, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71680, 71723, 71840, 71903, 71935, 71935, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 123136, 123180, 123191, 123197, 123214, 123214, 123584, 123627, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101], eS = [48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2208, 2228, 2230, 2237, 2259, 2273, 2275, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3328, 3331, 3333, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7673, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43047, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69376, 69404, 69415, 69415, 69424, 69456, 69600, 69622, 69632, 69702, 69734, 69743, 69759, 69818, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69958, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70096, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70206, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70751, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71680, 71738, 71840, 71913, 71935, 71935, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 119141, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123584, 123641, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999], tS = /^\/\/\/?\s*@(ts-expect-error|ts-ignore)/, rS = /^(?:\/|\*)*\s*@(ts-expect-error|ts-ignore)/, nS = cA(Ty), ll = 7, Qp = /^#!.*/, ii = String.prototype.codePointAt ? (e, t6) => e.codePointAt(t6) : function(t6, r) {
              let s = t6.length;
              if (r < 0 || r >= s)
                return;
              let f10 = t6.charCodeAt(r);
              if (f10 >= 55296 && f10 <= 56319 && s > r + 1) {
                let x10 = t6.charCodeAt(r + 1);
                if (x10 >= 56320 && x10 <= 57343)
                  return (f10 - 55296) * 1024 + x10 - 56320 + 65536;
              }
              return f10;
            }, iS = String.fromCodePoint ? (e) => String.fromCodePoint(e) : mA;
          } });
          function gA(e) {
            return So(e) || A_(e);
          }
          function yA(e) {
            return uo(e, av);
          }
          function aS(e) {
            switch (Uf(e)) {
              case 99:
                return "lib.esnext.full.d.ts";
              case 9:
                return "lib.es2022.full.d.ts";
              case 8:
                return "lib.es2021.full.d.ts";
              case 7:
                return "lib.es2020.full.d.ts";
              case 6:
                return "lib.es2019.full.d.ts";
              case 5:
                return "lib.es2018.full.d.ts";
              case 4:
                return "lib.es2017.full.d.ts";
              case 3:
                return "lib.es2016.full.d.ts";
              case 2:
                return "lib.es6.d.ts";
              default:
                return "lib.d.ts";
            }
          }
          function Ir2(e) {
            return e.start + e.length;
          }
          function sS(e) {
            return e.length === 0;
          }
          function vA(e, t6) {
            return t6 >= e.start && t6 < Ir2(e);
          }
          function bA(e, t6) {
            return t6 >= e.pos && t6 <= e.end;
          }
          function TA(e, t6) {
            return t6.start >= e.start && Ir2(t6) <= Ir2(e);
          }
          function SA(e, t6) {
            return oS(e, t6) !== void 0;
          }
          function oS(e, t6) {
            let r = _S(e, t6);
            return r && r.length === 0 ? void 0 : r;
          }
          function xA(e, t6) {
            return Sy(e.start, e.length, t6.start, t6.length);
          }
          function EA(e, t6, r) {
            return Sy(e.start, e.length, t6, r);
          }
          function Sy(e, t6, r, s) {
            let f10 = e + t6, x10 = r + s;
            return r <= f10 && x10 >= e;
          }
          function wA(e, t6) {
            return t6 <= Ir2(e) && t6 >= e.start;
          }
          function _S(e, t6) {
            let r = Math.max(e.start, t6.start), s = Math.min(Ir2(e), Ir2(t6));
            return r <= s ? ha(r, s) : void 0;
          }
          function L_(e, t6) {
            if (e < 0)
              throw new Error("start < 0");
            if (t6 < 0)
              throw new Error("length < 0");
            return { start: e, length: t6 };
          }
          function ha(e, t6) {
            return L_(e, t6 - e);
          }
          function R_(e) {
            return L_(e.span.start, e.newLength);
          }
          function cS(e) {
            return sS(e.span) && e.newLength === 0;
          }
          function Zp(e, t6) {
            if (t6 < 0)
              throw new Error("newLength < 0");
            return { span: e, newLength: t6 };
          }
          function CA(e) {
            if (e.length === 0)
              return Vy;
            if (e.length === 1)
              return e[0];
            let t6 = e[0], r = t6.span.start, s = Ir2(t6.span), f10 = r + t6.newLength;
            for (let x10 = 1; x10 < e.length; x10++) {
              let w6 = e[x10], A6 = r, g9 = s, B = f10, N10 = w6.span.start, X2 = Ir2(w6.span), F2 = N10 + w6.newLength;
              r = Math.min(A6, N10), s = Math.max(g9, g9 + (X2 - B)), f10 = Math.max(F2, F2 + (B - X2));
            }
            return Zp(ha(r, s), f10 - r);
          }
          function AA(e) {
            if (e && e.kind === 165) {
              for (let t6 = e; t6; t6 = t6.parent)
                if (ga(t6) || bi(t6) || t6.kind === 261)
                  return t6;
            }
          }
          function lS(e, t6) {
            return Vs(e) && rn(e, 16476) && t6.kind === 173;
          }
          function uS(e) {
            return df(e) ? me2(e.elements, pS) : false;
          }
          function pS(e) {
            return cd(e) ? true : uS(e.name);
          }
          function fS(e) {
            let t6 = e.parent;
            for (; Xl(t6.parent); )
              t6 = t6.parent.parent;
            return t6.parent;
          }
          function xy(e, t6) {
            Xl(e) && (e = fS(e));
            let r = t6(e);
            return e.kind === 257 && (e = e.parent), e && e.kind === 258 && (r |= t6(e), e = e.parent), e && e.kind === 240 && (r |= t6(e)), r;
          }
          function ef(e) {
            return xy(e, Rf);
          }
          function PA(e) {
            return xy(e, K4);
          }
          function tf2(e) {
            return xy(e, (t6) => t6.flags);
          }
          function DA(e, t6, r) {
            let s = e.toLowerCase(), f10 = /^([a-z]+)([_\-]([a-z]+))?$/.exec(s);
            if (!f10) {
              r && r.push(Ol(ve.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"));
              return;
            }
            let x10 = f10[1], w6 = f10[3];
            pe2(Hy, s) && !A6(x10, w6, r) && A6(x10, void 0, r), xp(e);
            function A6(g9, B, N10) {
              let X2 = Un(t6.getExecutingFilePath()), F2 = ma(X2), $ = tn(F2, g9);
              if (B && ($ = $ + "-" + B), $ = t6.resolvePath(tn($, "diagnosticMessages.generated.json")), !t6.fileExists($))
                return false;
              let ae = "";
              try {
                ae = t6.readFile($);
              } catch {
                return N10 && N10.push(Ol(ve.Unable_to_open_file_0, $)), false;
              }
              try {
                yx(JSON.parse(ae));
              } catch {
                return N10 && N10.push(Ol(ve.Corrupted_locale_file_0, $)), false;
              }
              return true;
            }
          }
          function ul(e, t6) {
            if (e)
              for (; e.original !== void 0; )
                e = e.original;
            return !e || !t6 || t6(e) ? e : void 0;
          }
          function zi(e, t6) {
            for (; e; ) {
              let r = t6(e);
              if (r === "quit")
                return;
              if (r)
                return e;
              e = e.parent;
            }
          }
          function pl(e) {
            return (e.flags & 8) === 0;
          }
          function fl(e, t6) {
            if (e === void 0 || pl(e))
              return e;
            for (e = e.original; e; ) {
              if (pl(e))
                return !t6 || t6(e) ? e : void 0;
              e = e.original;
            }
          }
          function vi(e) {
            return e.length >= 2 && e.charCodeAt(0) === 95 && e.charCodeAt(1) === 95 ? "_" + e : e;
          }
          function dl(e) {
            let t6 = e;
            return t6.length >= 3 && t6.charCodeAt(0) === 95 && t6.charCodeAt(1) === 95 && t6.charCodeAt(2) === 95 ? t6.substr(1) : t6;
          }
          function qr2(e) {
            return dl(e.escapedText);
          }
          function dS(e) {
            let t6 = _l(e.escapedText);
            return t6 ? ln(t6, ba) : void 0;
          }
          function rf(e) {
            return e.valueDeclaration && zS(e.valueDeclaration) ? qr2(e.valueDeclaration.name) : dl(e.escapedName);
          }
          function mS(e) {
            let t6 = e.parent.parent;
            if (t6) {
              if (ko(t6))
                return nf(t6);
              switch (t6.kind) {
                case 240:
                  if (t6.declarationList && t6.declarationList.declarations[0])
                    return nf(t6.declarationList.declarations[0]);
                  break;
                case 241:
                  let r = t6.expression;
                  switch (r.kind === 223 && r.operatorToken.kind === 63 && (r = r.left), r.kind) {
                    case 208:
                      return r.name;
                    case 209:
                      let s = r.argumentExpression;
                      if (yt(s))
                        return s;
                  }
                  break;
                case 214:
                  return nf(t6.expression);
                case 253: {
                  if (ko(t6.statement) || mf(t6.statement))
                    return nf(t6.statement);
                  break;
                }
              }
            }
          }
          function nf(e) {
            let t6 = ml(e);
            return t6 && yt(t6) ? t6 : void 0;
          }
          function hS(e, t6) {
            return !!(af(e) && yt(e.name) && qr2(e.name) === qr2(t6) || zo(e) && Ke3(e.declarationList.declarations, (r) => hS(r, t6)));
          }
          function gS(e) {
            return e.name || mS(e);
          }
          function af(e) {
            return !!e.name;
          }
          function Ey(e) {
            switch (e.kind) {
              case 79:
                return e;
              case 351:
              case 344: {
                let { name: r } = e;
                if (r.kind === 163)
                  return r.right;
                break;
              }
              case 210:
              case 223: {
                let r = e;
                switch (ps(r)) {
                  case 1:
                  case 4:
                  case 5:
                  case 3:
                    return Cf(r.left);
                  case 7:
                  case 8:
                  case 9:
                    return r.arguments[1];
                  default:
                    return;
                }
              }
              case 349:
                return gS(e);
              case 343:
                return mS(e);
              case 274: {
                let { expression: r } = e;
                return yt(r) ? r : void 0;
              }
              case 209:
                let t6 = e;
                if (x0(t6))
                  return t6.argumentExpression;
            }
            return e.name;
          }
          function ml(e) {
            if (e !== void 0)
              return Ey(e) || (ad(e) || sd(e) || _d(e) ? yS(e) : void 0);
          }
          function yS(e) {
            if (e.parent) {
              if (lc(e.parent) || Xl(e.parent))
                return e.parent.name;
              if (ur2(e.parent) && e === e.parent.right) {
                if (yt(e.parent.left))
                  return e.parent.left;
                if (Lo(e.parent.left))
                  return Cf(e.parent.left);
              } else if (Vi(e.parent) && yt(e.parent.name))
                return e.parent.name;
            } else
              return;
          }
          function kA(e) {
            if (Il(e))
              return ee2(e.modifiers, zl);
          }
          function sf(e) {
            if (rn(e, 126975))
              return ee2(e.modifiers, Oy);
          }
          function vS(e, t6) {
            if (e.name)
              if (yt(e.name)) {
                let r = e.name.escapedText;
                return j_(e.parent, t6).filter((s) => pc(s) && yt(s.name) && s.name.escapedText === r);
              } else {
                let r = e.parent.parameters.indexOf(e);
                Y3.assert(r > -1, "Parameters should always be in their parents' parameter list");
                let s = j_(e.parent, t6).filter(pc);
                if (r < s.length)
                  return [s[r]];
              }
            return Bt;
          }
          function of(e) {
            return vS(e, false);
          }
          function bS(e) {
            return vS(e, true);
          }
          function TS(e, t6) {
            let r = e.name.escapedText;
            return j_(e.parent, t6).filter((s) => Go(s) && s.typeParameters.some((f10) => f10.name.escapedText === r));
          }
          function SS(e) {
            return TS(e, false);
          }
          function xS(e) {
            return TS(e, true);
          }
          function IA(e) {
            return !!Nr(e, pc);
          }
          function ES(e) {
            return Nr(e, md);
          }
          function wS(e) {
            return MS(e, hE);
          }
          function NA(e) {
            return Nr(e, pE);
          }
          function OA(e) {
            return Nr(e, d22);
          }
          function CS(e) {
            return Nr(e, d22, true);
          }
          function MA(e) {
            return Nr(e, m2);
          }
          function AS(e) {
            return Nr(e, m2, true);
          }
          function LA(e) {
            return Nr(e, h2);
          }
          function PS(e) {
            return Nr(e, h2, true);
          }
          function RA(e) {
            return Nr(e, g2);
          }
          function DS(e) {
            return Nr(e, g2, true);
          }
          function kS(e) {
            return Nr(e, fE, true);
          }
          function jA(e) {
            return Nr(e, v22);
          }
          function IS(e) {
            return Nr(e, v22, true);
          }
          function JA(e) {
            return Nr(e, dE);
          }
          function FA(e) {
            return Nr(e, mE);
          }
          function NS(e) {
            return Nr(e, b2);
          }
          function BA(e) {
            return Nr(e, Go);
          }
          function wy(e) {
            return Nr(e, T2);
          }
          function _f(e) {
            let t6 = Nr(e, au);
            if (t6 && t6.typeExpression && t6.typeExpression.type)
              return t6;
          }
          function cf(e) {
            let t6 = Nr(e, au);
            return !t6 && Vs(e) && (t6 = Ae2(of(e), (r) => !!r.typeExpression)), t6 && t6.typeExpression && t6.typeExpression.type;
          }
          function OS(e) {
            let t6 = NS(e);
            if (t6 && t6.typeExpression)
              return t6.typeExpression.type;
            let r = _f(e);
            if (r && r.typeExpression) {
              let s = r.typeExpression.type;
              if (id(s)) {
                let f10 = Ae2(s.members, Vv);
                return f10 && f10.type;
              }
              if ($l(s) || dd(s))
                return s.type;
            }
          }
          function j_(e, t6) {
            var r, s;
            if (!Af(e))
              return Bt;
            let f10 = (r = e.jsDoc) == null ? void 0 : r.jsDocCache;
            if (f10 === void 0 || t6) {
              let x10 = r4(e, t6);
              Y3.assert(x10.length < 2 || x10[0] !== x10[1]), f10 = ne2(x10, (w6) => Ho(w6) ? w6.tags : w6), t6 || ((s = e.jsDoc) != null || (e.jsDoc = []), e.jsDoc.jsDocCache = f10);
            }
            return f10;
          }
          function hl(e) {
            return j_(e, false);
          }
          function qA(e) {
            return j_(e, true);
          }
          function Nr(e, t6, r) {
            return Ae2(j_(e, r), t6);
          }
          function MS(e, t6) {
            return hl(e).filter(t6);
          }
          function UA(e, t6) {
            return hl(e).filter((r) => r.kind === t6);
          }
          function zA(e) {
            return typeof e == "string" ? e : e == null ? void 0 : e.map((t6) => t6.kind === 324 ? t6.text : WA(t6)).join("");
          }
          function WA(e) {
            let t6 = e.kind === 327 ? "link" : e.kind === 328 ? "linkcode" : "linkplain", r = e.name ? ls(e.name) : "", s = e.name && e.text.startsWith("://") ? "" : " ";
            return `{@${t6} ${r}${s}${e.text}}`;
          }
          function VA(e) {
            if (iu(e)) {
              if (y2(e.parent)) {
                let t6 = P0(e.parent);
                if (t6 && I(t6.tags))
                  return ne2(t6.tags, (r) => Go(r) ? r.typeParameters : void 0);
              }
              return Bt;
            }
            if (Cl(e))
              return Y3.assert(e.parent.kind === 323), ne2(e.parent.tags, (t6) => Go(t6) ? t6.typeParameters : void 0);
            if (e.typeParameters || IE(e) && e.typeParameters)
              return e.typeParameters;
            if (Pr(e)) {
              let t6 = F4(e);
              if (t6.length)
                return t6;
              let r = cf(e);
              if (r && $l(r) && r.typeParameters)
                return r.typeParameters;
            }
            return Bt;
          }
          function HA(e) {
            return e.constraint ? e.constraint : Go(e.parent) && e === e.parent.typeParameters[0] ? e.parent.constraint : void 0;
          }
          function js(e) {
            return e.kind === 79 || e.kind === 80;
          }
          function GA(e) {
            return e.kind === 175 || e.kind === 174;
          }
          function LS(e) {
            return bn(e) && !!(e.flags & 32);
          }
          function RS(e) {
            return gs(e) && !!(e.flags & 32);
          }
          function Cy(e) {
            return sc(e) && !!(e.flags & 32);
          }
          function Ay(e) {
            let t6 = e.kind;
            return !!(e.flags & 32) && (t6 === 208 || t6 === 209 || t6 === 210 || t6 === 232);
          }
          function Py(e) {
            return Ay(e) && !Uo(e) && !!e.questionDotToken;
          }
          function $A(e) {
            return Py(e.parent) && e.parent.expression === e;
          }
          function KA(e) {
            return !Ay(e.parent) || Py(e.parent) || e !== e.parent.expression;
          }
          function XA(e) {
            return e.kind === 223 && e.operatorToken.kind === 60;
          }
          function jS(e) {
            return ac(e) && yt(e.typeName) && e.typeName.escapedText === "const" && !e.typeArguments;
          }
          function lf(e) {
            return $o(e, 8);
          }
          function JS(e) {
            return Uo(e) && !!(e.flags & 32);
          }
          function YA(e) {
            return e.kind === 249 || e.kind === 248;
          }
          function QA(e) {
            return e.kind === 277 || e.kind === 276;
          }
          function FS(e) {
            switch (e.kind) {
              case 305:
              case 306:
                return true;
              default:
                return false;
            }
          }
          function ZA(e) {
            return FS(e) || e.kind === 303 || e.kind === 307;
          }
          function Dy(e) {
            return e.kind === 351 || e.kind === 344;
          }
          function eP(e) {
            return gl(e.kind);
          }
          function gl(e) {
            return e >= 163;
          }
          function BS(e) {
            return e >= 0 && e <= 162;
          }
          function tP(e) {
            return BS(e.kind);
          }
          function _s(e) {
            return Jr(e, "pos") && Jr(e, "end");
          }
          function ky(e) {
            return 8 <= e && e <= 14;
          }
          function Iy(e) {
            return ky(e.kind);
          }
          function rP(e) {
            switch (e.kind) {
              case 207:
              case 206:
              case 13:
              case 215:
              case 228:
                return true;
            }
            return false;
          }
          function yl(e) {
            return 14 <= e && e <= 17;
          }
          function nP(e) {
            return yl(e.kind);
          }
          function iP(e) {
            let t6 = e.kind;
            return t6 === 16 || t6 === 17;
          }
          function aP(e) {
            return nE(e) || aE(e);
          }
          function qS(e) {
            switch (e.kind) {
              case 273:
                return e.isTypeOnly || e.parent.parent.isTypeOnly;
              case 271:
                return e.parent.isTypeOnly;
              case 270:
              case 268:
                return e.isTypeOnly;
            }
            return false;
          }
          function US(e) {
            switch (e.kind) {
              case 278:
                return e.isTypeOnly || e.parent.parent.isTypeOnly;
              case 275:
                return e.isTypeOnly && !!e.moduleSpecifier && !e.exportClause;
              case 277:
                return e.parent.isTypeOnly;
            }
            return false;
          }
          function sP(e) {
            return qS(e) || US(e);
          }
          function oP(e) {
            return Gn(e) || yt(e);
          }
          function _P(e) {
            return e.kind === 10 || yl(e.kind);
          }
          function cs(e) {
            var t6;
            return yt(e) && ((t6 = e.emitNode) == null ? void 0 : t6.autoGenerate) !== void 0;
          }
          function Ny(e) {
            var t6;
            return vn(e) && ((t6 = e.emitNode) == null ? void 0 : t6.autoGenerate) !== void 0;
          }
          function zS(e) {
            return (Bo(e) || Ly(e)) && vn(e.name);
          }
          function cP(e) {
            return bn(e) && vn(e.name);
          }
          function Wi(e) {
            switch (e) {
              case 126:
              case 127:
              case 132:
              case 85:
              case 136:
              case 88:
              case 93:
              case 101:
              case 123:
              case 121:
              case 122:
              case 146:
              case 124:
              case 145:
              case 161:
                return true;
            }
            return false;
          }
          function WS(e) {
            return !!(Q0(e) & 16476);
          }
          function VS(e) {
            return WS(e) || e === 124 || e === 161 || e === 127;
          }
          function Oy(e) {
            return Wi(e.kind);
          }
          function lP(e) {
            let t6 = e.kind;
            return t6 === 163 || t6 === 79;
          }
          function vl(e) {
            let t6 = e.kind;
            return t6 === 79 || t6 === 80 || t6 === 10 || t6 === 8 || t6 === 164;
          }
          function uP(e) {
            let t6 = e.kind;
            return t6 === 79 || t6 === 203 || t6 === 204;
          }
          function ga(e) {
            return !!e && My(e.kind);
          }
          function uf(e) {
            return !!e && (My(e.kind) || Hl(e));
          }
          function HS(e) {
            return e && GS(e.kind);
          }
          function pP(e) {
            return e.kind === 110 || e.kind === 95;
          }
          function GS(e) {
            switch (e) {
              case 259:
              case 171:
              case 173:
              case 174:
              case 175:
              case 215:
              case 216:
                return true;
              default:
                return false;
            }
          }
          function My(e) {
            switch (e) {
              case 170:
              case 176:
              case 326:
              case 177:
              case 178:
              case 181:
              case 320:
              case 182:
                return true;
              default:
                return GS(e);
            }
          }
          function fP(e) {
            return wi(e) || rE(e) || Ql(e) && ga(e.parent);
          }
          function Js(e) {
            let t6 = e.kind;
            return t6 === 173 || t6 === 169 || t6 === 171 || t6 === 174 || t6 === 175 || t6 === 178 || t6 === 172 || t6 === 237;
          }
          function bi(e) {
            return e && (e.kind === 260 || e.kind === 228);
          }
          function pf(e) {
            return e && (e.kind === 174 || e.kind === 175);
          }
          function $S(e) {
            return Bo(e) && H4(e);
          }
          function Ly(e) {
            switch (e.kind) {
              case 171:
              case 174:
              case 175:
                return true;
              default:
                return false;
            }
          }
          function dP(e) {
            switch (e.kind) {
              case 171:
              case 174:
              case 175:
              case 169:
                return true;
              default:
                return false;
            }
          }
          function ff(e) {
            return Oy(e) || zl(e);
          }
          function Ry(e) {
            let t6 = e.kind;
            return t6 === 177 || t6 === 176 || t6 === 168 || t6 === 170 || t6 === 178 || t6 === 174 || t6 === 175;
          }
          function mP(e) {
            return Ry(e) || Js(e);
          }
          function jy(e) {
            let t6 = e.kind;
            return t6 === 299 || t6 === 300 || t6 === 301 || t6 === 171 || t6 === 174 || t6 === 175;
          }
          function Jy(e) {
            return hx(e.kind);
          }
          function hP(e) {
            switch (e.kind) {
              case 181:
              case 182:
                return true;
            }
            return false;
          }
          function df(e) {
            if (e) {
              let t6 = e.kind;
              return t6 === 204 || t6 === 203;
            }
            return false;
          }
          function KS(e) {
            let t6 = e.kind;
            return t6 === 206 || t6 === 207;
          }
          function gP(e) {
            let t6 = e.kind;
            return t6 === 205 || t6 === 229;
          }
          function Fy(e) {
            switch (e.kind) {
              case 257:
              case 166:
              case 205:
                return true;
            }
            return false;
          }
          function yP(e) {
            return Vi(e) || Vs(e) || YS(e) || ZS(e);
          }
          function vP(e) {
            return XS(e) || QS(e);
          }
          function XS(e) {
            switch (e.kind) {
              case 203:
              case 207:
                return true;
            }
            return false;
          }
          function YS(e) {
            switch (e.kind) {
              case 205:
              case 299:
              case 300:
              case 301:
                return true;
            }
            return false;
          }
          function QS(e) {
            switch (e.kind) {
              case 204:
              case 206:
                return true;
            }
            return false;
          }
          function ZS(e) {
            switch (e.kind) {
              case 205:
              case 229:
              case 227:
              case 206:
              case 207:
              case 79:
              case 208:
              case 209:
                return true;
            }
            return ms(e, true);
          }
          function bP(e) {
            let t6 = e.kind;
            return t6 === 208 || t6 === 163 || t6 === 202;
          }
          function TP(e) {
            let t6 = e.kind;
            return t6 === 208 || t6 === 163;
          }
          function SP(e) {
            switch (e.kind) {
              case 283:
              case 282:
              case 210:
              case 211:
              case 212:
              case 167:
                return true;
              default:
                return false;
            }
          }
          function xP(e) {
            return e.kind === 210 || e.kind === 211;
          }
          function EP(e) {
            let t6 = e.kind;
            return t6 === 225 || t6 === 14;
          }
          function Do(e) {
            return e3(lf(e).kind);
          }
          function e3(e) {
            switch (e) {
              case 208:
              case 209:
              case 211:
              case 210:
              case 281:
              case 282:
              case 285:
              case 212:
              case 206:
              case 214:
              case 207:
              case 228:
              case 215:
              case 79:
              case 80:
              case 13:
              case 8:
              case 9:
              case 10:
              case 14:
              case 225:
              case 95:
              case 104:
              case 108:
              case 110:
              case 106:
              case 232:
              case 230:
              case 233:
              case 100:
              case 279:
                return true;
              default:
                return false;
            }
          }
          function t3(e) {
            return r3(lf(e).kind);
          }
          function r3(e) {
            switch (e) {
              case 221:
              case 222:
              case 217:
              case 218:
              case 219:
              case 220:
              case 213:
                return true;
              default:
                return e3(e);
            }
          }
          function wP(e) {
            switch (e.kind) {
              case 222:
                return true;
              case 221:
                return e.operator === 45 || e.operator === 46;
              default:
                return false;
            }
          }
          function CP(e) {
            switch (e.kind) {
              case 104:
              case 110:
              case 95:
              case 221:
                return true;
              default:
                return Iy(e);
            }
          }
          function mf(e) {
            return AP(lf(e).kind);
          }
          function AP(e) {
            switch (e) {
              case 224:
              case 226:
              case 216:
              case 223:
              case 227:
              case 231:
              case 229:
              case 357:
              case 356:
              case 235:
                return true;
              default:
                return r3(e);
            }
          }
          function PP(e) {
            let t6 = e.kind;
            return t6 === 213 || t6 === 231;
          }
          function DP(e) {
            return c2(e) || Z8(e);
          }
          function n3(e, t6) {
            switch (e.kind) {
              case 245:
              case 246:
              case 247:
              case 243:
              case 244:
                return true;
              case 253:
                return t6 && n3(e.statement, t6);
            }
            return false;
          }
          function i3(e) {
            return Vo(e) || cc(e);
          }
          function kP(e) {
            return Ke3(e, i3);
          }
          function IP(e) {
            return !bf(e) && !Vo(e) && !rn(e, 1) && !yf(e);
          }
          function NP(e) {
            return bf(e) || Vo(e) || rn(e, 1);
          }
          function OP(e) {
            return e.kind === 246 || e.kind === 247;
          }
          function MP(e) {
            return Ql(e) || mf(e);
          }
          function LP(e) {
            return Ql(e);
          }
          function RP(e) {
            return r2(e) || mf(e);
          }
          function jP(e) {
            let t6 = e.kind;
            return t6 === 265 || t6 === 264 || t6 === 79;
          }
          function JP(e) {
            let t6 = e.kind;
            return t6 === 265 || t6 === 264;
          }
          function FP(e) {
            let t6 = e.kind;
            return t6 === 79 || t6 === 264;
          }
          function BP(e) {
            let t6 = e.kind;
            return t6 === 272 || t6 === 271;
          }
          function qP(e) {
            return e.kind === 264 || e.kind === 263;
          }
          function UP(e) {
            switch (e.kind) {
              case 216:
              case 223:
              case 205:
              case 210:
              case 176:
              case 260:
              case 228:
              case 172:
              case 173:
              case 182:
              case 177:
              case 209:
              case 263:
              case 302:
              case 274:
              case 275:
              case 278:
              case 259:
              case 215:
              case 181:
              case 174:
              case 79:
              case 270:
              case 268:
              case 273:
              case 178:
              case 261:
              case 341:
              case 343:
              case 320:
              case 344:
              case 351:
              case 326:
              case 349:
              case 325:
              case 288:
              case 289:
              case 290:
              case 197:
              case 171:
              case 170:
              case 264:
              case 199:
              case 277:
              case 267:
              case 271:
              case 211:
              case 14:
              case 8:
              case 207:
              case 166:
              case 208:
              case 299:
              case 169:
              case 168:
              case 175:
              case 300:
              case 308:
              case 301:
              case 10:
              case 262:
              case 184:
              case 165:
              case 257:
                return true;
              default:
                return false;
            }
          }
          function zP(e) {
            switch (e.kind) {
              case 216:
              case 238:
              case 176:
              case 266:
              case 295:
              case 172:
              case 191:
              case 173:
              case 182:
              case 177:
              case 245:
              case 246:
              case 247:
              case 259:
              case 215:
              case 181:
              case 174:
              case 178:
              case 341:
              case 343:
              case 320:
              case 326:
              case 349:
              case 197:
              case 171:
              case 170:
              case 264:
              case 175:
              case 308:
              case 262:
                return true;
              default:
                return false;
            }
          }
          function WP(e) {
            return e === 216 || e === 205 || e === 260 || e === 228 || e === 172 || e === 173 || e === 263 || e === 302 || e === 278 || e === 259 || e === 215 || e === 174 || e === 270 || e === 268 || e === 273 || e === 261 || e === 288 || e === 171 || e === 170 || e === 264 || e === 267 || e === 271 || e === 277 || e === 166 || e === 299 || e === 169 || e === 168 || e === 175 || e === 300 || e === 262 || e === 165 || e === 257 || e === 349 || e === 341 || e === 351;
          }
          function By(e) {
            return e === 259 || e === 279 || e === 260 || e === 261 || e === 262 || e === 263 || e === 264 || e === 269 || e === 268 || e === 275 || e === 274 || e === 267;
          }
          function qy(e) {
            return e === 249 || e === 248 || e === 256 || e === 243 || e === 241 || e === 239 || e === 246 || e === 247 || e === 245 || e === 242 || e === 253 || e === 250 || e === 252 || e === 254 || e === 255 || e === 240 || e === 244 || e === 251 || e === 355 || e === 359 || e === 358;
          }
          function ko(e) {
            return e.kind === 165 ? e.parent && e.parent.kind !== 348 || Pr(e) : WP(e.kind);
          }
          function VP(e) {
            return By(e.kind);
          }
          function HP(e) {
            return qy(e.kind);
          }
          function a3(e) {
            let t6 = e.kind;
            return qy(t6) || By(t6) || GP(e);
          }
          function GP(e) {
            return e.kind !== 238 || e.parent !== void 0 && (e.parent.kind === 255 || e.parent.kind === 295) ? false : !O3(e);
          }
          function s3(e) {
            let t6 = e.kind;
            return qy(t6) || By(t6) || t6 === 238;
          }
          function $P(e) {
            let t6 = e.kind;
            return t6 === 280 || t6 === 163 || t6 === 79;
          }
          function KP(e) {
            let t6 = e.kind;
            return t6 === 108 || t6 === 79 || t6 === 208;
          }
          function o3(e) {
            let t6 = e.kind;
            return t6 === 281 || t6 === 291 || t6 === 282 || t6 === 11 || t6 === 285;
          }
          function XP(e) {
            let t6 = e.kind;
            return t6 === 288 || t6 === 290;
          }
          function YP(e) {
            let t6 = e.kind;
            return t6 === 10 || t6 === 291;
          }
          function _3(e) {
            let t6 = e.kind;
            return t6 === 283 || t6 === 282;
          }
          function QP(e) {
            let t6 = e.kind;
            return t6 === 292 || t6 === 293;
          }
          function Uy(e) {
            return e.kind >= 312 && e.kind <= 353;
          }
          function c3(e) {
            return e.kind === 323 || e.kind === 322 || e.kind === 324 || Sl(e) || zy(e) || f2(e) || iu(e);
          }
          function zy(e) {
            return e.kind >= 330 && e.kind <= 353;
          }
          function bl(e) {
            return e.kind === 175;
          }
          function Tl(e) {
            return e.kind === 174;
          }
          function ya(e) {
            if (!Af(e))
              return false;
            let { jsDoc: t6 } = e;
            return !!t6 && t6.length > 0;
          }
          function ZP(e) {
            return !!e.type;
          }
          function l3(e) {
            return !!e.initializer;
          }
          function eD(e) {
            switch (e.kind) {
              case 257:
              case 166:
              case 205:
              case 169:
              case 299:
              case 302:
                return true;
              default:
                return false;
            }
          }
          function Wy(e) {
            return e.kind === 288 || e.kind === 290 || jy(e);
          }
          function tD(e) {
            return e.kind === 180 || e.kind === 230;
          }
          function rD(e) {
            let t6 = Gy;
            for (let r of e) {
              if (!r.length)
                continue;
              let s = 0;
              for (; s < r.length && s < t6 && os(r.charCodeAt(s)); s++)
                ;
              if (s < t6 && (t6 = s), t6 === 0)
                return 0;
            }
            return t6 === Gy ? void 0 : t6;
          }
          function Ti(e) {
            return e.kind === 10 || e.kind === 14;
          }
          function Sl(e) {
            return e.kind === 327 || e.kind === 328 || e.kind === 329;
          }
          function nD(e) {
            let t6 = Cn(e.parameters);
            return !!t6 && u3(t6);
          }
          function u3(e) {
            let t6 = pc(e) ? e.typeExpression && e.typeExpression.type : e.type;
            return e.dotDotDotToken !== void 0 || !!t6 && t6.kind === 321;
          }
          var Vy, Hy, Gy, iD = D({ "src/compiler/utilitiesPublic.ts"() {
            "use strict";
            nn(), Vy = Zp(L_(0, 0), 0), Hy = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"], Gy = 1073741823;
          } });
          function aD(e, t6) {
            let r = e.declarations;
            if (r) {
              for (let s of r)
                if (s.kind === t6)
                  return s;
            }
          }
          function sD(e, t6) {
            return ee2(e.declarations || Bt, (r) => r.kind === t6);
          }
          function oD(e) {
            let t6 = /* @__PURE__ */ new Map();
            if (e)
              for (let r of e)
                t6.set(r.escapedName, r);
            return t6;
          }
          function $y(e) {
            return (e.flags & 33554432) !== 0;
          }
          function _D() {
            var e = "";
            let t6 = (r) => e += r;
            return { getText: () => e, write: t6, rawWrite: t6, writeKeyword: t6, writeOperator: t6, writePunctuation: t6, writeSpace: t6, writeStringLiteral: t6, writeLiteral: t6, writeParameter: t6, writeProperty: t6, writeSymbol: (r, s) => t6(r), writeTrailingSemicolon: t6, writeComment: t6, getTextPos: () => e.length, getLine: () => 0, getColumn: () => 0, getIndent: () => 0, isAtStartOfLine: () => false, hasTrailingComment: () => false, hasTrailingWhitespace: () => !!e.length && os(e.charCodeAt(e.length - 1)), writeLine: () => e += " ", increaseIndent: yn, decreaseIndent: yn, clear: () => e = "" };
          }
          function cD(e, t6) {
            return e.configFilePath !== t6.configFilePath || p3(e, t6);
          }
          function p3(e, t6) {
            return J_(e, t6, moduleResolutionOptionDeclarations);
          }
          function lD(e, t6) {
            return J_(e, t6, optionsAffectingProgramStructure);
          }
          function J_(e, t6, r) {
            return e !== t6 && r.some((s) => !gv(uv(e, s), uv(t6, s)));
          }
          function uD(e, t6) {
            for (; ; ) {
              let r = t6(e);
              if (r === "quit")
                return;
              if (r !== void 0)
                return r;
              if (wi(e))
                return;
              e = e.parent;
            }
          }
          function pD(e, t6) {
            let r = e.entries();
            for (let [s, f10] of r) {
              let x10 = t6(f10, s);
              if (x10)
                return x10;
            }
          }
          function fD(e, t6) {
            let r = e.keys();
            for (let s of r) {
              let f10 = t6(s);
              if (f10)
                return f10;
            }
          }
          function dD(e, t6) {
            e.forEach((r, s) => {
              t6.set(s, r);
            });
          }
          function mD(e) {
            let t6 = Z_.getText();
            try {
              return e(Z_), Z_.getText();
            } finally {
              Z_.clear(), Z_.writeKeyword(t6);
            }
          }
          function hf(e) {
            return e.end - e.pos;
          }
          function hD(e, t6, r) {
            var s, f10;
            return (f10 = (s = e == null ? void 0 : e.resolvedModules) == null ? void 0 : s.get(t6, r)) == null ? void 0 : f10.resolvedModule;
          }
          function gD(e, t6, r, s) {
            e.resolvedModules || (e.resolvedModules = createModeAwareCache()), e.resolvedModules.set(t6, s, r);
          }
          function yD(e, t6, r, s) {
            e.resolvedTypeReferenceDirectiveNames || (e.resolvedTypeReferenceDirectiveNames = createModeAwareCache()), e.resolvedTypeReferenceDirectiveNames.set(t6, s, r);
          }
          function vD(e, t6, r) {
            var s, f10;
            return (f10 = (s = e == null ? void 0 : e.resolvedTypeReferenceDirectiveNames) == null ? void 0 : s.get(t6, r)) == null ? void 0 : f10.resolvedTypeReferenceDirective;
          }
          function bD(e, t6) {
            return e.path === t6.path && !e.prepend == !t6.prepend && !e.circular == !t6.circular;
          }
          function TD(e, t6) {
            return e === t6 || e.resolvedModule === t6.resolvedModule || !!e.resolvedModule && !!t6.resolvedModule && e.resolvedModule.isExternalLibraryImport === t6.resolvedModule.isExternalLibraryImport && e.resolvedModule.extension === t6.resolvedModule.extension && e.resolvedModule.resolvedFileName === t6.resolvedModule.resolvedFileName && e.resolvedModule.originalPath === t6.resolvedModule.originalPath && SD(e.resolvedModule.packageId, t6.resolvedModule.packageId);
          }
          function SD(e, t6) {
            return e === t6 || !!e && !!t6 && e.name === t6.name && e.subModuleName === t6.subModuleName && e.version === t6.version;
          }
          function f3(e) {
            let { name: t6, subModuleName: r } = e;
            return r ? `${t6}/${r}` : t6;
          }
          function xD(e) {
            return `${f3(e)}@${e.version}`;
          }
          function ED(e, t6) {
            return e === t6 || e.resolvedTypeReferenceDirective === t6.resolvedTypeReferenceDirective || !!e.resolvedTypeReferenceDirective && !!t6.resolvedTypeReferenceDirective && e.resolvedTypeReferenceDirective.resolvedFileName === t6.resolvedTypeReferenceDirective.resolvedFileName && !!e.resolvedTypeReferenceDirective.primary == !!t6.resolvedTypeReferenceDirective.primary && e.resolvedTypeReferenceDirective.originalPath === t6.resolvedTypeReferenceDirective.originalPath;
          }
          function wD(e, t6, r, s, f10, x10) {
            Y3.assert(e.length === r.length);
            for (let w6 = 0; w6 < e.length; w6++) {
              let A6 = r[w6], g9 = e[w6], B = x10.getName(g9), N10 = x10.getMode(g9, t6), X2 = s && s.get(B, N10);
              if (X2 ? !A6 || !f10(X2, A6) : A6)
                return true;
            }
            return false;
          }
          function Ky(e) {
            return CD(e), (e.flags & 524288) !== 0;
          }
          function CD(e) {
            e.flags & 1048576 || ((e.flags & 131072 || xr2(e, Ky)) && (e.flags |= 524288), e.flags |= 1048576);
          }
          function Si(e) {
            for (; e && e.kind !== 308; )
              e = e.parent;
            return e;
          }
          function AD(e) {
            return Si(e.valueDeclaration || E3(e));
          }
          function PD(e, t6) {
            return !!e && (e.scriptKind === 1 || e.scriptKind === 2) && !e.checkJsDirective && t6 === void 0;
          }
          function DD(e) {
            switch (e.kind) {
              case 238:
              case 266:
              case 245:
              case 246:
              case 247:
                return true;
            }
            return false;
          }
          function kD(e, t6) {
            return Y3.assert(e >= 0), ss(t6)[e];
          }
          function ID(e) {
            let t6 = Si(e), r = Ls(t6, e.pos);
            return `${t6.fileName}(${r.line + 1},${r.character + 1})`;
          }
          function d3(e, t6) {
            Y3.assert(e >= 0);
            let r = ss(t6), s = e, f10 = t6.text;
            if (s + 1 === r.length)
              return f10.length - 1;
            {
              let x10 = r[s], w6 = r[s + 1] - 1;
              for (Y3.assert(un(f10.charCodeAt(w6))); x10 <= w6 && un(f10.charCodeAt(w6)); )
                w6--;
              return w6;
            }
          }
          function m3(e, t6, r) {
            return !(r && r(t6)) && !e.identifiers.has(t6);
          }
          function va(e) {
            return e === void 0 ? true : e.pos === e.end && e.pos >= 0 && e.kind !== 1;
          }
          function xl(e) {
            return !va(e);
          }
          function ND(e, t6) {
            return Fo(e) ? t6 === e.expression : Hl(e) ? t6 === e.modifiers : Wl(e) ? t6 === e.initializer : Bo(e) ? t6 === e.questionToken && $S(e) : lc(e) ? t6 === e.modifiers || t6 === e.questionToken || t6 === e.exclamationToken || F_(e.modifiers, t6, ff) : nu(e) ? t6 === e.equalsToken || t6 === e.modifiers || t6 === e.questionToken || t6 === e.exclamationToken || F_(e.modifiers, t6, ff) : Vl(e) ? t6 === e.exclamationToken : nc(e) ? t6 === e.typeParameters || t6 === e.type || F_(e.typeParameters, t6, Fo) : Gl(e) ? t6 === e.typeParameters || F_(e.typeParameters, t6, Fo) : ic(e) ? t6 === e.typeParameters || t6 === e.type || F_(e.typeParameters, t6, Fo) : a2(e) ? t6 === e.modifiers || F_(e.modifiers, t6, ff) : false;
          }
          function F_(e, t6, r) {
            return !e || ir2(t6) || !r(t6) ? false : pe2(e, t6);
          }
          function h3(e, t6, r) {
            if (t6 === void 0 || t6.length === 0)
              return e;
            let s = 0;
            for (; s < e.length && r(e[s]); ++s)
              ;
            return e.splice(s, 0, ...t6), e;
          }
          function g3(e, t6, r) {
            if (t6 === void 0)
              return e;
            let s = 0;
            for (; s < e.length && r(e[s]); ++s)
              ;
            return e.splice(s, 0, t6), e;
          }
          function y3(e) {
            return us(e) || !!(xi(e) & 2097152);
          }
          function OD(e, t6) {
            return h3(e, t6, us);
          }
          function MD(e, t6) {
            return h3(e, t6, y3);
          }
          function LD(e, t6) {
            return g3(e, t6, us);
          }
          function RD(e, t6) {
            return g3(e, t6, y3);
          }
          function jD(e, t6, r) {
            if (e.charCodeAt(t6 + 1) === 47 && t6 + 2 < r && e.charCodeAt(t6 + 2) === 47) {
              let s = e.substring(t6, r);
              return !!(bv.test(s) || Tv.test(s) || i8.test(s) || a8.test(s));
            }
            return false;
          }
          function v3(e, t6) {
            return e.charCodeAt(t6 + 1) === 42 && e.charCodeAt(t6 + 2) === 33;
          }
          function JD(e, t6) {
            let r = new Map(t6.map((w6) => [`${Ls(e, w6.range.end).line}`, w6])), s = /* @__PURE__ */ new Map();
            return { getUnusedExpectations: f10, markUsed: x10 };
            function f10() {
              return Za(r.entries()).filter((w6) => {
                let [A6, g9] = w6;
                return g9.type === 0 && !s.get(A6);
              }).map((w6) => {
                let [A6, g9] = w6;
                return g9;
              });
            }
            function x10(w6) {
              return r.has(`${w6}`) ? (s.set(`${w6}`, true), true) : false;
            }
          }
          function Io(e, t6, r) {
            return va(e) ? e.pos : Uy(e) || e.kind === 11 ? Ar2((t6 || Si(e)).text, e.pos, false, true) : r && ya(e) ? Io(e.jsDoc[0], t6) : e.kind === 354 && e._children.length > 0 ? Io(e._children[0], t6, r) : Ar2((t6 || Si(e)).text, e.pos, false, false, q3(e));
          }
          function FD(e, t6) {
            let r = !va(e) && fc(e) ? te2(e.modifiers, zl) : void 0;
            return r ? Ar2((t6 || Si(e)).text, r.end) : Io(e, t6);
          }
          function No(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return B_(e.text, t6, r);
          }
          function BD(e) {
            return !!zi(e, lE);
          }
          function b3(e) {
            return !!(cc(e) && e.exportClause && ld(e.exportClause) && e.exportClause.name.escapedText === "default");
          }
          function B_(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            if (va(t6))
              return "";
            let s = e.substring(r ? t6.pos : Ar2(e, t6.pos), t6.end);
            return BD(t6) && (s = s.split(/\r\n|\n|\r/).map((f10) => nl(f10.replace(/^\s*\*/, ""))).join(`
`)), s;
          }
          function gf(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return No(Si(e), e, t6);
          }
          function qD(e) {
            return e.pos;
          }
          function UD(e, t6) {
            return Ya(e, t6, qD, Vr2);
          }
          function xi(e) {
            let t6 = e.emitNode;
            return t6 && t6.flags || 0;
          }
          function zD(e) {
            let t6 = e.emitNode;
            return t6 && t6.internalFlags || 0;
          }
          function WD(e, t6, r) {
            var s;
            if (t6 && VD(e, r))
              return No(t6, e);
            switch (e.kind) {
              case 10: {
                let f10 = r & 2 ? A4 : r & 1 || xi(e) & 33554432 ? Nf : Of;
                return e.singleQuote ? "'" + f10(e.text, 39) + "'" : '"' + f10(e.text, 34) + '"';
              }
              case 14:
              case 15:
              case 16:
              case 17: {
                let f10 = r & 1 || xi(e) & 33554432 ? Nf : Of, x10 = (s = e.rawText) != null ? s : SN(f10(e.text, 96));
                switch (e.kind) {
                  case 14:
                    return "`" + x10 + "`";
                  case 15:
                    return "`" + x10 + "${";
                  case 16:
                    return "}" + x10 + "${";
                  case 17:
                    return "}" + x10 + "`";
                }
                break;
              }
              case 8:
              case 9:
                return e.text;
              case 13:
                return r & 4 && e.isUnterminated ? e.text + (e.text.charCodeAt(e.text.length - 1) === 92 ? " /" : "/") : e.text;
            }
            return Y3.fail(`Literal kind '${e.kind}' not accounted for.`);
          }
          function VD(e, t6) {
            return fs(e) || !e.parent || t6 & 4 && e.isUnterminated ? false : zs(e) && e.numericLiteralFlags & 512 ? !!(t6 & 8) : !Uv(e);
          }
          function HD(e) {
            return Ji(e) ? '"' + Of(e) + '"' : "" + e;
          }
          function GD(e) {
            return sl(e).replace(/^(\d)/, "_$1").replace(/\W/g, "_");
          }
          function $D(e) {
            return (tf2(e) & 3) !== 0 || T3(e);
          }
          function T3(e) {
            let t6 = If(e);
            return t6.kind === 257 && t6.parent.kind === 295;
          }
          function yf(e) {
            return Ea(e) && (e.name.kind === 10 || vf(e));
          }
          function KD(e) {
            return Ea(e) && e.name.kind === 10;
          }
          function XD(e) {
            return Ea(e) && Gn(e.name);
          }
          function S3(e) {
            return Ea(e) || yt(e);
          }
          function YD(e) {
            return QD(e.valueDeclaration);
          }
          function QD(e) {
            return !!e && e.kind === 264 && !e.body;
          }
          function ZD(e) {
            return e.kind === 308 || e.kind === 264 || uf(e);
          }
          function vf(e) {
            return !!(e.flags & 1024);
          }
          function Xy(e) {
            return yf(e) && x3(e);
          }
          function x3(e) {
            switch (e.parent.kind) {
              case 308:
                return Qo(e.parent);
              case 265:
                return yf(e.parent.parent) && wi(e.parent.parent.parent) && !Qo(e.parent.parent.parent);
            }
            return false;
          }
          function E3(e) {
            var t6;
            return (t6 = e.declarations) == null ? void 0 : t6.find((r) => !Xy(r) && !(Ea(r) && vf(r)));
          }
          function ek(e) {
            return e === 1 || e === 100 || e === 199;
          }
          function Yy(e, t6) {
            return Qo(e) || zf(t6) || ek(Ei(t6)) && !!e.commonJsModuleIndicator;
          }
          function tk(e, t6) {
            switch (e.scriptKind) {
              case 1:
              case 3:
              case 2:
              case 4:
                break;
              default:
                return false;
            }
            return e.isDeclarationFile ? false : lv(t6, "alwaysStrict") || SE(e.statements) ? true : Qo(e) || zf(t6) ? Ei(t6) >= 5 ? true : !t6.noImplicitUseStrict : false;
          }
          function rk(e) {
            return !!(e.flags & 16777216) || rn(e, 2);
          }
          function w3(e, t6) {
            switch (e.kind) {
              case 308:
              case 266:
              case 295:
              case 264:
              case 245:
              case 246:
              case 247:
              case 173:
              case 171:
              case 174:
              case 175:
              case 259:
              case 215:
              case 216:
              case 169:
              case 172:
                return true;
              case 238:
                return !uf(t6);
            }
            return false;
          }
          function nk(e) {
            switch (Y3.type(e), e.kind) {
              case 341:
              case 349:
              case 326:
                return true;
              default:
                return C3(e);
            }
          }
          function C3(e) {
            switch (Y3.type(e), e.kind) {
              case 176:
              case 177:
              case 170:
              case 178:
              case 181:
              case 182:
              case 320:
              case 260:
              case 228:
              case 261:
              case 262:
              case 348:
              case 259:
              case 171:
              case 173:
              case 174:
              case 175:
              case 215:
              case 216:
                return true;
              default:
                return false;
            }
          }
          function Qy(e) {
            switch (e.kind) {
              case 269:
              case 268:
                return true;
              default:
                return false;
            }
          }
          function ik(e) {
            return Qy(e) || Ef(e);
          }
          function ak(e) {
            switch (e.kind) {
              case 269:
              case 268:
              case 240:
              case 260:
              case 259:
              case 264:
              case 262:
              case 261:
              case 263:
                return true;
              default:
                return false;
            }
          }
          function sk(e) {
            return bf(e) || Ea(e) || Kl(e) || s0(e);
          }
          function bf(e) {
            return Qy(e) || cc(e);
          }
          function Zy(e) {
            return zi(e.parent, (t6) => w3(t6, t6.parent));
          }
          function ok(e, t6) {
            let r = Zy(e);
            for (; r; )
              t6(r), r = Zy(r);
          }
          function A3(e) {
            return !e || hf(e) === 0 ? "(Missing)" : gf(e);
          }
          function _k(e) {
            return e.declaration ? A3(e.declaration.parameters[0].name) : void 0;
          }
          function ck(e) {
            return e.kind === 164 && !Ta(e.expression);
          }
          function e0(e) {
            var t6;
            switch (e.kind) {
              case 79:
              case 80:
                return (t6 = e.emitNode) != null && t6.autoGenerate ? void 0 : e.escapedText;
              case 10:
              case 8:
              case 14:
                return vi(e.text);
              case 164:
                return Ta(e.expression) ? vi(e.expression.text) : void 0;
              default:
                return Y3.assertNever(e);
            }
          }
          function lk(e) {
            return Y3.checkDefined(e0(e));
          }
          function ls(e) {
            switch (e.kind) {
              case 108:
                return "this";
              case 80:
              case 79:
                return hf(e) === 0 ? qr2(e) : gf(e);
              case 163:
                return ls(e.left) + "." + ls(e.right);
              case 208:
                return yt(e.name) || vn(e.name) ? ls(e.expression) + "." + ls(e.name) : Y3.assertNever(e.name);
              case 314:
                return ls(e.left) + ls(e.right);
              default:
                return Y3.assertNever(e);
            }
          }
          function uk(e, t6, r, s, f10, x10) {
            let w6 = Si(e);
            return P3(w6, e, t6, r, s, f10, x10);
          }
          function pk(e, t6, r, s, f10, x10, w6) {
            let A6 = Ar2(e.text, t6.pos);
            return iv(e, A6, t6.end - A6, r, s, f10, x10, w6);
          }
          function P3(e, t6, r, s, f10, x10, w6) {
            let A6 = i0(e, t6);
            return iv(e, A6.start, A6.length, r, s, f10, x10, w6);
          }
          function fk(e, t6, r, s) {
            let f10 = i0(e, t6);
            return r0(e, f10.start, f10.length, r, s);
          }
          function dk(e, t6, r, s) {
            let f10 = Ar2(e.text, t6.pos);
            return r0(e, f10, t6.end - f10, r, s);
          }
          function t0(e, t6, r) {
            Y3.assertGreaterThanOrEqual(t6, 0), Y3.assertGreaterThanOrEqual(r, 0), e && (Y3.assertLessThanOrEqual(t6, e.text.length), Y3.assertLessThanOrEqual(t6 + r, e.text.length));
          }
          function r0(e, t6, r, s, f10) {
            return t0(e, t6, r), { file: e, start: t6, length: r, code: s.code, category: s.category, messageText: s.next ? s : s.messageText, relatedInformation: f10 };
          }
          function mk(e, t6, r) {
            return { file: e, start: 0, length: 0, code: t6.code, category: t6.category, messageText: t6.next ? t6 : t6.messageText, relatedInformation: r };
          }
          function hk(e) {
            return typeof e.messageText == "string" ? { code: e.code, category: e.category, messageText: e.messageText, next: e.next } : e.messageText;
          }
          function gk(e, t6, r) {
            return { file: e, start: t6.pos, length: t6.end - t6.pos, code: r.code, category: r.category, messageText: r.message };
          }
          function n0(e, t6) {
            let r = Po(e.languageVersion, true, e.languageVariant, e.text, void 0, t6);
            r.scan();
            let s = r.getTokenPos();
            return ha(s, r.getTextPos());
          }
          function yk(e, t6) {
            let r = Po(e.languageVersion, true, e.languageVariant, e.text, void 0, t6);
            return r.scan(), r.getToken();
          }
          function vk(e, t6) {
            let r = Ar2(e.text, t6.pos);
            if (t6.body && t6.body.kind === 238) {
              let { line: s } = Ls(e, t6.body.pos), { line: f10 } = Ls(e, t6.body.end);
              if (s < f10)
                return L_(r, d3(s, e) - r + 1);
            }
            return ha(r, t6.end);
          }
          function i0(e, t6) {
            let r = t6;
            switch (t6.kind) {
              case 308:
                let x10 = Ar2(e.text, 0, false);
                return x10 === e.text.length ? L_(0, 0) : n0(e, x10);
              case 257:
              case 205:
              case 260:
              case 228:
              case 261:
              case 264:
              case 263:
              case 302:
              case 259:
              case 215:
              case 171:
              case 174:
              case 175:
              case 262:
              case 169:
              case 168:
              case 271:
                r = t6.name;
                break;
              case 216:
                return vk(e, t6);
              case 292:
              case 293:
                let w6 = Ar2(e.text, t6.pos), A6 = t6.statements.length > 0 ? t6.statements[0].pos : t6.end;
                return ha(w6, A6);
            }
            if (r === void 0)
              return n0(e, t6.pos);
            Y3.assert(!Ho(r));
            let s = va(r), f10 = s || td(t6) ? r.pos : Ar2(e.text, r.pos);
            return s ? (Y3.assert(f10 === r.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809"), Y3.assert(f10 === r.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")) : (Y3.assert(f10 >= r.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809"), Y3.assert(f10 <= r.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")), ha(f10, r.end);
          }
          function bk(e) {
            return (e.externalModuleIndicator || e.commonJsModuleIndicator) !== void 0;
          }
          function a0(e) {
            return e.scriptKind === 6;
          }
          function Tk(e) {
            return !!(ef(e) & 2048);
          }
          function Sk(e) {
            return !!(ef(e) & 64 && !lS(e, e.parent));
          }
          function D3(e) {
            return !!(tf2(e) & 2);
          }
          function xk(e) {
            return !!(tf2(e) & 1);
          }
          function Ek(e) {
            return e.kind === 210 && e.expression.kind === 106;
          }
          function s0(e) {
            return e.kind === 210 && e.expression.kind === 100;
          }
          function o0(e) {
            return t2(e) && e.keywordToken === 100 && e.name.escapedText === "meta";
          }
          function k3(e) {
            return Kl(e) && Yv(e.argument) && Gn(e.argument.literal);
          }
          function us(e) {
            return e.kind === 241 && e.expression.kind === 10;
          }
          function Tf(e) {
            return !!(xi(e) & 2097152);
          }
          function _0(e) {
            return Tf(e) && Wo(e);
          }
          function wk(e) {
            return yt(e.name) && !e.initializer;
          }
          function c0(e) {
            return Tf(e) && zo(e) && me2(e.declarationList.declarations, wk);
          }
          function Ck(e, t6) {
            return e.kind !== 11 ? Ao(t6.text, e.pos) : void 0;
          }
          function I3(e, t6) {
            let r = e.kind === 166 || e.kind === 165 || e.kind === 215 || e.kind === 216 || e.kind === 214 || e.kind === 257 || e.kind === 278 ? Ft(HT(t6, e.pos), Ao(t6, e.pos)) : Ao(t6, e.pos);
            return ee2(r, (s) => t6.charCodeAt(s.pos + 1) === 42 && t6.charCodeAt(s.pos + 2) === 42 && t6.charCodeAt(s.pos + 3) !== 47);
          }
          function l0(e) {
            if (179 <= e.kind && e.kind <= 202)
              return true;
            switch (e.kind) {
              case 131:
              case 157:
              case 148:
              case 160:
              case 152:
              case 134:
              case 153:
              case 149:
              case 155:
              case 144:
                return true;
              case 114:
                return e.parent.kind !== 219;
              case 230:
                return ru(e.parent) && !Z0(e);
              case 165:
                return e.parent.kind === 197 || e.parent.kind === 192;
              case 79:
                (e.parent.kind === 163 && e.parent.right === e || e.parent.kind === 208 && e.parent.name === e) && (e = e.parent), Y3.assert(e.kind === 79 || e.kind === 163 || e.kind === 208, "'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.");
              case 163:
              case 208:
              case 108: {
                let { parent: t6 } = e;
                if (t6.kind === 183)
                  return false;
                if (t6.kind === 202)
                  return !t6.isTypeOf;
                if (179 <= t6.kind && t6.kind <= 202)
                  return true;
                switch (t6.kind) {
                  case 230:
                    return ru(t6.parent) && !Z0(t6);
                  case 165:
                    return e === t6.constraint;
                  case 348:
                    return e === t6.constraint;
                  case 169:
                  case 168:
                  case 166:
                  case 257:
                    return e === t6.type;
                  case 259:
                  case 215:
                  case 216:
                  case 173:
                  case 171:
                  case 170:
                  case 174:
                  case 175:
                    return e === t6.type;
                  case 176:
                  case 177:
                  case 178:
                    return e === t6.type;
                  case 213:
                    return e === t6.type;
                  case 210:
                  case 211:
                    return pe2(t6.typeArguments, e);
                  case 212:
                    return false;
                }
              }
            }
            return false;
          }
          function Ak(e, t6) {
            for (; e; ) {
              if (e.kind === t6)
                return true;
              e = e.parent;
            }
            return false;
          }
          function Pk(e, t6) {
            return r(e);
            function r(s) {
              switch (s.kind) {
                case 250:
                  return t6(s);
                case 266:
                case 238:
                case 242:
                case 243:
                case 244:
                case 245:
                case 246:
                case 247:
                case 251:
                case 252:
                case 292:
                case 293:
                case 253:
                case 255:
                case 295:
                  return xr2(s, r);
              }
            }
          }
          function Dk(e, t6) {
            return r(e);
            function r(s) {
              switch (s.kind) {
                case 226:
                  t6(s);
                  let f10 = s.expression;
                  f10 && r(f10);
                  return;
                case 263:
                case 261:
                case 264:
                case 262:
                  return;
                default:
                  if (ga(s)) {
                    if (s.name && s.name.kind === 164) {
                      r(s.name.expression);
                      return;
                    }
                  } else
                    l0(s) || xr2(s, r);
              }
            }
          }
          function kk(e) {
            return e && e.kind === 185 ? e.elementType : e && e.kind === 180 ? Xa(e.typeArguments) : void 0;
          }
          function Ik(e) {
            switch (e.kind) {
              case 261:
              case 260:
              case 228:
              case 184:
                return e.members;
              case 207:
                return e.properties;
            }
          }
          function u0(e) {
            if (e)
              switch (e.kind) {
                case 205:
                case 302:
                case 166:
                case 299:
                case 169:
                case 168:
                case 300:
                case 257:
                  return true;
              }
            return false;
          }
          function Nk(e) {
            return u0(e) || pf(e);
          }
          function N3(e) {
            return e.parent.kind === 258 && e.parent.parent.kind === 240;
          }
          function Ok(e) {
            return Pr(e) ? Hs(e.parent) && ur2(e.parent.parent) && ps(e.parent.parent) === 2 || p0(e.parent) : false;
          }
          function p0(e) {
            return Pr(e) ? ur2(e) && ps(e) === 1 : false;
          }
          function Mk(e) {
            return (Vi(e) ? D3(e) && yt(e.name) && N3(e) : Bo(e) ? $0(e) && Lf(e) : Wl(e) && $0(e)) || p0(e);
          }
          function Lk(e) {
            switch (e.kind) {
              case 171:
              case 170:
              case 173:
              case 174:
              case 175:
              case 259:
              case 215:
                return true;
            }
            return false;
          }
          function Rk(e, t6) {
            for (; ; ) {
              if (t6 && t6(e), e.statement.kind !== 253)
                return e.statement;
              e = e.statement;
            }
          }
          function O3(e) {
            return e && e.kind === 238 && ga(e.parent);
          }
          function jk(e) {
            return e && e.kind === 171 && e.parent.kind === 207;
          }
          function Jk(e) {
            return (e.kind === 171 || e.kind === 174 || e.kind === 175) && (e.parent.kind === 207 || e.parent.kind === 228);
          }
          function Fk(e) {
            return e && e.kind === 1;
          }
          function Bk(e) {
            return e && e.kind === 0;
          }
          function f0(e, t6, r) {
            return e.properties.filter((s) => {
              if (s.kind === 299) {
                let f10 = e0(s.name);
                return t6 === f10 || !!r && r === f10;
              }
              return false;
            });
          }
          function qk(e, t6, r) {
            return q2(f0(e, t6), (s) => Yl(s.initializer) ? Ae2(s.initializer.elements, (f10) => Gn(f10) && f10.text === r) : void 0);
          }
          function M3(e) {
            if (e && e.statements.length) {
              let t6 = e.statements[0].expression;
              return ln(t6, Hs);
            }
          }
          function Uk(e, t6, r) {
            return q2(L3(e, t6), (s) => Yl(s.initializer) ? Ae2(s.initializer.elements, (f10) => Gn(f10) && f10.text === r) : void 0);
          }
          function L3(e, t6) {
            let r = M3(e);
            return r ? f0(r, t6) : Bt;
          }
          function zk(e) {
            return zi(e.parent, ga);
          }
          function Wk(e) {
            return zi(e.parent, HS);
          }
          function Vk(e) {
            return zi(e.parent, bi);
          }
          function Hk(e) {
            return zi(e.parent, (t6) => bi(t6) || ga(t6) ? "quit" : Hl(t6));
          }
          function Gk(e) {
            return zi(e.parent, uf);
          }
          function d0(e, t6, r) {
            for (Y3.assert(e.kind !== 308); ; ) {
              if (e = e.parent, !e)
                return Y3.fail();
              switch (e.kind) {
                case 164:
                  if (r && bi(e.parent.parent))
                    return e;
                  e = e.parent.parent;
                  break;
                case 167:
                  e.parent.kind === 166 && Js(e.parent.parent) ? e = e.parent.parent : Js(e.parent) && (e = e.parent);
                  break;
                case 216:
                  if (!t6)
                    continue;
                case 259:
                case 215:
                case 264:
                case 172:
                case 169:
                case 168:
                case 171:
                case 170:
                case 173:
                case 174:
                case 175:
                case 176:
                case 177:
                case 178:
                case 263:
                case 308:
                  return e;
              }
            }
          }
          function $k(e) {
            switch (e.kind) {
              case 216:
              case 259:
              case 215:
              case 169:
                return true;
              case 238:
                switch (e.parent.kind) {
                  case 173:
                  case 171:
                  case 174:
                  case 175:
                    return true;
                  default:
                    return false;
                }
              default:
                return false;
            }
          }
          function Kk(e) {
            yt(e) && (_c(e.parent) || Wo(e.parent)) && e.parent.name === e && (e = e.parent);
            let t6 = d0(e, true, false);
            return wi(t6);
          }
          function Xk(e) {
            let t6 = d0(e, false, false);
            if (t6)
              switch (t6.kind) {
                case 173:
                case 259:
                case 215:
                  return t6;
              }
          }
          function Yk(e, t6) {
            for (; ; ) {
              if (e = e.parent, !e)
                return;
              switch (e.kind) {
                case 164:
                  e = e.parent;
                  break;
                case 259:
                case 215:
                case 216:
                  if (!t6)
                    continue;
                case 169:
                case 168:
                case 171:
                case 170:
                case 173:
                case 174:
                case 175:
                case 172:
                  return e;
                case 167:
                  e.parent.kind === 166 && Js(e.parent.parent) ? e = e.parent.parent : Js(e.parent) && (e = e.parent);
                  break;
              }
            }
          }
          function Qk(e) {
            if (e.kind === 215 || e.kind === 216) {
              let t6 = e, r = e.parent;
              for (; r.kind === 214; )
                t6 = r, r = r.parent;
              if (r.kind === 210 && r.expression === t6)
                return r;
            }
          }
          function Zk(e) {
            return e.kind === 106 || Sf(e);
          }
          function Sf(e) {
            let t6 = e.kind;
            return (t6 === 208 || t6 === 209) && e.expression.kind === 106;
          }
          function eI(e) {
            let t6 = e.kind;
            return (t6 === 208 || t6 === 209) && e.expression.kind === 108;
          }
          function tI(e) {
            var t6;
            return !!e && Vi(e) && ((t6 = e.initializer) == null ? void 0 : t6.kind) === 108;
          }
          function rI(e) {
            return !!e && (nu(e) || lc(e)) && ur2(e.parent.parent) && e.parent.parent.operatorToken.kind === 63 && e.parent.parent.right.kind === 108;
          }
          function nI(e) {
            switch (e.kind) {
              case 180:
                return e.typeName;
              case 230:
                return Bs(e.expression) ? e.expression : void 0;
              case 79:
              case 163:
                return e;
            }
          }
          function iI(e) {
            switch (e.kind) {
              case 212:
                return e.tag;
              case 283:
              case 282:
                return e.tagName;
              default:
                return e.expression;
            }
          }
          function R3(e, t6, r, s) {
            if (e && af(t6) && vn(t6.name))
              return false;
            switch (t6.kind) {
              case 260:
                return true;
              case 228:
                return !e;
              case 169:
                return r !== void 0 && (e ? _c(r) : bi(r) && !W4(t6) && !V4(t6));
              case 174:
              case 175:
              case 171:
                return t6.body !== void 0 && r !== void 0 && (e ? _c(r) : bi(r));
              case 166:
                return e ? r !== void 0 && r.body !== void 0 && (r.kind === 173 || r.kind === 171 || r.kind === 175) && j4(r) !== t6 && s !== void 0 && s.kind === 260 : false;
            }
            return false;
          }
          function q_(e, t6, r, s) {
            return Il(t6) && R3(e, t6, r, s);
          }
          function m0(e, t6, r, s) {
            return q_(e, t6, r, s) || h0(e, t6, r);
          }
          function h0(e, t6, r) {
            switch (t6.kind) {
              case 260:
                return Ke3(t6.members, (s) => m0(e, s, t6, r));
              case 228:
                return !e && Ke3(t6.members, (s) => m0(e, s, t6, r));
              case 171:
              case 175:
              case 173:
                return Ke3(t6.parameters, (s) => q_(e, s, t6, r));
              default:
                return false;
            }
          }
          function aI(e, t6) {
            if (q_(e, t6))
              return true;
            let r = R4(t6);
            return !!r && h0(e, r, t6);
          }
          function sI(e, t6, r) {
            let s;
            if (pf(t6)) {
              let { firstAccessor: f10, secondAccessor: x10, setAccessor: w6 } = W0(r.members, t6), A6 = Il(f10) ? f10 : x10 && Il(x10) ? x10 : void 0;
              if (!A6 || t6 !== A6)
                return false;
              s = w6 == null ? void 0 : w6.parameters;
            } else
              Vl(t6) && (s = t6.parameters);
            if (q_(e, t6, r))
              return true;
            if (s) {
              for (let f10 of s)
                if (!kl(f10) && q_(e, f10, t6, r))
                  return true;
            }
            return false;
          }
          function j3(e) {
            if (e.textSourceNode) {
              switch (e.textSourceNode.kind) {
                case 10:
                  return j3(e.textSourceNode);
                case 14:
                  return e.text === "";
              }
              return false;
            }
            return e.text === "";
          }
          function xf(e) {
            let { parent: t6 } = e;
            return t6.kind === 283 || t6.kind === 282 || t6.kind === 284 ? t6.tagName === e : false;
          }
          function g0(e) {
            switch (e.kind) {
              case 106:
              case 104:
              case 110:
              case 95:
              case 13:
              case 206:
              case 207:
              case 208:
              case 209:
              case 210:
              case 211:
              case 212:
              case 231:
              case 213:
              case 235:
              case 232:
              case 214:
              case 215:
              case 228:
              case 216:
              case 219:
              case 217:
              case 218:
              case 221:
              case 222:
              case 223:
              case 224:
              case 227:
              case 225:
              case 229:
              case 281:
              case 282:
              case 285:
              case 226:
              case 220:
              case 233:
                return true;
              case 230:
                return !ru(e.parent) && !md(e.parent);
              case 163:
                for (; e.parent.kind === 163; )
                  e = e.parent;
                return e.parent.kind === 183 || Sl(e.parent) || fd(e.parent) || uc(e.parent) || xf(e);
              case 314:
                for (; uc(e.parent); )
                  e = e.parent;
                return e.parent.kind === 183 || Sl(e.parent) || fd(e.parent) || uc(e.parent) || xf(e);
              case 80:
                return ur2(e.parent) && e.parent.left === e && e.parent.operatorToken.kind === 101;
              case 79:
                if (e.parent.kind === 183 || Sl(e.parent) || fd(e.parent) || uc(e.parent) || xf(e))
                  return true;
              case 8:
              case 9:
              case 10:
              case 14:
              case 108:
                return J32(e);
              default:
                return false;
            }
          }
          function J32(e) {
            let { parent: t6 } = e;
            switch (t6.kind) {
              case 257:
              case 166:
              case 169:
              case 168:
              case 302:
              case 299:
              case 205:
                return t6.initializer === e;
              case 241:
              case 242:
              case 243:
              case 244:
              case 250:
              case 251:
              case 252:
              case 292:
              case 254:
                return t6.expression === e;
              case 245:
                let r = t6;
                return r.initializer === e && r.initializer.kind !== 258 || r.condition === e || r.incrementor === e;
              case 246:
              case 247:
                let s = t6;
                return s.initializer === e && s.initializer.kind !== 258 || s.expression === e;
              case 213:
              case 231:
                return e === t6.expression;
              case 236:
                return e === t6.expression;
              case 164:
                return e === t6.expression;
              case 167:
              case 291:
              case 290:
              case 301:
                return true;
              case 230:
                return t6.expression === e && !l0(t6);
              case 300:
                return t6.objectAssignmentInitializer === e;
              case 235:
                return e === t6.expression;
              default:
                return g0(t6);
            }
          }
          function F3(e) {
            for (; e.kind === 163 || e.kind === 79; )
              e = e.parent;
            return e.kind === 183;
          }
          function oI(e) {
            return ld(e) && !!e.parent.moduleSpecifier;
          }
          function B3(e) {
            return e.kind === 268 && e.moduleReference.kind === 280;
          }
          function _I(e) {
            return Y3.assert(B3(e)), e.moduleReference.expression;
          }
          function cI(e) {
            return Ef(e) && rv(e.initializer).arguments[0];
          }
          function lI(e) {
            return e.kind === 268 && e.moduleReference.kind !== 280;
          }
          function y0(e) {
            return Pr(e);
          }
          function uI(e) {
            return !Pr(e);
          }
          function Pr(e) {
            return !!e && !!(e.flags & 262144);
          }
          function pI(e) {
            return !!e && !!(e.flags & 67108864);
          }
          function fI(e) {
            return !a0(e);
          }
          function q3(e) {
            return !!e && !!(e.flags & 8388608);
          }
          function dI(e) {
            return ac(e) && yt(e.typeName) && e.typeName.escapedText === "Object" && e.typeArguments && e.typeArguments.length === 2 && (e.typeArguments[0].kind === 152 || e.typeArguments[0].kind === 148);
          }
          function El(e, t6) {
            if (e.kind !== 210)
              return false;
            let { expression: r, arguments: s } = e;
            if (r.kind !== 79 || r.escapedText !== "require" || s.length !== 1)
              return false;
            let f10 = s[0];
            return !t6 || Ti(f10);
          }
          function U3(e) {
            return z3(e, false);
          }
          function Ef(e) {
            return z3(e, true);
          }
          function mI(e) {
            return Xl(e) && Ef(e.parent.parent);
          }
          function z3(e, t6) {
            return Vi(e) && !!e.initializer && El(t6 ? rv(e.initializer) : e.initializer, true);
          }
          function W3(e) {
            return zo(e) && e.declarationList.declarations.length > 0 && me2(e.declarationList.declarations, (t6) => U3(t6));
          }
          function hI(e) {
            return e === 39 || e === 34;
          }
          function gI(e, t6) {
            return No(t6, e).charCodeAt(0) === 34;
          }
          function v0(e) {
            return ur2(e) || Lo(e) || yt(e) || sc(e);
          }
          function V3(e) {
            return Pr(e) && e.initializer && ur2(e.initializer) && (e.initializer.operatorToken.kind === 56 || e.initializer.operatorToken.kind === 60) && e.name && Bs(e.name) && z_(e.name, e.initializer.left) ? e.initializer.right : e.initializer;
          }
          function yI(e) {
            let t6 = V3(e);
            return t6 && U_(t6, Nl(e.name));
          }
          function vI(e, t6) {
            return c(e.properties, (r) => lc(r) && yt(r.name) && r.name.escapedText === "value" && r.initializer && U_(r.initializer, t6));
          }
          function bI(e) {
            if (e && e.parent && ur2(e.parent) && e.parent.operatorToken.kind === 63) {
              let t6 = Nl(e.parent.left);
              return U_(e.parent.right, t6) || TI(e.parent.left, e.parent.right, t6);
            }
            if (e && sc(e) && S0(e)) {
              let t6 = vI(e.arguments[2], e.arguments[1].text === "prototype");
              if (t6)
                return t6;
            }
          }
          function U_(e, t6) {
            if (sc(e)) {
              let r = Pl(e.expression);
              return r.kind === 215 || r.kind === 216 ? e : void 0;
            }
            if (e.kind === 215 || e.kind === 228 || e.kind === 216 || Hs(e) && (e.properties.length === 0 || t6))
              return e;
          }
          function TI(e, t6, r) {
            let s = ur2(t6) && (t6.operatorToken.kind === 56 || t6.operatorToken.kind === 60) && U_(t6.right, r);
            if (s && z_(e, t6.left))
              return s;
          }
          function SI(e) {
            let t6 = Vi(e.parent) ? e.parent.name : ur2(e.parent) && e.parent.operatorToken.kind === 63 ? e.parent.left : void 0;
            return t6 && U_(e.right, Nl(t6)) && Bs(t6) && z_(t6, e.left);
          }
          function xI(e) {
            if (ur2(e.parent)) {
              let t6 = (e.parent.operatorToken.kind === 56 || e.parent.operatorToken.kind === 60) && ur2(e.parent.parent) ? e.parent.parent : e.parent;
              if (t6.operatorToken.kind === 63 && yt(t6.left))
                return t6.left;
            } else if (Vi(e.parent))
              return e.parent.name;
          }
          function z_(e, t6) {
            return L0(e) && L0(t6) ? kf(e) === kf(t6) : js(e) && wf(t6) && (t6.expression.kind === 108 || yt(t6.expression) && (t6.expression.escapedText === "window" || t6.expression.escapedText === "self" || t6.expression.escapedText === "global")) ? z_(e, $3(t6)) : wf(e) && wf(t6) ? Fs(e) === Fs(t6) && z_(e.expression, t6.expression) : false;
          }
          function b0(e) {
            for (; ms(e, true); )
              e = e.right;
            return e;
          }
          function H3(e) {
            return yt(e) && e.escapedText === "exports";
          }
          function G3(e) {
            return yt(e) && e.escapedText === "module";
          }
          function T0(e) {
            return (bn(e) || wl(e)) && G3(e.expression) && Fs(e) === "exports";
          }
          function ps(e) {
            let t6 = EI(e);
            return t6 === 5 || Pr(e) ? t6 : 0;
          }
          function S0(e) {
            return I(e.arguments) === 3 && bn(e.expression) && yt(e.expression.expression) && qr2(e.expression.expression) === "Object" && qr2(e.expression.name) === "defineProperty" && Ta(e.arguments[1]) && V_(e.arguments[0], true);
          }
          function wf(e) {
            return bn(e) || wl(e);
          }
          function wl(e) {
            return gs(e) && Ta(e.argumentExpression);
          }
          function W_(e, t6) {
            return bn(e) && (!t6 && e.expression.kind === 108 || yt(e.name) && V_(e.expression, true)) || x0(e, t6);
          }
          function x0(e, t6) {
            return wl(e) && (!t6 && e.expression.kind === 108 || Bs(e.expression) || W_(e.expression, true));
          }
          function V_(e, t6) {
            return Bs(e) || W_(e, t6);
          }
          function $3(e) {
            return bn(e) ? e.name : e.argumentExpression;
          }
          function EI(e) {
            if (sc(e)) {
              if (!S0(e))
                return 0;
              let t6 = e.arguments[0];
              return H3(t6) || T0(t6) ? 8 : W_(t6) && Fs(t6) === "prototype" ? 9 : 7;
            }
            return e.operatorToken.kind !== 63 || !Lo(e.left) || wI(b0(e)) ? 0 : V_(e.left.expression, true) && Fs(e.left) === "prototype" && Hs(X3(e)) ? 6 : K3(e.left);
          }
          function wI(e) {
            return Qv(e) && zs(e.expression) && e.expression.text === "0";
          }
          function Cf(e) {
            if (bn(e))
              return e.name;
            let t6 = Pl(e.argumentExpression);
            return zs(t6) || Ti(t6) ? t6 : e;
          }
          function Fs(e) {
            let t6 = Cf(e);
            if (t6) {
              if (yt(t6))
                return t6.escapedText;
              if (Ti(t6) || zs(t6))
                return vi(t6.text);
            }
          }
          function K3(e) {
            if (e.expression.kind === 108)
              return 4;
            if (T0(e))
              return 2;
            if (V_(e.expression, true)) {
              if (Nl(e.expression))
                return 3;
              let t6 = e;
              for (; !yt(t6.expression); )
                t6 = t6.expression;
              let r = t6.expression;
              if ((r.escapedText === "exports" || r.escapedText === "module" && Fs(t6) === "exports") && W_(e))
                return 1;
              if (V_(e, true) || gs(e) && M0(e))
                return 5;
            }
            return 0;
          }
          function X3(e) {
            for (; ur2(e.right); )
              e = e.right;
            return e.right;
          }
          function CI(e) {
            return ur2(e) && ps(e) === 3;
          }
          function AI(e) {
            return Pr(e) && e.parent && e.parent.kind === 241 && (!gs(e) || wl(e)) && !!_f(e.parent);
          }
          function PI(e, t6) {
            let { valueDeclaration: r } = e;
            (!r || !(t6.flags & 16777216 && !Pr(t6) && !(r.flags & 16777216)) && v0(r) && !v0(t6) || r.kind !== t6.kind && S3(r)) && (e.valueDeclaration = t6);
          }
          function DI(e) {
            if (!e || !e.valueDeclaration)
              return false;
            let t6 = e.valueDeclaration;
            return t6.kind === 259 || Vi(t6) && t6.initializer && ga(t6.initializer);
          }
          function kI(e) {
            var t6, r;
            switch (e.kind) {
              case 257:
              case 205:
                return (t6 = zi(e.initializer, (s) => El(s, true))) == null ? void 0 : t6.arguments[0];
              case 269:
                return ln(e.moduleSpecifier, Ti);
              case 268:
                return ln((r = ln(e.moduleReference, ud)) == null ? void 0 : r.expression, Ti);
              case 270:
              case 277:
                return ln(e.parent.moduleSpecifier, Ti);
              case 271:
              case 278:
                return ln(e.parent.parent.moduleSpecifier, Ti);
              case 273:
                return ln(e.parent.parent.parent.moduleSpecifier, Ti);
              default:
                Y3.assertNever(e);
            }
          }
          function II(e) {
            return Y32(e) || Y3.failBadSyntaxKind(e.parent);
          }
          function Y32(e) {
            switch (e.parent.kind) {
              case 269:
              case 275:
                return e.parent;
              case 280:
                return e.parent.parent;
              case 210:
                return s0(e.parent) || El(e.parent, false) ? e.parent : void 0;
              case 198:
                return Y3.assert(Gn(e)), ln(e.parent.parent, Kl);
              default:
                return;
            }
          }
          function E0(e) {
            switch (e.kind) {
              case 269:
              case 275:
                return e.moduleSpecifier;
              case 268:
                return e.moduleReference.kind === 280 ? e.moduleReference.expression : void 0;
              case 202:
                return k3(e) ? e.argument.literal : void 0;
              case 210:
                return e.arguments[0];
              case 264:
                return e.name.kind === 10 ? e.name : void 0;
              default:
                return Y3.assertNever(e);
            }
          }
          function Q3(e) {
            switch (e.kind) {
              case 269:
                return e.importClause && ln(e.importClause.namedBindings, _2);
              case 268:
                return e;
              case 275:
                return e.exportClause && ln(e.exportClause, ld);
              default:
                return Y3.assertNever(e);
            }
          }
          function Z3(e) {
            return e.kind === 269 && !!e.importClause && !!e.importClause.name;
          }
          function NI(e, t6) {
            if (e.name) {
              let r = t6(e);
              if (r)
                return r;
            }
            if (e.namedBindings) {
              let r = _2(e.namedBindings) ? t6(e.namedBindings) : c(e.namedBindings.elements, t6);
              if (r)
                return r;
            }
          }
          function OI(e) {
            if (e)
              switch (e.kind) {
                case 166:
                case 171:
                case 170:
                case 300:
                case 299:
                case 169:
                case 168:
                  return e.questionToken !== void 0;
              }
            return false;
          }
          function MI(e) {
            let t6 = dd(e) ? pa(e.parameters) : void 0, r = ln(t6 && t6.name, yt);
            return !!r && r.escapedText === "new";
          }
          function Cl(e) {
            return e.kind === 349 || e.kind === 341 || e.kind === 343;
          }
          function LI(e) {
            return Cl(e) || n2(e);
          }
          function RI(e) {
            return Zl(e) && ur2(e.expression) && e.expression.operatorToken.kind === 63 ? b0(e.expression) : void 0;
          }
          function e4(e) {
            return Zl(e) && ur2(e.expression) && ps(e.expression) !== 0 && ur2(e.expression.right) && (e.expression.right.operatorToken.kind === 56 || e.expression.right.operatorToken.kind === 60) ? e.expression.right.right : void 0;
          }
          function w0(e) {
            switch (e.kind) {
              case 240:
                let t6 = Al(e);
                return t6 && t6.initializer;
              case 169:
                return e.initializer;
              case 299:
                return e.initializer;
            }
          }
          function Al(e) {
            return zo(e) ? pa(e.declarationList.declarations) : void 0;
          }
          function t4(e) {
            return Ea(e) && e.body && e.body.kind === 264 ? e.body : void 0;
          }
          function jI(e) {
            if (e.kind >= 240 && e.kind <= 256)
              return true;
            switch (e.kind) {
              case 79:
              case 108:
              case 106:
              case 163:
              case 233:
              case 209:
              case 208:
              case 205:
              case 215:
              case 216:
              case 171:
              case 174:
              case 175:
                return true;
              default:
                return false;
            }
          }
          function Af(e) {
            switch (e.kind) {
              case 216:
              case 223:
              case 238:
              case 249:
              case 176:
              case 292:
              case 260:
              case 228:
              case 172:
              case 173:
              case 182:
              case 177:
              case 248:
              case 256:
              case 243:
              case 209:
              case 239:
              case 1:
              case 263:
              case 302:
              case 274:
              case 275:
              case 278:
              case 241:
              case 246:
              case 247:
              case 245:
              case 259:
              case 215:
              case 181:
              case 174:
              case 79:
              case 242:
              case 269:
              case 268:
              case 178:
              case 261:
              case 320:
              case 326:
              case 253:
              case 171:
              case 170:
              case 264:
              case 199:
              case 267:
              case 207:
              case 166:
              case 214:
              case 208:
              case 299:
              case 169:
              case 168:
              case 250:
              case 175:
              case 300:
              case 301:
              case 252:
              case 254:
              case 255:
              case 262:
              case 165:
              case 257:
              case 240:
              case 244:
              case 251:
                return true;
              default:
                return false;
            }
          }
          function r4(e, t6) {
            let r;
            u0(e) && l3(e) && ya(e.initializer) && (r = jr2(r, n4(e, Zn(e.initializer.jsDoc))));
            let s = e;
            for (; s && s.parent; ) {
              if (ya(s) && (r = jr2(r, n4(e, Zn(s.jsDoc)))), s.kind === 166) {
                r = jr2(r, (t6 ? bS : of)(s));
                break;
              }
              if (s.kind === 165) {
                r = jr2(r, (t6 ? xS : SS)(s));
                break;
              }
              s = a4(s);
            }
            return r || Bt;
          }
          function n4(e, t6) {
            if (Ho(t6)) {
              let r = ee2(t6.tags, (s) => i4(e, s));
              return t6.tags === r ? [t6] : r;
            }
            return i4(e, t6) ? [t6] : void 0;
          }
          function i4(e, t6) {
            return !(au(t6) || T2(t6)) || !t6.parent || !Ho(t6.parent) || !qo(t6.parent.parent) || t6.parent.parent === e;
          }
          function a4(e) {
            let t6 = e.parent;
            if (t6.kind === 299 || t6.kind === 274 || t6.kind === 169 || t6.kind === 241 && e.kind === 208 || t6.kind === 250 || t4(t6) || ur2(e) && e.operatorToken.kind === 63)
              return t6;
            if (t6.parent && (Al(t6.parent) === e || ur2(t6) && t6.operatorToken.kind === 63))
              return t6.parent;
            if (t6.parent && t6.parent.parent && (Al(t6.parent.parent) || w0(t6.parent.parent) === e || e4(t6.parent.parent)))
              return t6.parent.parent;
          }
          function JI(e) {
            if (e.symbol)
              return e.symbol;
            if (!yt(e.name))
              return;
            let t6 = e.name.escapedText, r = C0(e);
            if (!r)
              return;
            let s = Ae2(r.parameters, (f10) => f10.name.kind === 79 && f10.name.escapedText === t6);
            return s && s.symbol;
          }
          function FI(e) {
            if (Ho(e.parent) && e.parent.tags) {
              let t6 = Ae2(e.parent.tags, Cl);
              if (t6)
                return t6;
            }
            return C0(e);
          }
          function C0(e) {
            let t6 = A0(e);
            if (t6)
              return Wl(t6) && t6.type && ga(t6.type) ? t6.type : ga(t6) ? t6 : void 0;
          }
          function A0(e) {
            let t6 = s4(e);
            if (t6)
              return e4(t6) || RI(t6) || w0(t6) || Al(t6) || t4(t6) || t6;
          }
          function s4(e) {
            let t6 = P0(e);
            if (!t6)
              return;
            let r = t6.parent;
            if (r && r.jsDoc && t6 === Cn(r.jsDoc))
              return r;
          }
          function P0(e) {
            return zi(e.parent, Ho);
          }
          function BI(e) {
            let t6 = e.name.escapedText, { typeParameters: r } = e.parent.parent.parent;
            return r && Ae2(r, (s) => s.name.escapedText === t6);
          }
          function qI(e) {
            return !!e.typeArguments;
          }
          function o4(e) {
            let t6 = e.parent;
            for (; ; ) {
              switch (t6.kind) {
                case 223:
                  let r = t6.operatorToken.kind;
                  return G_(r) && t6.left === e ? r === 63 || jf(r) ? 1 : 2 : 0;
                case 221:
                case 222:
                  let s = t6.operator;
                  return s === 45 || s === 46 ? 2 : 0;
                case 246:
                case 247:
                  return t6.initializer === e ? 1 : 0;
                case 214:
                case 206:
                case 227:
                case 232:
                  e = t6;
                  break;
                case 301:
                  e = t6.parent;
                  break;
                case 300:
                  if (t6.name !== e)
                    return 0;
                  e = t6.parent;
                  break;
                case 299:
                  if (t6.name === e)
                    return 0;
                  e = t6.parent;
                  break;
                default:
                  return 0;
              }
              t6 = e.parent;
            }
          }
          function UI(e) {
            return o4(e) !== 0;
          }
          function zI(e) {
            switch (e.kind) {
              case 238:
              case 240:
              case 251:
              case 242:
              case 252:
              case 266:
              case 292:
              case 293:
              case 253:
              case 245:
              case 246:
              case 247:
              case 243:
              case 244:
              case 255:
              case 295:
                return true;
            }
            return false;
          }
          function WI(e) {
            return ad(e) || sd(e) || Ly(e) || Wo(e) || nc(e);
          }
          function _4(e, t6) {
            for (; e && e.kind === t6; )
              e = e.parent;
            return e;
          }
          function VI(e) {
            return _4(e, 193);
          }
          function D0(e) {
            return _4(e, 214);
          }
          function HI(e) {
            let t6;
            for (; e && e.kind === 193; )
              t6 = e, e = e.parent;
            return [t6, e];
          }
          function GI(e) {
            for (; Kv(e); )
              e = e.type;
            return e;
          }
          function Pl(e, t6) {
            return $o(e, t6 ? 17 : 1);
          }
          function $I(e) {
            return e.kind !== 208 && e.kind !== 209 ? false : (e = D0(e.parent), e && e.kind === 217);
          }
          function KI(e, t6) {
            for (; e; ) {
              if (e === t6)
                return true;
              e = e.parent;
            }
            return false;
          }
          function c4(e) {
            return !wi(e) && !df(e) && ko(e.parent) && e.parent.name === e;
          }
          function XI(e) {
            let t6 = e.parent;
            switch (e.kind) {
              case 10:
              case 14:
              case 8:
                if (Ws(t6))
                  return t6.parent;
              case 79:
                if (ko(t6))
                  return t6.name === e ? t6 : void 0;
                if (rc(t6)) {
                  let r = t6.parent;
                  return pc(r) && r.name === t6 ? r : void 0;
                } else {
                  let r = t6.parent;
                  return ur2(r) && ps(r) !== 0 && (r.left.symbol || r.symbol) && ml(r) === e ? r : void 0;
                }
              case 80:
                return ko(t6) && t6.name === e ? t6 : void 0;
              default:
                return;
            }
          }
          function l4(e) {
            return Ta(e) && e.parent.kind === 164 && ko(e.parent.parent);
          }
          function YI(e) {
            let t6 = e.parent;
            switch (t6.kind) {
              case 169:
              case 168:
              case 171:
              case 170:
              case 174:
              case 175:
              case 302:
              case 299:
              case 208:
                return t6.name === e;
              case 163:
                return t6.right === e;
              case 205:
              case 273:
                return t6.propertyName === e;
              case 278:
              case 288:
              case 282:
              case 283:
              case 284:
                return true;
            }
            return false;
          }
          function QI(e) {
            return e.kind === 268 || e.kind === 267 || e.kind === 270 && e.name || e.kind === 271 || e.kind === 277 || e.kind === 273 || e.kind === 278 || e.kind === 274 && I0(e) ? true : Pr(e) && (ur2(e) && ps(e) === 2 && I0(e) || bn(e) && ur2(e.parent) && e.parent.left === e && e.parent.operatorToken.kind === 63 && k0(e.parent.right));
          }
          function u4(e) {
            switch (e.parent.kind) {
              case 270:
              case 273:
              case 271:
              case 278:
              case 274:
              case 268:
              case 277:
                return e.parent;
              case 163:
                do
                  e = e.parent;
                while (e.parent.kind === 163);
                return u4(e);
            }
          }
          function k0(e) {
            return Bs(e) || _d(e);
          }
          function I0(e) {
            let t6 = p4(e);
            return k0(t6);
          }
          function p4(e) {
            return Vo(e) ? e.expression : e.right;
          }
          function ZI(e) {
            return e.kind === 300 ? e.name : e.kind === 299 ? e.initializer : e.parent.right;
          }
          function f4(e) {
            let t6 = d4(e);
            if (t6 && Pr(e)) {
              let r = ES(e);
              if (r)
                return r.class;
            }
            return t6;
          }
          function d4(e) {
            let t6 = Pf(e.heritageClauses, 94);
            return t6 && t6.types.length > 0 ? t6.types[0] : void 0;
          }
          function m4(e) {
            if (Pr(e))
              return wS(e).map((t6) => t6.class);
            {
              let t6 = Pf(e.heritageClauses, 117);
              return t6 == null ? void 0 : t6.types;
            }
          }
          function h4(e) {
            return eu(e) ? g4(e) || Bt : bi(e) && Ft(Cp(f4(e)), m4(e)) || Bt;
          }
          function g4(e) {
            let t6 = Pf(e.heritageClauses, 94);
            return t6 ? t6.types : void 0;
          }
          function Pf(e, t6) {
            if (e) {
              for (let r of e)
                if (r.token === t6)
                  return r;
            }
          }
          function eN(e, t6) {
            for (; e; ) {
              if (e.kind === t6)
                return e;
              e = e.parent;
            }
          }
          function ba(e) {
            return 81 <= e && e <= 162;
          }
          function N0(e) {
            return 126 <= e && e <= 162;
          }
          function y4(e) {
            return ba(e) && !N0(e);
          }
          function tN(e) {
            return 117 <= e && e <= 125;
          }
          function rN(e) {
            let t6 = _l(e);
            return t6 !== void 0 && y4(t6);
          }
          function nN(e) {
            let t6 = _l(e);
            return t6 !== void 0 && ba(t6);
          }
          function iN(e) {
            let t6 = dS(e);
            return !!t6 && !N0(t6);
          }
          function aN(e) {
            return 2 <= e && e <= 7;
          }
          function sN(e) {
            if (!e)
              return 4;
            let t6 = 0;
            switch (e.kind) {
              case 259:
              case 215:
              case 171:
                e.asteriskToken && (t6 |= 1);
              case 216:
                rn(e, 512) && (t6 |= 2);
                break;
            }
            return e.body || (t6 |= 4), t6;
          }
          function oN(e) {
            switch (e.kind) {
              case 259:
              case 215:
              case 216:
              case 171:
                return e.body !== void 0 && e.asteriskToken === void 0 && rn(e, 512);
            }
            return false;
          }
          function Ta(e) {
            return Ti(e) || zs(e);
          }
          function O0(e) {
            return od(e) && (e.operator === 39 || e.operator === 40) && zs(e.operand);
          }
          function v4(e) {
            let t6 = ml(e);
            return !!t6 && M0(t6);
          }
          function M0(e) {
            if (!(e.kind === 164 || e.kind === 209))
              return false;
            let t6 = gs(e) ? Pl(e.argumentExpression) : e.expression;
            return !Ta(t6) && !O0(t6);
          }
          function Df(e) {
            switch (e.kind) {
              case 79:
              case 80:
                return e.escapedText;
              case 10:
              case 8:
                return vi(e.text);
              case 164:
                let t6 = e.expression;
                return Ta(t6) ? vi(t6.text) : O0(t6) ? t6.operator === 40 ? Br2(t6.operator) + t6.operand.text : t6.operand.text : void 0;
              default:
                return Y3.assertNever(e);
            }
          }
          function L0(e) {
            switch (e.kind) {
              case 79:
              case 10:
              case 14:
              case 8:
                return true;
              default:
                return false;
            }
          }
          function kf(e) {
            return js(e) ? qr2(e) : e.text;
          }
          function b4(e) {
            return js(e) ? e.escapedText : vi(e.text);
          }
          function _N(e) {
            return `__@${getSymbolId(e)}@${e.escapedName}`;
          }
          function cN(e, t6) {
            return `__#${getSymbolId(e)}@${t6}`;
          }
          function lN(e) {
            return Pn(e.escapedName, "__@");
          }
          function uN(e) {
            return Pn(e.escapedName, "__#");
          }
          function pN(e) {
            return e.kind === 79 && e.escapedText === "Symbol";
          }
          function T4(e) {
            return yt(e) ? qr2(e) === "__proto__" : Gn(e) && e.text === "__proto__";
          }
          function H_(e, t6) {
            switch (e = $o(e), e.kind) {
              case 228:
              case 215:
                if (e.name)
                  return false;
                break;
              case 216:
                break;
              default:
                return false;
            }
            return typeof t6 == "function" ? t6(e) : true;
          }
          function S4(e) {
            switch (e.kind) {
              case 299:
                return !T4(e.name);
              case 300:
                return !!e.objectAssignmentInitializer;
              case 257:
                return yt(e.name) && !!e.initializer;
              case 166:
                return yt(e.name) && !!e.initializer && !e.dotDotDotToken;
              case 205:
                return yt(e.name) && !!e.initializer && !e.dotDotDotToken;
              case 169:
                return !!e.initializer;
              case 223:
                switch (e.operatorToken.kind) {
                  case 63:
                  case 76:
                  case 75:
                  case 77:
                    return yt(e.left);
                }
                break;
              case 274:
                return true;
            }
            return false;
          }
          function fN(e, t6) {
            if (!S4(e))
              return false;
            switch (e.kind) {
              case 299:
                return H_(e.initializer, t6);
              case 300:
                return H_(e.objectAssignmentInitializer, t6);
              case 257:
              case 166:
              case 205:
              case 169:
                return H_(e.initializer, t6);
              case 223:
                return H_(e.right, t6);
              case 274:
                return H_(e.expression, t6);
            }
          }
          function dN(e) {
            return e.escapedText === "push" || e.escapedText === "unshift";
          }
          function mN(e) {
            return If(e).kind === 166;
          }
          function If(e) {
            for (; e.kind === 205; )
              e = e.parent.parent;
            return e;
          }
          function hN(e) {
            let t6 = e.kind;
            return t6 === 173 || t6 === 215 || t6 === 259 || t6 === 216 || t6 === 171 || t6 === 174 || t6 === 175 || t6 === 264 || t6 === 308;
          }
          function fs(e) {
            return hs(e.pos) || hs(e.end);
          }
          function gN(e) {
            return fl(e, wi) || e;
          }
          function yN(e) {
            let t6 = R0(e), r = e.kind === 211 && e.arguments !== void 0;
            return x4(e.kind, t6, r);
          }
          function x4(e, t6, r) {
            switch (e) {
              case 211:
                return r ? 0 : 1;
              case 221:
              case 218:
              case 219:
              case 217:
              case 220:
              case 224:
              case 226:
                return 1;
              case 223:
                switch (t6) {
                  case 42:
                  case 63:
                  case 64:
                  case 65:
                  case 67:
                  case 66:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 78:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                    return 1;
                }
            }
            return 0;
          }
          function vN(e) {
            let t6 = R0(e), r = e.kind === 211 && e.arguments !== void 0;
            return E4(e.kind, t6, r);
          }
          function R0(e) {
            return e.kind === 223 ? e.operatorToken.kind : e.kind === 221 || e.kind === 222 ? e.operator : e.kind;
          }
          function E4(e, t6, r) {
            switch (e) {
              case 357:
                return 0;
              case 227:
                return 1;
              case 226:
                return 2;
              case 224:
                return 4;
              case 223:
                switch (t6) {
                  case 27:
                    return 0;
                  case 63:
                  case 64:
                  case 65:
                  case 67:
                  case 66:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 78:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                    return 3;
                  default:
                    return Dl(t6);
                }
              case 213:
              case 232:
              case 221:
              case 218:
              case 219:
              case 217:
              case 220:
                return 16;
              case 222:
                return 17;
              case 210:
                return 18;
              case 211:
                return r ? 19 : 18;
              case 212:
              case 208:
              case 209:
              case 233:
                return 19;
              case 231:
              case 235:
                return 11;
              case 108:
              case 106:
              case 79:
              case 80:
              case 104:
              case 110:
              case 95:
              case 8:
              case 9:
              case 10:
              case 206:
              case 207:
              case 215:
              case 216:
              case 228:
              case 13:
              case 14:
              case 225:
              case 214:
              case 229:
              case 281:
              case 282:
              case 285:
                return 20;
              default:
                return -1;
            }
          }
          function Dl(e) {
            switch (e) {
              case 60:
                return 4;
              case 56:
                return 5;
              case 55:
                return 6;
              case 51:
                return 7;
              case 52:
                return 8;
              case 50:
                return 9;
              case 34:
              case 35:
              case 36:
              case 37:
                return 10;
              case 29:
              case 31:
              case 32:
              case 33:
              case 102:
              case 101:
              case 128:
              case 150:
                return 11;
              case 47:
              case 48:
              case 49:
                return 12;
              case 39:
              case 40:
                return 13;
              case 41:
              case 43:
              case 44:
                return 14;
              case 42:
                return 15;
            }
            return -1;
          }
          function bN(e) {
            return ee2(e, (t6) => {
              switch (t6.kind) {
                case 291:
                  return !!t6.expression;
                case 11:
                  return !t6.containsOnlyTriviaWhiteSpaces;
                default:
                  return true;
              }
            });
          }
          function TN() {
            let e = [], t6 = [], r = /* @__PURE__ */ new Map(), s = false;
            return { add: x10, lookup: f10, getGlobalDiagnostics: w6, getDiagnostics: A6 };
            function f10(g9) {
              let B;
              if (g9.file ? B = r.get(g9.file.fileName) : B = e, !B)
                return;
              let N10 = Ya(B, g9, rr2, qf);
              if (N10 >= 0)
                return B[N10];
            }
            function x10(g9) {
              let B;
              g9.file ? (B = r.get(g9.file.fileName), B || (B = [], r.set(g9.file.fileName, B), Qn(t6, g9.file.fileName, ri))) : (s && (s = false, e = e.slice()), B = e), Qn(B, g9, qf);
            }
            function w6() {
              return s = true, e;
            }
            function A6(g9) {
              if (g9)
                return r.get(g9) || [];
              let B = ge(t6, (N10) => r.get(N10));
              return e.length && B.unshift(...e), B;
            }
          }
          function SN(e) {
            return e.replace(s8, "\\${");
          }
          function w4(e) {
            return e && !!(k8(e) ? e.templateFlags : e.head.templateFlags || Ke3(e.templateSpans, (t6) => !!t6.literal.templateFlags));
          }
          function C4(e) {
            return "\\u" + ("0000" + e.toString(16).toUpperCase()).slice(-4);
          }
          function xN(e, t6, r) {
            if (e.charCodeAt(0) === 0) {
              let s = r.charCodeAt(t6 + e.length);
              return s >= 48 && s <= 57 ? "\\x00" : "\\0";
            }
            return l8.get(e) || C4(e.charCodeAt(0));
          }
          function Nf(e, t6) {
            let r = t6 === 96 ? c8 : t6 === 39 ? _8 : o8;
            return e.replace(r, xN);
          }
          function Of(e, t6) {
            return e = Nf(e, t6), Cv.test(e) ? e.replace(Cv, (r) => C4(r.charCodeAt(0))) : e;
          }
          function EN(e) {
            return "&#x" + e.toString(16).toUpperCase() + ";";
          }
          function wN(e) {
            return e.charCodeAt(0) === 0 ? "&#0;" : f8.get(e) || EN(e.charCodeAt(0));
          }
          function A4(e, t6) {
            let r = t6 === 39 ? p8 : u8;
            return e.replace(r, wN);
          }
          function CN(e) {
            let t6 = e.length;
            return t6 >= 2 && e.charCodeAt(0) === e.charCodeAt(t6 - 1) && AN(e.charCodeAt(0)) ? e.substring(1, t6 - 1) : e;
          }
          function AN(e) {
            return e === 39 || e === 34 || e === 96;
          }
          function P4(e) {
            let t6 = e.charCodeAt(0);
            return t6 >= 97 && t6 <= 122 || Fi(e, "-") || Fi(e, ":");
          }
          function j0(e) {
            let t6 = jo[1];
            for (let r = jo.length; r <= e; r++)
              jo.push(jo[r - 1] + t6);
            return jo[e];
          }
          function Oo() {
            return jo[1].length;
          }
          function PN() {
            return Fi(C2, "-dev") || Fi(C2, "-insiders");
          }
          function DN(e) {
            var t6, r, s, f10, x10, w6 = false;
            function A6(Se2) {
              let Ye2 = Kp(Se2);
              Ye2.length > 1 ? (f10 = f10 + Ye2.length - 1, x10 = t6.length - Se2.length + Zn(Ye2), s = x10 - t6.length === 0) : s = false;
            }
            function g9(Se2) {
              Se2 && Se2.length && (s && (Se2 = j0(r) + Se2, s = false), t6 += Se2, A6(Se2));
            }
            function B(Se2) {
              Se2 && (w6 = false), g9(Se2);
            }
            function N10(Se2) {
              Se2 && (w6 = true), g9(Se2);
            }
            function X2() {
              t6 = "", r = 0, s = true, f10 = 0, x10 = 0, w6 = false;
            }
            function F2(Se2) {
              Se2 !== void 0 && (t6 += Se2, A6(Se2), w6 = false);
            }
            function $(Se2) {
              Se2 && Se2.length && B(Se2);
            }
            function ae(Se2) {
              (!s || Se2) && (t6 += e, f10++, x10 = t6.length, s = true, w6 = false);
            }
            function Te2() {
              return s ? t6.length : t6.length + e.length;
            }
            return X2(), { write: B, rawWrite: F2, writeLiteral: $, writeLine: ae, increaseIndent: () => {
              r++;
            }, decreaseIndent: () => {
              r--;
            }, getIndent: () => r, getTextPos: () => t6.length, getLine: () => f10, getColumn: () => s ? r * Oo() : t6.length - x10, getText: () => t6, isAtStartOfLine: () => s, hasTrailingComment: () => w6, hasTrailingWhitespace: () => !!t6.length && os(t6.charCodeAt(t6.length - 1)), clear: X2, writeKeyword: B, writeOperator: B, writeParameter: B, writeProperty: B, writePunctuation: B, writeSpace: B, writeStringLiteral: B, writeSymbol: (Se2, Ye2) => B(Se2), writeTrailingSemicolon: B, writeComment: N10, getTextPosWithWriteLine: Te2 };
          }
          function kN(e) {
            let t6 = false;
            function r() {
              t6 && (e.writeTrailingSemicolon(";"), t6 = false);
            }
            return Object.assign(Object.assign({}, e), {}, { writeTrailingSemicolon() {
              t6 = true;
            }, writeLiteral(s) {
              r(), e.writeLiteral(s);
            }, writeStringLiteral(s) {
              r(), e.writeStringLiteral(s);
            }, writeSymbol(s, f10) {
              r(), e.writeSymbol(s, f10);
            }, writePunctuation(s) {
              r(), e.writePunctuation(s);
            }, writeKeyword(s) {
              r(), e.writeKeyword(s);
            }, writeOperator(s) {
              r(), e.writeOperator(s);
            }, writeParameter(s) {
              r(), e.writeParameter(s);
            }, writeSpace(s) {
              r(), e.writeSpace(s);
            }, writeProperty(s) {
              r(), e.writeProperty(s);
            }, writeComment(s) {
              r(), e.writeComment(s);
            }, writeLine() {
              r(), e.writeLine();
            }, increaseIndent() {
              r(), e.increaseIndent();
            }, decreaseIndent() {
              r(), e.decreaseIndent();
            } });
          }
          function J0(e) {
            return e.useCaseSensitiveFileNames ? e.useCaseSensitiveFileNames() : false;
          }
          function D4(e) {
            return wp(J0(e));
          }
          function k4(e, t6, r) {
            return t6.moduleName || F0(e, t6.fileName, r && r.fileName);
          }
          function I4(e, t6) {
            return e.getCanonicalFileName(as(t6, e.getCurrentDirectory()));
          }
          function IN(e, t6, r) {
            let s = t6.getExternalModuleFileFromDeclaration(r);
            if (!s || s.isDeclarationFile)
              return;
            let f10 = E0(r);
            if (!(f10 && Ti(f10) && !So(f10.text) && I4(e, s.path).indexOf(I4(e, wo(e.getCommonSourceDirectory()))) === -1))
              return k4(e, s);
          }
          function F0(e, t6, r) {
            let s = (g9) => e.getCanonicalFileName(g9), f10 = Ui(r ? ma(r) : e.getCommonSourceDirectory(), e.getCurrentDirectory(), s), x10 = as(t6, e.getCurrentDirectory()), w6 = uy(f10, x10, f10, s, false), A6 = Ll(w6);
            return r ? _y(A6) : A6;
          }
          function NN(e, t6, r) {
            let s = t6.getCompilerOptions(), f10;
            return s.outDir ? f10 = Ll(M4(e, t6, s.outDir)) : f10 = Ll(e), f10 + r;
          }
          function ON(e, t6) {
            return N4(e, t6.getCompilerOptions(), t6.getCurrentDirectory(), t6.getCommonSourceDirectory(), (r) => t6.getCanonicalFileName(r));
          }
          function N4(e, t6, r, s, f10) {
            let x10 = t6.declarationDir || t6.outDir, w6 = x10 ? U0(e, x10, r, s, f10) : e, A6 = O4(w6);
            return Ll(w6) + A6;
          }
          function O4(e) {
            return da(e, [".mjs", ".mts"]) ? ".d.mts" : da(e, [".cjs", ".cts"]) ? ".d.cts" : da(e, [".json"]) ? ".d.json.ts" : ".d.ts";
          }
          function MN(e) {
            return da(e, [".d.mts", ".mjs", ".mts"]) ? [".mts", ".mjs"] : da(e, [".d.cts", ".cjs", ".cts"]) ? [".cts", ".cjs"] : da(e, [".d.json.ts"]) ? [".json"] : [".tsx", ".ts", ".jsx", ".js"];
          }
          function B0(e) {
            return e.outFile || e.out;
          }
          function LN(e, t6) {
            var r, s;
            if (e.paths)
              return (s = e.baseUrl) != null ? s : Y3.checkDefined(e.pathsBasePath || ((r = t6.getCurrentDirectory) == null ? void 0 : r.call(t6)), "Encountered 'paths' without a 'baseUrl', config file, or host 'getCurrentDirectory'.");
          }
          function RN(e, t6, r) {
            let s = e.getCompilerOptions();
            if (B0(s)) {
              let f10 = Ei(s), x10 = s.emitDeclarationOnly || f10 === 2 || f10 === 4;
              return ee2(e.getSourceFiles(), (w6) => (x10 || !Qo(w6)) && q0(w6, e, r));
            } else {
              let f10 = t6 === void 0 ? e.getSourceFiles() : [t6];
              return ee2(f10, (x10) => q0(x10, e, r));
            }
          }
          function q0(e, t6, r) {
            return !(t6.getCompilerOptions().noEmitForJsFiles && y0(e)) && !e.isDeclarationFile && !t6.isSourceFileFromExternalLibrary(e) && (r || !(a0(e) && t6.getResolvedProjectReferenceToRedirect(e.fileName)) && !t6.isSourceOfProjectReferenceRedirect(e.fileName));
          }
          function M4(e, t6, r) {
            return U0(e, r, t6.getCurrentDirectory(), t6.getCommonSourceDirectory(), (s) => t6.getCanonicalFileName(s));
          }
          function U0(e, t6, r, s, f10) {
            let x10 = as(e, r);
            return x10 = f10(x10).indexOf(f10(s)) === 0 ? x10.substring(s.length) : x10, tn(t6, x10);
          }
          function jN(e, t6, r, s, f10, x10, w6) {
            e.writeFile(r, s, f10, (A6) => {
              t6.add(Ol(ve.Could_not_write_file_0_Colon_1, r, A6));
            }, x10, w6);
          }
          function L4(e, t6, r) {
            if (e.length > Bi(e) && !r(e)) {
              let s = ma(e);
              L4(s, t6, r), t6(e);
            }
          }
          function JN(e, t6, r, s, f10, x10) {
            try {
              s(e, t6, r);
            } catch {
              L4(ma(Un(e)), f10, x10), s(e, t6, r);
            }
          }
          function FN(e, t6) {
            let r = ss(e);
            return k_(r, t6);
          }
          function ds(e, t6) {
            return k_(e, t6);
          }
          function R4(e) {
            return Ae2(e.members, (t6) => nc(t6) && xl(t6.body));
          }
          function z0(e) {
            if (e && e.parameters.length > 0) {
              let t6 = e.parameters.length === 2 && kl(e.parameters[0]);
              return e.parameters[t6 ? 1 : 0];
            }
          }
          function BN(e) {
            let t6 = z0(e);
            return t6 && t6.type;
          }
          function j4(e) {
            if (e.parameters.length && !iu(e)) {
              let t6 = e.parameters[0];
              if (kl(t6))
                return t6;
            }
          }
          function kl(e) {
            return Mf(e.name);
          }
          function Mf(e) {
            return !!e && e.kind === 79 && J4(e);
          }
          function qN(e) {
            if (!Mf(e))
              return false;
            for (; rc(e.parent) && e.parent.left === e; )
              e = e.parent;
            return e.parent.kind === 183;
          }
          function J4(e) {
            return e.escapedText === "this";
          }
          function W0(e, t6) {
            let r, s, f10, x10;
            return v4(t6) ? (r = t6, t6.kind === 174 ? f10 = t6 : t6.kind === 175 ? x10 = t6 : Y3.fail("Accessor has wrong kind")) : c(e, (w6) => {
              if (pf(w6) && G0(w6) === G0(t6)) {
                let A6 = Df(w6.name), g9 = Df(t6.name);
                A6 === g9 && (r ? s || (s = w6) : r = w6, w6.kind === 174 && !f10 && (f10 = w6), w6.kind === 175 && !x10 && (x10 = w6));
              }
            }), { firstAccessor: r, secondAccessor: s, getAccessor: f10, setAccessor: x10 };
          }
          function V0(e) {
            if (!Pr(e) && Wo(e))
              return;
            let t6 = e.type;
            return t6 || !Pr(e) ? t6 : Dy(e) ? e.typeExpression && e.typeExpression.type : cf(e);
          }
          function UN(e) {
            return e.type;
          }
          function zN(e) {
            return iu(e) ? e.type && e.type.typeExpression && e.type.typeExpression.type : e.type || (Pr(e) ? OS(e) : void 0);
          }
          function F4(e) {
            return ne2(hl(e), (t6) => WN(t6) ? t6.typeParameters : void 0);
          }
          function WN(e) {
            return Go(e) && !(e.parent.kind === 323 && (e.parent.tags.some(Cl) || e.parent.tags.some(y2)));
          }
          function VN(e) {
            let t6 = z0(e);
            return t6 && V0(t6);
          }
          function B4(e, t6, r, s) {
            q4(e, t6, r.pos, s);
          }
          function q4(e, t6, r, s) {
            s && s.length && r !== s[0].pos && ds(e, r) !== ds(e, s[0].pos) && t6.writeLine();
          }
          function HN(e, t6, r, s) {
            r !== s && ds(e, r) !== ds(e, s) && t6.writeLine();
          }
          function U4(e, t6, r, s, f10, x10, w6, A6) {
            if (s && s.length > 0) {
              f10 && r.writeSpace(" ");
              let g9 = false;
              for (let B of s)
                g9 && (r.writeSpace(" "), g9 = false), A6(e, t6, r, B.pos, B.end, w6), B.hasTrailingNewLine ? r.writeLine() : g9 = true;
              g9 && x10 && r.writeSpace(" ");
            }
          }
          function GN(e, t6, r, s, f10, x10, w6) {
            let A6, g9;
            if (w6 ? f10.pos === 0 && (A6 = ee2(Ao(e, f10.pos), B)) : A6 = Ao(e, f10.pos), A6) {
              let N10 = [], X2;
              for (let F2 of A6) {
                if (X2) {
                  let $ = ds(t6, X2.end);
                  if (ds(t6, F2.pos) >= $ + 2)
                    break;
                }
                N10.push(F2), X2 = F2;
              }
              if (N10.length) {
                let F2 = ds(t6, Zn(N10).end);
                ds(t6, Ar2(e, f10.pos)) >= F2 + 2 && (B4(t6, r, f10, A6), U4(e, t6, r, N10, false, true, x10, s), g9 = { nodePos: f10.pos, detachedCommentEndPos: Zn(N10).end });
              }
            }
            return g9;
            function B(N10) {
              return v3(e, N10.pos);
            }
          }
          function $N(e, t6, r, s, f10, x10) {
            if (e.charCodeAt(s + 1) === 42) {
              let w6 = my(t6, s), A6 = t6.length, g9;
              for (let B = s, N10 = w6.line; B < f10; N10++) {
                let X2 = N10 + 1 === A6 ? e.length + 1 : t6[N10 + 1];
                if (B !== s) {
                  g9 === void 0 && (g9 = z4(e, t6[w6.line], s));
                  let $ = r.getIndent() * Oo() - g9 + z4(e, B, X2);
                  if ($ > 0) {
                    let ae = $ % Oo(), Te2 = j0(($ - ae) / Oo());
                    for (r.rawWrite(Te2); ae; )
                      r.rawWrite(" "), ae--;
                  } else
                    r.rawWrite("");
                }
                KN(e, f10, r, x10, B, X2), B = X2;
              }
            } else
              r.writeComment(e.substring(s, f10));
          }
          function KN(e, t6, r, s, f10, x10) {
            let w6 = Math.min(t6, x10 - 1), A6 = Pp(e.substring(f10, w6));
            A6 ? (r.writeComment(A6), w6 !== t6 && r.writeLine()) : r.rawWrite(s);
          }
          function z4(e, t6, r) {
            let s = 0;
            for (; t6 < r && N_(e.charCodeAt(t6)); t6++)
              e.charCodeAt(t6) === 9 ? s += Oo() - s % Oo() : s++;
            return s;
          }
          function XN(e) {
            return Rf(e) !== 0;
          }
          function YN(e) {
            return X0(e) !== 0;
          }
          function H0(e, t6) {
            return !!G4(e, t6);
          }
          function rn(e, t6) {
            return !!$4(e, t6);
          }
          function G0(e) {
            return Js(e) && Lf(e) || Hl(e);
          }
          function Lf(e) {
            return rn(e, 32);
          }
          function QN(e) {
            return H0(e, 16384);
          }
          function W4(e) {
            return rn(e, 256);
          }
          function V4(e) {
            return rn(e, 2);
          }
          function H4(e) {
            return rn(e, 128);
          }
          function $0(e) {
            return H0(e, 64);
          }
          function Il(e) {
            return rn(e, 131072);
          }
          function G4(e, t6) {
            return Rf(e) & t6;
          }
          function $4(e, t6) {
            return X0(e) & t6;
          }
          function K0(e, t6, r) {
            return e.kind >= 0 && e.kind <= 162 ? 0 : (e.modifierFlagsCache & 536870912 || (e.modifierFlagsCache = Y0(e) | 536870912), t6 && !(e.modifierFlagsCache & 4096) && (r || Pr(e)) && e.parent && (e.modifierFlagsCache |= X4(e) | 4096), e.modifierFlagsCache & -536875009);
          }
          function Rf(e) {
            return K0(e, true);
          }
          function K4(e) {
            return K0(e, true, true);
          }
          function X0(e) {
            return K0(e, false);
          }
          function X4(e) {
            let t6 = 0;
            return e.parent && !Vs(e) && (Pr(e) && (CS(e) && (t6 |= 4), AS(e) && (t6 |= 8), PS(e) && (t6 |= 16), DS(e) && (t6 |= 64), kS(e) && (t6 |= 16384)), IS(e) && (t6 |= 8192)), t6;
          }
          function Y4(e) {
            return Y0(e) | X4(e);
          }
          function Y0(e) {
            let t6 = fc(e) ? Vn(e.modifiers) : 0;
            return (e.flags & 4 || e.kind === 79 && e.flags & 2048) && (t6 |= 1), t6;
          }
          function Vn(e) {
            let t6 = 0;
            if (e)
              for (let r of e)
                t6 |= Q0(r.kind);
            return t6;
          }
          function Q0(e) {
            switch (e) {
              case 124:
                return 32;
              case 123:
                return 4;
              case 122:
                return 16;
              case 121:
                return 8;
              case 126:
                return 256;
              case 127:
                return 128;
              case 93:
                return 1;
              case 136:
                return 2;
              case 85:
                return 2048;
              case 88:
                return 1024;
              case 132:
                return 512;
              case 146:
                return 64;
              case 161:
                return 16384;
              case 101:
                return 32768;
              case 145:
                return 65536;
              case 167:
                return 131072;
            }
            return 0;
          }
          function Q4(e) {
            return e === 56 || e === 55;
          }
          function ZN(e) {
            return Q4(e) || e === 53;
          }
          function jf(e) {
            return e === 75 || e === 76 || e === 77;
          }
          function eO(e) {
            return ur2(e) && jf(e.operatorToken.kind);
          }
          function Z4(e) {
            return Q4(e) || e === 60;
          }
          function tO(e) {
            return ur2(e) && Z4(e.operatorToken.kind);
          }
          function G_(e) {
            return e >= 63 && e <= 78;
          }
          function ex(e) {
            let t6 = tx(e);
            return t6 && !t6.isImplements ? t6.class : void 0;
          }
          function tx(e) {
            if (e2(e)) {
              if (ru(e.parent) && bi(e.parent.parent))
                return { class: e.parent.parent, isImplements: e.parent.token === 117 };
              if (md(e.parent)) {
                let t6 = A0(e.parent);
                if (t6 && bi(t6))
                  return { class: t6, isImplements: false };
              }
            }
          }
          function ms(e, t6) {
            return ur2(e) && (t6 ? e.operatorToken.kind === 63 : G_(e.operatorToken.kind)) && Do(e.left);
          }
          function rO(e) {
            return ms(e.parent) && e.parent.left === e;
          }
          function nO(e) {
            if (ms(e, true)) {
              let t6 = e.left.kind;
              return t6 === 207 || t6 === 206;
            }
            return false;
          }
          function Z0(e) {
            return ex(e) !== void 0;
          }
          function Bs(e) {
            return e.kind === 79 || rx(e);
          }
          function iO(e) {
            switch (e.kind) {
              case 79:
                return e;
              case 163:
                do
                  e = e.left;
                while (e.kind !== 79);
                return e;
              case 208:
                do
                  e = e.expression;
                while (e.kind !== 79);
                return e;
            }
          }
          function ev(e) {
            return e.kind === 79 || e.kind === 108 || e.kind === 106 || e.kind === 233 || e.kind === 208 && ev(e.expression) || e.kind === 214 && ev(e.expression);
          }
          function rx(e) {
            return bn(e) && yt(e.name) && Bs(e.expression);
          }
          function tv(e) {
            if (bn(e)) {
              let t6 = tv(e.expression);
              if (t6 !== void 0)
                return t6 + "." + ls(e.name);
            } else if (gs(e)) {
              let t6 = tv(e.expression);
              if (t6 !== void 0 && vl(e.argumentExpression))
                return t6 + "." + Df(e.argumentExpression);
            } else if (yt(e))
              return dl(e.escapedText);
          }
          function Nl(e) {
            return W_(e) && Fs(e) === "prototype";
          }
          function aO(e) {
            return e.parent.kind === 163 && e.parent.right === e || e.parent.kind === 208 && e.parent.name === e;
          }
          function nx(e) {
            return bn(e.parent) && e.parent.name === e || gs(e.parent) && e.parent.argumentExpression === e;
          }
          function sO(e) {
            return rc(e.parent) && e.parent.right === e || bn(e.parent) && e.parent.name === e || uc(e.parent) && e.parent.right === e;
          }
          function oO(e) {
            return e.kind === 207 && e.properties.length === 0;
          }
          function _O(e) {
            return e.kind === 206 && e.elements.length === 0;
          }
          function cO(e) {
            if (!(!lO(e) || !e.declarations)) {
              for (let t6 of e.declarations)
                if (t6.localSymbol)
                  return t6.localSymbol;
            }
          }
          function lO(e) {
            return e && I(e.declarations) > 0 && rn(e.declarations[0], 1024);
          }
          function uO(e) {
            return Ae2(y8, (t6) => ns(e, t6));
          }
          function pO(e) {
            let t6 = [], r = e.length;
            for (let s = 0; s < r; s++) {
              let f10 = e.charCodeAt(s);
              f10 < 128 ? t6.push(f10) : f10 < 2048 ? (t6.push(f10 >> 6 | 192), t6.push(f10 & 63 | 128)) : f10 < 65536 ? (t6.push(f10 >> 12 | 224), t6.push(f10 >> 6 & 63 | 128), t6.push(f10 & 63 | 128)) : f10 < 131072 ? (t6.push(f10 >> 18 | 240), t6.push(f10 >> 12 & 63 | 128), t6.push(f10 >> 6 & 63 | 128), t6.push(f10 & 63 | 128)) : Y3.assert(false, "Unexpected code point");
            }
            return t6;
          }
          function ix(e) {
            let t6 = "", r = pO(e), s = 0, f10 = r.length, x10, w6, A6, g9;
            for (; s < f10; )
              x10 = r[s] >> 2, w6 = (r[s] & 3) << 4 | r[s + 1] >> 4, A6 = (r[s + 1] & 15) << 2 | r[s + 2] >> 6, g9 = r[s + 2] & 63, s + 1 >= f10 ? A6 = g9 = 64 : s + 2 >= f10 && (g9 = 64), t6 += xa.charAt(x10) + xa.charAt(w6) + xa.charAt(A6) + xa.charAt(g9), s += 3;
            return t6;
          }
          function fO(e) {
            let t6 = "", r = 0, s = e.length;
            for (; r < s; ) {
              let f10 = e[r];
              if (f10 < 128)
                t6 += String.fromCharCode(f10), r++;
              else if ((f10 & 192) === 192) {
                let x10 = f10 & 63;
                r++;
                let w6 = e[r];
                for (; (w6 & 192) === 128; )
                  x10 = x10 << 6 | w6 & 63, r++, w6 = e[r];
                t6 += String.fromCharCode(x10);
              } else
                t6 += String.fromCharCode(f10), r++;
            }
            return t6;
          }
          function dO(e, t6) {
            return e && e.base64encode ? e.base64encode(t6) : ix(t6);
          }
          function mO(e, t6) {
            if (e && e.base64decode)
              return e.base64decode(t6);
            let r = t6.length, s = [], f10 = 0;
            for (; f10 < r && t6.charCodeAt(f10) !== xa.charCodeAt(64); ) {
              let x10 = xa.indexOf(t6[f10]), w6 = xa.indexOf(t6[f10 + 1]), A6 = xa.indexOf(t6[f10 + 2]), g9 = xa.indexOf(t6[f10 + 3]), B = (x10 & 63) << 2 | w6 >> 4 & 3, N10 = (w6 & 15) << 4 | A6 >> 2 & 15, X2 = (A6 & 3) << 6 | g9 & 63;
              N10 === 0 && A6 !== 0 ? s.push(B) : X2 === 0 && g9 !== 0 ? s.push(B, N10) : s.push(B, N10, X2), f10 += 4;
            }
            return fO(s);
          }
          function ax(e, t6) {
            let r = Ji(t6) ? t6 : t6.readFile(e);
            if (!r)
              return;
            let s = parseConfigFileTextToJson(e, r);
            return s.error ? void 0 : s.config;
          }
          function hO(e, t6) {
            return ax(e, t6) || {};
          }
          function sx(e, t6) {
            return !t6.directoryExists || t6.directoryExists(e);
          }
          function ox(e) {
            switch (e.newLine) {
              case 0:
                return d8;
              case 1:
              case void 0:
                return m8;
            }
          }
          function Jf(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
            return Y3.assert(t6 >= e || t6 === -1), { pos: e, end: t6 };
          }
          function gO(e, t6) {
            return Jf(e.pos, t6);
          }
          function Ff(e, t6) {
            return Jf(t6, e.end);
          }
          function _x(e) {
            let t6 = fc(e) ? te2(e.modifiers, zl) : void 0;
            return t6 && !hs(t6.end) ? Ff(e, t6.end) : e;
          }
          function yO(e) {
            if (Bo(e) || Vl(e))
              return Ff(e, e.name.pos);
            let t6 = fc(e) ? Cn(e.modifiers) : void 0;
            return t6 && !hs(t6.end) ? Ff(e, t6.end) : _x(e);
          }
          function vO(e) {
            return e.pos === e.end;
          }
          function bO(e, t6) {
            return Jf(e, e + Br2(t6).length);
          }
          function TO(e, t6) {
            return cx(e, e, t6);
          }
          function SO(e, t6, r) {
            return $_(K_(e, r, false), K_(t6, r, false), r);
          }
          function xO(e, t6, r) {
            return $_(e.end, t6.end, r);
          }
          function cx(e, t6, r) {
            return $_(K_(e, r, false), t6.end, r);
          }
          function EO(e, t6, r) {
            return $_(e.end, K_(t6, r, false), r);
          }
          function wO(e, t6, r, s) {
            let f10 = K_(t6, r, s);
            return I_(r, e.end, f10);
          }
          function CO(e, t6, r) {
            return I_(r, e.end, t6.end);
          }
          function AO(e, t6) {
            return !$_(e.pos, e.end, t6);
          }
          function $_(e, t6, r) {
            return I_(r, e, t6) === 0;
          }
          function K_(e, t6, r) {
            return hs(e.pos) ? -1 : Ar2(t6.text, e.pos, false, r);
          }
          function PO(e, t6, r, s) {
            let f10 = Ar2(r.text, e, false, s), x10 = kO(f10, t6, r);
            return I_(r, x10 != null ? x10 : t6, f10);
          }
          function DO(e, t6, r, s) {
            let f10 = Ar2(r.text, e, false, s);
            return I_(r, e, Math.min(t6, f10));
          }
          function kO(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 ? arguments[2] : void 0;
            for (; e-- > t6; )
              if (!os(r.text.charCodeAt(e)))
                return e;
          }
          function IO(e) {
            let t6 = fl(e);
            if (t6)
              switch (t6.parent.kind) {
                case 263:
                case 264:
                  return t6 === t6.parent.name;
              }
            return false;
          }
          function NO(e) {
            return ee2(e.declarations, lx);
          }
          function lx(e) {
            return Vi(e) && e.initializer !== void 0;
          }
          function OO(e) {
            return e.watch && Jr(e, "watch");
          }
          function MO(e) {
            e.close();
          }
          function ux(e) {
            return e.flags & 33554432 ? e.links.checkFlags : 0;
          }
          function LO(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (e.valueDeclaration) {
              let r = t6 && e.declarations && Ae2(e.declarations, ic) || e.flags & 32768 && Ae2(e.declarations, Gl) || e.valueDeclaration, s = ef(r);
              return e.parent && e.parent.flags & 32 ? s : s & -29;
            }
            if (ux(e) & 6) {
              let r = e.links.checkFlags, s = r & 1024 ? 8 : r & 256 ? 4 : 16, f10 = r & 2048 ? 32 : 0;
              return s | f10;
            }
            return e.flags & 4194304 ? 36 : 0;
          }
          function RO(e, t6) {
            return e.flags & 2097152 ? t6.getAliasedSymbol(e) : e;
          }
          function jO(e) {
            return e.exportSymbol ? e.exportSymbol.flags | e.flags : e.flags;
          }
          function JO(e) {
            return Mo(e) === 1;
          }
          function FO(e) {
            return Mo(e) !== 0;
          }
          function Mo(e) {
            let { parent: t6 } = e;
            if (!t6)
              return 0;
            switch (t6.kind) {
              case 214:
                return Mo(t6);
              case 222:
              case 221:
                let { operator: s } = t6;
                return s === 45 || s === 46 ? r() : 0;
              case 223:
                let { left: f10, operatorToken: x10 } = t6;
                return f10 === e && G_(x10.kind) ? x10.kind === 63 ? 1 : r() : 0;
              case 208:
                return t6.name !== e ? 0 : Mo(t6);
              case 299: {
                let w6 = Mo(t6.parent);
                return e === t6.name ? BO(w6) : w6;
              }
              case 300:
                return e === t6.objectAssignmentInitializer ? 0 : Mo(t6.parent);
              case 206:
                return Mo(t6);
              default:
                return 0;
            }
            function r() {
              return t6.parent && D0(t6.parent).kind === 241 ? 1 : 2;
            }
          }
          function BO(e) {
            switch (e) {
              case 0:
                return 1;
              case 1:
                return 0;
              case 2:
                return 2;
              default:
                return Y3.assertNever(e);
            }
          }
          function px(e, t6) {
            if (!e || !t6 || Object.keys(e).length !== Object.keys(t6).length)
              return false;
            for (let r in e)
              if (typeof e[r] == "object") {
                if (!px(e[r], t6[r]))
                  return false;
              } else if (typeof e[r] != "function" && e[r] !== t6[r])
                return false;
            return true;
          }
          function qO(e, t6) {
            e.forEach(t6), e.clear();
          }
          function fx(e, t6, r) {
            let { onDeleteValue: s, onExistingValue: f10 } = r;
            e.forEach((x10, w6) => {
              let A6 = t6.get(w6);
              A6 === void 0 ? (e.delete(w6), s(x10, w6)) : f10 && f10(x10, A6, w6);
            });
          }
          function UO(e, t6, r) {
            fx(e, t6, r);
            let { createNewValue: s } = r;
            t6.forEach((f10, x10) => {
              e.has(x10) || e.set(x10, s(x10, f10));
            });
          }
          function zO(e) {
            if (e.flags & 32) {
              let t6 = dx(e);
              return !!t6 && rn(t6, 256);
            }
            return false;
          }
          function dx(e) {
            var t6;
            return (t6 = e.declarations) == null ? void 0 : t6.find(bi);
          }
          function Bf(e) {
            return e.flags & 3899393 ? e.objectFlags : 0;
          }
          function WO(e, t6) {
            return !!FT(e, (r) => t6(r) ? true : void 0);
          }
          function VO(e) {
            return !!e && !!e.declarations && !!e.declarations[0] && a2(e.declarations[0]);
          }
          function HO(e) {
            let { moduleSpecifier: t6 } = e;
            return Gn(t6) ? t6.text : gf(t6);
          }
          function mx(e) {
            let t6;
            return xr2(e, (r) => {
              xl(r) && (t6 = r);
            }, (r) => {
              for (let s = r.length - 1; s >= 0; s--)
                if (xl(r[s])) {
                  t6 = r[s];
                  break;
                }
            }), t6;
          }
          function GO(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            return e.has(t6) ? false : (e.set(t6, r), true);
          }
          function $O(e) {
            return bi(e) || eu(e) || id(e);
          }
          function hx(e) {
            return e >= 179 && e <= 202 || e === 131 || e === 157 || e === 148 || e === 160 || e === 149 || e === 134 || e === 152 || e === 153 || e === 114 || e === 155 || e === 144 || e === 139 || e === 230 || e === 315 || e === 316 || e === 317 || e === 318 || e === 319 || e === 320 || e === 321;
          }
          function Lo(e) {
            return e.kind === 208 || e.kind === 209;
          }
          function KO(e) {
            return e.kind === 208 ? e.name : (Y3.assert(e.kind === 209), e.argumentExpression);
          }
          function XO(e) {
            switch (e.kind) {
              case "text":
              case "internal":
                return true;
              default:
                return false;
            }
          }
          function YO(e) {
            return e.kind === 272 || e.kind === 276;
          }
          function rv(e) {
            for (; Lo(e); )
              e = e.expression;
            return e;
          }
          function QO(e, t6) {
            if (Lo(e.parent) && nx(e))
              return r(e.parent);
            function r(s) {
              if (s.kind === 208) {
                let f10 = t6(s.name);
                if (f10 !== void 0)
                  return f10;
              } else if (s.kind === 209)
                if (yt(s.argumentExpression) || Ti(s.argumentExpression)) {
                  let f10 = t6(s.argumentExpression);
                  if (f10 !== void 0)
                    return f10;
                } else
                  return;
              if (Lo(s.expression))
                return r(s.expression);
              if (yt(s.expression))
                return t6(s.expression);
            }
          }
          function ZO(e, t6) {
            for (; ; ) {
              switch (e.kind) {
                case 222:
                  e = e.operand;
                  continue;
                case 223:
                  e = e.left;
                  continue;
                case 224:
                  e = e.condition;
                  continue;
                case 212:
                  e = e.tag;
                  continue;
                case 210:
                  if (t6)
                    return e;
                case 231:
                case 209:
                case 208:
                case 232:
                case 356:
                case 235:
                  e = e.expression;
                  continue;
              }
              return e;
            }
          }
          function eM(e, t6) {
            this.flags = e, this.escapedName = t6, this.declarations = void 0, this.valueDeclaration = void 0, this.id = 0, this.mergeId = 0, this.parent = void 0, this.members = void 0, this.exports = void 0, this.exportSymbol = void 0, this.constEnumOnlyModule = void 0, this.isReferenced = void 0, this.isAssigned = void 0, this.links = void 0;
          }
          function tM(e, t6) {
            this.flags = t6, (Y3.isDebugging || rs) && (this.checker = e);
          }
          function rM(e, t6) {
            this.flags = t6, Y3.isDebugging && (this.checker = e);
          }
          function nv(e, t6, r) {
            this.pos = t6, this.end = r, this.kind = e, this.id = 0, this.flags = 0, this.modifierFlagsCache = 0, this.transformFlags = 0, this.parent = void 0, this.original = void 0, this.emitNode = void 0;
          }
          function nM(e, t6, r) {
            this.pos = t6, this.end = r, this.kind = e, this.id = 0, this.flags = 0, this.transformFlags = 0, this.parent = void 0, this.emitNode = void 0;
          }
          function iM(e, t6, r) {
            this.pos = t6, this.end = r, this.kind = e, this.id = 0, this.flags = 0, this.transformFlags = 0, this.parent = void 0, this.original = void 0, this.emitNode = void 0;
          }
          function aM(e, t6, r) {
            this.fileName = e, this.text = t6, this.skipTrivia = r || ((s) => s);
          }
          function sM(e) {
            Av.push(e), e(lr2);
          }
          function gx(e) {
            Object.assign(lr2, e), c(Av, (t6) => t6(lr2));
          }
          function X_(e, t6) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            return e.replace(/{(\d+)}/g, (s, f10) => "" + Y3.checkDefined(t6[+f10 + r]));
          }
          function yx(e) {
            jl = e;
          }
          function vx(e) {
            !jl && e && (jl = e());
          }
          function Y_(e) {
            return jl && jl[e.key] || e.message;
          }
          function Ro(e, t6, r, s) {
            t0(void 0, t6, r);
            let f10 = Y_(s);
            return arguments.length > 4 && (f10 = X_(f10, arguments, 4)), { file: void 0, start: t6, length: r, messageText: f10, category: s.category, code: s.code, reportsUnnecessary: s.reportsUnnecessary, fileName: e };
          }
          function oM(e) {
            return e.file === void 0 && e.start !== void 0 && e.length !== void 0 && typeof e.fileName == "string";
          }
          function bx(e, t6) {
            let r = t6.fileName || "", s = t6.text.length;
            Y3.assertEqual(e.fileName, r), Y3.assertLessThanOrEqual(e.start, s), Y3.assertLessThanOrEqual(e.start + e.length, s);
            let f10 = { file: t6, start: e.start, length: e.length, messageText: e.messageText, category: e.category, code: e.code, reportsUnnecessary: e.reportsUnnecessary };
            if (e.relatedInformation) {
              f10.relatedInformation = [];
              for (let x10 of e.relatedInformation)
                oM(x10) && x10.fileName === r ? (Y3.assertLessThanOrEqual(x10.start, s), Y3.assertLessThanOrEqual(x10.start + x10.length, s), f10.relatedInformation.push(bx(x10, t6))) : f10.relatedInformation.push(x10);
            }
            return f10;
          }
          function qs(e, t6) {
            let r = [];
            for (let s of e)
              r.push(bx(s, t6));
            return r;
          }
          function iv(e, t6, r, s) {
            t0(e, t6, r);
            let f10 = Y_(s);
            return arguments.length > 4 && (f10 = X_(f10, arguments, 4)), { file: e, start: t6, length: r, messageText: f10, category: s.category, code: s.code, reportsUnnecessary: s.reportsUnnecessary, reportsDeprecated: s.reportsDeprecated };
          }
          function _M(e, t6) {
            let r = Y_(t6);
            return arguments.length > 2 && (r = X_(r, arguments, 2)), r;
          }
          function Ol(e) {
            let t6 = Y_(e);
            return arguments.length > 1 && (t6 = X_(t6, arguments, 1)), { file: void 0, start: void 0, length: void 0, messageText: t6, category: e.category, code: e.code, reportsUnnecessary: e.reportsUnnecessary, reportsDeprecated: e.reportsDeprecated };
          }
          function cM(e, t6) {
            return { file: void 0, start: void 0, length: void 0, code: e.code, category: e.category, messageText: e.next ? e : e.messageText, relatedInformation: t6 };
          }
          function lM(e, t6) {
            let r = Y_(t6);
            return arguments.length > 2 && (r = X_(r, arguments, 2)), { messageText: r, category: t6.category, code: t6.code, next: e === void 0 || Array.isArray(e) ? e : [e] };
          }
          function uM(e, t6) {
            let r = e;
            for (; r.next; )
              r = r.next[0];
            r.next = [t6];
          }
          function Tx(e) {
            return e.file ? e.file.path : void 0;
          }
          function av(e, t6) {
            return qf(e, t6) || pM(e, t6) || 0;
          }
          function qf(e, t6) {
            return ri(Tx(e), Tx(t6)) || Vr2(e.start, t6.start) || Vr2(e.length, t6.length) || Vr2(e.code, t6.code) || Sx(e.messageText, t6.messageText) || 0;
          }
          function pM(e, t6) {
            return !e.relatedInformation && !t6.relatedInformation ? 0 : e.relatedInformation && t6.relatedInformation ? Vr2(e.relatedInformation.length, t6.relatedInformation.length) || c(e.relatedInformation, (r, s) => {
              let f10 = t6.relatedInformation[s];
              return av(r, f10);
            }) || 0 : e.relatedInformation ? -1 : 1;
          }
          function Sx(e, t6) {
            if (typeof e == "string" && typeof t6 == "string")
              return ri(e, t6);
            if (typeof e == "string")
              return -1;
            if (typeof t6 == "string")
              return 1;
            let r = ri(e.messageText, t6.messageText);
            if (r)
              return r;
            if (!e.next && !t6.next)
              return 0;
            if (!e.next)
              return -1;
            if (!t6.next)
              return 1;
            let s = Math.min(e.next.length, t6.next.length);
            for (let f10 = 0; f10 < s; f10++)
              if (r = Sx(e.next[f10], t6.next[f10]), r)
                return r;
            return e.next.length < t6.next.length ? -1 : e.next.length > t6.next.length ? 1 : 0;
          }
          function sv(e) {
            return e === 4 || e === 2 || e === 1 || e === 6 ? 1 : 0;
          }
          function xx(e) {
            if (e.transformFlags & 2)
              return _3(e) || pd(e) ? e : xr2(e, xx);
          }
          function fM(e) {
            return e.isDeclarationFile ? void 0 : xx(e);
          }
          function dM(e) {
            return (e.impliedNodeFormat === 99 || da(e.fileName, [".cjs", ".cts", ".mjs", ".mts"])) && !e.isDeclarationFile ? true : void 0;
          }
          function Ex(e) {
            switch (wx(e)) {
              case 3:
                return (f10) => {
                  f10.externalModuleIndicator = ou(f10) || !f10.isDeclarationFile || void 0;
                };
              case 1:
                return (f10) => {
                  f10.externalModuleIndicator = ou(f10);
                };
              case 2:
                let t6 = [ou];
                (e.jsx === 4 || e.jsx === 5) && t6.push(fM), t6.push(dM);
                let r = W1(...t6);
                return (f10) => void (f10.externalModuleIndicator = r(f10));
            }
          }
          function Uf(e) {
            var t6;
            return (t6 = e.target) != null ? t6 : e.module === 100 && 9 || e.module === 199 && 99 || 1;
          }
          function Ei(e) {
            return typeof e.module == "number" ? e.module : Uf(e) >= 2 ? 5 : 1;
          }
          function mM(e) {
            return e >= 5 && e <= 99;
          }
          function Ml(e) {
            let t6 = e.moduleResolution;
            if (t6 === void 0)
              switch (Ei(e)) {
                case 1:
                  t6 = 2;
                  break;
                case 100:
                  t6 = 3;
                  break;
                case 199:
                  t6 = 99;
                  break;
                default:
                  t6 = 1;
                  break;
              }
            return t6;
          }
          function wx(e) {
            return e.moduleDetection || (Ei(e) === 100 || Ei(e) === 199 ? 3 : 2);
          }
          function hM(e) {
            switch (Ei(e)) {
              case 1:
              case 2:
              case 5:
              case 6:
              case 7:
              case 99:
              case 100:
              case 199:
                return true;
              default:
                return false;
            }
          }
          function zf(e) {
            return !!(e.isolatedModules || e.verbatimModuleSyntax);
          }
          function gM(e) {
            return e.verbatimModuleSyntax || e.isolatedModules && e.preserveValueImports;
          }
          function yM(e) {
            return e.allowUnreachableCode === false;
          }
          function vM(e) {
            return e.allowUnusedLabels === false;
          }
          function bM(e) {
            return !!(cv(e) && e.declarationMap);
          }
          function ov(e) {
            if (e.esModuleInterop !== void 0)
              return e.esModuleInterop;
            switch (Ei(e)) {
              case 100:
              case 199:
                return true;
            }
          }
          function TM(e) {
            return e.allowSyntheticDefaultImports !== void 0 ? e.allowSyntheticDefaultImports : ov(e) || Ei(e) === 4 || Ml(e) === 100;
          }
          function _v(e) {
            return e >= 3 && e <= 99 || e === 100;
          }
          function SM(e) {
            let t6 = Ml(e);
            if (!_v(t6))
              return false;
            if (e.resolvePackageJsonExports !== void 0)
              return e.resolvePackageJsonExports;
            switch (t6) {
              case 3:
              case 99:
              case 100:
                return true;
            }
            return false;
          }
          function xM(e) {
            let t6 = Ml(e);
            if (!_v(t6))
              return false;
            if (e.resolvePackageJsonExports !== void 0)
              return e.resolvePackageJsonExports;
            switch (t6) {
              case 3:
              case 99:
              case 100:
                return true;
            }
            return false;
          }
          function Cx(e) {
            return e.resolveJsonModule !== void 0 ? e.resolveJsonModule : Ml(e) === 100;
          }
          function cv(e) {
            return !!(e.declaration || e.composite);
          }
          function EM(e) {
            return !!(e.preserveConstEnums || zf(e));
          }
          function wM(e) {
            return !!(e.incremental || e.composite);
          }
          function lv(e, t6) {
            return e[t6] === void 0 ? !!e.strict : !!e[t6];
          }
          function Ax(e) {
            return e.allowJs === void 0 ? !!e.checkJs : e.allowJs;
          }
          function CM(e) {
            return e.useDefineForClassFields === void 0 ? Uf(e) >= 9 : e.useDefineForClassFields;
          }
          function AM(e, t6) {
            return J_(t6, e, semanticDiagnosticsOptionDeclarations);
          }
          function PM(e, t6) {
            return J_(t6, e, affectsEmitOptionDeclarations);
          }
          function DM(e, t6) {
            return J_(t6, e, affectsDeclarationPathOptionDeclarations);
          }
          function uv(e, t6) {
            return t6.strictFlag ? lv(e, t6.name) : e[t6.name];
          }
          function kM(e) {
            let t6 = e.jsx;
            return t6 === 2 || t6 === 4 || t6 === 5;
          }
          function IM(e, t6) {
            let r = t6 == null ? void 0 : t6.pragmas.get("jsximportsource"), s = ir2(r) ? r[r.length - 1] : r;
            return e.jsx === 4 || e.jsx === 5 || e.jsxImportSource || s ? (s == null ? void 0 : s.arguments.factory) || e.jsxImportSource || "react" : void 0;
          }
          function NM(e, t6) {
            return e ? `${e}/${t6.jsx === 5 ? "jsx-dev-runtime" : "jsx-runtime"}` : void 0;
          }
          function OM(e) {
            let t6 = false;
            for (let r = 0; r < e.length; r++)
              if (e.charCodeAt(r) === 42)
                if (!t6)
                  t6 = true;
                else
                  return false;
            return true;
          }
          function MM(e, t6) {
            let r, s, f10, x10 = false;
            return { getSymlinkedFiles: () => f10, getSymlinkedDirectories: () => r, getSymlinkedDirectoriesByRealpath: () => s, setSymlinkedFile: (A6, g9) => (f10 || (f10 = /* @__PURE__ */ new Map())).set(A6, g9), setSymlinkedDirectory: (A6, g9) => {
              let B = Ui(A6, e, t6);
              Hx(B) || (B = wo(B), g9 !== false && !(r != null && r.has(B)) && (s || (s = Be2())).add(wo(g9.realPath), A6), (r || (r = /* @__PURE__ */ new Map())).set(B, g9));
            }, setSymlinksFromResolutions(A6, g9) {
              var B, N10;
              Y3.assert(!x10), x10 = true;
              for (let X2 of A6)
                (B = X2.resolvedModules) == null || B.forEach((F2) => w6(this, F2.resolvedModule)), (N10 = X2.resolvedTypeReferenceDirectiveNames) == null || N10.forEach((F2) => w6(this, F2.resolvedTypeReferenceDirective));
              g9.forEach((X2) => w6(this, X2.resolvedTypeReferenceDirective));
            }, hasProcessedResolutions: () => x10 };
            function w6(A6, g9) {
              if (!g9 || !g9.originalPath || !g9.resolvedFileName)
                return;
              let { resolvedFileName: B, originalPath: N10 } = g9;
              A6.setSymlinkedFile(Ui(N10, e, t6), B);
              let [X2, F2] = LM(B, N10, e, t6) || Bt;
              X2 && F2 && A6.setSymlinkedDirectory(F2, { real: X2, realPath: Ui(X2, e, t6) });
            }
          }
          function LM(e, t6, r, s) {
            let f10 = qi(as(e, r)), x10 = qi(as(t6, r)), w6 = false;
            for (; f10.length >= 2 && x10.length >= 2 && !Px(f10[f10.length - 2], s) && !Px(x10[x10.length - 2], s) && s(f10[f10.length - 1]) === s(x10[x10.length - 1]); )
              f10.pop(), x10.pop(), w6 = true;
            return w6 ? [xo(f10), xo(x10)] : void 0;
          }
          function Px(e, t6) {
            return e !== void 0 && (t6(e) === "node_modules" || Pn(e, "@"));
          }
          function RM(e) {
            return ay(e.charCodeAt(0)) ? e.slice(1) : void 0;
          }
          function jM(e, t6, r) {
            let s = ST(e, t6, r);
            return s === void 0 ? void 0 : RM(s);
          }
          function JM(e) {
            return e.replace(Xf, FM);
          }
          function FM(e) {
            return "\\" + e;
          }
          function Wf(e, t6, r) {
            let s = pv(e, t6, r);
            return !s || !s.length ? void 0 : `^(${s.map((w6) => `(${w6})`).join("|")})${r === "exclude" ? "($|/)" : "$"}`;
          }
          function pv(e, t6, r) {
            if (!(e === void 0 || e.length === 0))
              return ne2(e, (s) => s && kx(s, t6, r, Nv[r]));
          }
          function Dx(e) {
            return !/[.*?]/.test(e);
          }
          function BM(e, t6, r) {
            let s = e && kx(e, t6, r, Nv[r]);
            return s && `^(${s})${r === "exclude" ? "($|/)" : "$"}`;
          }
          function kx(e, t6, r, s) {
            let { singleAsteriskRegexFragment: f10, doubleAsteriskRegexFragment: x10, replaceWildcardCharacter: w6 } = s, A6 = "", g9 = false, B = $p(e, t6), N10 = Zn(B);
            if (r !== "exclude" && N10 === "**")
              return;
            B[0] = P_(B[0]), Dx(N10) && B.push("**", "*");
            let X2 = 0;
            for (let F2 of B) {
              if (F2 === "**")
                A6 += x10;
              else if (r === "directories" && (A6 += "(", X2++), g9 && (A6 += zn), r !== "exclude") {
                let $ = "";
                F2.charCodeAt(0) === 42 ? ($ += "([^./]" + f10 + ")?", F2 = F2.substr(1)) : F2.charCodeAt(0) === 63 && ($ += "[^./]", F2 = F2.substr(1)), $ += F2.replace(Xf, w6), $ !== F2 && (A6 += Yf), A6 += $;
              } else
                A6 += F2.replace(Xf, w6);
              g9 = true;
            }
            for (; X2 > 0; )
              A6 += ")?", X2--;
            return A6;
          }
          function fv(e, t6) {
            return e === "*" ? t6 : e === "?" ? "[^/]" : "\\" + e;
          }
          function Ix(e, t6, r, s, f10) {
            e = Un(e), f10 = Un(f10);
            let x10 = tn(f10, e);
            return { includeFilePatterns: Ze2(pv(r, x10, "files"), (w6) => `^${w6}$`), includeFilePattern: Wf(r, x10, "files"), includeDirectoryPattern: Wf(r, x10, "directories"), excludePattern: Wf(t6, x10, "exclude"), basePaths: UM(e, r, s) };
          }
          function Vf(e, t6) {
            return new RegExp(e, t6 ? "" : "i");
          }
          function qM(e, t6, r, s, f10, x10, w6, A6, g9) {
            e = Un(e), x10 = Un(x10);
            let B = Ix(e, r, s, f10, x10), N10 = B.includeFilePatterns && B.includeFilePatterns.map((Ye2) => Vf(Ye2, f10)), X2 = B.includeDirectoryPattern && Vf(B.includeDirectoryPattern, f10), F2 = B.excludePattern && Vf(B.excludePattern, f10), $ = N10 ? N10.map(() => []) : [[]], ae = /* @__PURE__ */ new Map(), Te2 = wp(f10);
            for (let Ye2 of B.basePaths)
              Se2(Ye2, tn(x10, Ye2), w6);
            return ct($);
            function Se2(Ye2, Ne2, oe2) {
              let Ve2 = Te2(g9(Ne2));
              if (ae.has(Ve2))
                return;
              ae.set(Ve2, true);
              let { files: pt2, directories: Gt } = A6(Ye2);
              for (let Nt of Is(pt2, ri)) {
                let Xt = tn(Ye2, Nt), er2 = tn(Ne2, Nt);
                if (!(t6 && !da(Xt, t6)) && !(F2 && F2.test(er2)))
                  if (!N10)
                    $[0].push(Xt);
                  else {
                    let Tn = he(N10, (Hr2) => Hr2.test(er2));
                    Tn !== -1 && $[Tn].push(Xt);
                  }
              }
              if (!(oe2 !== void 0 && (oe2--, oe2 === 0)))
                for (let Nt of Is(Gt, ri)) {
                  let Xt = tn(Ye2, Nt), er2 = tn(Ne2, Nt);
                  (!X2 || X2.test(er2)) && (!F2 || !F2.test(er2)) && Se2(Xt, er2, oe2);
                }
            }
          }
          function UM(e, t6, r) {
            let s = [e];
            if (t6) {
              let f10 = [];
              for (let x10 of t6) {
                let w6 = A_(x10) ? x10 : Un(tn(e, x10));
                f10.push(zM(w6));
              }
              f10.sort(rl(!r));
              for (let x10 of f10)
                me2(s, (w6) => !jT(w6, x10, e, !r)) && s.push(x10);
            }
            return s;
          }
          function zM(e) {
            let t6 = Je2(e, h8);
            return t6 < 0 ? OT(e) ? P_(ma(e)) : e : e.substring(0, e.lastIndexOf(zn, t6));
          }
          function Nx(e, t6) {
            return t6 || Ox(e) || 3;
          }
          function Ox(e) {
            switch (e.substr(e.lastIndexOf(".")).toLowerCase()) {
              case ".js":
              case ".cjs":
              case ".mjs":
                return 1;
              case ".jsx":
                return 2;
              case ".ts":
              case ".cts":
              case ".mts":
                return 3;
              case ".tsx":
                return 4;
              case ".json":
                return 6;
              default:
                return 0;
            }
          }
          function Mx(e, t6) {
            let r = e && Ax(e);
            if (!t6 || t6.length === 0)
              return r ? Jl : Jo;
            let s = r ? Jl : Jo, f10 = ct(s);
            return [...s, ...qt(t6, (w6) => w6.scriptKind === 7 || r && WM(w6.scriptKind) && f10.indexOf(w6.extension) === -1 ? [w6.extension] : void 0)];
          }
          function Lx(e, t6) {
            return !e || !Cx(e) ? t6 : t6 === Jl ? v8 : t6 === Jo ? g8 : [...t6, [".json"]];
          }
          function WM(e) {
            return e === 1 || e === 2;
          }
          function dv(e) {
            return Ke3(Lv, (t6) => ns(e, t6));
          }
          function mv(e) {
            return Ke3(Ov, (t6) => ns(e, t6));
          }
          function Rx(e) {
            let { imports: t6 } = e, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : W1(dv, mv);
            return q2(t6, (s) => {
              let { text: f10 } = s;
              return So(f10) ? r(f10) : void 0;
            }) || false;
          }
          function VM(e, t6, r, s) {
            if (e === "js" || t6 === 99)
              return shouldAllowImportingTsExtension(r) && f10() !== 2 ? 3 : 2;
            if (e === "minimal")
              return 0;
            if (e === "index")
              return 1;
            if (!shouldAllowImportingTsExtension(r))
              return Rx(s) ? 2 : 0;
            return f10();
            function f10() {
              let x10 = false, w6 = s.imports.length ? s.imports.map((A6) => A6.text) : y0(s) ? HM(s).map((A6) => A6.arguments[0].text) : Bt;
              for (let A6 of w6)
                if (So(A6)) {
                  if (mv(A6))
                    return 3;
                  dv(A6) && (x10 = true);
                }
              return x10 ? 2 : 0;
            }
          }
          function HM(e) {
            let t6 = 0, r;
            for (let s of e.statements) {
              if (t6 > 3)
                break;
              W3(s) ? r = Ft(r, s.declarationList.declarations.map((f10) => f10.initializer)) : Zl(s) && El(s.expression, true) ? r = tr2(r, s.expression) : t6++;
            }
            return r || Bt;
          }
          function GM(e, t6, r) {
            if (!e)
              return false;
            let s = Mx(t6, r);
            for (let f10 of ct(Lx(t6, s)))
              if (ns(e, f10))
                return true;
            return false;
          }
          function jx(e) {
            let t6 = e.match(/\//g);
            return t6 ? t6.length : 0;
          }
          function $M(e, t6) {
            return Vr2(jx(e), jx(t6));
          }
          function Ll(e) {
            for (let t6 of Qf) {
              let r = Jx(e, t6);
              if (r !== void 0)
                return r;
            }
            return e;
          }
          function Jx(e, t6) {
            return ns(e, t6) ? Fx(e, t6) : void 0;
          }
          function Fx(e, t6) {
            return e.substring(0, e.length - t6.length);
          }
          function KM(e, t6) {
            return RT(e, t6, Qf, false);
          }
          function Bx(e) {
            let t6 = e.indexOf("*");
            return t6 === -1 ? e : e.indexOf("*", t6 + 1) !== -1 ? void 0 : { prefix: e.substr(0, t6), suffix: e.substr(t6 + 1) };
          }
          function XM(e) {
            return qt(ho(e), (t6) => Bx(t6));
          }
          function hs(e) {
            return !(e >= 0);
          }
          function qx(e) {
            return e === ".ts" || e === ".tsx" || e === ".d.ts" || e === ".cts" || e === ".mts" || e === ".d.mts" || e === ".d.cts" || Pn(e, ".d.") && es(e, ".ts");
          }
          function YM(e) {
            return qx(e) || e === ".json";
          }
          function QM(e) {
            let t6 = hv(e);
            return t6 !== void 0 ? t6 : Y3.fail(`File ${e} has unknown extension.`);
          }
          function ZM(e) {
            return hv(e) !== void 0;
          }
          function hv(e) {
            return Ae2(Qf, (t6) => ns(e, t6));
          }
          function eL(e, t6) {
            return e.checkJsDirective ? e.checkJsDirective.enabled : t6.checkJs;
          }
          function tL(e, t6) {
            let r = [];
            for (let s of e) {
              if (s === t6)
                return t6;
              Ji(s) || r.push(s);
            }
            return TT(r, (s) => s, t6);
          }
          function rL(e, t6) {
            let r = e.indexOf(t6);
            return Y3.assert(r !== -1), e.slice(r);
          }
          function Rl(e) {
            for (var t6 = arguments.length, r = new Array(t6 > 1 ? t6 - 1 : 0), s = 1; s < t6; s++)
              r[s - 1] = arguments[s];
            return r.length && (e.relatedInformation || (e.relatedInformation = []), Y3.assert(e.relatedInformation !== Bt, "Diagnostic had empty array singleton for related info, but is still being constructed!"), e.relatedInformation.push(...r)), e;
          }
          function nL(e, t6) {
            Y3.assert(e.length !== 0);
            let r = t6(e[0]), s = r;
            for (let f10 = 1; f10 < e.length; f10++) {
              let x10 = t6(e[f10]);
              x10 < r ? r = x10 : x10 > s && (s = x10);
            }
            return { min: r, max: s };
          }
          function iL(e) {
            return { pos: Io(e), end: e.end };
          }
          function aL(e, t6) {
            let r = t6.pos - 1, s = Math.min(e.text.length, Ar2(e.text, t6.end) + 1);
            return { pos: r, end: s };
          }
          function sL(e, t6, r) {
            return t6.skipLibCheck && e.isDeclarationFile || t6.skipDefaultLibCheck && e.hasNoDefaultLib || r.isSourceOfProjectReferenceRedirect(e.fileName);
          }
          function gv(e, t6) {
            return e === t6 || typeof e == "object" && e !== null && typeof t6 == "object" && t6 !== null && S_(e, t6, gv);
          }
          function Hf(e) {
            let t6;
            switch (e.charCodeAt(1)) {
              case 98:
              case 66:
                t6 = 1;
                break;
              case 111:
              case 79:
                t6 = 3;
                break;
              case 120:
              case 88:
                t6 = 4;
                break;
              default:
                let B = e.length - 1, N10 = 0;
                for (; e.charCodeAt(N10) === 48; )
                  N10++;
                return e.slice(N10, B) || "0";
            }
            let r = 2, s = e.length - 1, f10 = (s - r) * t6, x10 = new Uint16Array((f10 >>> 4) + (f10 & 15 ? 1 : 0));
            for (let B = s - 1, N10 = 0; B >= r; B--, N10 += t6) {
              let X2 = N10 >>> 4, F2 = e.charCodeAt(B), ae = (F2 <= 57 ? F2 - 48 : 10 + F2 - (F2 <= 70 ? 65 : 97)) << (N10 & 15);
              x10[X2] |= ae;
              let Te2 = ae >>> 16;
              Te2 && (x10[X2 + 1] |= Te2);
            }
            let w6 = "", A6 = x10.length - 1, g9 = true;
            for (; g9; ) {
              let B = 0;
              g9 = false;
              for (let N10 = A6; N10 >= 0; N10--) {
                let X2 = B << 16 | x10[N10], F2 = X2 / 10 | 0;
                x10[N10] = F2, B = X2 - F2 * 10, F2 && !g9 && (A6 = N10, g9 = true);
              }
              w6 = B + w6;
            }
            return w6;
          }
          function yv(e) {
            let { negative: t6, base10Value: r } = e;
            return (t6 && r !== "0" ? "-" : "") + r;
          }
          function oL(e) {
            if (zx(e, false))
              return Ux(e);
          }
          function Ux(e) {
            let t6 = e.startsWith("-"), r = Hf(`${t6 ? e.slice(1) : e}n`);
            return { negative: t6, base10Value: r };
          }
          function zx(e, t6) {
            if (e === "")
              return false;
            let r = Po(99, false), s = true;
            r.setOnError(() => s = false), r.setText(e + "n");
            let f10 = r.scan(), x10 = f10 === 40;
            x10 && (f10 = r.scan());
            let w6 = r.getTokenFlags();
            return s && f10 === 9 && r.getTextPos() === e.length + 1 && !(w6 & 512) && (!t6 || e === yv({ negative: x10, base10Value: Hf(r.getTokenValue()) }));
          }
          function _L(e) {
            return !!(e.flags & 16777216) || F3(e) || uL(e) || lL(e) || !(g0(e) || cL(e));
          }
          function cL(e) {
            return yt(e) && nu(e.parent) && e.parent.name === e;
          }
          function lL(e) {
            for (; e.kind === 79 || e.kind === 208; )
              e = e.parent;
            if (e.kind !== 164)
              return false;
            if (rn(e.parent, 256))
              return true;
            let t6 = e.parent.parent.kind;
            return t6 === 261 || t6 === 184;
          }
          function uL(e) {
            if (e.kind !== 79)
              return false;
            let t6 = zi(e.parent, (r) => {
              switch (r.kind) {
                case 294:
                  return true;
                case 208:
                case 230:
                  return false;
                default:
                  return "quit";
              }
            });
            return (t6 == null ? void 0 : t6.token) === 117 || (t6 == null ? void 0 : t6.parent.kind) === 261;
          }
          function pL(e) {
            return ac(e) && yt(e.typeName);
          }
          function fL(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fa;
            if (e.length < 2)
              return true;
            let r = e[0];
            for (let s = 1, f10 = e.length; s < f10; s++) {
              let x10 = e[s];
              if (!t6(r, x10))
                return false;
            }
            return true;
          }
          function Gf(e, t6) {
            return e.pos = t6, e;
          }
          function Wx(e, t6) {
            return e.end = t6, e;
          }
          function Us(e, t6, r) {
            return Wx(Gf(e, t6), r);
          }
          function $f(e, t6, r) {
            return Us(e, t6, t6 + r);
          }
          function dL(e, t6) {
            return e && (e.flags = t6), e;
          }
          function Sa(e, t6) {
            return e && t6 && (e.parent = t6), e;
          }
          function Q_(e, t6) {
            if (e)
              for (let r of e)
                Sa(r, t6);
            return e;
          }
          function Vx(e, t6) {
            if (!e)
              return e;
            return D2(e, Uy(e) ? r : f10), e;
            function r(x10, w6) {
              if (t6 && x10.parent === w6)
                return "skip";
              Sa(x10, w6);
            }
            function s(x10) {
              if (ya(x10))
                for (let w6 of x10.jsDoc)
                  r(w6, x10), D2(w6, r);
            }
            function f10(x10, w6) {
              return r(x10, w6) || s(x10);
            }
          }
          function mL(e) {
            return !cd(e);
          }
          function hL(e) {
            return Yl(e) && me2(e.elements, mL);
          }
          function gL(e) {
            for (Y3.assertIsDefined(e.parent); ; ) {
              let t6 = e.parent;
              if (qo(t6)) {
                e = t6;
                continue;
              }
              if (Zl(t6) || Qv(t6) || eE(t6) && (t6.initializer === e || t6.incrementor === e))
                return true;
              if (oc(t6)) {
                if (e !== Zn(t6.elements))
                  return true;
                e = t6;
                continue;
              }
              if (ur2(t6) && t6.operatorToken.kind === 27) {
                if (e === t6.left)
                  return true;
                e = t6;
                continue;
              }
              return false;
            }
          }
          function Hx(e) {
            return Ke3(ignoredPaths, (t6) => Fi(e, t6));
          }
          function yL(e) {
            if (!e.parent)
              return;
            switch (e.kind) {
              case 165:
                let { parent: r } = e;
                return r.kind === 192 ? void 0 : r.typeParameters;
              case 166:
                return e.parent.parameters;
              case 201:
                return e.parent.templateSpans;
              case 236:
                return e.parent.templateSpans;
              case 167: {
                let { parent: s } = e;
                return ME(s) ? s.modifiers : void 0;
              }
              case 294:
                return e.parent.heritageClauses;
            }
            let { parent: t6 } = e;
            if (zy(e))
              return f2(e.parent) ? void 0 : e.parent.tags;
            switch (t6.kind) {
              case 184:
              case 261:
                return Ry(e) ? t6.members : void 0;
              case 189:
              case 190:
                return t6.types;
              case 186:
              case 206:
              case 357:
              case 272:
              case 276:
                return t6.elements;
              case 207:
              case 289:
                return t6.properties;
              case 210:
              case 211:
                return Jy(e) ? t6.typeArguments : t6.expression === e ? void 0 : t6.arguments;
              case 281:
              case 285:
                return o3(e) ? t6.children : void 0;
              case 283:
              case 282:
                return Jy(e) ? t6.typeArguments : void 0;
              case 238:
              case 292:
              case 293:
              case 265:
                return t6.statements;
              case 266:
                return t6.clauses;
              case 260:
              case 228:
                return Js(e) ? t6.members : void 0;
              case 263:
                return cE(e) ? t6.members : void 0;
              case 308:
                return t6.statements;
            }
          }
          function vL(e) {
            if (!e.typeParameters) {
              if (Ke3(e.parameters, (t6) => !V0(t6)))
                return true;
              if (e.kind !== 216) {
                let t6 = pa(e.parameters);
                if (!(t6 && kl(t6)))
                  return true;
              }
            }
            return false;
          }
          function bL(e) {
            return e === "Infinity" || e === "-Infinity" || e === "NaN";
          }
          function Gx(e) {
            return e.kind === 257 && e.parent.kind === 295;
          }
          function TL(e) {
            let t6 = e.valueDeclaration && If(e.valueDeclaration);
            return !!t6 && (Vs(t6) || Gx(t6));
          }
          function SL(e) {
            return e.kind === 215 || e.kind === 216;
          }
          function xL(e) {
            return e.replace(/\$/gm, () => "\\$");
          }
          function $x(e) {
            return (+e).toString() === e;
          }
          function EL(e, t6, r, s) {
            return vy(e, t6) ? si.createIdentifier(e) : !s && $x(e) && +e >= 0 ? si.createNumericLiteral(+e) : si.createStringLiteral(e, !!r);
          }
          function Kx(e) {
            return !!(e.flags & 262144 && e.isThisType);
          }
          function wL(e) {
            let t6 = 0, r = 0, s = 0, f10 = 0, x10;
            ((B) => {
              B[B.BeforeNodeModules = 0] = "BeforeNodeModules", B[B.NodeModules = 1] = "NodeModules", B[B.Scope = 2] = "Scope", B[B.PackageContent = 3] = "PackageContent";
            })(x10 || (x10 = {}));
            let w6 = 0, A6 = 0, g9 = 0;
            for (; A6 >= 0; )
              switch (w6 = A6, A6 = e.indexOf("/", w6 + 1), g9) {
                case 0:
                  e.indexOf(nodeModulesPathPart, w6) === w6 && (t6 = w6, r = A6, g9 = 1);
                  break;
                case 1:
                case 2:
                  g9 === 1 && e.charAt(w6 + 1) === "@" ? g9 = 2 : (s = A6, g9 = 3);
                  break;
                case 3:
                  e.indexOf(nodeModulesPathPart, w6) === w6 ? g9 = 1 : g9 = 3;
                  break;
              }
            return f10 = w6, g9 > 1 ? { topLevelNodeModulesIndex: t6, topLevelPackageNameIndex: r, packageRootIndex: s, fileNameIndex: f10 } : void 0;
          }
          function CL(e) {
            var t6;
            return e.kind === 344 ? (t6 = e.typeExpression) == null ? void 0 : t6.type : e.type;
          }
          function Xx(e) {
            switch (e.kind) {
              case 165:
              case 260:
              case 261:
              case 262:
              case 263:
              case 349:
              case 341:
              case 343:
                return true;
              case 270:
                return e.isTypeOnly;
              case 273:
              case 278:
                return e.parent.parent.isTypeOnly;
              default:
                return false;
            }
          }
          function AL(e) {
            return i22(e) || zo(e) || Wo(e) || _c(e) || eu(e) || Xx(e) || Ea(e) && !Xy(e) && !vf(e);
          }
          function Yx(e) {
            if (!Dy(e))
              return false;
            let { isBracketed: t6, typeExpression: r } = e;
            return t6 || !!r && r.type.kind === 319;
          }
          function PL(e, t6) {
            if (e.length === 0)
              return false;
            let r = e.charCodeAt(0);
            return r === 35 ? e.length > 1 && Wn(e.charCodeAt(1), t6) : Wn(r, t6);
          }
          function Qx(e) {
            var t6;
            return ((t6 = getSnippetElement(e)) == null ? void 0 : t6.kind) === 0;
          }
          function Zx(e) {
            return Pr(e) && (e.type && e.type.kind === 319 || of(e).some((t6) => {
              let { isBracketed: r, typeExpression: s } = t6;
              return r || !!s && s.type.kind === 319;
            }));
          }
          function DL(e) {
            switch (e.kind) {
              case 169:
              case 168:
                return !!e.questionToken;
              case 166:
                return !!e.questionToken || Zx(e);
              case 351:
              case 344:
                return Yx(e);
              default:
                return false;
            }
          }
          function kL(e) {
            let t6 = e.kind;
            return (t6 === 208 || t6 === 209) && Uo(e.expression);
          }
          function IL(e) {
            return Pr(e) && qo(e) && ya(e) && !!wy(e);
          }
          function NL(e) {
            return Y3.checkDefined(e8(e));
          }
          function e8(e) {
            let t6 = wy(e);
            return t6 && t6.typeExpression && t6.typeExpression.type;
          }
          var t8, Kf, r8, n8, Z_, vv, bv, i8, Tv, a8, Sv, xv, Ev, wv, s8, o8, _8, c8, l8, Cv, u8, p8, f8, jo, xa, d8, m8, lr2, Av, jl, Xf, h8, Pv, Yf, Dv, kv, Iv, Nv, Jo, Ov, g8, y8, Mv, Lv, Jl, v8, Rv, b8, jv, Qf, T8, OL = D({ "src/compiler/utilities.ts"() {
            "use strict";
            nn(), t8 = [], Kf = "tslib", r8 = 160, n8 = 1e6, Z_ = _D(), vv = ((e) => (e[e.None = 0] = "None", e[e.NeverAsciiEscape = 1] = "NeverAsciiEscape", e[e.JsxAttributeEscape = 2] = "JsxAttributeEscape", e[e.TerminateUnterminatedLiterals = 4] = "TerminateUnterminatedLiterals", e[e.AllowNumericSeparator = 8] = "AllowNumericSeparator", e))(vv || {}), bv = /^(\/\/\/\s*<reference\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/, i8 = /^(\/\/\/\s*<reference\s+types\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/, Tv = /^(\/\/\/\s*<amd-dependency\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/, a8 = /^(\/\/\/\s*<reference\s+no-default-lib\s*=\s*)(('[^']*')|("[^"]*"))\s*\/>/, Sv = ((e) => (e[e.None = 0] = "None", e[e.Definite = 1] = "Definite", e[e.Compound = 2] = "Compound", e))(Sv || {}), xv = ((e) => (e[e.Normal = 0] = "Normal", e[e.Generator = 1] = "Generator", e[e.Async = 2] = "Async", e[e.Invalid = 4] = "Invalid", e[e.AsyncGenerator = 3] = "AsyncGenerator", e))(xv || {}), Ev = ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(Ev || {}), wv = ((e) => (e[e.Comma = 0] = "Comma", e[e.Spread = 1] = "Spread", e[e.Yield = 2] = "Yield", e[e.Assignment = 3] = "Assignment", e[e.Conditional = 4] = "Conditional", e[e.Coalesce = 4] = "Coalesce", e[e.LogicalOR = 5] = "LogicalOR", e[e.LogicalAND = 6] = "LogicalAND", e[e.BitwiseOR = 7] = "BitwiseOR", e[e.BitwiseXOR = 8] = "BitwiseXOR", e[e.BitwiseAND = 9] = "BitwiseAND", e[e.Equality = 10] = "Equality", e[e.Relational = 11] = "Relational", e[e.Shift = 12] = "Shift", e[e.Additive = 13] = "Additive", e[e.Multiplicative = 14] = "Multiplicative", e[e.Exponentiation = 15] = "Exponentiation", e[e.Unary = 16] = "Unary", e[e.Update = 17] = "Update", e[e.LeftHandSide = 18] = "LeftHandSide", e[e.Member = 19] = "Member", e[e.Primary = 20] = "Primary", e[e.Highest = 20] = "Highest", e[e.Lowest = 0] = "Lowest", e[e.Invalid = -1] = "Invalid", e))(wv || {}), s8 = /\$\{/g, o8 = /[\\\"\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g, _8 = /[\\\'\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g, c8 = /\r\n|[\\\`\u0000-\u001f\t\v\f\b\r\u2028\u2029\u0085]/g, l8 = new Map(Object.entries({ "	": "\\t", "\v": "\\v", "\f": "\\f", "\b": "\\b", "\r": "\\r", "\n": "\\n", "\\": "\\\\", '"': '\\"', "'": "\\'", "`": "\\`", "\u2028": "\\u2028", "\u2029": "\\u2029", "Â": "\\u0085", "\r\n": "\\r\\n" })), Cv = /[^\u0000-\u007F]/g, u8 = /[\"\u0000-\u001f\u2028\u2029\u0085]/g, p8 = /[\'\u0000-\u001f\u2028\u2029\u0085]/g, f8 = new Map(Object.entries({ '"': "&quot;", "'": "&apos;" })), jo = ["", "    "], xa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", d8 = `\r
`, m8 = `
`, lr2 = { getNodeConstructor: () => nv, getTokenConstructor: () => nM, getIdentifierConstructor: () => iM, getPrivateIdentifierConstructor: () => nv, getSourceFileConstructor: () => nv, getSymbolConstructor: () => eM, getTypeConstructor: () => tM, getSignatureConstructor: () => rM, getSourceMapSourceConstructor: () => aM }, Av = [], Xf = /[^\w\s\/]/g, h8 = [42, 63], Pv = ["node_modules", "bower_components", "jspm_packages"], Yf = `(?!(${Pv.join("|")})(/|$))`, Dv = { singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*", doubleAsteriskRegexFragment: `(/${Yf}[^/.][^/]*)*?`, replaceWildcardCharacter: (e) => fv(e, Dv.singleAsteriskRegexFragment) }, kv = { singleAsteriskRegexFragment: "[^/]*", doubleAsteriskRegexFragment: `(/${Yf}[^/.][^/]*)*?`, replaceWildcardCharacter: (e) => fv(e, kv.singleAsteriskRegexFragment) }, Iv = { singleAsteriskRegexFragment: "[^/]*", doubleAsteriskRegexFragment: "(/.+?)?", replaceWildcardCharacter: (e) => fv(e, Iv.singleAsteriskRegexFragment) }, Nv = { files: Dv, directories: kv, exclude: Iv }, Jo = [[".ts", ".tsx", ".d.ts"], [".cts", ".d.cts"], [".mts", ".d.mts"]], Ov = ct(Jo), g8 = [...Jo, [".json"]], y8 = [".d.ts", ".d.cts", ".d.mts", ".cts", ".mts", ".ts", ".tsx", ".cts", ".mts"], Mv = [[".js", ".jsx"], [".mjs"], [".cjs"]], Lv = ct(Mv), Jl = [[".ts", ".tsx", ".d.ts", ".js", ".jsx"], [".cts", ".d.cts", ".cjs"], [".mts", ".d.mts", ".mjs"]], v8 = [...Jl, [".json"]], Rv = [".d.ts", ".d.cts", ".d.mts"], b8 = [".ts", ".cts", ".mts", ".tsx"], jv = ((e) => (e[e.Minimal = 0] = "Minimal", e[e.Index = 1] = "Index", e[e.JsExtension = 2] = "JsExtension", e[e.TsExtension = 3] = "TsExtension", e))(jv || {}), Qf = [".d.ts", ".d.mts", ".d.cts", ".mjs", ".mts", ".cjs", ".cts", ".ts", ".js", ".tsx", ".jsx", ".json"], T8 = { files: Bt, directories: Bt };
          } });
          function S8() {
            let e, t6, r, s, f10;
            return { createBaseSourceFileNode: x10, createBaseIdentifierNode: w6, createBasePrivateIdentifierNode: A6, createBaseTokenNode: g9, createBaseNode: B };
            function x10(N10) {
              return new (f10 || (f10 = lr2.getSourceFileConstructor()))(N10, -1, -1);
            }
            function w6(N10) {
              return new (r || (r = lr2.getIdentifierConstructor()))(N10, -1, -1);
            }
            function A6(N10) {
              return new (s || (s = lr2.getPrivateIdentifierConstructor()))(N10, -1, -1);
            }
            function g9(N10) {
              return new (t6 || (t6 = lr2.getTokenConstructor()))(N10, -1, -1);
            }
            function B(N10) {
              return new (e || (e = lr2.getNodeConstructor()))(N10, -1, -1);
            }
          }
          var ML = D({ "src/compiler/factory/baseNodeFactory.ts"() {
            "use strict";
            nn();
          } }), Jv, LL = D({ "src/compiler/factory/parenthesizerRules.ts"() {
            "use strict";
            nn(), Jv = { getParenthesizeLeftSideOfBinaryForOperator: (e) => rr2, getParenthesizeRightSideOfBinaryForOperator: (e) => rr2, parenthesizeLeftSideOfBinary: (e, t6) => t6, parenthesizeRightSideOfBinary: (e, t6, r) => r, parenthesizeExpressionOfComputedPropertyName: rr2, parenthesizeConditionOfConditionalExpression: rr2, parenthesizeBranchOfConditionalExpression: rr2, parenthesizeExpressionOfExportDefault: rr2, parenthesizeExpressionOfNew: (e) => ti(e, Do), parenthesizeLeftSideOfAccess: (e) => ti(e, Do), parenthesizeOperandOfPostfixUnary: (e) => ti(e, Do), parenthesizeOperandOfPrefixUnary: (e) => ti(e, t3), parenthesizeExpressionsOfCommaDelimitedList: (e) => ti(e, _s), parenthesizeExpressionForDisallowedComma: rr2, parenthesizeExpressionOfExpressionStatement: rr2, parenthesizeConciseBodyOfArrowFunction: rr2, parenthesizeCheckTypeOfConditionalType: rr2, parenthesizeExtendsTypeOfConditionalType: rr2, parenthesizeConstituentTypesOfUnionType: (e) => ti(e, _s), parenthesizeConstituentTypeOfUnionType: rr2, parenthesizeConstituentTypesOfIntersectionType: (e) => ti(e, _s), parenthesizeConstituentTypeOfIntersectionType: rr2, parenthesizeOperandOfTypeOperator: rr2, parenthesizeOperandOfReadonlyTypeOperator: rr2, parenthesizeNonArrayTypeOfPostfixType: rr2, parenthesizeElementTypesOfTupleType: (e) => ti(e, _s), parenthesizeElementTypeOfTupleType: rr2, parenthesizeTypeOfOptionalType: rr2, parenthesizeTypeArguments: (e) => e && ti(e, _s), parenthesizeLeadingTypeArgument: rr2 };
          } }), RL = () => {
          }, x8 = () => new Proxy({}, { get: () => () => {
          } });
          function jL(e) {
            Bv.push(e);
          }
          function Zf(e, t6) {
            let r = e & 8 ? JL : FL, s = tl(() => e & 1 ? Jv : createParenthesizerRules(Ye2)), f10 = tl(() => e & 2 ? nullNodeConverters : x8(Ye2)), x10 = An((n9) => (o, l) => xu(o, n9, l)), w6 = An((n9) => (o) => Tu(n9, o)), A6 = An((n9) => (o) => Su(o, n9)), g9 = An((n9) => () => db(n9)), B = An((n9) => (o) => Ac(n9, o)), N10 = An((n9) => (o, l) => mb(n9, o, l)), X2 = An((n9) => (o, l) => Km(n9, o, l)), F2 = An((n9) => (o, l) => Xm(n9, o, l)), $ = An((n9) => (o, l) => ph(n9, o, l)), ae = An((n9) => (o, l, p) => Cb(n9, o, l, p)), Te2 = An((n9) => (o, l, p) => fh(n9, o, l, p)), Se2 = An((n9) => (o, l, p, k) => Ab(n9, o, l, p, k)), Ye2 = { get parenthesizer() {
              return s();
            }, get converters() {
              return f10();
            }, baseFactory: t6, flags: e, createNodeArray: Ne2, createNumericLiteral: Gt, createBigIntLiteral: Nt, createStringLiteral: er2, createStringLiteralFromNode: Tn, createRegularExpressionLiteral: Hr2, createLiteralLikeNode: Gi, createIdentifier: Ut, createTempVariable: kn, createLoopVariable: an, createUniqueName: mr2, getGeneratedNameForNode: $i, createPrivateIdentifier: Ur2, createUniquePrivateName: _r2, getGeneratedPrivateNameForNode: Sn, createToken: pr2, createSuper: Zt, createThis: Or2, createNull: Nn, createTrue: ar2, createFalse: oi, createModifier: cr2, createModifiersFromModifierFlags: $r2, createQualifiedName: hr2, updateQualifiedName: On, createComputedPropertyName: nr2, updateComputedPropertyName: br2, createTypeParameterDeclaration: Kr2, updateTypeParameterDeclaration: wa, createParameterDeclaration: $n, updateParameterDeclaration: Ki, createDecorator: Mn, updateDecorator: _i, createPropertySignature: Ca, updatePropertySignature: St, createPropertyDeclaration: He2, updatePropertyDeclaration: _t, createMethodSignature: ft, updateMethodSignature: Kt, createMethodDeclaration: zt, updateMethodDeclaration: xe2, createConstructorDeclaration: Mt, updateConstructorDeclaration: It, createGetAccessorDeclaration: gr2, updateGetAccessorDeclaration: Ln, createSetAccessorDeclaration: ci, updateSetAccessorDeclaration: Xi, createCallSignature: vs, updateCallSignature: $s, createConstructSignature: li, updateConstructSignature: Yi2, createIndexSignature: Qi, updateIndexSignature: bs, createClassStaticBlockDeclaration: Re2, updateClassStaticBlockDeclaration: ot2, createTemplateLiteralTypeSpan: Ai, updateTemplateLiteralTypeSpan: xn, createKeywordTypeNode: Dt, createTypePredicateNode: Pi, updateTypePredicateNode: Z, createTypeReferenceNode: ie2, updateTypeReferenceNode: U2, createFunctionTypeNode: L, updateFunctionTypeNode: fe2, createConstructorTypeNode: it, updateConstructorTypeNode: Ge2, createTypeQueryNode: Yt, updateTypeQueryNode: $t, createTypeLiteralNode: Wt, updateTypeLiteralNode: Xr, createArrayTypeNode: Dr2, updateArrayTypeNode: Lr, createTupleTypeNode: yr2, updateTupleTypeNode: Rn, createNamedTupleMember: wt, updateNamedTupleMember: Tr3, createOptionalTypeNode: Tt, updateOptionalTypeNode: kt, createRestTypeNode: de2, updateRestTypeNode: jn, createUnionTypeNode: e_, updateUnionTypeNode: mc, createIntersectionTypeNode: Da, updateIntersectionTypeNode: Ts, createConditionalTypeNode: Ot, updateConditionalTypeNode: dr2, createInferTypeNode: Dd, updateInferTypeNode: ea, createImportTypeNode: Id, updateImportTypeNode: ka, createParenthesizedType: t_, updateParenthesizedType: En, createThisTypeNode: Er2, createTypeOperatorNode: Q2, updateTypeOperatorNode: Jn, createIndexedAccessTypeNode: Ia, updateIndexedAccessTypeNode: Ss, createMappedTypeNode: hc, updateMappedTypeNode: wr2, createLiteralTypeNode: zr2, updateLiteralTypeNode: xs, createTemplateLiteralType: kd, updateTemplateLiteralType: sn, createObjectBindingPattern: Nd, updateObjectBindingPattern: R2, createArrayBindingPattern: Es, updateArrayBindingPattern: j2, createBindingElement: gc, updateBindingElement: Ks, createArrayLiteralExpression: uu, updateArrayLiteralExpression: Od, createObjectLiteralExpression: r_, updateObjectLiteralExpression: J22, createPropertyAccessExpression: e & 4 ? (n9, o) => setEmitFlags(ta(n9, o), 262144) : ta, updatePropertyAccessExpression: Ld, createPropertyAccessChain: e & 4 ? (n9, o, l) => setEmitFlags(Xs(n9, o, l), 262144) : Xs, updatePropertyAccessChain: Rd, createElementAccessExpression: pu, updateElementAccessExpression: F22, createElementAccessChain: fu, updateElementAccessChain: jd, createCallExpression: Na, updateCallExpression: B2, createCallChain: du, updateCallChain: Kn, createNewExpression: vc, updateNewExpression: mu, createTaggedTemplateExpression: hu, updateTaggedTemplateExpression: q22, createTypeAssertion: Fd, updateTypeAssertion: Bd, createParenthesizedExpression: gu, updateParenthesizedExpression: qd, createFunctionExpression: yu, updateFunctionExpression: Ud, createArrowFunction: vu, updateArrowFunction: zd, createDeleteExpression: bu, updateDeleteExpression: U22, createTypeOfExpression: mn, updateTypeOfExpression: z2, createVoidExpression: ui, updateVoidExpression: W2, createAwaitExpression: Oa, updateAwaitExpression: Ys, createPrefixUnaryExpression: Tu, updatePrefixUnaryExpression: bc, createPostfixUnaryExpression: Su, updatePostfixUnaryExpression: Wd, createBinaryExpression: xu, updateBinaryExpression: V2, createConditionalExpression: Eu, updateConditionalExpression: H2, createTemplateExpression: Di, updateTemplateExpression: Hd, createTemplateHead: Sc, createTemplateMiddle: Cu, createTemplateTail: G22, createNoSubstitutionTemplateLiteral: $d, createTemplateLiteralLikeNode: Qs, createYieldExpression: Kd, updateYieldExpression: $2, createSpreadElement: Xd, updateSpreadElement: K2, createClassExpression: Yd, updateClassExpression: xc, createOmittedExpression: X22, createExpressionWithTypeArguments: Qd, updateExpressionWithTypeArguments: Xn, createAsExpression: Ec, updateAsExpression: Zd, createNonNullExpression: em, updateNonNullExpression: Au, createSatisfiesExpression: tm, updateSatisfiesExpression: Pu, createNonNullChain: pi, updateNonNullChain: rm, createMetaProperty: wc, updateMetaProperty: ra, createTemplateSpan: i_, updateTemplateSpan: nm, createSemicolonClassElement: im, createBlock: Zs, updateBlock: am, createVariableStatement: sm, updateVariableStatement: om, createEmptyStatement: Du, createExpressionStatement: a_, updateExpressionStatement: Y22, createIfStatement: ku, updateIfStatement: Q22, createDoStatement: Iu, updateDoStatement: Z2, createWhileStatement: _m, updateWhileStatement: eb, createForStatement: Nu, updateForStatement: cm, createForInStatement: lm, updateForInStatement: tb, createForOfStatement: um, updateForOfStatement: rb, createContinueStatement: pm, updateContinueStatement: fm, createBreakStatement: Ou, updateBreakStatement: dm, createReturnStatement: mm, updateReturnStatement: nb, createWithStatement: Mu, updateWithStatement: hm, createSwitchStatement: Lu, updateSwitchStatement: eo, createLabeledStatement: gm, updateLabeledStatement: ym, createThrowStatement: vm, updateThrowStatement: ib, createTryStatement: bm, updateTryStatement: ab, createDebuggerStatement: Tm, createVariableDeclaration: Cc, updateVariableDeclaration: Sm, createVariableDeclarationList: Ru, updateVariableDeclarationList: sb, createFunctionDeclaration: xm, updateFunctionDeclaration: ju, createClassDeclaration: Em, updateClassDeclaration: Ju, createInterfaceDeclaration: wm, updateInterfaceDeclaration: Cm, createTypeAliasDeclaration: sr2, updateTypeAliasDeclaration: Ma, createEnumDeclaration: Fu, updateEnumDeclaration: La2, createModuleDeclaration: Am, updateModuleDeclaration: Sr2, createModuleBlock: Ra, updateModuleBlock: Yr2, createCaseBlock: Pm, updateCaseBlock: _b, createNamespaceExportDeclaration: Dm, updateNamespaceExportDeclaration: km, createImportEqualsDeclaration: Im, updateImportEqualsDeclaration: Nm, createImportDeclaration: Om, updateImportDeclaration: Mm, createImportClause: Lm, updateImportClause: Rm, createAssertClause: Bu, updateAssertClause: lb, createAssertEntry: s_, updateAssertEntry: jm, createImportTypeAssertionContainer: qu, updateImportTypeAssertionContainer: Jm, createNamespaceImport: Fm, updateNamespaceImport: Uu, createNamespaceExport: Bm2, updateNamespaceExport: qm, createNamedImports: Um, updateNamedImports: ub, createImportSpecifier: zm2, updateImportSpecifier: pb, createExportAssignment: zu, updateExportAssignment: Wu, createExportDeclaration: na, updateExportDeclaration: Wm, createNamedExports: to, updateNamedExports: Hm, createExportSpecifier: Vu, updateExportSpecifier: o_, createMissingDeclaration: fb, createExternalModuleReference: Gm2, updateExternalModuleReference: $m, get createJSDocAllType() {
              return g9(315);
            }, get createJSDocUnknownType() {
              return g9(316);
            }, get createJSDocNonNullableType() {
              return X2(318);
            }, get updateJSDocNonNullableType() {
              return F2(318);
            }, get createJSDocNullableType() {
              return X2(317);
            }, get updateJSDocNullableType() {
              return F2(317);
            }, get createJSDocOptionalType() {
              return B(319);
            }, get updateJSDocOptionalType() {
              return N10(319);
            }, get createJSDocVariadicType() {
              return B(321);
            }, get updateJSDocVariadicType() {
              return N10(321);
            }, get createJSDocNamepathType() {
              return B(322);
            }, get updateJSDocNamepathType() {
              return N10(322);
            }, createJSDocFunctionType: Ym, updateJSDocFunctionType: hb, createJSDocTypeLiteral: Qm, updateJSDocTypeLiteral: gb, createJSDocTypeExpression: Zm, updateJSDocTypeExpression: yb, createJSDocSignature: eh, updateJSDocSignature: Hu, createJSDocTemplateTag: __, updateJSDocTemplateTag: Gu, createJSDocTypedefTag: $u, updateJSDocTypedefTag: th, createJSDocParameterTag: Pc, updateJSDocParameterTag: vb, createJSDocPropertyTag: Ku, updateJSDocPropertyTag: bb, createJSDocCallbackTag: rh, updateJSDocCallbackTag: nh, createJSDocOverloadTag: ih, updateJSDocOverloadTag: ah, createJSDocAugmentsTag: sh, updateJSDocAugmentsTag: Xu, createJSDocImplementsTag: Yu, updateJSDocImplementsTag: wb, createJSDocSeeTag: ro, updateJSDocSeeTag: Tb, createJSDocNameReference: ws, updateJSDocNameReference: Dc, createJSDocMemberName: oh, updateJSDocMemberName: Sb, createJSDocLink: _h, updateJSDocLink: xb, createJSDocLinkCode: ch, updateJSDocLinkCode: lh, createJSDocLinkPlain: uh, updateJSDocLinkPlain: Eb, get createJSDocTypeTag() {
              return Te2(347);
            }, get updateJSDocTypeTag() {
              return Se2(347);
            }, get createJSDocReturnTag() {
              return Te2(345);
            }, get updateJSDocReturnTag() {
              return Se2(345);
            }, get createJSDocThisTag() {
              return Te2(346);
            }, get updateJSDocThisTag() {
              return Se2(346);
            }, get createJSDocAuthorTag() {
              return $(333);
            }, get updateJSDocAuthorTag() {
              return ae(333);
            }, get createJSDocClassTag() {
              return $(335);
            }, get updateJSDocClassTag() {
              return ae(335);
            }, get createJSDocPublicTag() {
              return $(336);
            }, get updateJSDocPublicTag() {
              return ae(336);
            }, get createJSDocPrivateTag() {
              return $(337);
            }, get updateJSDocPrivateTag() {
              return ae(337);
            }, get createJSDocProtectedTag() {
              return $(338);
            }, get updateJSDocProtectedTag() {
              return ae(338);
            }, get createJSDocReadonlyTag() {
              return $(339);
            }, get updateJSDocReadonlyTag() {
              return ae(339);
            }, get createJSDocOverrideTag() {
              return $(340);
            }, get updateJSDocOverrideTag() {
              return ae(340);
            }, get createJSDocDeprecatedTag() {
              return $(334);
            }, get updateJSDocDeprecatedTag() {
              return ae(334);
            }, get createJSDocThrowsTag() {
              return Te2(352);
            }, get updateJSDocThrowsTag() {
              return Se2(352);
            }, get createJSDocSatisfiesTag() {
              return Te2(353);
            }, get updateJSDocSatisfiesTag() {
              return Se2(353);
            }, createJSDocEnumTag: mh, updateJSDocEnumTag: Db, createJSDocUnknownTag: dh, updateJSDocUnknownTag: Pb, createJSDocText: hh, updateJSDocText: Qu, createJSDocComment: gh, updateJSDocComment: yh, createJsxElement: Zu, updateJsxElement: kb, createJsxSelfClosingElement: c_, updateJsxSelfClosingElement: vh, createJsxOpeningElement: bh, updateJsxOpeningElement: Ib, createJsxClosingElement: on, updateJsxClosingElement: Th2, createJsxFragment: ep, createJsxText: l_, updateJsxText: Ob, createJsxOpeningFragment: kc, createJsxJsxClosingFragment: Mb, updateJsxFragment: Nb, createJsxAttribute: Sh, updateJsxAttribute: Lb, createJsxAttributes: xh, updateJsxAttributes: tp, createJsxSpreadAttribute: no, updateJsxSpreadAttribute: Rb, createJsxExpression: Ic, updateJsxExpression: Eh, createCaseClause: wh, updateCaseClause: rp, createDefaultClause: np, updateDefaultClause: jb, createHeritageClause: Ch, updateHeritageClause: Ah, createCatchClause: ip, updateCatchClause: Ph, createPropertyAssignment: Fa, updatePropertyAssignment: Jb, createShorthandPropertyAssignment: Dh, updateShorthandPropertyAssignment: Bb, createSpreadAssignment: ap, updateSpreadAssignment: ki, createEnumMember: sp, updateEnumMember: qb, createSourceFile: Ub, updateSourceFile: Mh, createRedirectedSourceFile: Ih, createBundle: Lh, updateBundle: Wb, createUnparsedSource: Nc2, createUnparsedPrologue: Vb, createUnparsedPrepend: Hb, createUnparsedTextLike: Gb, createUnparsedSyntheticReference: $b, createInputFiles: Kb, createSyntheticExpression: Rh, createSyntaxList: jh, createNotEmittedStatement: Jh, createPartiallyEmittedExpression: Fh, updatePartiallyEmittedExpression: Bh, createCommaListExpression: Mc, updateCommaListExpression: Xb, createEndOfDeclarationMarker: Yb, createMergeDeclarationMarker: Qb, createSyntheticReferenceExpression: Uh, updateSyntheticReferenceExpression: _p, cloneNode: cp, get createComma() {
              return x10(27);
            }, get createAssignment() {
              return x10(63);
            }, get createLogicalOr() {
              return x10(56);
            }, get createLogicalAnd() {
              return x10(55);
            }, get createBitwiseOr() {
              return x10(51);
            }, get createBitwiseXor() {
              return x10(52);
            }, get createBitwiseAnd() {
              return x10(50);
            }, get createStrictEquality() {
              return x10(36);
            }, get createStrictInequality() {
              return x10(37);
            }, get createEquality() {
              return x10(34);
            }, get createInequality() {
              return x10(35);
            }, get createLessThan() {
              return x10(29);
            }, get createLessThanEquals() {
              return x10(32);
            }, get createGreaterThan() {
              return x10(31);
            }, get createGreaterThanEquals() {
              return x10(33);
            }, get createLeftShift() {
              return x10(47);
            }, get createRightShift() {
              return x10(48);
            }, get createUnsignedRightShift() {
              return x10(49);
            }, get createAdd() {
              return x10(39);
            }, get createSubtract() {
              return x10(40);
            }, get createMultiply() {
              return x10(41);
            }, get createDivide() {
              return x10(43);
            }, get createModulo() {
              return x10(44);
            }, get createExponent() {
              return x10(42);
            }, get createPrefixPlus() {
              return w6(39);
            }, get createPrefixMinus() {
              return w6(40);
            }, get createPrefixIncrement() {
              return w6(45);
            }, get createPrefixDecrement() {
              return w6(46);
            }, get createBitwiseNot() {
              return w6(54);
            }, get createLogicalNot() {
              return w6(53);
            }, get createPostfixIncrement() {
              return A6(45);
            }, get createPostfixDecrement() {
              return A6(46);
            }, createImmediatelyInvokedFunctionExpression: n6, createImmediatelyInvokedArrowFunction: Lc, createVoidZero: Rc2, createExportDefault: zh, createExternalModuleExport: i6, createTypeCheck: a6, createMethodCall: Ba, createGlobalMethodCall: io, createFunctionBindCall: s6, createFunctionCallCall: o6, createFunctionApplyCall: _6, createArraySliceCall: Wh, createArrayConcatCall: Vh, createObjectDefinePropertyCall: u, createObjectGetOwnPropertyDescriptorCall: b, createReflectGetCall: O10, createReflectSetCall: j6, createPropertyDescriptor: re2, createCallBinding: Jt, createAssignmentTargetWrapper: Lt, inlineExpressions: At, getInternalName: Fn, getLocalName: di, getExportName: Ii, getDeclarationName: _n, getNamespaceMemberName: qa, getExternalModuleOrNamespaceExportName: Hh, restoreOuterExpressions: We2, restoreEnclosingLabel: $e2, createUseStrictPrologue: wn, copyPrologue: lp, copyStandardPrologue: Ua, copyCustomPrologue: up, ensureUseStrict: Qr2, liftToBlock: jc, mergeLexicalEnvironment: $h, updateModifiers: Kh };
            return c(Bv, (n9) => n9(Ye2)), Ye2;
            function Ne2(n9, o) {
              if (n9 === void 0 || n9 === Bt)
                n9 = [];
              else if (_s(n9)) {
                if (o === void 0 || n9.hasTrailingComma === o)
                  return n9.transformFlags === void 0 && E8(n9), Y3.attachNodeArrayDebugInfo(n9), n9;
                let k = n9.slice();
                return k.pos = n9.pos, k.end = n9.end, k.hasTrailingComma = o, k.transformFlags = n9.transformFlags, Y3.attachNodeArrayDebugInfo(k), k;
              }
              let l = n9.length, p = l >= 1 && l <= 4 ? n9.slice() : n9;
              return p.pos = -1, p.end = -1, p.hasTrailingComma = !!o, p.transformFlags = 0, E8(p), Y3.attachNodeArrayDebugInfo(p), p;
            }
            function oe2(n9) {
              return t6.createBaseNode(n9);
            }
            function Ve2(n9) {
              let o = oe2(n9);
              return o.symbol = void 0, o.localSymbol = void 0, o;
            }
            function pt2(n9, o) {
              return n9 !== o && (n9.typeArguments = o.typeArguments), r(n9, o);
            }
            function Gt(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = Ve2(8);
              return l.text = typeof n9 == "number" ? n9 + "" : n9, l.numericLiteralFlags = o, o & 384 && (l.transformFlags |= 1024), l;
            }
            function Nt(n9) {
              let o = In(9);
              return o.text = typeof n9 == "string" ? n9 : yv(n9) + "n", o.transformFlags |= 4, o;
            }
            function Xt(n9, o) {
              let l = Ve2(10);
              return l.text = n9, l.singleQuote = o, l;
            }
            function er2(n9, o, l) {
              let p = Xt(n9, o);
              return p.hasExtendedUnicodeEscape = l, l && (p.transformFlags |= 1024), p;
            }
            function Tn(n9) {
              let o = Xt(kf(n9), void 0);
              return o.textSourceNode = n9, o;
            }
            function Hr2(n9) {
              let o = In(13);
              return o.text = n9, o;
            }
            function Gi(n9, o) {
              switch (n9) {
                case 8:
                  return Gt(o, 0);
                case 9:
                  return Nt(o);
                case 10:
                  return er2(o, void 0);
                case 11:
                  return l_(o, false);
                case 12:
                  return l_(o, true);
                case 13:
                  return Hr2(o);
                case 14:
                  return Qs(n9, o, void 0, 0);
              }
            }
            function pn(n9) {
              let o = t6.createBaseIdentifierNode(79);
              return o.escapedText = n9, o.jsDoc = void 0, o.flowNode = void 0, o.symbol = void 0, o;
            }
            function fn(n9, o, l, p) {
              let k = pn(vi(n9));
              return setIdentifierAutoGenerate(k, { flags: o, id: Bl, prefix: l, suffix: p }), Bl++, k;
            }
            function Ut(n9, o, l) {
              o === void 0 && n9 && (o = _l(n9)), o === 79 && (o = void 0);
              let p = pn(vi(n9));
              return l && (p.flags |= 128), p.escapedText === "await" && (p.transformFlags |= 67108864), p.flags & 128 && (p.transformFlags |= 1024), p;
            }
            function kn(n9, o, l, p) {
              let k = 1;
              o && (k |= 8);
              let V = fn("", k, l, p);
              return n9 && n9(V), V;
            }
            function an(n9) {
              let o = 2;
              return n9 && (o |= 8), fn("", o, void 0, void 0);
            }
            function mr2(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0;
              return Y3.assert(!(o & 7), "Argument out of range: flags"), Y3.assert((o & 48) !== 32, "GeneratedIdentifierFlags.FileLevel cannot be set without also setting GeneratedIdentifierFlags.Optimistic"), fn(n9, 3 | o, l, p);
            }
            function $i(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0;
              Y3.assert(!(o & 7), "Argument out of range: flags");
              let k = n9 ? js(n9) ? bd(false, l, n9, p, qr2) : `generated@${getNodeId(n9)}` : "";
              (l || p) && (o |= 16);
              let V = fn(k, 4 | o, l, p);
              return V.original = n9, V;
            }
            function dn(n9) {
              let o = t6.createBasePrivateIdentifierNode(80);
              return o.escapedText = n9, o.transformFlags |= 16777216, o;
            }
            function Ur2(n9) {
              return Pn(n9, "#") || Y3.fail("First character of private identifier must be #: " + n9), dn(vi(n9));
            }
            function Gr2(n9, o, l, p) {
              let k = dn(vi(n9));
              return setIdentifierAutoGenerate(k, { flags: o, id: Bl, prefix: l, suffix: p }), Bl++, k;
            }
            function _r2(n9, o, l) {
              n9 && !Pn(n9, "#") && Y3.fail("First character of private identifier must be #: " + n9);
              let p = 8 | (n9 ? 3 : 1);
              return Gr2(n9 != null ? n9 : "", p, o, l);
            }
            function Sn(n9, o, l) {
              let p = js(n9) ? bd(true, o, n9, l, qr2) : `#generated@${getNodeId(n9)}`, V = Gr2(p, 4 | (o || l ? 16 : 0), o, l);
              return V.original = n9, V;
            }
            function In(n9) {
              return t6.createBaseTokenNode(n9);
            }
            function pr2(n9) {
              Y3.assert(n9 >= 0 && n9 <= 162, "Invalid token"), Y3.assert(n9 <= 14 || n9 >= 17, "Invalid token. Use 'createTemplateLiteralLikeNode' to create template literals."), Y3.assert(n9 <= 8 || n9 >= 14, "Invalid token. Use 'createLiteralLikeNode' to create literals."), Y3.assert(n9 !== 79, "Invalid token. Use 'createIdentifier' to create identifiers");
              let o = In(n9), l = 0;
              switch (n9) {
                case 132:
                  l = 384;
                  break;
                case 123:
                case 121:
                case 122:
                case 146:
                case 126:
                case 136:
                case 85:
                case 131:
                case 148:
                case 160:
                case 144:
                case 149:
                case 101:
                case 145:
                case 161:
                case 152:
                case 134:
                case 153:
                case 114:
                case 157:
                case 155:
                  l = 1;
                  break;
                case 106:
                  l = 134218752, o.flowNode = void 0;
                  break;
                case 124:
                  l = 1024;
                  break;
                case 127:
                  l = 16777216;
                  break;
                case 108:
                  l = 16384, o.flowNode = void 0;
                  break;
              }
              return l && (o.transformFlags |= l), o;
            }
            function Zt() {
              return pr2(106);
            }
            function Or2() {
              return pr2(108);
            }
            function Nn() {
              return pr2(104);
            }
            function ar2() {
              return pr2(110);
            }
            function oi() {
              return pr2(95);
            }
            function cr2(n9) {
              return pr2(n9);
            }
            function $r2(n9) {
              let o = [];
              return n9 & 1 && o.push(cr2(93)), n9 & 2 && o.push(cr2(136)), n9 & 1024 && o.push(cr2(88)), n9 & 2048 && o.push(cr2(85)), n9 & 4 && o.push(cr2(123)), n9 & 8 && o.push(cr2(121)), n9 & 16 && o.push(cr2(122)), n9 & 256 && o.push(cr2(126)), n9 & 32 && o.push(cr2(124)), n9 & 16384 && o.push(cr2(161)), n9 & 64 && o.push(cr2(146)), n9 & 128 && o.push(cr2(127)), n9 & 512 && o.push(cr2(132)), n9 & 32768 && o.push(cr2(101)), n9 & 65536 && o.push(cr2(145)), o.length ? o : void 0;
            }
            function hr2(n9, o) {
              let l = oe2(163);
              return l.left = n9, l.right = Qt(o), l.transformFlags |= ye(l.left) | ec(l.right), l.flowNode = void 0, l;
            }
            function On(n9, o, l) {
              return n9.left !== o || n9.right !== l ? r(hr2(o, l), n9) : n9;
            }
            function nr2(n9) {
              let o = oe2(164);
              return o.expression = s().parenthesizeExpressionOfComputedPropertyName(n9), o.transformFlags |= ye(o.expression) | 1024 | 131072, o;
            }
            function br2(n9, o) {
              return n9.expression !== o ? r(nr2(o), n9) : n9;
            }
            function Kr2(n9, o, l, p) {
              let k = Ve2(165);
              return k.modifiers = xt(n9), k.name = Qt(o), k.constraint = l, k.default = p, k.transformFlags = 1, k.expression = void 0, k.jsDoc = void 0, k;
            }
            function wa(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.name !== l || n9.constraint !== p || n9.default !== k ? r(Kr2(o, l, p, k), n9) : n9;
            }
            function $n(n9, o, l, p, k, V) {
              var we2, et;
              let ht = Ve2(166);
              return ht.modifiers = xt(n9), ht.dotDotDotToken = o, ht.name = Qt(l), ht.questionToken = p, ht.type = k, ht.initializer = Wa(V), Mf(ht.name) ? ht.transformFlags = 1 : ht.transformFlags = gt2(ht.modifiers) | ye(ht.dotDotDotToken) | ai(ht.name) | ye(ht.questionToken) | ye(ht.initializer) | (((we2 = ht.questionToken) != null ? we2 : ht.type) ? 1 : 0) | (((et = ht.dotDotDotToken) != null ? et : ht.initializer) ? 1024 : 0) | (Vn(ht.modifiers) & 16476 ? 8192 : 0), ht.jsDoc = void 0, ht;
            }
            function Ki(n9, o, l, p, k, V, we2) {
              return n9.modifiers !== o || n9.dotDotDotToken !== l || n9.name !== p || n9.questionToken !== k || n9.type !== V || n9.initializer !== we2 ? r($n(o, l, p, k, V, we2), n9) : n9;
            }
            function Mn(n9) {
              let o = oe2(167);
              return o.expression = s().parenthesizeLeftSideOfAccess(n9, false), o.transformFlags |= ye(o.expression) | 1 | 8192 | 33554432, o;
            }
            function _i(n9, o) {
              return n9.expression !== o ? r(Mn(o), n9) : n9;
            }
            function Ca(n9, o, l, p) {
              let k = Ve2(168);
              return k.modifiers = xt(n9), k.name = Qt(o), k.type = p, k.questionToken = l, k.transformFlags = 1, k.initializer = void 0, k.jsDoc = void 0, k;
            }
            function St(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.name !== l || n9.questionToken !== p || n9.type !== k ? ue2(Ca(o, l, p, k), n9) : n9;
            }
            function ue2(n9, o) {
              return n9 !== o && (n9.initializer = o.initializer), r(n9, o);
            }
            function He2(n9, o, l, p, k) {
              let V = Ve2(169);
              V.modifiers = xt(n9), V.name = Qt(o), V.questionToken = l && ql(l) ? l : void 0, V.exclamationToken = l && rd(l) ? l : void 0, V.type = p, V.initializer = Wa(k);
              let we2 = V.flags & 16777216 || Vn(V.modifiers) & 2;
              return V.transformFlags = gt2(V.modifiers) | ai(V.name) | ye(V.initializer) | (we2 || V.questionToken || V.exclamationToken || V.type ? 1 : 0) | (Ws(V.name) || Vn(V.modifiers) & 32 && V.initializer ? 8192 : 0) | 16777216, V.jsDoc = void 0, V;
            }
            function _t(n9, o, l, p, k, V) {
              return n9.modifiers !== o || n9.name !== l || n9.questionToken !== (p !== void 0 && ql(p) ? p : void 0) || n9.exclamationToken !== (p !== void 0 && rd(p) ? p : void 0) || n9.type !== k || n9.initializer !== V ? r(He2(o, l, p, k, V), n9) : n9;
            }
            function ft(n9, o, l, p, k, V) {
              let we2 = Ve2(170);
              return we2.modifiers = xt(n9), we2.name = Qt(o), we2.questionToken = l, we2.typeParameters = xt(p), we2.parameters = xt(k), we2.type = V, we2.transformFlags = 1, we2.jsDoc = void 0, we2.locals = void 0, we2.nextContainer = void 0, we2.typeArguments = void 0, we2;
            }
            function Kt(n9, o, l, p, k, V, we2) {
              return n9.modifiers !== o || n9.name !== l || n9.questionToken !== p || n9.typeParameters !== k || n9.parameters !== V || n9.type !== we2 ? pt2(ft(o, l, p, k, V, we2), n9) : n9;
            }
            function zt(n9, o, l, p, k, V, we2, et) {
              let ht = Ve2(171);
              if (ht.modifiers = xt(n9), ht.asteriskToken = o, ht.name = Qt(l), ht.questionToken = p, ht.exclamationToken = void 0, ht.typeParameters = xt(k), ht.parameters = Ne2(V), ht.type = we2, ht.body = et, !ht.body)
                ht.transformFlags = 1;
              else {
                let hn = Vn(ht.modifiers) & 512, Ni = !!ht.asteriskToken, ia = hn && Ni;
                ht.transformFlags = gt2(ht.modifiers) | ye(ht.asteriskToken) | ai(ht.name) | ye(ht.questionToken) | gt2(ht.typeParameters) | gt2(ht.parameters) | ye(ht.type) | ye(ht.body) & -67108865 | (ia ? 128 : hn ? 256 : Ni ? 2048 : 0) | (ht.questionToken || ht.typeParameters || ht.type ? 1 : 0) | 1024;
              }
              return ht.typeArguments = void 0, ht.jsDoc = void 0, ht.locals = void 0, ht.nextContainer = void 0, ht.flowNode = void 0, ht.endFlowNode = void 0, ht.returnFlowNode = void 0, ht;
            }
            function xe2(n9, o, l, p, k, V, we2, et, ht) {
              return n9.modifiers !== o || n9.asteriskToken !== l || n9.name !== p || n9.questionToken !== k || n9.typeParameters !== V || n9.parameters !== we2 || n9.type !== et || n9.body !== ht ? Le2(zt(o, l, p, k, V, we2, et, ht), n9) : n9;
            }
            function Le2(n9, o) {
              return n9 !== o && (n9.exclamationToken = o.exclamationToken), r(n9, o);
            }
            function Re2(n9) {
              let o = Ve2(172);
              return o.body = n9, o.transformFlags = ye(n9) | 16777216, o.modifiers = void 0, o.jsDoc = void 0, o.locals = void 0, o.nextContainer = void 0, o.endFlowNode = void 0, o.returnFlowNode = void 0, o;
            }
            function ot2(n9, o) {
              return n9.body !== o ? Ct(Re2(o), n9) : n9;
            }
            function Ct(n9, o) {
              return n9 !== o && (n9.modifiers = o.modifiers), r(n9, o);
            }
            function Mt(n9, o, l) {
              let p = Ve2(173);
              return p.modifiers = xt(n9), p.parameters = Ne2(o), p.body = l, p.transformFlags = gt2(p.modifiers) | gt2(p.parameters) | ye(p.body) & -67108865 | 1024, p.typeParameters = void 0, p.type = void 0, p.typeArguments = void 0, p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p.endFlowNode = void 0, p.returnFlowNode = void 0, p;
            }
            function It(n9, o, l, p) {
              return n9.modifiers !== o || n9.parameters !== l || n9.body !== p ? Mr2(Mt(o, l, p), n9) : n9;
            }
            function Mr2(n9, o) {
              return n9 !== o && (n9.typeParameters = o.typeParameters, n9.type = o.type), pt2(n9, o);
            }
            function gr2(n9, o, l, p, k) {
              let V = Ve2(174);
              return V.modifiers = xt(n9), V.name = Qt(o), V.parameters = Ne2(l), V.type = p, V.body = k, V.body ? V.transformFlags = gt2(V.modifiers) | ai(V.name) | gt2(V.parameters) | ye(V.type) | ye(V.body) & -67108865 | (V.type ? 1 : 0) : V.transformFlags = 1, V.typeArguments = void 0, V.typeParameters = void 0, V.jsDoc = void 0, V.locals = void 0, V.nextContainer = void 0, V.flowNode = void 0, V.endFlowNode = void 0, V.returnFlowNode = void 0, V;
            }
            function Ln(n9, o, l, p, k, V) {
              return n9.modifiers !== o || n9.name !== l || n9.parameters !== p || n9.type !== k || n9.body !== V ? ys(gr2(o, l, p, k, V), n9) : n9;
            }
            function ys(n9, o) {
              return n9 !== o && (n9.typeParameters = o.typeParameters), pt2(n9, o);
            }
            function ci(n9, o, l, p) {
              let k = Ve2(175);
              return k.modifiers = xt(n9), k.name = Qt(o), k.parameters = Ne2(l), k.body = p, k.body ? k.transformFlags = gt2(k.modifiers) | ai(k.name) | gt2(k.parameters) | ye(k.body) & -67108865 | (k.type ? 1 : 0) : k.transformFlags = 1, k.typeArguments = void 0, k.typeParameters = void 0, k.type = void 0, k.jsDoc = void 0, k.locals = void 0, k.nextContainer = void 0, k.flowNode = void 0, k.endFlowNode = void 0, k.returnFlowNode = void 0, k;
            }
            function Xi(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.name !== l || n9.parameters !== p || n9.body !== k ? Aa(ci(o, l, p, k), n9) : n9;
            }
            function Aa(n9, o) {
              return n9 !== o && (n9.typeParameters = o.typeParameters, n9.type = o.type), pt2(n9, o);
            }
            function vs(n9, o, l) {
              let p = Ve2(176);
              return p.typeParameters = xt(n9), p.parameters = xt(o), p.type = l, p.transformFlags = 1, p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p.typeArguments = void 0, p;
            }
            function $s(n9, o, l, p) {
              return n9.typeParameters !== o || n9.parameters !== l || n9.type !== p ? pt2(vs(o, l, p), n9) : n9;
            }
            function li(n9, o, l) {
              let p = Ve2(177);
              return p.typeParameters = xt(n9), p.parameters = xt(o), p.type = l, p.transformFlags = 1, p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p.typeArguments = void 0, p;
            }
            function Yi2(n9, o, l, p) {
              return n9.typeParameters !== o || n9.parameters !== l || n9.type !== p ? pt2(li(o, l, p), n9) : n9;
            }
            function Qi(n9, o, l) {
              let p = Ve2(178);
              return p.modifiers = xt(n9), p.parameters = xt(o), p.type = l, p.transformFlags = 1, p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p.typeArguments = void 0, p;
            }
            function bs(n9, o, l, p) {
              return n9.parameters !== l || n9.type !== p || n9.modifiers !== o ? pt2(Qi(o, l, p), n9) : n9;
            }
            function Ai(n9, o) {
              let l = oe2(201);
              return l.type = n9, l.literal = o, l.transformFlags = 1, l;
            }
            function xn(n9, o, l) {
              return n9.type !== o || n9.literal !== l ? r(Ai(o, l), n9) : n9;
            }
            function Dt(n9) {
              return pr2(n9);
            }
            function Pi(n9, o, l) {
              let p = oe2(179);
              return p.assertsModifier = n9, p.parameterName = Qt(o), p.type = l, p.transformFlags = 1, p;
            }
            function Z(n9, o, l, p) {
              return n9.assertsModifier !== o || n9.parameterName !== l || n9.type !== p ? r(Pi(o, l, p), n9) : n9;
            }
            function ie2(n9, o) {
              let l = oe2(180);
              return l.typeName = Qt(n9), l.typeArguments = o && s().parenthesizeTypeArguments(Ne2(o)), l.transformFlags = 1, l;
            }
            function U2(n9, o, l) {
              return n9.typeName !== o || n9.typeArguments !== l ? r(ie2(o, l), n9) : n9;
            }
            function L(n9, o, l) {
              let p = Ve2(181);
              return p.typeParameters = xt(n9), p.parameters = xt(o), p.type = l, p.transformFlags = 1, p.modifiers = void 0, p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p.typeArguments = void 0, p;
            }
            function fe2(n9, o, l, p) {
              return n9.typeParameters !== o || n9.parameters !== l || n9.type !== p ? T(L(o, l, p), n9) : n9;
            }
            function T(n9, o) {
              return n9 !== o && (n9.modifiers = o.modifiers), pt2(n9, o);
            }
            function it() {
              return arguments.length === 4 ? mt(...arguments) : arguments.length === 3 ? _e(...arguments) : Y3.fail("Incorrect number of arguments specified.");
            }
            function mt(n9, o, l, p) {
              let k = Ve2(182);
              return k.modifiers = xt(n9), k.typeParameters = xt(o), k.parameters = xt(l), k.type = p, k.transformFlags = 1, k.jsDoc = void 0, k.locals = void 0, k.nextContainer = void 0, k.typeArguments = void 0, k;
            }
            function _e(n9, o, l) {
              return mt(void 0, n9, o, l);
            }
            function Ge2() {
              return arguments.length === 5 ? bt(...arguments) : arguments.length === 4 ? jt(...arguments) : Y3.fail("Incorrect number of arguments specified.");
            }
            function bt(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.typeParameters !== l || n9.parameters !== p || n9.type !== k ? pt2(it(o, l, p, k), n9) : n9;
            }
            function jt(n9, o, l, p) {
              return bt(n9, n9.modifiers, o, l, p);
            }
            function Yt(n9, o) {
              let l = oe2(183);
              return l.exprName = n9, l.typeArguments = o && s().parenthesizeTypeArguments(o), l.transformFlags = 1, l;
            }
            function $t(n9, o, l) {
              return n9.exprName !== o || n9.typeArguments !== l ? r(Yt(o, l), n9) : n9;
            }
            function Wt(n9) {
              let o = Ve2(184);
              return o.members = Ne2(n9), o.transformFlags = 1, o;
            }
            function Xr(n9, o) {
              return n9.members !== o ? r(Wt(o), n9) : n9;
            }
            function Dr2(n9) {
              let o = oe2(185);
              return o.elementType = s().parenthesizeNonArrayTypeOfPostfixType(n9), o.transformFlags = 1, o;
            }
            function Lr(n9, o) {
              return n9.elementType !== o ? r(Dr2(o), n9) : n9;
            }
            function yr2(n9) {
              let o = oe2(186);
              return o.elements = Ne2(s().parenthesizeElementTypesOfTupleType(n9)), o.transformFlags = 1, o;
            }
            function Rn(n9, o) {
              return n9.elements !== o ? r(yr2(o), n9) : n9;
            }
            function wt(n9, o, l, p) {
              let k = Ve2(199);
              return k.dotDotDotToken = n9, k.name = o, k.questionToken = l, k.type = p, k.transformFlags = 1, k.jsDoc = void 0, k;
            }
            function Tr3(n9, o, l, p, k) {
              return n9.dotDotDotToken !== o || n9.name !== l || n9.questionToken !== p || n9.type !== k ? r(wt(o, l, p, k), n9) : n9;
            }
            function Tt(n9) {
              let o = oe2(187);
              return o.type = s().parenthesizeTypeOfOptionalType(n9), o.transformFlags = 1, o;
            }
            function kt(n9, o) {
              return n9.type !== o ? r(Tt(o), n9) : n9;
            }
            function de2(n9) {
              let o = oe2(188);
              return o.type = n9, o.transformFlags = 1, o;
            }
            function jn(n9, o) {
              return n9.type !== o ? r(de2(o), n9) : n9;
            }
            function Zi(n9, o, l) {
              let p = oe2(n9);
              return p.types = Ye2.createNodeArray(l(o)), p.transformFlags = 1, p;
            }
            function Pa(n9, o, l) {
              return n9.types !== o ? r(Zi(n9.kind, o, l), n9) : n9;
            }
            function e_(n9) {
              return Zi(189, n9, s().parenthesizeConstituentTypesOfUnionType);
            }
            function mc(n9, o) {
              return Pa(n9, o, s().parenthesizeConstituentTypesOfUnionType);
            }
            function Da(n9) {
              return Zi(190, n9, s().parenthesizeConstituentTypesOfIntersectionType);
            }
            function Ts(n9, o) {
              return Pa(n9, o, s().parenthesizeConstituentTypesOfIntersectionType);
            }
            function Ot(n9, o, l, p) {
              let k = oe2(191);
              return k.checkType = s().parenthesizeCheckTypeOfConditionalType(n9), k.extendsType = s().parenthesizeExtendsTypeOfConditionalType(o), k.trueType = l, k.falseType = p, k.transformFlags = 1, k.locals = void 0, k.nextContainer = void 0, k;
            }
            function dr2(n9, o, l, p, k) {
              return n9.checkType !== o || n9.extendsType !== l || n9.trueType !== p || n9.falseType !== k ? r(Ot(o, l, p, k), n9) : n9;
            }
            function Dd(n9) {
              let o = oe2(192);
              return o.typeParameter = n9, o.transformFlags = 1, o;
            }
            function ea(n9, o) {
              return n9.typeParameter !== o ? r(Dd(o), n9) : n9;
            }
            function kd(n9, o) {
              let l = oe2(200);
              return l.head = n9, l.templateSpans = Ne2(o), l.transformFlags = 1, l;
            }
            function sn(n9, o, l) {
              return n9.head !== o || n9.templateSpans !== l ? r(kd(o, l), n9) : n9;
            }
            function Id(n9, o, l, p) {
              let k = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, V = oe2(202);
              return V.argument = n9, V.assertions = o, V.qualifier = l, V.typeArguments = p && s().parenthesizeTypeArguments(p), V.isTypeOf = k, V.transformFlags = 1, V;
            }
            function ka(n9, o, l, p, k) {
              let V = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : n9.isTypeOf;
              return n9.argument !== o || n9.assertions !== l || n9.qualifier !== p || n9.typeArguments !== k || n9.isTypeOf !== V ? r(Id(o, l, p, k, V), n9) : n9;
            }
            function t_(n9) {
              let o = oe2(193);
              return o.type = n9, o.transformFlags = 1, o;
            }
            function En(n9, o) {
              return n9.type !== o ? r(t_(o), n9) : n9;
            }
            function Er2() {
              let n9 = oe2(194);
              return n9.transformFlags = 1, n9;
            }
            function Q2(n9, o) {
              let l = oe2(195);
              return l.operator = n9, l.type = n9 === 146 ? s().parenthesizeOperandOfReadonlyTypeOperator(o) : s().parenthesizeOperandOfTypeOperator(o), l.transformFlags = 1, l;
            }
            function Jn(n9, o) {
              return n9.type !== o ? r(Q2(n9.operator, o), n9) : n9;
            }
            function Ia(n9, o) {
              let l = oe2(196);
              return l.objectType = s().parenthesizeNonArrayTypeOfPostfixType(n9), l.indexType = o, l.transformFlags = 1, l;
            }
            function Ss(n9, o, l) {
              return n9.objectType !== o || n9.indexType !== l ? r(Ia(o, l), n9) : n9;
            }
            function hc(n9, o, l, p, k, V) {
              let we2 = Ve2(197);
              return we2.readonlyToken = n9, we2.typeParameter = o, we2.nameType = l, we2.questionToken = p, we2.type = k, we2.members = V && Ne2(V), we2.transformFlags = 1, we2.locals = void 0, we2.nextContainer = void 0, we2;
            }
            function wr2(n9, o, l, p, k, V, we2) {
              return n9.readonlyToken !== o || n9.typeParameter !== l || n9.nameType !== p || n9.questionToken !== k || n9.type !== V || n9.members !== we2 ? r(hc(o, l, p, k, V, we2), n9) : n9;
            }
            function zr2(n9) {
              let o = oe2(198);
              return o.literal = n9, o.transformFlags = 1, o;
            }
            function xs(n9, o) {
              return n9.literal !== o ? r(zr2(o), n9) : n9;
            }
            function Nd(n9) {
              let o = oe2(203);
              return o.elements = Ne2(n9), o.transformFlags |= gt2(o.elements) | 1024 | 524288, o.transformFlags & 32768 && (o.transformFlags |= 65664), o;
            }
            function R2(n9, o) {
              return n9.elements !== o ? r(Nd(o), n9) : n9;
            }
            function Es(n9) {
              let o = oe2(204);
              return o.elements = Ne2(n9), o.transformFlags |= gt2(o.elements) | 1024 | 524288, o;
            }
            function j2(n9, o) {
              return n9.elements !== o ? r(Es(o), n9) : n9;
            }
            function gc(n9, o, l, p) {
              let k = Ve2(205);
              return k.dotDotDotToken = n9, k.propertyName = Qt(o), k.name = Qt(l), k.initializer = Wa(p), k.transformFlags |= ye(k.dotDotDotToken) | ai(k.propertyName) | ai(k.name) | ye(k.initializer) | (k.dotDotDotToken ? 32768 : 0) | 1024, k.flowNode = void 0, k;
            }
            function Ks(n9, o, l, p, k) {
              return n9.propertyName !== l || n9.dotDotDotToken !== o || n9.name !== p || n9.initializer !== k ? r(gc(o, l, p, k), n9) : n9;
            }
            function uu(n9, o) {
              let l = oe2(206), p = n9 && Cn(n9), k = Ne2(n9, p && cd(p) ? true : void 0);
              return l.elements = s().parenthesizeExpressionsOfCommaDelimitedList(k), l.multiLine = o, l.transformFlags |= gt2(l.elements), l;
            }
            function Od(n9, o) {
              return n9.elements !== o ? r(uu(o, n9.multiLine), n9) : n9;
            }
            function r_(n9, o) {
              let l = Ve2(207);
              return l.properties = Ne2(n9), l.multiLine = o, l.transformFlags |= gt2(l.properties), l.jsDoc = void 0, l;
            }
            function J22(n9, o) {
              return n9.properties !== o ? r(r_(o, n9.multiLine), n9) : n9;
            }
            function Md(n9, o, l) {
              let p = Ve2(208);
              return p.expression = n9, p.questionDotToken = o, p.name = l, p.transformFlags = ye(p.expression) | ye(p.questionDotToken) | (yt(p.name) ? ec(p.name) : ye(p.name) | 536870912), p.jsDoc = void 0, p.flowNode = void 0, p;
            }
            function ta(n9, o) {
              let l = Md(s().parenthesizeLeftSideOfAccess(n9, false), void 0, Qt(o));
              return nd(n9) && (l.transformFlags |= 384), l;
            }
            function Ld(n9, o, l) {
              return LS(n9) ? Rd(n9, o, n9.questionDotToken, ti(l, yt)) : n9.expression !== o || n9.name !== l ? r(ta(o, l), n9) : n9;
            }
            function Xs(n9, o, l) {
              let p = Md(s().parenthesizeLeftSideOfAccess(n9, true), o, Qt(l));
              return p.flags |= 32, p.transformFlags |= 32, p;
            }
            function Rd(n9, o, l, p) {
              return Y3.assert(!!(n9.flags & 32), "Cannot update a PropertyAccessExpression using updatePropertyAccessChain. Use updatePropertyAccess instead."), n9.expression !== o || n9.questionDotToken !== l || n9.name !== p ? r(Xs(o, l, p), n9) : n9;
            }
            function yc(n9, o, l) {
              let p = Ve2(209);
              return p.expression = n9, p.questionDotToken = o, p.argumentExpression = l, p.transformFlags |= ye(p.expression) | ye(p.questionDotToken) | ye(p.argumentExpression), p.jsDoc = void 0, p.flowNode = void 0, p;
            }
            function pu(n9, o) {
              let l = yc(s().parenthesizeLeftSideOfAccess(n9, false), void 0, za(o));
              return nd(n9) && (l.transformFlags |= 384), l;
            }
            function F22(n9, o, l) {
              return RS(n9) ? jd(n9, o, n9.questionDotToken, l) : n9.expression !== o || n9.argumentExpression !== l ? r(pu(o, l), n9) : n9;
            }
            function fu(n9, o, l) {
              let p = yc(s().parenthesizeLeftSideOfAccess(n9, true), o, za(l));
              return p.flags |= 32, p.transformFlags |= 32, p;
            }
            function jd(n9, o, l, p) {
              return Y3.assert(!!(n9.flags & 32), "Cannot update a ElementAccessExpression using updateElementAccessChain. Use updateElementAccess instead."), n9.expression !== o || n9.questionDotToken !== l || n9.argumentExpression !== p ? r(fu(o, l, p), n9) : n9;
            }
            function Jd(n9, o, l, p) {
              let k = Ve2(210);
              return k.expression = n9, k.questionDotToken = o, k.typeArguments = l, k.arguments = p, k.transformFlags |= ye(k.expression) | ye(k.questionDotToken) | gt2(k.typeArguments) | gt2(k.arguments), k.typeArguments && (k.transformFlags |= 1), Sf(k.expression) && (k.transformFlags |= 16384), k;
            }
            function Na(n9, o, l) {
              let p = Jd(s().parenthesizeLeftSideOfAccess(n9, false), void 0, xt(o), s().parenthesizeExpressionsOfCommaDelimitedList(Ne2(l)));
              return M8(p.expression) && (p.transformFlags |= 8388608), p;
            }
            function B2(n9, o, l, p) {
              return Cy(n9) ? Kn(n9, o, n9.questionDotToken, l, p) : n9.expression !== o || n9.typeArguments !== l || n9.arguments !== p ? r(Na(o, l, p), n9) : n9;
            }
            function du(n9, o, l, p) {
              let k = Jd(s().parenthesizeLeftSideOfAccess(n9, true), o, xt(l), s().parenthesizeExpressionsOfCommaDelimitedList(Ne2(p)));
              return k.flags |= 32, k.transformFlags |= 32, k;
            }
            function Kn(n9, o, l, p, k) {
              return Y3.assert(!!(n9.flags & 32), "Cannot update a CallExpression using updateCallChain. Use updateCall instead."), n9.expression !== o || n9.questionDotToken !== l || n9.typeArguments !== p || n9.arguments !== k ? r(du(o, l, p, k), n9) : n9;
            }
            function vc(n9, o, l) {
              let p = Ve2(211);
              return p.expression = s().parenthesizeExpressionOfNew(n9), p.typeArguments = xt(o), p.arguments = l ? s().parenthesizeExpressionsOfCommaDelimitedList(l) : void 0, p.transformFlags |= ye(p.expression) | gt2(p.typeArguments) | gt2(p.arguments) | 32, p.typeArguments && (p.transformFlags |= 1), p;
            }
            function mu(n9, o, l, p) {
              return n9.expression !== o || n9.typeArguments !== l || n9.arguments !== p ? r(vc(o, l, p), n9) : n9;
            }
            function hu(n9, o, l) {
              let p = oe2(212);
              return p.tag = s().parenthesizeLeftSideOfAccess(n9, false), p.typeArguments = xt(o), p.template = l, p.transformFlags |= ye(p.tag) | gt2(p.typeArguments) | ye(p.template) | 1024, p.typeArguments && (p.transformFlags |= 1), w4(p.template) && (p.transformFlags |= 128), p;
            }
            function q22(n9, o, l, p) {
              return n9.tag !== o || n9.typeArguments !== l || n9.template !== p ? r(hu(o, l, p), n9) : n9;
            }
            function Fd(n9, o) {
              let l = oe2(213);
              return l.expression = s().parenthesizeOperandOfPrefixUnary(o), l.type = n9, l.transformFlags |= ye(l.expression) | ye(l.type) | 1, l;
            }
            function Bd(n9, o, l) {
              return n9.type !== o || n9.expression !== l ? r(Fd(o, l), n9) : n9;
            }
            function gu(n9) {
              let o = oe2(214);
              return o.expression = n9, o.transformFlags = ye(o.expression), o.jsDoc = void 0, o;
            }
            function qd(n9, o) {
              return n9.expression !== o ? r(gu(o), n9) : n9;
            }
            function yu(n9, o, l, p, k, V, we2) {
              let et = Ve2(215);
              et.modifiers = xt(n9), et.asteriskToken = o, et.name = Qt(l), et.typeParameters = xt(p), et.parameters = Ne2(k), et.type = V, et.body = we2;
              let ht = Vn(et.modifiers) & 512, hn = !!et.asteriskToken, Ni = ht && hn;
              return et.transformFlags = gt2(et.modifiers) | ye(et.asteriskToken) | ai(et.name) | gt2(et.typeParameters) | gt2(et.parameters) | ye(et.type) | ye(et.body) & -67108865 | (Ni ? 128 : ht ? 256 : hn ? 2048 : 0) | (et.typeParameters || et.type ? 1 : 0) | 4194304, et.typeArguments = void 0, et.jsDoc = void 0, et.locals = void 0, et.nextContainer = void 0, et.flowNode = void 0, et.endFlowNode = void 0, et.returnFlowNode = void 0, et;
            }
            function Ud(n9, o, l, p, k, V, we2, et) {
              return n9.name !== p || n9.modifiers !== o || n9.asteriskToken !== l || n9.typeParameters !== k || n9.parameters !== V || n9.type !== we2 || n9.body !== et ? pt2(yu(o, l, p, k, V, we2, et), n9) : n9;
            }
            function vu(n9, o, l, p, k, V) {
              let we2 = Ve2(216);
              we2.modifiers = xt(n9), we2.typeParameters = xt(o), we2.parameters = Ne2(l), we2.type = p, we2.equalsGreaterThanToken = k != null ? k : pr2(38), we2.body = s().parenthesizeConciseBodyOfArrowFunction(V);
              let et = Vn(we2.modifiers) & 512;
              return we2.transformFlags = gt2(we2.modifiers) | gt2(we2.typeParameters) | gt2(we2.parameters) | ye(we2.type) | ye(we2.equalsGreaterThanToken) | ye(we2.body) & -67108865 | (we2.typeParameters || we2.type ? 1 : 0) | (et ? 16640 : 0) | 1024, we2.typeArguments = void 0, we2.jsDoc = void 0, we2.locals = void 0, we2.nextContainer = void 0, we2.flowNode = void 0, we2.endFlowNode = void 0, we2.returnFlowNode = void 0, we2;
            }
            function zd(n9, o, l, p, k, V, we2) {
              return n9.modifiers !== o || n9.typeParameters !== l || n9.parameters !== p || n9.type !== k || n9.equalsGreaterThanToken !== V || n9.body !== we2 ? pt2(vu(o, l, p, k, V, we2), n9) : n9;
            }
            function bu(n9) {
              let o = oe2(217);
              return o.expression = s().parenthesizeOperandOfPrefixUnary(n9), o.transformFlags |= ye(o.expression), o;
            }
            function U22(n9, o) {
              return n9.expression !== o ? r(bu(o), n9) : n9;
            }
            function mn(n9) {
              let o = oe2(218);
              return o.expression = s().parenthesizeOperandOfPrefixUnary(n9), o.transformFlags |= ye(o.expression), o;
            }
            function z2(n9, o) {
              return n9.expression !== o ? r(mn(o), n9) : n9;
            }
            function ui(n9) {
              let o = oe2(219);
              return o.expression = s().parenthesizeOperandOfPrefixUnary(n9), o.transformFlags |= ye(o.expression), o;
            }
            function W2(n9, o) {
              return n9.expression !== o ? r(ui(o), n9) : n9;
            }
            function Oa(n9) {
              let o = oe2(220);
              return o.expression = s().parenthesizeOperandOfPrefixUnary(n9), o.transformFlags |= ye(o.expression) | 256 | 128 | 2097152, o;
            }
            function Ys(n9, o) {
              return n9.expression !== o ? r(Oa(o), n9) : n9;
            }
            function Tu(n9, o) {
              let l = oe2(221);
              return l.operator = n9, l.operand = s().parenthesizeOperandOfPrefixUnary(o), l.transformFlags |= ye(l.operand), (n9 === 45 || n9 === 46) && yt(l.operand) && !cs(l.operand) && !E2(l.operand) && (l.transformFlags |= 268435456), l;
            }
            function bc(n9, o) {
              return n9.operand !== o ? r(Tu(n9.operator, o), n9) : n9;
            }
            function Su(n9, o) {
              let l = oe2(222);
              return l.operator = o, l.operand = s().parenthesizeOperandOfPostfixUnary(n9), l.transformFlags |= ye(l.operand), yt(l.operand) && !cs(l.operand) && !E2(l.operand) && (l.transformFlags |= 268435456), l;
            }
            function Wd(n9, o) {
              return n9.operand !== o ? r(Su(o, n9.operator), n9) : n9;
            }
            function xu(n9, o, l) {
              let p = Ve2(223), k = c6(o), V = k.kind;
              return p.left = s().parenthesizeLeftSideOfBinary(V, n9), p.operatorToken = k, p.right = s().parenthesizeRightSideOfBinary(V, p.left, l), p.transformFlags |= ye(p.left) | ye(p.operatorToken) | ye(p.right), V === 60 ? p.transformFlags |= 32 : V === 63 ? Hs(p.left) ? p.transformFlags |= 5248 | Vd(p.left) : Yl(p.left) && (p.transformFlags |= 5120 | Vd(p.left)) : V === 42 || V === 67 ? p.transformFlags |= 512 : jf(V) && (p.transformFlags |= 16), V === 101 && vn(p.left) && (p.transformFlags |= 536870912), p.jsDoc = void 0, p;
            }
            function Vd(n9) {
              return A2(n9) ? 65536 : 0;
            }
            function V2(n9, o, l, p) {
              return n9.left !== o || n9.operatorToken !== l || n9.right !== p ? r(xu(o, l, p), n9) : n9;
            }
            function Eu(n9, o, l, p, k) {
              let V = oe2(224);
              return V.condition = s().parenthesizeConditionOfConditionalExpression(n9), V.questionToken = o != null ? o : pr2(57), V.whenTrue = s().parenthesizeBranchOfConditionalExpression(l), V.colonToken = p != null ? p : pr2(58), V.whenFalse = s().parenthesizeBranchOfConditionalExpression(k), V.transformFlags |= ye(V.condition) | ye(V.questionToken) | ye(V.whenTrue) | ye(V.colonToken) | ye(V.whenFalse), V;
            }
            function H2(n9, o, l, p, k, V) {
              return n9.condition !== o || n9.questionToken !== l || n9.whenTrue !== p || n9.colonToken !== k || n9.whenFalse !== V ? r(Eu(o, l, p, k, V), n9) : n9;
            }
            function Di(n9, o) {
              let l = oe2(225);
              return l.head = n9, l.templateSpans = Ne2(o), l.transformFlags |= ye(l.head) | gt2(l.templateSpans) | 1024, l;
            }
            function Hd(n9, o, l) {
              return n9.head !== o || n9.templateSpans !== l ? r(Di(o, l), n9) : n9;
            }
            function Tc(n9, o, l) {
              let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
              Y3.assert(!(p & -2049), "Unsupported template flags.");
              let k;
              if (l !== void 0 && l !== o && (k = BL(n9, l), typeof k == "object"))
                return Y3.fail("Invalid raw text");
              if (o === void 0) {
                if (k === void 0)
                  return Y3.fail("Arguments 'text' and 'rawText' may not both be undefined.");
                o = k;
              } else
                k !== void 0 && Y3.assert(o === k, "Expected argument 'text' to be the normalized (i.e. 'cooked') version of argument 'rawText'.");
              return o;
            }
            function Gd(n9) {
              let o = 1024;
              return n9 && (o |= 128), o;
            }
            function n_(n9, o, l, p) {
              let k = In(n9);
              return k.text = o, k.rawText = l, k.templateFlags = p & 2048, k.transformFlags = Gd(k.templateFlags), k;
            }
            function wu(n9, o, l, p) {
              let k = Ve2(n9);
              return k.text = o, k.rawText = l, k.templateFlags = p & 2048, k.transformFlags = Gd(k.templateFlags), k;
            }
            function Qs(n9, o, l, p) {
              return n9 === 14 ? wu(n9, o, l, p) : n_(n9, o, l, p);
            }
            function Sc(n9, o, l) {
              return n9 = Tc(15, n9, o, l), Qs(15, n9, o, l);
            }
            function Cu(n9, o, l) {
              return n9 = Tc(15, n9, o, l), Qs(16, n9, o, l);
            }
            function G22(n9, o, l) {
              return n9 = Tc(15, n9, o, l), Qs(17, n9, o, l);
            }
            function $d(n9, o, l) {
              return n9 = Tc(15, n9, o, l), wu(14, n9, o, l);
            }
            function Kd(n9, o) {
              Y3.assert(!n9 || !!o, "A `YieldExpression` with an asteriskToken must have an expression.");
              let l = oe2(226);
              return l.expression = o && s().parenthesizeExpressionForDisallowedComma(o), l.asteriskToken = n9, l.transformFlags |= ye(l.expression) | ye(l.asteriskToken) | 1024 | 128 | 1048576, l;
            }
            function $2(n9, o, l) {
              return n9.expression !== l || n9.asteriskToken !== o ? r(Kd(o, l), n9) : n9;
            }
            function Xd(n9) {
              let o = oe2(227);
              return o.expression = s().parenthesizeExpressionForDisallowedComma(n9), o.transformFlags |= ye(o.expression) | 1024 | 32768, o;
            }
            function K2(n9, o) {
              return n9.expression !== o ? r(Xd(o), n9) : n9;
            }
            function Yd(n9, o, l, p, k) {
              let V = Ve2(228);
              return V.modifiers = xt(n9), V.name = Qt(o), V.typeParameters = xt(l), V.heritageClauses = xt(p), V.members = Ne2(k), V.transformFlags |= gt2(V.modifiers) | ai(V.name) | gt2(V.typeParameters) | gt2(V.heritageClauses) | gt2(V.members) | (V.typeParameters ? 1 : 0) | 1024, V.jsDoc = void 0, V;
            }
            function xc(n9, o, l, p, k, V) {
              return n9.modifiers !== o || n9.name !== l || n9.typeParameters !== p || n9.heritageClauses !== k || n9.members !== V ? r(Yd(o, l, p, k, V), n9) : n9;
            }
            function X22() {
              return oe2(229);
            }
            function Qd(n9, o) {
              let l = oe2(230);
              return l.expression = s().parenthesizeLeftSideOfAccess(n9, false), l.typeArguments = o && s().parenthesizeTypeArguments(o), l.transformFlags |= ye(l.expression) | gt2(l.typeArguments) | 1024, l;
            }
            function Xn(n9, o, l) {
              return n9.expression !== o || n9.typeArguments !== l ? r(Qd(o, l), n9) : n9;
            }
            function Ec(n9, o) {
              let l = oe2(231);
              return l.expression = n9, l.type = o, l.transformFlags |= ye(l.expression) | ye(l.type) | 1, l;
            }
            function Zd(n9, o, l) {
              return n9.expression !== o || n9.type !== l ? r(Ec(o, l), n9) : n9;
            }
            function em(n9) {
              let o = oe2(232);
              return o.expression = s().parenthesizeLeftSideOfAccess(n9, false), o.transformFlags |= ye(o.expression) | 1, o;
            }
            function Au(n9, o) {
              return JS(n9) ? rm(n9, o) : n9.expression !== o ? r(em(o), n9) : n9;
            }
            function tm(n9, o) {
              let l = oe2(235);
              return l.expression = n9, l.type = o, l.transformFlags |= ye(l.expression) | ye(l.type) | 1, l;
            }
            function Pu(n9, o, l) {
              return n9.expression !== o || n9.type !== l ? r(tm(o, l), n9) : n9;
            }
            function pi(n9) {
              let o = oe2(232);
              return o.flags |= 32, o.expression = s().parenthesizeLeftSideOfAccess(n9, true), o.transformFlags |= ye(o.expression) | 1, o;
            }
            function rm(n9, o) {
              return Y3.assert(!!(n9.flags & 32), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead."), n9.expression !== o ? r(pi(o), n9) : n9;
            }
            function wc(n9, o) {
              let l = oe2(233);
              switch (l.keywordToken = n9, l.name = o, l.transformFlags |= ye(l.name), n9) {
                case 103:
                  l.transformFlags |= 1024;
                  break;
                case 100:
                  l.transformFlags |= 4;
                  break;
                default:
                  return Y3.assertNever(n9);
              }
              return l.flowNode = void 0, l;
            }
            function ra(n9, o) {
              return n9.name !== o ? r(wc(n9.keywordToken, o), n9) : n9;
            }
            function i_(n9, o) {
              let l = oe2(236);
              return l.expression = n9, l.literal = o, l.transformFlags |= ye(l.expression) | ye(l.literal) | 1024, l;
            }
            function nm(n9, o, l) {
              return n9.expression !== o || n9.literal !== l ? r(i_(o, l), n9) : n9;
            }
            function im() {
              let n9 = oe2(237);
              return n9.transformFlags |= 1024, n9;
            }
            function Zs(n9, o) {
              let l = oe2(238);
              return l.statements = Ne2(n9), l.multiLine = o, l.transformFlags |= gt2(l.statements), l.jsDoc = void 0, l.locals = void 0, l.nextContainer = void 0, l;
            }
            function am(n9, o) {
              return n9.statements !== o ? r(Zs(o, n9.multiLine), n9) : n9;
            }
            function sm(n9, o) {
              let l = oe2(240);
              return l.modifiers = xt(n9), l.declarationList = ir2(o) ? Ru(o) : o, l.transformFlags |= gt2(l.modifiers) | ye(l.declarationList), Vn(l.modifiers) & 2 && (l.transformFlags = 1), l.jsDoc = void 0, l.flowNode = void 0, l;
            }
            function om(n9, o, l) {
              return n9.modifiers !== o || n9.declarationList !== l ? r(sm(o, l), n9) : n9;
            }
            function Du() {
              let n9 = oe2(239);
              return n9.jsDoc = void 0, n9;
            }
            function a_(n9) {
              let o = oe2(241);
              return o.expression = s().parenthesizeExpressionOfExpressionStatement(n9), o.transformFlags |= ye(o.expression), o.jsDoc = void 0, o.flowNode = void 0, o;
            }
            function Y22(n9, o) {
              return n9.expression !== o ? r(a_(o), n9) : n9;
            }
            function ku(n9, o, l) {
              let p = oe2(242);
              return p.expression = n9, p.thenStatement = Yn(o), p.elseStatement = Yn(l), p.transformFlags |= ye(p.expression) | ye(p.thenStatement) | ye(p.elseStatement), p.jsDoc = void 0, p.flowNode = void 0, p;
            }
            function Q22(n9, o, l, p) {
              return n9.expression !== o || n9.thenStatement !== l || n9.elseStatement !== p ? r(ku(o, l, p), n9) : n9;
            }
            function Iu(n9, o) {
              let l = oe2(243);
              return l.statement = Yn(n9), l.expression = o, l.transformFlags |= ye(l.statement) | ye(l.expression), l.jsDoc = void 0, l.flowNode = void 0, l;
            }
            function Z2(n9, o, l) {
              return n9.statement !== o || n9.expression !== l ? r(Iu(o, l), n9) : n9;
            }
            function _m(n9, o) {
              let l = oe2(244);
              return l.expression = n9, l.statement = Yn(o), l.transformFlags |= ye(l.expression) | ye(l.statement), l.jsDoc = void 0, l.flowNode = void 0, l;
            }
            function eb(n9, o, l) {
              return n9.expression !== o || n9.statement !== l ? r(_m(o, l), n9) : n9;
            }
            function Nu(n9, o, l, p) {
              let k = oe2(245);
              return k.initializer = n9, k.condition = o, k.incrementor = l, k.statement = Yn(p), k.transformFlags |= ye(k.initializer) | ye(k.condition) | ye(k.incrementor) | ye(k.statement), k.jsDoc = void 0, k.locals = void 0, k.nextContainer = void 0, k.flowNode = void 0, k;
            }
            function cm(n9, o, l, p, k) {
              return n9.initializer !== o || n9.condition !== l || n9.incrementor !== p || n9.statement !== k ? r(Nu(o, l, p, k), n9) : n9;
            }
            function lm(n9, o, l) {
              let p = oe2(246);
              return p.initializer = n9, p.expression = o, p.statement = Yn(l), p.transformFlags |= ye(p.initializer) | ye(p.expression) | ye(p.statement), p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p.flowNode = void 0, p;
            }
            function tb(n9, o, l, p) {
              return n9.initializer !== o || n9.expression !== l || n9.statement !== p ? r(lm(o, l, p), n9) : n9;
            }
            function um(n9, o, l, p) {
              let k = oe2(247);
              return k.awaitModifier = n9, k.initializer = o, k.expression = s().parenthesizeExpressionForDisallowedComma(l), k.statement = Yn(p), k.transformFlags |= ye(k.awaitModifier) | ye(k.initializer) | ye(k.expression) | ye(k.statement) | 1024, n9 && (k.transformFlags |= 128), k.jsDoc = void 0, k.locals = void 0, k.nextContainer = void 0, k.flowNode = void 0, k;
            }
            function rb(n9, o, l, p, k) {
              return n9.awaitModifier !== o || n9.initializer !== l || n9.expression !== p || n9.statement !== k ? r(um(o, l, p, k), n9) : n9;
            }
            function pm(n9) {
              let o = oe2(248);
              return o.label = Qt(n9), o.transformFlags |= ye(o.label) | 4194304, o.jsDoc = void 0, o.flowNode = void 0, o;
            }
            function fm(n9, o) {
              return n9.label !== o ? r(pm(o), n9) : n9;
            }
            function Ou(n9) {
              let o = oe2(249);
              return o.label = Qt(n9), o.transformFlags |= ye(o.label) | 4194304, o.jsDoc = void 0, o.flowNode = void 0, o;
            }
            function dm(n9, o) {
              return n9.label !== o ? r(Ou(o), n9) : n9;
            }
            function mm(n9) {
              let o = oe2(250);
              return o.expression = n9, o.transformFlags |= ye(o.expression) | 128 | 4194304, o.jsDoc = void 0, o.flowNode = void 0, o;
            }
            function nb(n9, o) {
              return n9.expression !== o ? r(mm(o), n9) : n9;
            }
            function Mu(n9, o) {
              let l = oe2(251);
              return l.expression = n9, l.statement = Yn(o), l.transformFlags |= ye(l.expression) | ye(l.statement), l.jsDoc = void 0, l.flowNode = void 0, l;
            }
            function hm(n9, o, l) {
              return n9.expression !== o || n9.statement !== l ? r(Mu(o, l), n9) : n9;
            }
            function Lu(n9, o) {
              let l = oe2(252);
              return l.expression = s().parenthesizeExpressionForDisallowedComma(n9), l.caseBlock = o, l.transformFlags |= ye(l.expression) | ye(l.caseBlock), l.jsDoc = void 0, l.flowNode = void 0, l.possiblyExhaustive = false, l;
            }
            function eo(n9, o, l) {
              return n9.expression !== o || n9.caseBlock !== l ? r(Lu(o, l), n9) : n9;
            }
            function gm(n9, o) {
              let l = oe2(253);
              return l.label = Qt(n9), l.statement = Yn(o), l.transformFlags |= ye(l.label) | ye(l.statement), l.jsDoc = void 0, l.flowNode = void 0, l;
            }
            function ym(n9, o, l) {
              return n9.label !== o || n9.statement !== l ? r(gm(o, l), n9) : n9;
            }
            function vm(n9) {
              let o = oe2(254);
              return o.expression = n9, o.transformFlags |= ye(o.expression), o.jsDoc = void 0, o.flowNode = void 0, o;
            }
            function ib(n9, o) {
              return n9.expression !== o ? r(vm(o), n9) : n9;
            }
            function bm(n9, o, l) {
              let p = oe2(255);
              return p.tryBlock = n9, p.catchClause = o, p.finallyBlock = l, p.transformFlags |= ye(p.tryBlock) | ye(p.catchClause) | ye(p.finallyBlock), p.jsDoc = void 0, p.flowNode = void 0, p;
            }
            function ab(n9, o, l, p) {
              return n9.tryBlock !== o || n9.catchClause !== l || n9.finallyBlock !== p ? r(bm(o, l, p), n9) : n9;
            }
            function Tm() {
              let n9 = oe2(256);
              return n9.jsDoc = void 0, n9.flowNode = void 0, n9;
            }
            function Cc(n9, o, l, p) {
              var k;
              let V = Ve2(257);
              return V.name = Qt(n9), V.exclamationToken = o, V.type = l, V.initializer = Wa(p), V.transformFlags |= ai(V.name) | ye(V.initializer) | (((k = V.exclamationToken) != null ? k : V.type) ? 1 : 0), V.jsDoc = void 0, V;
            }
            function Sm(n9, o, l, p, k) {
              return n9.name !== o || n9.type !== p || n9.exclamationToken !== l || n9.initializer !== k ? r(Cc(o, l, p, k), n9) : n9;
            }
            function Ru(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = oe2(258);
              return l.flags |= o & 3, l.declarations = Ne2(n9), l.transformFlags |= gt2(l.declarations) | 4194304, o & 3 && (l.transformFlags |= 263168), l;
            }
            function sb(n9, o) {
              return n9.declarations !== o ? r(Ru(o, n9.flags), n9) : n9;
            }
            function xm(n9, o, l, p, k, V, we2) {
              let et = Ve2(259);
              if (et.modifiers = xt(n9), et.asteriskToken = o, et.name = Qt(l), et.typeParameters = xt(p), et.parameters = Ne2(k), et.type = V, et.body = we2, !et.body || Vn(et.modifiers) & 2)
                et.transformFlags = 1;
              else {
                let ht = Vn(et.modifiers) & 512, hn = !!et.asteriskToken, Ni = ht && hn;
                et.transformFlags = gt2(et.modifiers) | ye(et.asteriskToken) | ai(et.name) | gt2(et.typeParameters) | gt2(et.parameters) | ye(et.type) | ye(et.body) & -67108865 | (Ni ? 128 : ht ? 256 : hn ? 2048 : 0) | (et.typeParameters || et.type ? 1 : 0) | 4194304;
              }
              return et.typeArguments = void 0, et.jsDoc = void 0, et.locals = void 0, et.nextContainer = void 0, et.endFlowNode = void 0, et.returnFlowNode = void 0, et;
            }
            function ju(n9, o, l, p, k, V, we2, et) {
              return n9.modifiers !== o || n9.asteriskToken !== l || n9.name !== p || n9.typeParameters !== k || n9.parameters !== V || n9.type !== we2 || n9.body !== et ? ob(xm(o, l, p, k, V, we2, et), n9) : n9;
            }
            function ob(n9, o) {
              return n9 !== o && n9.modifiers === o.modifiers && (n9.modifiers = o.modifiers), pt2(n9, o);
            }
            function Em(n9, o, l, p, k) {
              let V = Ve2(260);
              return V.modifiers = xt(n9), V.name = Qt(o), V.typeParameters = xt(l), V.heritageClauses = xt(p), V.members = Ne2(k), Vn(V.modifiers) & 2 ? V.transformFlags = 1 : (V.transformFlags |= gt2(V.modifiers) | ai(V.name) | gt2(V.typeParameters) | gt2(V.heritageClauses) | gt2(V.members) | (V.typeParameters ? 1 : 0) | 1024, V.transformFlags & 8192 && (V.transformFlags |= 1)), V.jsDoc = void 0, V;
            }
            function Ju(n9, o, l, p, k, V) {
              return n9.modifiers !== o || n9.name !== l || n9.typeParameters !== p || n9.heritageClauses !== k || n9.members !== V ? r(Em(o, l, p, k, V), n9) : n9;
            }
            function wm(n9, o, l, p, k) {
              let V = Ve2(261);
              return V.modifiers = xt(n9), V.name = Qt(o), V.typeParameters = xt(l), V.heritageClauses = xt(p), V.members = Ne2(k), V.transformFlags = 1, V.jsDoc = void 0, V;
            }
            function Cm(n9, o, l, p, k, V) {
              return n9.modifiers !== o || n9.name !== l || n9.typeParameters !== p || n9.heritageClauses !== k || n9.members !== V ? r(wm(o, l, p, k, V), n9) : n9;
            }
            function sr2(n9, o, l, p) {
              let k = Ve2(262);
              return k.modifiers = xt(n9), k.name = Qt(o), k.typeParameters = xt(l), k.type = p, k.transformFlags = 1, k.jsDoc = void 0, k.locals = void 0, k.nextContainer = void 0, k;
            }
            function Ma(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.name !== l || n9.typeParameters !== p || n9.type !== k ? r(sr2(o, l, p, k), n9) : n9;
            }
            function Fu(n9, o, l) {
              let p = Ve2(263);
              return p.modifiers = xt(n9), p.name = Qt(o), p.members = Ne2(l), p.transformFlags |= gt2(p.modifiers) | ye(p.name) | gt2(p.members) | 1, p.transformFlags &= -67108865, p.jsDoc = void 0, p;
            }
            function La2(n9, o, l, p) {
              return n9.modifiers !== o || n9.name !== l || n9.members !== p ? r(Fu(o, l, p), n9) : n9;
            }
            function Am(n9, o, l) {
              let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, k = Ve2(264);
              return k.modifiers = xt(n9), k.flags |= p & 1044, k.name = o, k.body = l, Vn(k.modifiers) & 2 ? k.transformFlags = 1 : k.transformFlags |= gt2(k.modifiers) | ye(k.name) | ye(k.body) | 1, k.transformFlags &= -67108865, k.jsDoc = void 0, k.locals = void 0, k.nextContainer = void 0, k;
            }
            function Sr2(n9, o, l, p) {
              return n9.modifiers !== o || n9.name !== l || n9.body !== p ? r(Am(o, l, p, n9.flags), n9) : n9;
            }
            function Ra(n9) {
              let o = oe2(265);
              return o.statements = Ne2(n9), o.transformFlags |= gt2(o.statements), o.jsDoc = void 0, o;
            }
            function Yr2(n9, o) {
              return n9.statements !== o ? r(Ra(o), n9) : n9;
            }
            function Pm(n9) {
              let o = oe2(266);
              return o.clauses = Ne2(n9), o.transformFlags |= gt2(o.clauses), o.locals = void 0, o.nextContainer = void 0, o;
            }
            function _b(n9, o) {
              return n9.clauses !== o ? r(Pm(o), n9) : n9;
            }
            function Dm(n9) {
              let o = Ve2(267);
              return o.name = Qt(n9), o.transformFlags |= ec(o.name) | 1, o.modifiers = void 0, o.jsDoc = void 0, o;
            }
            function km(n9, o) {
              return n9.name !== o ? cb(Dm(o), n9) : n9;
            }
            function cb(n9, o) {
              return n9 !== o && (n9.modifiers = o.modifiers), r(n9, o);
            }
            function Im(n9, o, l, p) {
              let k = Ve2(268);
              return k.modifiers = xt(n9), k.name = Qt(l), k.isTypeOnly = o, k.moduleReference = p, k.transformFlags |= gt2(k.modifiers) | ec(k.name) | ye(k.moduleReference), ud(k.moduleReference) || (k.transformFlags |= 1), k.transformFlags &= -67108865, k.jsDoc = void 0, k;
            }
            function Nm(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.isTypeOnly !== l || n9.name !== p || n9.moduleReference !== k ? r(Im(o, l, p, k), n9) : n9;
            }
            function Om(n9, o, l, p) {
              let k = oe2(269);
              return k.modifiers = xt(n9), k.importClause = o, k.moduleSpecifier = l, k.assertClause = p, k.transformFlags |= ye(k.importClause) | ye(k.moduleSpecifier), k.transformFlags &= -67108865, k.jsDoc = void 0, k;
            }
            function Mm(n9, o, l, p, k) {
              return n9.modifiers !== o || n9.importClause !== l || n9.moduleSpecifier !== p || n9.assertClause !== k ? r(Om(o, l, p, k), n9) : n9;
            }
            function Lm(n9, o, l) {
              let p = Ve2(270);
              return p.isTypeOnly = n9, p.name = o, p.namedBindings = l, p.transformFlags |= ye(p.name) | ye(p.namedBindings), n9 && (p.transformFlags |= 1), p.transformFlags &= -67108865, p;
            }
            function Rm(n9, o, l, p) {
              return n9.isTypeOnly !== o || n9.name !== l || n9.namedBindings !== p ? r(Lm(o, l, p), n9) : n9;
            }
            function Bu(n9, o) {
              let l = oe2(296);
              return l.elements = Ne2(n9), l.multiLine = o, l.transformFlags |= 4, l;
            }
            function lb(n9, o, l) {
              return n9.elements !== o || n9.multiLine !== l ? r(Bu(o, l), n9) : n9;
            }
            function s_(n9, o) {
              let l = oe2(297);
              return l.name = n9, l.value = o, l.transformFlags |= 4, l;
            }
            function jm(n9, o, l) {
              return n9.name !== o || n9.value !== l ? r(s_(o, l), n9) : n9;
            }
            function qu(n9, o) {
              let l = oe2(298);
              return l.assertClause = n9, l.multiLine = o, l;
            }
            function Jm(n9, o, l) {
              return n9.assertClause !== o || n9.multiLine !== l ? r(qu(o, l), n9) : n9;
            }
            function Fm(n9) {
              let o = Ve2(271);
              return o.name = n9, o.transformFlags |= ye(o.name), o.transformFlags &= -67108865, o;
            }
            function Uu(n9, o) {
              return n9.name !== o ? r(Fm(o), n9) : n9;
            }
            function Bm2(n9) {
              let o = Ve2(277);
              return o.name = n9, o.transformFlags |= ye(o.name) | 4, o.transformFlags &= -67108865, o;
            }
            function qm(n9, o) {
              return n9.name !== o ? r(Bm2(o), n9) : n9;
            }
            function Um(n9) {
              let o = oe2(272);
              return o.elements = Ne2(n9), o.transformFlags |= gt2(o.elements), o.transformFlags &= -67108865, o;
            }
            function ub(n9, o) {
              return n9.elements !== o ? r(Um(o), n9) : n9;
            }
            function zm2(n9, o, l) {
              let p = Ve2(273);
              return p.isTypeOnly = n9, p.propertyName = o, p.name = l, p.transformFlags |= ye(p.propertyName) | ye(p.name), p.transformFlags &= -67108865, p;
            }
            function pb(n9, o, l, p) {
              return n9.isTypeOnly !== o || n9.propertyName !== l || n9.name !== p ? r(zm2(o, l, p), n9) : n9;
            }
            function zu(n9, o, l) {
              let p = Ve2(274);
              return p.modifiers = xt(n9), p.isExportEquals = o, p.expression = o ? s().parenthesizeRightSideOfBinary(63, void 0, l) : s().parenthesizeExpressionOfExportDefault(l), p.transformFlags |= gt2(p.modifiers) | ye(p.expression), p.transformFlags &= -67108865, p.jsDoc = void 0, p;
            }
            function Wu(n9, o, l) {
              return n9.modifiers !== o || n9.expression !== l ? r(zu(o, n9.isExportEquals, l), n9) : n9;
            }
            function na(n9, o, l, p, k) {
              let V = Ve2(275);
              return V.modifiers = xt(n9), V.isTypeOnly = o, V.exportClause = l, V.moduleSpecifier = p, V.assertClause = k, V.transformFlags |= gt2(V.modifiers) | ye(V.exportClause) | ye(V.moduleSpecifier), V.transformFlags &= -67108865, V.jsDoc = void 0, V;
            }
            function Wm(n9, o, l, p, k, V) {
              return n9.modifiers !== o || n9.isTypeOnly !== l || n9.exportClause !== p || n9.moduleSpecifier !== k || n9.assertClause !== V ? Vm(na(o, l, p, k, V), n9) : n9;
            }
            function Vm(n9, o) {
              return n9 !== o && n9.modifiers === o.modifiers && (n9.modifiers = o.modifiers), r(n9, o);
            }
            function to(n9) {
              let o = oe2(276);
              return o.elements = Ne2(n9), o.transformFlags |= gt2(o.elements), o.transformFlags &= -67108865, o;
            }
            function Hm(n9, o) {
              return n9.elements !== o ? r(to(o), n9) : n9;
            }
            function Vu(n9, o, l) {
              let p = oe2(278);
              return p.isTypeOnly = n9, p.propertyName = Qt(o), p.name = Qt(l), p.transformFlags |= ye(p.propertyName) | ye(p.name), p.transformFlags &= -67108865, p.jsDoc = void 0, p;
            }
            function o_(n9, o, l, p) {
              return n9.isTypeOnly !== o || n9.propertyName !== l || n9.name !== p ? r(Vu(o, l, p), n9) : n9;
            }
            function fb() {
              let n9 = Ve2(279);
              return n9.jsDoc = void 0, n9;
            }
            function Gm2(n9) {
              let o = oe2(280);
              return o.expression = n9, o.transformFlags |= ye(o.expression), o.transformFlags &= -67108865, o;
            }
            function $m(n9, o) {
              return n9.expression !== o ? r(Gm2(o), n9) : n9;
            }
            function db(n9) {
              return oe2(n9);
            }
            function Km(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, p = Ac(n9, l ? o && s().parenthesizeNonArrayTypeOfPostfixType(o) : o);
              return p.postfix = l, p;
            }
            function Ac(n9, o) {
              let l = oe2(n9);
              return l.type = o, l;
            }
            function Xm(n9, o, l) {
              return o.type !== l ? r(Km(n9, l, o.postfix), o) : o;
            }
            function mb(n9, o, l) {
              return o.type !== l ? r(Ac(n9, l), o) : o;
            }
            function Ym(n9, o) {
              let l = Ve2(320);
              return l.parameters = xt(n9), l.type = o, l.transformFlags = gt2(l.parameters) | (l.type ? 1 : 0), l.jsDoc = void 0, l.locals = void 0, l.nextContainer = void 0, l.typeArguments = void 0, l;
            }
            function hb(n9, o, l) {
              return n9.parameters !== o || n9.type !== l ? r(Ym(o, l), n9) : n9;
            }
            function Qm(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, l = Ve2(325);
              return l.jsDocPropertyTags = xt(n9), l.isArrayType = o, l;
            }
            function gb(n9, o, l) {
              return n9.jsDocPropertyTags !== o || n9.isArrayType !== l ? r(Qm(o, l), n9) : n9;
            }
            function Zm(n9) {
              let o = oe2(312);
              return o.type = n9, o;
            }
            function yb(n9, o) {
              return n9.type !== o ? r(Zm(o), n9) : n9;
            }
            function eh(n9, o, l) {
              let p = Ve2(326);
              return p.typeParameters = xt(n9), p.parameters = Ne2(o), p.type = l, p.jsDoc = void 0, p.locals = void 0, p.nextContainer = void 0, p;
            }
            function Hu(n9, o, l, p) {
              return n9.typeParameters !== o || n9.parameters !== l || n9.type !== p ? r(eh(o, l, p), n9) : n9;
            }
            function fi(n9) {
              let o = ed(n9.kind);
              return n9.tagName.escapedText === vi(o) ? n9.tagName : Ut(o);
            }
            function ja(n9, o, l) {
              let p = oe2(n9);
              return p.tagName = o, p.comment = l, p;
            }
            function Ja(n9, o, l) {
              let p = Ve2(n9);
              return p.tagName = o, p.comment = l, p;
            }
            function __(n9, o, l, p) {
              let k = ja(348, n9 != null ? n9 : Ut("template"), p);
              return k.constraint = o, k.typeParameters = Ne2(l), k;
            }
            function Gu(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0, k = arguments.length > 4 ? arguments[4] : void 0;
              return n9.tagName !== o || n9.constraint !== l || n9.typeParameters !== p || n9.comment !== k ? r(__(o, l, p, k), n9) : n9;
            }
            function $u(n9, o, l, p) {
              let k = Ja(349, n9 != null ? n9 : Ut("typedef"), p);
              return k.typeExpression = o, k.fullName = l, k.name = w2(l), k.locals = void 0, k.nextContainer = void 0, k;
            }
            function th(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0, k = arguments.length > 4 ? arguments[4] : void 0;
              return n9.tagName !== o || n9.typeExpression !== l || n9.fullName !== p || n9.comment !== k ? r($u(o, l, p, k), n9) : n9;
            }
            function Pc(n9, o, l, p, k, V) {
              let we2 = Ja(344, n9 != null ? n9 : Ut("param"), V);
              return we2.typeExpression = p, we2.name = o, we2.isNameFirst = !!k, we2.isBracketed = l, we2;
            }
            function vb(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0, k = arguments.length > 4 ? arguments[4] : void 0, V = arguments.length > 5 ? arguments[5] : void 0, we2 = arguments.length > 6 ? arguments[6] : void 0;
              return n9.tagName !== o || n9.name !== l || n9.isBracketed !== p || n9.typeExpression !== k || n9.isNameFirst !== V || n9.comment !== we2 ? r(Pc(o, l, p, k, V, we2), n9) : n9;
            }
            function Ku(n9, o, l, p, k, V) {
              let we2 = Ja(351, n9 != null ? n9 : Ut("prop"), V);
              return we2.typeExpression = p, we2.name = o, we2.isNameFirst = !!k, we2.isBracketed = l, we2;
            }
            function bb(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0, k = arguments.length > 4 ? arguments[4] : void 0, V = arguments.length > 5 ? arguments[5] : void 0, we2 = arguments.length > 6 ? arguments[6] : void 0;
              return n9.tagName !== o || n9.name !== l || n9.isBracketed !== p || n9.typeExpression !== k || n9.isNameFirst !== V || n9.comment !== we2 ? r(Ku(o, l, p, k, V, we2), n9) : n9;
            }
            function rh(n9, o, l, p) {
              let k = Ja(341, n9 != null ? n9 : Ut("callback"), p);
              return k.typeExpression = o, k.fullName = l, k.name = w2(l), k.locals = void 0, k.nextContainer = void 0, k;
            }
            function nh(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0, k = arguments.length > 4 ? arguments[4] : void 0;
              return n9.tagName !== o || n9.typeExpression !== l || n9.fullName !== p || n9.comment !== k ? r(rh(o, l, p, k), n9) : n9;
            }
            function ih(n9, o, l) {
              let p = ja(342, n9 != null ? n9 : Ut("overload"), l);
              return p.typeExpression = o, p;
            }
            function ah(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0;
              return n9.tagName !== o || n9.typeExpression !== l || n9.comment !== p ? r(ih(o, l, p), n9) : n9;
            }
            function sh(n9, o, l) {
              let p = ja(331, n9 != null ? n9 : Ut("augments"), l);
              return p.class = o, p;
            }
            function Xu(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0;
              return n9.tagName !== o || n9.class !== l || n9.comment !== p ? r(sh(o, l, p), n9) : n9;
            }
            function Yu(n9, o, l) {
              let p = ja(332, n9 != null ? n9 : Ut("implements"), l);
              return p.class = o, p;
            }
            function ro(n9, o, l) {
              let p = ja(350, n9 != null ? n9 : Ut("see"), l);
              return p.name = o, p;
            }
            function Tb(n9, o, l, p) {
              return n9.tagName !== o || n9.name !== l || n9.comment !== p ? r(ro(o, l, p), n9) : n9;
            }
            function ws(n9) {
              let o = oe2(313);
              return o.name = n9, o;
            }
            function Dc(n9, o) {
              return n9.name !== o ? r(ws(o), n9) : n9;
            }
            function oh(n9, o) {
              let l = oe2(314);
              return l.left = n9, l.right = o, l.transformFlags |= ye(l.left) | ye(l.right), l;
            }
            function Sb(n9, o, l) {
              return n9.left !== o || n9.right !== l ? r(oh(o, l), n9) : n9;
            }
            function _h(n9, o) {
              let l = oe2(327);
              return l.name = n9, l.text = o, l;
            }
            function xb(n9, o, l) {
              return n9.name !== o ? r(_h(o, l), n9) : n9;
            }
            function ch(n9, o) {
              let l = oe2(328);
              return l.name = n9, l.text = o, l;
            }
            function lh(n9, o, l) {
              return n9.name !== o ? r(ch(o, l), n9) : n9;
            }
            function uh(n9, o) {
              let l = oe2(329);
              return l.name = n9, l.text = o, l;
            }
            function Eb(n9, o, l) {
              return n9.name !== o ? r(uh(o, l), n9) : n9;
            }
            function wb(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0;
              return n9.tagName !== o || n9.class !== l || n9.comment !== p ? r(Yu(o, l, p), n9) : n9;
            }
            function ph(n9, o, l) {
              return ja(n9, o != null ? o : Ut(ed(n9)), l);
            }
            function Cb(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fi(o), p = arguments.length > 3 ? arguments[3] : void 0;
              return o.tagName !== l || o.comment !== p ? r(ph(n9, l, p), o) : o;
            }
            function fh(n9, o, l, p) {
              let k = ja(n9, o != null ? o : Ut(ed(n9)), p);
              return k.typeExpression = l, k;
            }
            function Ab(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fi(o), p = arguments.length > 3 ? arguments[3] : void 0, k = arguments.length > 4 ? arguments[4] : void 0;
              return o.tagName !== l || o.typeExpression !== p || o.comment !== k ? r(fh(n9, l, p, k), o) : o;
            }
            function dh(n9, o) {
              return ja(330, n9, o);
            }
            function Pb(n9, o, l) {
              return n9.tagName !== o || n9.comment !== l ? r(dh(o, l), n9) : n9;
            }
            function mh(n9, o, l) {
              let p = Ja(343, n9 != null ? n9 : Ut(ed(343)), l);
              return p.typeExpression = o, p.locals = void 0, p.nextContainer = void 0, p;
            }
            function Db(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi(n9), l = arguments.length > 2 ? arguments[2] : void 0, p = arguments.length > 3 ? arguments[3] : void 0;
              return n9.tagName !== o || n9.typeExpression !== l || n9.comment !== p ? r(mh(o, l, p), n9) : n9;
            }
            function hh(n9) {
              let o = oe2(324);
              return o.text = n9, o;
            }
            function Qu(n9, o) {
              return n9.text !== o ? r(hh(o), n9) : n9;
            }
            function gh(n9, o) {
              let l = oe2(323);
              return l.comment = n9, l.tags = xt(o), l;
            }
            function yh(n9, o, l) {
              return n9.comment !== o || n9.tags !== l ? r(gh(o, l), n9) : n9;
            }
            function Zu(n9, o, l) {
              let p = oe2(281);
              return p.openingElement = n9, p.children = Ne2(o), p.closingElement = l, p.transformFlags |= ye(p.openingElement) | gt2(p.children) | ye(p.closingElement) | 2, p;
            }
            function kb(n9, o, l, p) {
              return n9.openingElement !== o || n9.children !== l || n9.closingElement !== p ? r(Zu(o, l, p), n9) : n9;
            }
            function c_(n9, o, l) {
              let p = oe2(282);
              return p.tagName = n9, p.typeArguments = xt(o), p.attributes = l, p.transformFlags |= ye(p.tagName) | gt2(p.typeArguments) | ye(p.attributes) | 2, p.typeArguments && (p.transformFlags |= 1), p;
            }
            function vh(n9, o, l, p) {
              return n9.tagName !== o || n9.typeArguments !== l || n9.attributes !== p ? r(c_(o, l, p), n9) : n9;
            }
            function bh(n9, o, l) {
              let p = oe2(283);
              return p.tagName = n9, p.typeArguments = xt(o), p.attributes = l, p.transformFlags |= ye(p.tagName) | gt2(p.typeArguments) | ye(p.attributes) | 2, o && (p.transformFlags |= 1), p;
            }
            function Ib(n9, o, l, p) {
              return n9.tagName !== o || n9.typeArguments !== l || n9.attributes !== p ? r(bh(o, l, p), n9) : n9;
            }
            function on(n9) {
              let o = oe2(284);
              return o.tagName = n9, o.transformFlags |= ye(o.tagName) | 2, o;
            }
            function Th2(n9, o) {
              return n9.tagName !== o ? r(on(o), n9) : n9;
            }
            function ep(n9, o, l) {
              let p = oe2(285);
              return p.openingFragment = n9, p.children = Ne2(o), p.closingFragment = l, p.transformFlags |= ye(p.openingFragment) | gt2(p.children) | ye(p.closingFragment) | 2, p;
            }
            function Nb(n9, o, l, p) {
              return n9.openingFragment !== o || n9.children !== l || n9.closingFragment !== p ? r(ep(o, l, p), n9) : n9;
            }
            function l_(n9, o) {
              let l = oe2(11);
              return l.text = n9, l.containsOnlyTriviaWhiteSpaces = !!o, l.transformFlags |= 2, l;
            }
            function Ob(n9, o, l) {
              return n9.text !== o || n9.containsOnlyTriviaWhiteSpaces !== l ? r(l_(o, l), n9) : n9;
            }
            function kc() {
              let n9 = oe2(286);
              return n9.transformFlags |= 2, n9;
            }
            function Mb() {
              let n9 = oe2(287);
              return n9.transformFlags |= 2, n9;
            }
            function Sh(n9, o) {
              let l = Ve2(288);
              return l.name = n9, l.initializer = o, l.transformFlags |= ye(l.name) | ye(l.initializer) | 2, l;
            }
            function Lb(n9, o, l) {
              return n9.name !== o || n9.initializer !== l ? r(Sh(o, l), n9) : n9;
            }
            function xh(n9) {
              let o = Ve2(289);
              return o.properties = Ne2(n9), o.transformFlags |= gt2(o.properties) | 2, o;
            }
            function tp(n9, o) {
              return n9.properties !== o ? r(xh(o), n9) : n9;
            }
            function no(n9) {
              let o = oe2(290);
              return o.expression = n9, o.transformFlags |= ye(o.expression) | 2, o;
            }
            function Rb(n9, o) {
              return n9.expression !== o ? r(no(o), n9) : n9;
            }
            function Ic(n9, o) {
              let l = oe2(291);
              return l.dotDotDotToken = n9, l.expression = o, l.transformFlags |= ye(l.dotDotDotToken) | ye(l.expression) | 2, l;
            }
            function Eh(n9, o) {
              return n9.expression !== o ? r(Ic(n9.dotDotDotToken, o), n9) : n9;
            }
            function wh(n9, o) {
              let l = oe2(292);
              return l.expression = s().parenthesizeExpressionForDisallowedComma(n9), l.statements = Ne2(o), l.transformFlags |= ye(l.expression) | gt2(l.statements), l.jsDoc = void 0, l;
            }
            function rp(n9, o, l) {
              return n9.expression !== o || n9.statements !== l ? r(wh(o, l), n9) : n9;
            }
            function np(n9) {
              let o = oe2(293);
              return o.statements = Ne2(n9), o.transformFlags = gt2(o.statements), o;
            }
            function jb(n9, o) {
              return n9.statements !== o ? r(np(o), n9) : n9;
            }
            function Ch(n9, o) {
              let l = oe2(294);
              switch (l.token = n9, l.types = Ne2(o), l.transformFlags |= gt2(l.types), n9) {
                case 94:
                  l.transformFlags |= 1024;
                  break;
                case 117:
                  l.transformFlags |= 1;
                  break;
                default:
                  return Y3.assertNever(n9);
              }
              return l;
            }
            function Ah(n9, o) {
              return n9.types !== o ? r(Ch(n9.token, o), n9) : n9;
            }
            function ip(n9, o) {
              let l = oe2(295);
              return l.variableDeclaration = Xh(n9), l.block = o, l.transformFlags |= ye(l.variableDeclaration) | ye(l.block) | (n9 ? 0 : 64), l.locals = void 0, l.nextContainer = void 0, l;
            }
            function Ph(n9, o, l) {
              return n9.variableDeclaration !== o || n9.block !== l ? r(ip(o, l), n9) : n9;
            }
            function Fa(n9, o) {
              let l = Ve2(299);
              return l.name = Qt(n9), l.initializer = s().parenthesizeExpressionForDisallowedComma(o), l.transformFlags |= ai(l.name) | ye(l.initializer), l.modifiers = void 0, l.questionToken = void 0, l.exclamationToken = void 0, l.jsDoc = void 0, l;
            }
            function Jb(n9, o, l) {
              return n9.name !== o || n9.initializer !== l ? Fb(Fa(o, l), n9) : n9;
            }
            function Fb(n9, o) {
              return n9 !== o && (n9.modifiers = o.modifiers, n9.questionToken = o.questionToken, n9.exclamationToken = o.exclamationToken), r(n9, o);
            }
            function Dh(n9, o) {
              let l = Ve2(300);
              return l.name = Qt(n9), l.objectAssignmentInitializer = o && s().parenthesizeExpressionForDisallowedComma(o), l.transformFlags |= ec(l.name) | ye(l.objectAssignmentInitializer) | 1024, l.equalsToken = void 0, l.modifiers = void 0, l.questionToken = void 0, l.exclamationToken = void 0, l.jsDoc = void 0, l;
            }
            function Bb(n9, o, l) {
              return n9.name !== o || n9.objectAssignmentInitializer !== l ? kh(Dh(o, l), n9) : n9;
            }
            function kh(n9, o) {
              return n9 !== o && (n9.modifiers = o.modifiers, n9.questionToken = o.questionToken, n9.exclamationToken = o.exclamationToken, n9.equalsToken = o.equalsToken), r(n9, o);
            }
            function ap(n9) {
              let o = Ve2(301);
              return o.expression = s().parenthesizeExpressionForDisallowedComma(n9), o.transformFlags |= ye(o.expression) | 128 | 65536, o.jsDoc = void 0, o;
            }
            function ki(n9, o) {
              return n9.expression !== o ? r(ap(o), n9) : n9;
            }
            function sp(n9, o) {
              let l = Ve2(302);
              return l.name = Qt(n9), l.initializer = o && s().parenthesizeExpressionForDisallowedComma(o), l.transformFlags |= ye(l.name) | ye(l.initializer) | 1, l.jsDoc = void 0, l;
            }
            function qb(n9, o, l) {
              return n9.name !== o || n9.initializer !== l ? r(sp(o, l), n9) : n9;
            }
            function Ub(n9, o, l) {
              let p = t6.createBaseSourceFileNode(308);
              return p.statements = Ne2(n9), p.endOfFileToken = o, p.flags |= l, p.text = "", p.fileName = "", p.path = "", p.resolvedPath = "", p.originalFileName = "", p.languageVersion = 0, p.languageVariant = 0, p.scriptKind = 0, p.isDeclarationFile = false, p.hasNoDefaultLib = false, p.transformFlags |= gt2(p.statements) | ye(p.endOfFileToken), p.locals = void 0, p.nextContainer = void 0, p.endFlowNode = void 0, p.nodeCount = 0, p.identifierCount = 0, p.symbolCount = 0, p.parseDiagnostics = void 0, p.bindDiagnostics = void 0, p.bindSuggestionDiagnostics = void 0, p.lineMap = void 0, p.externalModuleIndicator = void 0, p.setExternalModuleIndicator = void 0, p.pragmas = void 0, p.checkJsDirective = void 0, p.referencedFiles = void 0, p.typeReferenceDirectives = void 0, p.libReferenceDirectives = void 0, p.amdDependencies = void 0, p.commentDirectives = void 0, p.identifiers = void 0, p.packageJsonLocations = void 0, p.packageJsonScope = void 0, p.imports = void 0, p.moduleAugmentations = void 0, p.ambientModuleNames = void 0, p.resolvedModules = void 0, p.classifiableNames = void 0, p.impliedNodeFormat = void 0, p;
            }
            function Ih(n9) {
              let o = Object.create(n9.redirectTarget);
              return Object.defineProperties(o, { id: { get() {
                return this.redirectInfo.redirectTarget.id;
              }, set(l) {
                this.redirectInfo.redirectTarget.id = l;
              } }, symbol: { get() {
                return this.redirectInfo.redirectTarget.symbol;
              }, set(l) {
                this.redirectInfo.redirectTarget.symbol = l;
              } } }), o.redirectInfo = n9, o;
            }
            function Nh(n9) {
              let o = Ih(n9.redirectInfo);
              return o.flags |= n9.flags & -9, o.fileName = n9.fileName, o.path = n9.path, o.resolvedPath = n9.resolvedPath, o.originalFileName = n9.originalFileName, o.packageJsonLocations = n9.packageJsonLocations, o.packageJsonScope = n9.packageJsonScope, o.emitNode = void 0, o;
            }
            function op(n9) {
              let o = t6.createBaseSourceFileNode(308);
              o.flags |= n9.flags & -9;
              for (let l in n9)
                if (!(Jr(o, l) || !Jr(n9, l))) {
                  if (l === "emitNode") {
                    o.emitNode = void 0;
                    continue;
                  }
                  o[l] = n9[l];
                }
              return o;
            }
            function Oh(n9) {
              let o = n9.redirectInfo ? Nh(n9) : op(n9);
              return Dn(o, n9), o;
            }
            function zb(n9, o, l, p, k, V, we2) {
              let et = Oh(n9);
              return et.statements = Ne2(o), et.isDeclarationFile = l, et.referencedFiles = p, et.typeReferenceDirectives = k, et.hasNoDefaultLib = V, et.libReferenceDirectives = we2, et.transformFlags = gt2(et.statements) | ye(et.endOfFileToken), et;
            }
            function Mh(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : n9.isDeclarationFile, p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : n9.referencedFiles, k = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : n9.typeReferenceDirectives, V = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : n9.hasNoDefaultLib, we2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : n9.libReferenceDirectives;
              return n9.statements !== o || n9.isDeclarationFile !== l || n9.referencedFiles !== p || n9.typeReferenceDirectives !== k || n9.hasNoDefaultLib !== V || n9.libReferenceDirectives !== we2 ? r(zb(n9, o, l, p, k, V, we2), n9) : n9;
            }
            function Lh(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Bt, l = oe2(309);
              return l.prepends = o, l.sourceFiles = n9, l.syntheticFileReferences = void 0, l.syntheticTypeReferences = void 0, l.syntheticLibReferences = void 0, l.hasNoDefaultLib = void 0, l;
            }
            function Wb(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Bt;
              return n9.sourceFiles !== o || n9.prepends !== l ? r(Lh(o, l), n9) : n9;
            }
            function Nc2(n9, o, l) {
              let p = oe2(310);
              return p.prologues = n9, p.syntheticReferences = o, p.texts = l, p.fileName = "", p.text = "", p.referencedFiles = Bt, p.libReferenceDirectives = Bt, p.getLineAndCharacterOfPosition = (k) => Ls(p, k), p;
            }
            function Oc2(n9, o) {
              let l = oe2(n9);
              return l.data = o, l;
            }
            function Vb(n9) {
              return Oc2(303, n9);
            }
            function Hb(n9, o) {
              let l = Oc2(304, n9);
              return l.texts = o, l;
            }
            function Gb(n9, o) {
              return Oc2(o ? 306 : 305, n9);
            }
            function $b(n9) {
              let o = oe2(307);
              return o.data = n9.data, o.section = n9, o;
            }
            function Kb() {
              let n9 = oe2(311);
              return n9.javascriptText = "", n9.declarationText = "", n9;
            }
            function Rh(n9) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, l = arguments.length > 2 ? arguments[2] : void 0, p = oe2(234);
              return p.type = n9, p.isSpread = o, p.tupleNameSource = l, p;
            }
            function jh(n9) {
              let o = oe2(354);
              return o._children = n9, o;
            }
            function Jh(n9) {
              let o = oe2(355);
              return o.original = n9, Rt(o, n9), o;
            }
            function Fh(n9, o) {
              let l = oe2(356);
              return l.expression = n9, l.original = o, l.transformFlags |= ye(l.expression) | 1, Rt(l, o), l;
            }
            function Bh(n9, o) {
              return n9.expression !== o ? r(Fh(o, n9.original), n9) : n9;
            }
            function qh(n9) {
              if (fs(n9) && !pl(n9) && !n9.original && !n9.emitNode && !n9.id) {
                if (oc(n9))
                  return n9.elements;
                if (ur2(n9) && I8(n9.operatorToken))
                  return [n9.left, n9.right];
              }
              return n9;
            }
            function Mc(n9) {
              let o = oe2(357);
              return o.elements = Ne2(at3(n9, qh)), o.transformFlags |= gt2(o.elements), o;
            }
            function Xb(n9, o) {
              return n9.elements !== o ? r(Mc(o), n9) : n9;
            }
            function Yb(n9) {
              let o = oe2(359);
              return o.emitNode = {}, o.original = n9, o;
            }
            function Qb(n9) {
              let o = oe2(358);
              return o.emitNode = {}, o.original = n9, o;
            }
            function Uh(n9, o) {
              let l = oe2(360);
              return l.expression = n9, l.thisArg = o, l.transformFlags |= ye(l.expression) | ye(l.thisArg), l;
            }
            function _p(n9, o, l) {
              return n9.expression !== o || n9.thisArg !== l ? r(Uh(o, l), n9) : n9;
            }
            function Zb(n9) {
              let o = pn(n9.escapedText);
              return o.flags |= n9.flags & -9, o.transformFlags = n9.transformFlags, Dn(o, n9), setIdentifierAutoGenerate(o, Object.assign({}, n9.emitNode.autoGenerate)), o;
            }
            function e6(n9) {
              let o = pn(n9.escapedText);
              o.flags |= n9.flags & -9, o.jsDoc = n9.jsDoc, o.flowNode = n9.flowNode, o.symbol = n9.symbol, o.transformFlags = n9.transformFlags, Dn(o, n9);
              let l = getIdentifierTypeArguments(n9);
              return l && setIdentifierTypeArguments(o, l), o;
            }
            function t62(n9) {
              let o = dn(n9.escapedText);
              return o.flags |= n9.flags & -9, o.transformFlags = n9.transformFlags, Dn(o, n9), setIdentifierAutoGenerate(o, Object.assign({}, n9.emitNode.autoGenerate)), o;
            }
            function r6(n9) {
              let o = dn(n9.escapedText);
              return o.flags |= n9.flags & -9, o.transformFlags = n9.transformFlags, Dn(o, n9), o;
            }
            function cp(n9) {
              if (n9 === void 0)
                return n9;
              if (wi(n9))
                return Oh(n9);
              if (cs(n9))
                return Zb(n9);
              if (yt(n9))
                return e6(n9);
              if (Ny(n9))
                return t62(n9);
              if (vn(n9))
                return r6(n9);
              let o = gl(n9.kind) ? t6.createBaseNode(n9.kind) : t6.createBaseTokenNode(n9.kind);
              o.flags |= n9.flags & -9, o.transformFlags = n9.transformFlags, Dn(o, n9);
              for (let l in n9)
                Jr(o, l) || !Jr(n9, l) || (o[l] = n9[l]);
              return o;
            }
            function n6(n9, o, l) {
              return Na(yu(void 0, void 0, void 0, void 0, o ? [o] : [], void 0, Zs(n9, true)), void 0, l ? [l] : []);
            }
            function Lc(n9, o, l) {
              return Na(vu(void 0, void 0, o ? [o] : [], void 0, void 0, Zs(n9, true)), void 0, l ? [l] : []);
            }
            function Rc2() {
              return ui(Gt("0"));
            }
            function zh(n9) {
              return zu(void 0, false, n9);
            }
            function i6(n9) {
              return na(void 0, false, to([Vu(false, void 0, n9)]));
            }
            function a6(n9, o) {
              return o === "undefined" ? Ye2.createStrictEquality(n9, Rc2()) : Ye2.createStrictEquality(mn(n9), er2(o));
            }
            function Ba(n9, o, l) {
              return Cy(n9) ? du(Xs(n9, void 0, o), void 0, void 0, l) : Na(ta(n9, o), void 0, l);
            }
            function s6(n9, o, l) {
              return Ba(n9, "bind", [o, ...l]);
            }
            function o6(n9, o, l) {
              return Ba(n9, "call", [o, ...l]);
            }
            function _6(n9, o, l) {
              return Ba(n9, "apply", [o, l]);
            }
            function io(n9, o, l) {
              return Ba(Ut(n9), o, l);
            }
            function Wh(n9, o) {
              return Ba(n9, "slice", o === void 0 ? [] : [za(o)]);
            }
            function Vh(n9, o) {
              return Ba(n9, "concat", o);
            }
            function u(n9, o, l) {
              return io("Object", "defineProperty", [n9, za(o), l]);
            }
            function b(n9, o) {
              return io("Object", "getOwnPropertyDescriptor", [n9, za(o)]);
            }
            function O10(n9, o, l) {
              return io("Reflect", "get", l ? [n9, o, l] : [n9, o]);
            }
            function j6(n9, o, l, p) {
              return io("Reflect", "set", p ? [n9, o, l, p] : [n9, o, l]);
            }
            function z(n9, o, l) {
              return l ? (n9.push(Fa(o, l)), true) : false;
            }
            function re2(n9, o) {
              let l = [];
              z(l, "enumerable", za(n9.enumerable)), z(l, "configurable", za(n9.configurable));
              let p = z(l, "writable", za(n9.writable));
              p = z(l, "value", n9.value) || p;
              let k = z(l, "get", n9.get);
              return k = z(l, "set", n9.set) || k, Y3.assert(!(p && k), "A PropertyDescriptor may not be both an accessor descriptor and a data descriptor."), r_(l, !o);
            }
            function Ee2(n9, o) {
              switch (n9.kind) {
                case 214:
                  return qd(n9, o);
                case 213:
                  return Bd(n9, n9.type, o);
                case 231:
                  return Zd(n9, o, n9.type);
                case 235:
                  return Pu(n9, o, n9.type);
                case 232:
                  return Au(n9, o);
                case 356:
                  return Bh(n9, o);
              }
            }
            function qe(n9) {
              return qo(n9) && fs(n9) && fs(getSourceMapRange(n9)) && fs(getCommentRange(n9)) && !Ke3(getSyntheticLeadingComments(n9)) && !Ke3(getSyntheticTrailingComments(n9));
            }
            function We2(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 15;
              return n9 && yd(n9, l) && !qe(n9) ? Ee2(n9, We2(n9.expression, o)) : o;
            }
            function $e2(n9, o, l) {
              if (!o)
                return n9;
              let p = ym(o, o.label, tE(o.statement) ? $e2(n9, o.statement) : n9);
              return l && l(o), p;
            }
            function lt2(n9, o) {
              let l = Pl(n9);
              switch (l.kind) {
                case 79:
                  return o;
                case 108:
                case 8:
                case 9:
                case 10:
                  return false;
                case 206:
                  return l.elements.length !== 0;
                case 207:
                  return l.properties.length > 0;
                default:
                  return true;
              }
            }
            function Jt(n9, o, l) {
              let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, k = $o(n9, 15), V, we2;
              return Sf(k) ? (V = Or2(), we2 = k) : nd(k) ? (V = Or2(), we2 = l !== void 0 && l < 2 ? Rt(Ut("_super"), k) : k) : xi(k) & 8192 ? (V = Rc2(), we2 = s().parenthesizeLeftSideOfAccess(k, false)) : bn(k) ? lt2(k.expression, p) ? (V = kn(o), we2 = ta(Rt(Ye2.createAssignment(V, k.expression), k.expression), k.name), Rt(we2, k)) : (V = k.expression, we2 = k) : gs(k) ? lt2(k.expression, p) ? (V = kn(o), we2 = pu(Rt(Ye2.createAssignment(V, k.expression), k.expression), k.argumentExpression), Rt(we2, k)) : (V = k.expression, we2 = k) : (V = Rc2(), we2 = s().parenthesizeLeftSideOfAccess(n9, false)), { target: we2, thisArg: V };
            }
            function Lt(n9, o) {
              return ta(gu(r_([ci(void 0, "value", [$n(void 0, void 0, n9, void 0, void 0, void 0)], Zs([a_(o)]))])), "value");
            }
            function At(n9) {
              return n9.length > 10 ? Mc(n9) : Qa(n9, Ye2.createComma);
            }
            function kr2(n9, o, l) {
              let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, k = ml(n9);
              if (k && yt(k) && !cs(k)) {
                let V = Sa(Rt(cp(k), k), k.parent);
                return p |= xi(k), l || (p |= 96), o || (p |= 3072), p && setEmitFlags(V, p), V;
              }
              return $i(n9);
            }
            function Fn(n9, o, l) {
              return kr2(n9, o, l, 98304);
            }
            function di(n9, o, l) {
              return kr2(n9, o, l, 32768);
            }
            function Ii(n9, o, l) {
              return kr2(n9, o, l, 16384);
            }
            function _n(n9, o, l) {
              return kr2(n9, o, l);
            }
            function qa(n9, o, l, p) {
              let k = ta(n9, fs(o) ? o : cp(o));
              Rt(k, o);
              let V = 0;
              return p || (V |= 96), l || (V |= 3072), V && setEmitFlags(k, V), k;
            }
            function Hh(n9, o, l, p) {
              return n9 && rn(o, 1) ? qa(n9, kr2(o), l, p) : Ii(o, l, p);
            }
            function lp(n9, o, l, p) {
              let k = Ua(n9, o, 0, l);
              return up(n9, o, k, p);
            }
            function Gh(n9) {
              return Gn(n9.expression) && n9.expression.text === "use strict";
            }
            function wn() {
              return vd(a_(er2("use strict")));
            }
            function Ua(n9, o) {
              let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, p = arguments.length > 3 ? arguments[3] : void 0;
              Y3.assert(o.length === 0, "Prologue directives should be at the first statement in the target statements array");
              let k = false, V = n9.length;
              for (; l < V; ) {
                let we2 = n9[l];
                if (us(we2))
                  Gh(we2) && (k = true), o.push(we2);
                else
                  break;
                l++;
              }
              return p && !k && o.push(wn()), l;
            }
            function up(n9, o, l, p) {
              let k = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : vp, V = n9.length;
              for (; l !== void 0 && l < V; ) {
                let we2 = n9[l];
                if (xi(we2) & 2097152 && k(we2))
                  tr2(o, p ? visitNode(we2, p, a3) : we2);
                else
                  break;
                l++;
              }
              return l;
            }
            function Qr2(n9) {
              return TE(n9) ? n9 : Rt(Ne2([wn(), ...n9]), n9);
            }
            function jc(n9) {
              return Y3.assert(me2(n9, s3), "Cannot lift nodes to a Block."), Xa(n9) || Zs(n9);
            }
            function Cs(n9, o, l) {
              let p = l;
              for (; p < n9.length && o(n9[p]); )
                p++;
              return p;
            }
            function $h(n9, o) {
              if (!Ke3(o))
                return n9;
              let l = Cs(n9, us, 0), p = Cs(n9, _0, l), k = Cs(n9, c0, p), V = Cs(o, us, 0), we2 = Cs(o, _0, V), et = Cs(o, c0, we2), ht = Cs(o, Tf, et);
              Y3.assert(ht === o.length, "Expected declarations to be valid standard or custom prologues");
              let hn = _s(n9) ? n9.slice() : n9;
              if (ht > et && hn.splice(k, 0, ...o.slice(et, ht)), et > we2 && hn.splice(p, 0, ...o.slice(we2, et)), we2 > V && hn.splice(l, 0, ...o.slice(V, we2)), V > 0)
                if (l === 0)
                  hn.splice(0, 0, ...o.slice(0, V));
                else {
                  let Ni = /* @__PURE__ */ new Map();
                  for (let ia = 0; ia < l; ia++) {
                    let Oi = n9[ia];
                    Ni.set(Oi.expression.text, true);
                  }
                  for (let ia = V - 1; ia >= 0; ia--) {
                    let Oi = o[ia];
                    Ni.has(Oi.expression.text) || hn.unshift(Oi);
                  }
                }
              return _s(n9) ? Rt(Ne2(hn, n9.hasTrailingComma), n9) : n9;
            }
            function Kh(n9, o) {
              var l;
              let p;
              return typeof o == "number" ? p = $r2(o) : p = o, Fo(n9) ? wa(n9, p, n9.name, n9.constraint, n9.default) : Vs(n9) ? Ki(n9, p, n9.dotDotDotToken, n9.name, n9.questionToken, n9.type, n9.initializer) : Gv(n9) ? bt(n9, p, n9.typeParameters, n9.parameters, n9.type) : Wl(n9) ? St(n9, p, n9.name, n9.questionToken, n9.type) : Bo(n9) ? _t(n9, p, n9.name, (l = n9.questionToken) != null ? l : n9.exclamationToken, n9.type, n9.initializer) : L8(n9) ? Kt(n9, p, n9.name, n9.questionToken, n9.typeParameters, n9.parameters, n9.type) : Vl(n9) ? xe2(n9, p, n9.asteriskToken, n9.name, n9.questionToken, n9.typeParameters, n9.parameters, n9.type, n9.body) : nc(n9) ? It(n9, p, n9.parameters, n9.body) : Gl(n9) ? Ln(n9, p, n9.name, n9.parameters, n9.type, n9.body) : ic(n9) ? Xi(n9, p, n9.name, n9.parameters, n9.body) : Hv(n9) ? bs(n9, p, n9.parameters, n9.type) : ad(n9) ? Ud(n9, p, n9.asteriskToken, n9.name, n9.typeParameters, n9.parameters, n9.type, n9.body) : sd(n9) ? zd(n9, p, n9.typeParameters, n9.parameters, n9.type, n9.equalsGreaterThanToken, n9.body) : _d(n9) ? xc(n9, p, n9.name, n9.typeParameters, n9.heritageClauses, n9.members) : zo(n9) ? om(n9, p, n9.declarationList) : Wo(n9) ? ju(n9, p, n9.asteriskToken, n9.name, n9.typeParameters, n9.parameters, n9.type, n9.body) : _c(n9) ? Ju(n9, p, n9.name, n9.typeParameters, n9.heritageClauses, n9.members) : eu(n9) ? Cm(n9, p, n9.name, n9.typeParameters, n9.heritageClauses, n9.members) : n2(n9) ? Ma(n9, p, n9.name, n9.typeParameters, n9.type) : i22(n9) ? La2(n9, p, n9.name, n9.members) : Ea(n9) ? Sr2(n9, p, n9.name, n9.body) : s2(n9) ? Nm(n9, p, n9.isTypeOnly, n9.name, n9.moduleReference) : o2(n9) ? Mm(n9, p, n9.importClause, n9.moduleSpecifier, n9.assertClause) : Vo(n9) ? Wu(n9, p, n9.expression) : cc(n9) ? Wm(n9, p, n9.isTypeOnly, n9.exportClause, n9.moduleSpecifier, n9.assertClause) : Y3.assertNever(n9);
            }
            function xt(n9) {
              return n9 ? Ne2(n9) : void 0;
            }
            function Qt(n9) {
              return typeof n9 == "string" ? Ut(n9) : n9;
            }
            function za(n9) {
              return typeof n9 == "string" ? er2(n9) : typeof n9 == "number" ? Gt(n9) : typeof n9 == "boolean" ? n9 ? ar2() : oi() : n9;
            }
            function Wa(n9) {
              return n9 && s().parenthesizeExpressionForDisallowedComma(n9);
            }
            function c6(n9) {
              return typeof n9 == "number" ? pr2(n9) : n9;
            }
            function Yn(n9) {
              return n9 && c2(n9) ? Rt(Dn(Du(), n9), n9) : n9;
            }
            function Xh(n9) {
              return typeof n9 == "string" || n9 && !Vi(n9) ? Cc(n9, void 0, void 0, void 0) : n9;
            }
          }
          function JL(e, t6) {
            return e !== t6 && Rt(e, t6), e;
          }
          function FL(e, t6) {
            return e !== t6 && (Dn(e, t6), Rt(e, t6)), e;
          }
          function ed(e) {
            switch (e) {
              case 347:
                return "type";
              case 345:
                return "returns";
              case 346:
                return "this";
              case 343:
                return "enum";
              case 333:
                return "author";
              case 335:
                return "class";
              case 336:
                return "public";
              case 337:
                return "private";
              case 338:
                return "protected";
              case 339:
                return "readonly";
              case 340:
                return "override";
              case 348:
                return "template";
              case 349:
                return "typedef";
              case 344:
                return "param";
              case 351:
                return "prop";
              case 341:
                return "callback";
              case 342:
                return "overload";
              case 331:
                return "augments";
              case 332:
                return "implements";
              default:
                return Y3.fail(`Unsupported kind: ${Y3.formatSyntaxKind(e)}`);
            }
          }
          function BL(e, t6) {
            switch (Hn || (Hn = Po(99, false, 0)), e) {
              case 14:
                Hn.setText("`" + t6 + "`");
                break;
              case 15:
                Hn.setText("`" + t6 + "${");
                break;
              case 16:
                Hn.setText("}" + t6 + "${");
                break;
              case 17:
                Hn.setText("}" + t6 + "`");
                break;
            }
            let r = Hn.scan();
            if (r === 19 && (r = Hn.reScanTemplateToken(false)), Hn.isUnterminated())
              return Hn.setText(void 0), qv;
            let s;
            switch (r) {
              case 14:
              case 15:
              case 16:
              case 17:
                s = Hn.getTokenValue();
                break;
            }
            return s === void 0 || Hn.scan() !== 1 ? (Hn.setText(void 0), qv) : (Hn.setText(void 0), s);
          }
          function ai(e) {
            return e && yt(e) ? ec(e) : ye(e);
          }
          function ec(e) {
            return ye(e) & -67108865;
          }
          function qL(e, t6) {
            return t6 | e.transformFlags & 134234112;
          }
          function ye(e) {
            if (!e)
              return 0;
            let t6 = e.transformFlags & ~w8(e.kind);
            return af(e) && vl(e.name) ? qL(e.name, t6) : t6;
          }
          function gt2(e) {
            return e ? e.transformFlags : 0;
          }
          function E8(e) {
            let t6 = 0;
            for (let r of e)
              t6 |= ye(r);
            e.transformFlags = t6;
          }
          function w8(e) {
            if (e >= 179 && e <= 202)
              return -2;
            switch (e) {
              case 210:
              case 211:
              case 206:
                return -2147450880;
              case 264:
                return -1941676032;
              case 166:
                return -2147483648;
              case 216:
                return -2072174592;
              case 215:
              case 259:
                return -1937940480;
              case 258:
                return -2146893824;
              case 260:
              case 228:
                return -2147344384;
              case 173:
                return -1937948672;
              case 169:
                return -2013249536;
              case 171:
              case 174:
              case 175:
                return -2005057536;
              case 131:
              case 148:
              case 160:
              case 144:
              case 152:
              case 149:
              case 134:
              case 153:
              case 114:
              case 165:
              case 168:
              case 170:
              case 176:
              case 177:
              case 178:
              case 261:
              case 262:
                return -2;
              case 207:
                return -2147278848;
              case 295:
                return -2147418112;
              case 203:
              case 204:
                return -2147450880;
              case 213:
              case 235:
              case 231:
              case 356:
              case 214:
              case 106:
                return -2147483648;
              case 208:
              case 209:
                return -2147483648;
              default:
                return -2147483648;
            }
          }
          function Fl(e) {
            return e.flags |= 8, e;
          }
          function UL(e, t6, r) {
            let s, f10, x10, w6, A6, g9, B, N10, X2, F2;
            Ji(e) ? (x10 = "", w6 = e, A6 = e.length, g9 = t6, B = r) : (Y3.assert(t6 === "js" || t6 === "dts"), x10 = (t6 === "js" ? e.javascriptPath : e.declarationPath) || "", g9 = t6 === "js" ? e.javascriptMapPath : e.declarationMapPath, N10 = () => t6 === "js" ? e.javascriptText : e.declarationText, X2 = () => t6 === "js" ? e.javascriptMapText : e.declarationMapText, A6 = () => N10().length, e.buildInfo && e.buildInfo.bundle && (Y3.assert(r === void 0 || typeof r == "boolean"), s = r, f10 = t6 === "js" ? e.buildInfo.bundle.js : e.buildInfo.bundle.dts, F2 = e.oldFileOfCurrentEmit));
            let $ = F2 ? WL(Y3.checkDefined(f10)) : zL(f10, s, A6);
            return $.fileName = x10, $.sourceMapPath = g9, $.oldFileOfCurrentEmit = F2, N10 && X2 ? (Object.defineProperty($, "text", { get: N10 }), Object.defineProperty($, "sourceMapText", { get: X2 })) : (Y3.assert(!F2), $.text = w6 != null ? w6 : "", $.sourceMapText = B), $;
          }
          function zL(e, t6, r) {
            let s, f10, x10, w6, A6, g9, B, N10;
            for (let F2 of e ? e.sections : Bt)
              switch (F2.kind) {
                case "prologue":
                  s = tr2(s, Rt(si.createUnparsedPrologue(F2.data), F2));
                  break;
                case "emitHelpers":
                  f10 = tr2(f10, getAllUnscopedEmitHelpers().get(F2.data));
                  break;
                case "no-default-lib":
                  N10 = true;
                  break;
                case "reference":
                  x10 = tr2(x10, { pos: -1, end: -1, fileName: F2.data });
                  break;
                case "type":
                  w6 = tr2(w6, { pos: -1, end: -1, fileName: F2.data });
                  break;
                case "type-import":
                  w6 = tr2(w6, { pos: -1, end: -1, fileName: F2.data, resolutionMode: 99 });
                  break;
                case "type-require":
                  w6 = tr2(w6, { pos: -1, end: -1, fileName: F2.data, resolutionMode: 1 });
                  break;
                case "lib":
                  A6 = tr2(A6, { pos: -1, end: -1, fileName: F2.data });
                  break;
                case "prepend":
                  let $;
                  for (let ae of F2.texts)
                    (!t6 || ae.kind !== "internal") && ($ = tr2($, Rt(si.createUnparsedTextLike(ae.data, ae.kind === "internal"), ae)));
                  g9 = jr2(g9, $), B = tr2(B, si.createUnparsedPrepend(F2.data, $ != null ? $ : Bt));
                  break;
                case "internal":
                  if (t6) {
                    B || (B = []);
                    break;
                  }
                case "text":
                  B = tr2(B, Rt(si.createUnparsedTextLike(F2.data, F2.kind === "internal"), F2));
                  break;
                default:
                  Y3.assertNever(F2);
              }
            if (!B) {
              let F2 = si.createUnparsedTextLike(void 0, false);
              $f(F2, 0, typeof r == "function" ? r() : r), B = [F2];
            }
            let X2 = dc.createUnparsedSource(s != null ? s : Bt, void 0, B);
            return Q_(s, X2), Q_(B, X2), Q_(g9, X2), X2.hasNoDefaultLib = N10, X2.helpers = f10, X2.referencedFiles = x10 || Bt, X2.typeReferenceDirectives = w6, X2.libReferenceDirectives = A6 || Bt, X2;
          }
          function WL(e) {
            let t6, r;
            for (let f10 of e.sections)
              switch (f10.kind) {
                case "internal":
                case "text":
                  t6 = tr2(t6, Rt(si.createUnparsedTextLike(f10.data, f10.kind === "internal"), f10));
                  break;
                case "no-default-lib":
                case "reference":
                case "type":
                case "type-import":
                case "type-require":
                case "lib":
                  r = tr2(r, Rt(si.createUnparsedSyntheticReference(f10), f10));
                  break;
                case "prologue":
                case "emitHelpers":
                case "prepend":
                  break;
                default:
                  Y3.assertNever(f10);
              }
            let s = si.createUnparsedSource(Bt, r, t6 != null ? t6 : Bt);
            return Q_(r, s), Q_(t6, s), s.helpers = Ze2(e.sources && e.sources.helpers, (f10) => getAllUnscopedEmitHelpers().get(f10)), s;
          }
          function VL(e, t6, r, s, f10, x10) {
            return Ji(e) ? A8(void 0, e, r, s, void 0, t6, f10, x10) : C8(e, t6, r, s, f10, x10);
          }
          function C8(e, t6, r, s, f10, x10, w6, A6) {
            let g9 = dc.createInputFiles();
            g9.javascriptPath = t6, g9.javascriptMapPath = r, g9.declarationPath = s, g9.declarationMapPath = f10, g9.buildInfoPath = x10;
            let B = /* @__PURE__ */ new Map(), N10 = (ae) => {
              if (ae === void 0)
                return;
              let Te2 = B.get(ae);
              return Te2 === void 0 && (Te2 = e(ae), B.set(ae, Te2 !== void 0 ? Te2 : false)), Te2 !== false ? Te2 : void 0;
            }, X2 = (ae) => {
              let Te2 = N10(ae);
              return Te2 !== void 0 ? Te2 : `/* Input file ${ae} was missing */\r
`;
            }, F2;
            return Object.defineProperties(g9, { javascriptText: { get: () => X2(t6) }, javascriptMapText: { get: () => N10(r) }, declarationText: { get: () => X2(Y3.checkDefined(s)) }, declarationMapText: { get: () => N10(f10) }, buildInfo: { get: () => {
              var ae, Te2;
              if (F2 === void 0 && x10)
                if (w6 != null && w6.getBuildInfo)
                  F2 = (ae = w6.getBuildInfo(x10, A6.configFilePath)) != null ? ae : false;
                else {
                  let Se2 = N10(x10);
                  F2 = Se2 !== void 0 && (Te2 = getBuildInfo(x10, Se2)) != null ? Te2 : false;
                }
              return F2 || void 0;
            } } }), g9;
          }
          function A8(e, t6, r, s, f10, x10, w6, A6, g9, B, N10) {
            let X2 = dc.createInputFiles();
            return X2.javascriptPath = e, X2.javascriptText = t6, X2.javascriptMapPath = r, X2.javascriptMapText = s, X2.declarationPath = f10, X2.declarationText = x10, X2.declarationMapPath = w6, X2.declarationMapText = A6, X2.buildInfoPath = g9, X2.buildInfo = B, X2.oldFileOfCurrentEmit = N10, X2;
          }
          function HL(e, t6, r) {
            return new (D8 || (D8 = lr2.getSourceMapSourceConstructor()))(e, t6, r);
          }
          function Dn(e, t6) {
            if (e.original = t6, t6) {
              let r = t6.emitNode;
              r && (e.emitNode = GL(r, e.emitNode));
            }
            return e;
          }
          function GL(e, t6) {
            let { flags: r, internalFlags: s, leadingComments: f10, trailingComments: x10, commentRange: w6, sourceMapRange: A6, tokenSourceMapRanges: g9, constantValue: B, helpers: N10, startsOnNewLine: X2, snippetElement: F2 } = e;
            if (t6 || (t6 = {}), f10 && (t6.leadingComments = jr2(f10.slice(), t6.leadingComments)), x10 && (t6.trailingComments = jr2(x10.slice(), t6.trailingComments)), r && (t6.flags = r), s && (t6.internalFlags = s & -9), w6 && (t6.commentRange = w6), A6 && (t6.sourceMapRange = A6), g9 && (t6.tokenSourceMapRanges = $L(g9, t6.tokenSourceMapRanges)), B !== void 0 && (t6.constantValue = B), N10)
              for (let $ of N10)
                t6.helpers = g_(t6.helpers, $);
            return X2 !== void 0 && (t6.startsOnNewLine = X2), F2 !== void 0 && (t6.snippetElement = F2), t6;
          }
          function $L(e, t6) {
            t6 || (t6 = []);
            for (let r in e)
              t6[r] = e[r];
            return t6;
          }
          var Bl, Fv, Bv, Hn, qv, tc, P8, si, D8, KL = D({ "src/compiler/factory/nodeFactory.ts"() {
            "use strict";
            nn(), Bl = 0, Fv = ((e) => (e[e.None = 0] = "None", e[e.NoParenthesizerRules = 1] = "NoParenthesizerRules", e[e.NoNodeConverters = 2] = "NoNodeConverters", e[e.NoIndentationOnFreshPropertyAccess = 4] = "NoIndentationOnFreshPropertyAccess", e[e.NoOriginalNode = 8] = "NoOriginalNode", e))(Fv || {}), Bv = [], qv = {}, tc = S8(), P8 = { createBaseSourceFileNode: (e) => Fl(tc.createBaseSourceFileNode(e)), createBaseIdentifierNode: (e) => Fl(tc.createBaseIdentifierNode(e)), createBasePrivateIdentifierNode: (e) => Fl(tc.createBasePrivateIdentifierNode(e)), createBaseTokenNode: (e) => Fl(tc.createBaseTokenNode(e)), createBaseNode: (e) => Fl(tc.createBaseNode(e)) }, si = Zf(4, P8);
          } }), XL = () => {
          }, YL = () => {
          };
          function zs(e) {
            return e.kind === 8;
          }
          function Uv(e) {
            return e.kind === 9;
          }
          function Gn(e) {
            return e.kind === 10;
          }
          function td(e) {
            return e.kind === 11;
          }
          function QL(e) {
            return e.kind === 13;
          }
          function k8(e) {
            return e.kind === 14;
          }
          function ZL(e) {
            return e.kind === 15;
          }
          function eR(e) {
            return e.kind === 16;
          }
          function tR(e) {
            return e.kind === 17;
          }
          function rR(e) {
            return e.kind === 25;
          }
          function I8(e) {
            return e.kind === 27;
          }
          function zv(e) {
            return e.kind === 39;
          }
          function Wv(e) {
            return e.kind === 40;
          }
          function nR(e) {
            return e.kind === 41;
          }
          function rd(e) {
            return e.kind === 53;
          }
          function ql(e) {
            return e.kind === 57;
          }
          function iR(e) {
            return e.kind === 58;
          }
          function aR(e) {
            return e.kind === 28;
          }
          function sR(e) {
            return e.kind === 38;
          }
          function yt(e) {
            return e.kind === 79;
          }
          function vn(e) {
            return e.kind === 80;
          }
          function N8(e) {
            return e.kind === 93;
          }
          function oR(e) {
            return e.kind === 88;
          }
          function Ul(e) {
            return e.kind === 132;
          }
          function _R(e) {
            return e.kind === 129;
          }
          function cR(e) {
            return e.kind === 133;
          }
          function O8(e) {
            return e.kind === 146;
          }
          function lR(e) {
            return e.kind === 124;
          }
          function uR(e) {
            return e.kind === 126;
          }
          function pR(e) {
            return e.kind === 161;
          }
          function fR(e) {
            return e.kind === 127;
          }
          function nd(e) {
            return e.kind === 106;
          }
          function M8(e) {
            return e.kind === 100;
          }
          function dR(e) {
            return e.kind === 82;
          }
          function rc(e) {
            return e.kind === 163;
          }
          function Ws(e) {
            return e.kind === 164;
          }
          function Fo(e) {
            return e.kind === 165;
          }
          function Vs(e) {
            return e.kind === 166;
          }
          function zl(e) {
            return e.kind === 167;
          }
          function Wl(e) {
            return e.kind === 168;
          }
          function Bo(e) {
            return e.kind === 169;
          }
          function L8(e) {
            return e.kind === 170;
          }
          function Vl(e) {
            return e.kind === 171;
          }
          function Hl(e) {
            return e.kind === 172;
          }
          function nc(e) {
            return e.kind === 173;
          }
          function Gl(e) {
            return e.kind === 174;
          }
          function ic(e) {
            return e.kind === 175;
          }
          function Vv(e) {
            return e.kind === 176;
          }
          function R8(e) {
            return e.kind === 177;
          }
          function Hv(e) {
            return e.kind === 178;
          }
          function j8(e) {
            return e.kind === 179;
          }
          function ac(e) {
            return e.kind === 180;
          }
          function $l(e) {
            return e.kind === 181;
          }
          function Gv(e) {
            return e.kind === 182;
          }
          function J8(e) {
            return e.kind === 183;
          }
          function id(e) {
            return e.kind === 184;
          }
          function F8(e) {
            return e.kind === 185;
          }
          function B8(e) {
            return e.kind === 186;
          }
          function $v(e) {
            return e.kind === 199;
          }
          function q8(e) {
            return e.kind === 187;
          }
          function U8(e) {
            return e.kind === 188;
          }
          function z8(e) {
            return e.kind === 189;
          }
          function W8(e) {
            return e.kind === 190;
          }
          function V8(e) {
            return e.kind === 191;
          }
          function H8(e) {
            return e.kind === 192;
          }
          function Kv(e) {
            return e.kind === 193;
          }
          function Xv(e) {
            return e.kind === 194;
          }
          function G8(e) {
            return e.kind === 195;
          }
          function $8(e) {
            return e.kind === 196;
          }
          function K8(e) {
            return e.kind === 197;
          }
          function Yv(e) {
            return e.kind === 198;
          }
          function Kl(e) {
            return e.kind === 202;
          }
          function mR(e) {
            return e.kind === 201;
          }
          function hR(e) {
            return e.kind === 200;
          }
          function gR(e) {
            return e.kind === 203;
          }
          function yR(e) {
            return e.kind === 204;
          }
          function Xl(e) {
            return e.kind === 205;
          }
          function Yl(e) {
            return e.kind === 206;
          }
          function Hs(e) {
            return e.kind === 207;
          }
          function bn(e) {
            return e.kind === 208;
          }
          function gs(e) {
            return e.kind === 209;
          }
          function sc(e) {
            return e.kind === 210;
          }
          function X8(e) {
            return e.kind === 211;
          }
          function Y8(e) {
            return e.kind === 212;
          }
          function vR(e) {
            return e.kind === 213;
          }
          function qo(e) {
            return e.kind === 214;
          }
          function ad(e) {
            return e.kind === 215;
          }
          function sd(e) {
            return e.kind === 216;
          }
          function bR(e) {
            return e.kind === 217;
          }
          function TR(e) {
            return e.kind === 218;
          }
          function Qv(e) {
            return e.kind === 219;
          }
          function SR(e) {
            return e.kind === 220;
          }
          function od(e) {
            return e.kind === 221;
          }
          function Q8(e) {
            return e.kind === 222;
          }
          function ur2(e) {
            return e.kind === 223;
          }
          function xR(e) {
            return e.kind === 224;
          }
          function ER(e) {
            return e.kind === 225;
          }
          function wR(e) {
            return e.kind === 226;
          }
          function Zv(e) {
            return e.kind === 227;
          }
          function _d(e) {
            return e.kind === 228;
          }
          function cd(e) {
            return e.kind === 229;
          }
          function e2(e) {
            return e.kind === 230;
          }
          function CR(e) {
            return e.kind === 231;
          }
          function AR(e) {
            return e.kind === 235;
          }
          function Uo(e) {
            return e.kind === 232;
          }
          function t2(e) {
            return e.kind === 233;
          }
          function PR(e) {
            return e.kind === 234;
          }
          function Z8(e) {
            return e.kind === 356;
          }
          function oc(e) {
            return e.kind === 357;
          }
          function DR(e) {
            return e.kind === 236;
          }
          function kR(e) {
            return e.kind === 237;
          }
          function Ql(e) {
            return e.kind === 238;
          }
          function zo(e) {
            return e.kind === 240;
          }
          function IR(e) {
            return e.kind === 239;
          }
          function Zl(e) {
            return e.kind === 241;
          }
          function NR(e) {
            return e.kind === 242;
          }
          function OR(e) {
            return e.kind === 243;
          }
          function MR(e) {
            return e.kind === 244;
          }
          function eE(e) {
            return e.kind === 245;
          }
          function LR(e) {
            return e.kind === 246;
          }
          function RR(e) {
            return e.kind === 247;
          }
          function jR(e) {
            return e.kind === 248;
          }
          function JR(e) {
            return e.kind === 249;
          }
          function FR(e) {
            return e.kind === 250;
          }
          function BR(e) {
            return e.kind === 251;
          }
          function qR(e) {
            return e.kind === 252;
          }
          function tE(e) {
            return e.kind === 253;
          }
          function UR(e) {
            return e.kind === 254;
          }
          function zR(e) {
            return e.kind === 255;
          }
          function WR(e) {
            return e.kind === 256;
          }
          function Vi(e) {
            return e.kind === 257;
          }
          function r2(e) {
            return e.kind === 258;
          }
          function Wo(e) {
            return e.kind === 259;
          }
          function _c(e) {
            return e.kind === 260;
          }
          function eu(e) {
            return e.kind === 261;
          }
          function n2(e) {
            return e.kind === 262;
          }
          function i22(e) {
            return e.kind === 263;
          }
          function Ea(e) {
            return e.kind === 264;
          }
          function rE(e) {
            return e.kind === 265;
          }
          function VR(e) {
            return e.kind === 266;
          }
          function a2(e) {
            return e.kind === 267;
          }
          function s2(e) {
            return e.kind === 268;
          }
          function o2(e) {
            return e.kind === 269;
          }
          function HR(e) {
            return e.kind === 270;
          }
          function GR(e) {
            return e.kind === 298;
          }
          function $R(e) {
            return e.kind === 296;
          }
          function KR(e) {
            return e.kind === 297;
          }
          function _2(e) {
            return e.kind === 271;
          }
          function ld(e) {
            return e.kind === 277;
          }
          function XR(e) {
            return e.kind === 272;
          }
          function nE(e) {
            return e.kind === 273;
          }
          function Vo(e) {
            return e.kind === 274;
          }
          function cc(e) {
            return e.kind === 275;
          }
          function iE(e) {
            return e.kind === 276;
          }
          function aE(e) {
            return e.kind === 278;
          }
          function YR(e) {
            return e.kind === 279;
          }
          function c2(e) {
            return e.kind === 355;
          }
          function QR(e) {
            return e.kind === 360;
          }
          function ZR(e) {
            return e.kind === 358;
          }
          function ej(e) {
            return e.kind === 359;
          }
          function ud(e) {
            return e.kind === 280;
          }
          function l2(e) {
            return e.kind === 281;
          }
          function tj(e) {
            return e.kind === 282;
          }
          function tu(e) {
            return e.kind === 283;
          }
          function sE(e) {
            return e.kind === 284;
          }
          function pd(e) {
            return e.kind === 285;
          }
          function u2(e) {
            return e.kind === 286;
          }
          function rj(e) {
            return e.kind === 287;
          }
          function nj(e) {
            return e.kind === 288;
          }
          function p2(e) {
            return e.kind === 289;
          }
          function ij(e) {
            return e.kind === 290;
          }
          function aj(e) {
            return e.kind === 291;
          }
          function sj(e) {
            return e.kind === 292;
          }
          function oE(e) {
            return e.kind === 293;
          }
          function ru(e) {
            return e.kind === 294;
          }
          function oj(e) {
            return e.kind === 295;
          }
          function lc(e) {
            return e.kind === 299;
          }
          function nu(e) {
            return e.kind === 300;
          }
          function _E(e) {
            return e.kind === 301;
          }
          function cE(e) {
            return e.kind === 302;
          }
          function _j(e) {
            return e.kind === 304;
          }
          function wi(e) {
            return e.kind === 308;
          }
          function cj(e) {
            return e.kind === 309;
          }
          function lj(e) {
            return e.kind === 310;
          }
          function lE(e) {
            return e.kind === 312;
          }
          function fd(e) {
            return e.kind === 313;
          }
          function uc(e) {
            return e.kind === 314;
          }
          function uj(e) {
            return e.kind === 327;
          }
          function pj(e) {
            return e.kind === 328;
          }
          function fj(e) {
            return e.kind === 329;
          }
          function dj(e) {
            return e.kind === 315;
          }
          function mj(e) {
            return e.kind === 316;
          }
          function uE(e) {
            return e.kind === 317;
          }
          function hj(e) {
            return e.kind === 318;
          }
          function gj(e) {
            return e.kind === 319;
          }
          function dd(e) {
            return e.kind === 320;
          }
          function yj(e) {
            return e.kind === 321;
          }
          function vj(e) {
            return e.kind === 322;
          }
          function Ho(e) {
            return e.kind === 323;
          }
          function f2(e) {
            return e.kind === 325;
          }
          function iu(e) {
            return e.kind === 326;
          }
          function md(e) {
            return e.kind === 331;
          }
          function bj(e) {
            return e.kind === 333;
          }
          function pE(e) {
            return e.kind === 335;
          }
          function Tj(e) {
            return e.kind === 341;
          }
          function d22(e) {
            return e.kind === 336;
          }
          function m2(e) {
            return e.kind === 337;
          }
          function h2(e) {
            return e.kind === 338;
          }
          function g2(e) {
            return e.kind === 339;
          }
          function fE(e) {
            return e.kind === 340;
          }
          function y2(e) {
            return e.kind === 342;
          }
          function v22(e) {
            return e.kind === 334;
          }
          function Sj(e) {
            return e.kind === 350;
          }
          function dE(e) {
            return e.kind === 343;
          }
          function pc(e) {
            return e.kind === 344;
          }
          function b2(e) {
            return e.kind === 345;
          }
          function mE(e) {
            return e.kind === 346;
          }
          function au(e) {
            return e.kind === 347;
          }
          function Go(e) {
            return e.kind === 348;
          }
          function xj(e) {
            return e.kind === 349;
          }
          function Ej(e) {
            return e.kind === 330;
          }
          function wj(e) {
            return e.kind === 351;
          }
          function hE(e) {
            return e.kind === 332;
          }
          function T2(e) {
            return e.kind === 353;
          }
          function Cj(e) {
            return e.kind === 352;
          }
          function Aj(e) {
            return e.kind === 354;
          }
          var Pj = D({ "src/compiler/factory/nodeTests.ts"() {
            "use strict";
            nn();
          } });
          function Dj(e) {
            return e.createExportDeclaration(void 0, false, e.createNamedExports([]), void 0);
          }
          function hd(e, t6, r, s) {
            if (Ws(r))
              return Rt(e.createElementAccessExpression(t6, r.expression), s);
            {
              let f10 = Rt(js(r) ? e.createPropertyAccessExpression(t6, r) : e.createElementAccessExpression(t6, r), r);
              return addEmitFlags(f10, 128), f10;
            }
          }
          function S2(e, t6) {
            let r = dc.createIdentifier(e || "React");
            return Sa(r, fl(t6)), r;
          }
          function x2(e, t6, r) {
            if (rc(t6)) {
              let s = x2(e, t6.left, r), f10 = e.createIdentifier(qr2(t6.right));
              return f10.escapedText = t6.right.escapedText, e.createPropertyAccessExpression(s, f10);
            } else
              return S2(qr2(t6), r);
          }
          function gE(e, t6, r, s) {
            return t6 ? x2(e, t6, s) : e.createPropertyAccessExpression(S2(r, s), "createElement");
          }
          function kj(e, t6, r, s) {
            return t6 ? x2(e, t6, s) : e.createPropertyAccessExpression(S2(r, s), "Fragment");
          }
          function Ij(e, t6, r, s, f10, x10) {
            let w6 = [r];
            if (s && w6.push(s), f10 && f10.length > 0)
              if (s || w6.push(e.createNull()), f10.length > 1)
                for (let A6 of f10)
                  vd(A6), w6.push(A6);
              else
                w6.push(f10[0]);
            return Rt(e.createCallExpression(t6, void 0, w6), x10);
          }
          function Nj(e, t6, r, s, f10, x10, w6) {
            let g9 = [kj(e, r, s, x10), e.createNull()];
            if (f10 && f10.length > 0)
              if (f10.length > 1)
                for (let B of f10)
                  vd(B), g9.push(B);
              else
                g9.push(f10[0]);
            return Rt(e.createCallExpression(gE(e, t6, s, x10), void 0, g9), w6);
          }
          function Oj(e, t6, r) {
            if (r2(t6)) {
              let s = fo2(t6.declarations), f10 = e.updateVariableDeclaration(s, s.name, void 0, void 0, r);
              return Rt(e.createVariableStatement(void 0, e.updateVariableDeclarationList(t6, [f10])), t6);
            } else {
              let s = Rt(e.createAssignment(t6, r), t6);
              return Rt(e.createExpressionStatement(s), t6);
            }
          }
          function Mj(e, t6, r) {
            return Ql(t6) ? e.updateBlock(t6, Rt(e.createNodeArray([r, ...t6.statements]), t6.statements)) : e.createBlock(e.createNodeArray([t6, r]), true);
          }
          function yE(e, t6) {
            if (rc(t6)) {
              let r = yE(e, t6.left), s = Sa(Rt(e.cloneNode(t6.right), t6.right), t6.right.parent);
              return Rt(e.createPropertyAccessExpression(r, s), t6);
            } else
              return Sa(Rt(e.cloneNode(t6), t6), t6.parent);
          }
          function vE(e, t6) {
            return yt(t6) ? e.createStringLiteralFromNode(t6) : Ws(t6) ? Sa(Rt(e.cloneNode(t6.expression), t6.expression), t6.expression.parent) : Sa(Rt(e.cloneNode(t6), t6), t6.parent);
          }
          function Lj(e, t6, r, s, f10) {
            let { firstAccessor: x10, getAccessor: w6, setAccessor: A6 } = W0(t6, r);
            if (r === x10)
              return Rt(e.createObjectDefinePropertyCall(s, vE(e, r.name), e.createPropertyDescriptor({ enumerable: e.createFalse(), configurable: true, get: w6 && Rt(Dn(e.createFunctionExpression(sf(w6), void 0, void 0, void 0, w6.parameters, void 0, w6.body), w6), w6), set: A6 && Rt(Dn(e.createFunctionExpression(sf(A6), void 0, void 0, void 0, A6.parameters, void 0, A6.body), A6), A6) }, !f10)), x10);
          }
          function Rj(e, t6, r) {
            return Dn(Rt(e.createAssignment(hd(e, r, t6.name, t6.name), t6.initializer), t6), t6);
          }
          function jj(e, t6, r) {
            return Dn(Rt(e.createAssignment(hd(e, r, t6.name, t6.name), e.cloneNode(t6.name)), t6), t6);
          }
          function Jj(e, t6, r) {
            return Dn(Rt(e.createAssignment(hd(e, r, t6.name, t6.name), Dn(Rt(e.createFunctionExpression(sf(t6), t6.asteriskToken, void 0, void 0, t6.parameters, void 0, t6.body), t6), t6)), t6), t6);
          }
          function Fj(e, t6, r, s) {
            switch (r.name && vn(r.name) && Y3.failBadSyntaxKind(r.name, "Private identifiers are not allowed in object literals."), r.kind) {
              case 174:
              case 175:
                return Lj(e, t6.properties, r, s, !!t6.multiLine);
              case 299:
                return Rj(e, r, s);
              case 300:
                return jj(e, r, s);
              case 171:
                return Jj(e, r, s);
            }
          }
          function Bj(e, t6, r, s, f10) {
            let x10 = t6.operator;
            Y3.assert(x10 === 45 || x10 === 46, "Expected 'node' to be a pre- or post-increment or pre- or post-decrement expression");
            let w6 = e.createTempVariable(s);
            r = e.createAssignment(w6, r), Rt(r, t6.operand);
            let A6 = od(t6) ? e.createPrefixUnaryExpression(x10, w6) : e.createPostfixUnaryExpression(w6, x10);
            return Rt(A6, t6), f10 && (A6 = e.createAssignment(f10, A6), Rt(A6, t6)), r = e.createComma(r, A6), Rt(r, t6), Q8(t6) && (r = e.createComma(r, w6), Rt(r, t6)), r;
          }
          function qj(e) {
            return (xi(e) & 65536) !== 0;
          }
          function E2(e) {
            return (xi(e) & 32768) !== 0;
          }
          function Uj(e) {
            return (xi(e) & 16384) !== 0;
          }
          function bE(e) {
            return Gn(e.expression) && e.expression.text === "use strict";
          }
          function TE(e) {
            for (let t6 of e)
              if (us(t6)) {
                if (bE(t6))
                  return t6;
              } else
                break;
          }
          function SE(e) {
            let t6 = pa(e);
            return t6 !== void 0 && us(t6) && bE(t6);
          }
          function gd(e) {
            return e.kind === 223 && e.operatorToken.kind === 27;
          }
          function zj(e) {
            return gd(e) || oc(e);
          }
          function xE(e) {
            return qo(e) && Pr(e) && !!_f(e);
          }
          function Wj(e) {
            let t6 = cf(e);
            return Y3.assertIsDefined(t6), t6;
          }
          function yd(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 15;
            switch (e.kind) {
              case 214:
                return t6 & 16 && xE(e) ? false : (t6 & 1) !== 0;
              case 213:
              case 231:
              case 230:
              case 235:
                return (t6 & 2) !== 0;
              case 232:
                return (t6 & 4) !== 0;
              case 356:
                return (t6 & 8) !== 0;
            }
            return false;
          }
          function $o(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 15;
            for (; yd(e, t6); )
              e = e.expression;
            return e;
          }
          function Vj(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 15, r = e.parent;
            for (; yd(r, t6); )
              r = r.parent, Y3.assert(r);
            return r;
          }
          function Hj(e) {
            return $o(e, 6);
          }
          function vd(e) {
            return setStartsOnNewLine(e, true);
          }
          function EE(e) {
            let t6 = ul(e, wi), r = t6 && t6.emitNode;
            return r && r.externalHelpersModuleName;
          }
          function Gj(e) {
            let t6 = ul(e, wi), r = t6 && t6.emitNode;
            return !!r && (!!r.externalHelpersModuleName || !!r.externalHelpers);
          }
          function $j(e, t6, r, s, f10, x10, w6) {
            if (s.importHelpers && Yy(r, s)) {
              let A6, g9 = Ei(s);
              if (g9 >= 5 && g9 <= 99 || r.impliedNodeFormat === 99) {
                let B = getEmitHelpers(r);
                if (B) {
                  let N10 = [];
                  for (let X2 of B)
                    if (!X2.scoped) {
                      let F2 = X2.importName;
                      F2 && qn(N10, F2);
                    }
                  if (Ke3(N10)) {
                    N10.sort(ri), A6 = e.createNamedImports(Ze2(N10, ($) => m3(r, $) ? e.createImportSpecifier(false, void 0, e.createIdentifier($)) : e.createImportSpecifier(false, e.createIdentifier($), t6.getUnscopedHelperName($))));
                    let X2 = ul(r, wi), F2 = getOrCreateEmitNode(X2);
                    F2.externalHelpers = true;
                  }
                }
              } else {
                let B = wE(e, r, s, f10, x10 || w6);
                B && (A6 = e.createNamespaceImport(B));
              }
              if (A6) {
                let B = e.createImportDeclaration(void 0, e.createImportClause(false, void 0, A6), e.createStringLiteral(Kf), void 0);
                return addInternalEmitFlags(B, 2), B;
              }
            }
          }
          function wE(e, t6, r, s, f10) {
            if (r.importHelpers && Yy(t6, r)) {
              let x10 = EE(t6);
              if (x10)
                return x10;
              let w6 = Ei(r), A6 = (s || ov(r) && f10) && w6 !== 4 && (w6 < 5 || t6.impliedNodeFormat === 1);
              if (!A6) {
                let g9 = getEmitHelpers(t6);
                if (g9) {
                  for (let B of g9)
                    if (!B.scoped) {
                      A6 = true;
                      break;
                    }
                }
              }
              if (A6) {
                let g9 = ul(t6, wi), B = getOrCreateEmitNode(g9);
                return B.externalHelpersModuleName || (B.externalHelpersModuleName = e.createUniqueName(Kf));
              }
            }
          }
          function Kj(e, t6, r) {
            let s = Q3(t6);
            if (s && !Z3(t6) && !b3(t6)) {
              let f10 = s.name;
              return cs(f10) ? f10 : e.createIdentifier(No(r, f10) || qr2(f10));
            }
            if (t6.kind === 269 && t6.importClause || t6.kind === 275 && t6.moduleSpecifier)
              return e.getGeneratedNameForNode(t6);
          }
          function Xj(e, t6, r, s, f10, x10) {
            let w6 = E0(t6);
            if (w6 && Gn(w6))
              return Qj(t6, s, e, f10, x10) || Yj(e, w6, r) || e.cloneNode(w6);
          }
          function Yj(e, t6, r) {
            let s = r.renamedDependencies && r.renamedDependencies.get(t6.text);
            return s ? e.createStringLiteral(s) : void 0;
          }
          function CE(e, t6, r, s) {
            if (t6) {
              if (t6.moduleName)
                return e.createStringLiteral(t6.moduleName);
              if (!t6.isDeclarationFile && B0(s))
                return e.createStringLiteral(F0(r, t6.fileName));
            }
          }
          function Qj(e, t6, r, s, f10) {
            return CE(r, s.getExternalModuleFileFromDeclaration(e), t6, f10);
          }
          function AE(e) {
            if (Fy(e))
              return e.initializer;
            if (lc(e)) {
              let t6 = e.initializer;
              return ms(t6, true) ? t6.right : void 0;
            }
            if (nu(e))
              return e.objectAssignmentInitializer;
            if (ms(e, true))
              return e.right;
            if (Zv(e))
              return AE(e.expression);
          }
          function Ko(e) {
            if (Fy(e))
              return e.name;
            if (jy(e)) {
              switch (e.kind) {
                case 299:
                  return Ko(e.initializer);
                case 300:
                  return e.name;
                case 301:
                  return Ko(e.expression);
              }
              return;
            }
            return ms(e, true) ? Ko(e.left) : Zv(e) ? Ko(e.expression) : e;
          }
          function Zj(e) {
            switch (e.kind) {
              case 166:
              case 205:
                return e.dotDotDotToken;
              case 227:
              case 301:
                return e;
            }
          }
          function eJ(e) {
            let t6 = PE(e);
            return Y3.assert(!!t6 || _E(e), "Invalid property name for binding element."), t6;
          }
          function PE(e) {
            switch (e.kind) {
              case 205:
                if (e.propertyName) {
                  let r = e.propertyName;
                  return vn(r) ? Y3.failBadSyntaxKind(r) : Ws(r) && DE(r.expression) ? r.expression : r;
                }
                break;
              case 299:
                if (e.name) {
                  let r = e.name;
                  return vn(r) ? Y3.failBadSyntaxKind(r) : Ws(r) && DE(r.expression) ? r.expression : r;
                }
                break;
              case 301:
                return e.name && vn(e.name) ? Y3.failBadSyntaxKind(e.name) : e.name;
            }
            let t6 = Ko(e);
            if (t6 && vl(t6))
              return t6;
          }
          function DE(e) {
            let t6 = e.kind;
            return t6 === 10 || t6 === 8;
          }
          function kE(e) {
            switch (e.kind) {
              case 203:
              case 204:
              case 206:
                return e.elements;
              case 207:
                return e.properties;
            }
          }
          function w2(e) {
            if (e) {
              let t6 = e;
              for (; ; ) {
                if (yt(t6) || !t6.body)
                  return yt(t6) ? t6 : t6.name;
                t6 = t6.body;
              }
            }
          }
          function tJ(e) {
            let t6 = e.kind;
            return t6 === 173 || t6 === 175;
          }
          function IE(e) {
            let t6 = e.kind;
            return t6 === 173 || t6 === 174 || t6 === 175;
          }
          function rJ(e) {
            let t6 = e.kind;
            return t6 === 299 || t6 === 300 || t6 === 259 || t6 === 173 || t6 === 178 || t6 === 172 || t6 === 279 || t6 === 240 || t6 === 261 || t6 === 262 || t6 === 263 || t6 === 264 || t6 === 268 || t6 === 269 || t6 === 267 || t6 === 275 || t6 === 274;
          }
          function nJ(e) {
            let t6 = e.kind;
            return t6 === 172 || t6 === 299 || t6 === 300 || t6 === 279 || t6 === 267;
          }
          function iJ(e) {
            return ql(e) || rd(e);
          }
          function aJ(e) {
            return yt(e) || Xv(e);
          }
          function sJ(e) {
            return O8(e) || zv(e) || Wv(e);
          }
          function oJ(e) {
            return ql(e) || zv(e) || Wv(e);
          }
          function _J(e) {
            return yt(e) || Gn(e);
          }
          function cJ(e) {
            let t6 = e.kind;
            return t6 === 104 || t6 === 110 || t6 === 95 || Iy(e) || od(e);
          }
          function lJ(e) {
            return e === 42;
          }
          function uJ(e) {
            return e === 41 || e === 43 || e === 44;
          }
          function pJ(e) {
            return lJ(e) || uJ(e);
          }
          function fJ(e) {
            return e === 39 || e === 40;
          }
          function dJ(e) {
            return fJ(e) || pJ(e);
          }
          function mJ(e) {
            return e === 47 || e === 48 || e === 49;
          }
          function hJ(e) {
            return mJ(e) || dJ(e);
          }
          function gJ(e) {
            return e === 29 || e === 32 || e === 31 || e === 33 || e === 102 || e === 101;
          }
          function yJ(e) {
            return gJ(e) || hJ(e);
          }
          function vJ(e) {
            return e === 34 || e === 36 || e === 35 || e === 37;
          }
          function bJ(e) {
            return vJ(e) || yJ(e);
          }
          function TJ(e) {
            return e === 50 || e === 51 || e === 52;
          }
          function SJ(e) {
            return TJ(e) || bJ(e);
          }
          function xJ(e) {
            return e === 55 || e === 56;
          }
          function EJ(e) {
            return xJ(e) || SJ(e);
          }
          function wJ(e) {
            return e === 60 || EJ(e) || G_(e);
          }
          function CJ(e) {
            return wJ(e) || e === 27;
          }
          function AJ(e) {
            return CJ(e.kind);
          }
          function PJ(e, t6, r, s, f10, x10) {
            let w6 = new OE(e, t6, r, s, f10, x10);
            return A6;
            function A6(g9, B) {
              let N10 = { value: void 0 }, X2 = [Td2.enter], F2 = [g9], $ = [void 0], ae = 0;
              for (; X2[ae] !== Td2.done; )
                ae = X2[ae](w6, ae, X2, F2, $, N10, B);
              return Y3.assertEqual(ae, 0), N10.value;
            }
          }
          function NE(e) {
            return e === 93 || e === 88;
          }
          function DJ(e) {
            let t6 = e.kind;
            return NE(t6);
          }
          function kJ(e) {
            let t6 = e.kind;
            return Wi(t6) && !NE(t6);
          }
          function IJ(e, t6) {
            if (t6 !== void 0)
              return t6.length === 0 ? t6 : Rt(e.createNodeArray([], t6.hasTrailingComma), t6);
          }
          function NJ(e) {
            var t6;
            let r = e.emitNode.autoGenerate;
            if (r.flags & 4) {
              let s = r.id, f10 = e, x10 = f10.original;
              for (; x10; ) {
                f10 = x10;
                let w6 = (t6 = f10.emitNode) == null ? void 0 : t6.autoGenerate;
                if (js(f10) && (w6 === void 0 || w6.flags & 4 && w6.id !== s))
                  break;
                x10 = f10.original;
              }
              return f10;
            }
            return e;
          }
          function C22(e, t6) {
            return typeof e == "object" ? bd(false, e.prefix, e.node, e.suffix, t6) : typeof e == "string" ? e.length > 0 && e.charCodeAt(0) === 35 ? e.slice(1) : e : "";
          }
          function OJ(e, t6) {
            return typeof e == "string" ? e : MJ(e, Y3.checkDefined(t6));
          }
          function MJ(e, t6) {
            return Ny(e) ? t6(e).slice(1) : cs(e) ? t6(e) : vn(e) ? e.escapedText.slice(1) : qr2(e);
          }
          function bd(e, t6, r, s, f10) {
            return t6 = C22(t6, f10), s = C22(s, f10), r = OJ(r, f10), `${e ? "#" : ""}${t6}${r}${s}`;
          }
          function LJ(e, t6, r, s) {
            return e.updatePropertyDeclaration(t6, r, e.getGeneratedPrivateNameForNode(t6.name, void 0, "_accessor_storage"), void 0, void 0, s);
          }
          function RJ(e, t6, r, s) {
            return e.createGetAccessorDeclaration(r, s, [], void 0, e.createBlock([e.createReturnStatement(e.createPropertyAccessExpression(e.createThis(), e.getGeneratedPrivateNameForNode(t6.name, void 0, "_accessor_storage")))]));
          }
          function jJ(e, t6, r, s) {
            return e.createSetAccessorDeclaration(r, s, [e.createParameterDeclaration(void 0, void 0, "value")], e.createBlock([e.createExpressionStatement(e.createAssignment(e.createPropertyAccessExpression(e.createThis(), e.getGeneratedPrivateNameForNode(t6.name, void 0, "_accessor_storage")), e.createIdentifier("value")))]));
          }
          function JJ(e) {
            let t6 = e.expression;
            for (; ; ) {
              if (t6 = $o(t6), oc(t6)) {
                t6 = Zn(t6.elements);
                continue;
              }
              if (gd(t6)) {
                t6 = t6.right;
                continue;
              }
              if (ms(t6, true) && cs(t6.left))
                return t6;
              break;
            }
          }
          function FJ(e) {
            return qo(e) && fs(e) && !e.emitNode;
          }
          function su(e, t6) {
            if (FJ(e))
              su(e.expression, t6);
            else if (gd(e))
              su(e.left, t6), su(e.right, t6);
            else if (oc(e))
              for (let r of e.elements)
                su(r, t6);
            else
              t6.push(e);
          }
          function BJ(e) {
            let t6 = [];
            return su(e, t6), t6;
          }
          function A2(e) {
            if (e.transformFlags & 65536)
              return true;
            if (e.transformFlags & 128)
              for (let t6 of kE(e)) {
                let r = Ko(t6);
                if (r && KS(r) && (r.transformFlags & 65536 || r.transformFlags & 128 && A2(r)))
                  return true;
              }
            return false;
          }
          var Td2, OE, qJ = D({ "src/compiler/factory/utilities.ts"() {
            "use strict";
            nn(), ((e) => {
              function t6(N10, X2, F2, $, ae, Te2, Se2) {
                let Ye2 = X2 > 0 ? ae[X2 - 1] : void 0;
                return Y3.assertEqual(F2[X2], t6), ae[X2] = N10.onEnter($[X2], Ye2, Se2), F2[X2] = A6(N10, t6), X2;
              }
              e.enter = t6;
              function r(N10, X2, F2, $, ae, Te2, Se2) {
                Y3.assertEqual(F2[X2], r), Y3.assertIsDefined(N10.onLeft), F2[X2] = A6(N10, r);
                let Ye2 = N10.onLeft($[X2].left, ae[X2], $[X2]);
                return Ye2 ? (B(X2, $, Ye2), g9(X2, F2, $, ae, Ye2)) : X2;
              }
              e.left = r;
              function s(N10, X2, F2, $, ae, Te2, Se2) {
                return Y3.assertEqual(F2[X2], s), Y3.assertIsDefined(N10.onOperator), F2[X2] = A6(N10, s), N10.onOperator($[X2].operatorToken, ae[X2], $[X2]), X2;
              }
              e.operator = s;
              function f10(N10, X2, F2, $, ae, Te2, Se2) {
                Y3.assertEqual(F2[X2], f10), Y3.assertIsDefined(N10.onRight), F2[X2] = A6(N10, f10);
                let Ye2 = N10.onRight($[X2].right, ae[X2], $[X2]);
                return Ye2 ? (B(X2, $, Ye2), g9(X2, F2, $, ae, Ye2)) : X2;
              }
              e.right = f10;
              function x10(N10, X2, F2, $, ae, Te2, Se2) {
                Y3.assertEqual(F2[X2], x10), F2[X2] = A6(N10, x10);
                let Ye2 = N10.onExit($[X2], ae[X2]);
                if (X2 > 0) {
                  if (X2--, N10.foldState) {
                    let Ne2 = F2[X2] === x10 ? "right" : "left";
                    ae[X2] = N10.foldState(ae[X2], Ye2, Ne2);
                  }
                } else
                  Te2.value = Ye2;
                return X2;
              }
              e.exit = x10;
              function w6(N10, X2, F2, $, ae, Te2, Se2) {
                return Y3.assertEqual(F2[X2], w6), X2;
              }
              e.done = w6;
              function A6(N10, X2) {
                switch (X2) {
                  case t6:
                    if (N10.onLeft)
                      return r;
                  case r:
                    if (N10.onOperator)
                      return s;
                  case s:
                    if (N10.onRight)
                      return f10;
                  case f10:
                    return x10;
                  case x10:
                    return w6;
                  case w6:
                    return w6;
                  default:
                    Y3.fail("Invalid state");
                }
              }
              e.nextState = A6;
              function g9(N10, X2, F2, $, ae) {
                return N10++, X2[N10] = t6, F2[N10] = ae, $[N10] = void 0, N10;
              }
              function B(N10, X2, F2) {
                if (Y3.shouldAssert(2))
                  for (; N10 >= 0; )
                    Y3.assert(X2[N10] !== F2, "Circular traversal detected."), N10--;
              }
            })(Td2 || (Td2 = {})), OE = class {
              constructor(e, t6, r, s, f10, x10) {
                this.onEnter = e, this.onLeft = t6, this.onOperator = r, this.onRight = s, this.onExit = f10, this.foldState = x10;
              }
            };
          } });
          function Rt(e, t6) {
            return t6 ? Us(e, t6.pos, t6.end) : e;
          }
          function fc(e) {
            let t6 = e.kind;
            return t6 === 165 || t6 === 166 || t6 === 168 || t6 === 169 || t6 === 170 || t6 === 171 || t6 === 173 || t6 === 174 || t6 === 175 || t6 === 178 || t6 === 182 || t6 === 215 || t6 === 216 || t6 === 228 || t6 === 240 || t6 === 259 || t6 === 260 || t6 === 261 || t6 === 262 || t6 === 263 || t6 === 264 || t6 === 268 || t6 === 269 || t6 === 274 || t6 === 275;
          }
          function ME(e) {
            let t6 = e.kind;
            return t6 === 166 || t6 === 169 || t6 === 171 || t6 === 174 || t6 === 175 || t6 === 228 || t6 === 260;
          }
          var UJ = D({ "src/compiler/factory/utilitiesPublic.ts"() {
            "use strict";
            nn();
          } });
          function G2(e, t6) {
            return t6 && e(t6);
          }
          function ze(e, t6, r) {
            if (r) {
              if (t6)
                return t6(r);
              for (let s of r) {
                let f10 = e(s);
                if (f10)
                  return f10;
              }
            }
          }
          function LE(e, t6) {
            return e.charCodeAt(t6 + 1) === 42 && e.charCodeAt(t6 + 2) === 42 && e.charCodeAt(t6 + 3) !== 47;
          }
          function ou(e) {
            return c(e.statements, zJ) || WJ(e);
          }
          function zJ(e) {
            return fc(e) && VJ(e, 93) || s2(e) && ud(e.moduleReference) || o2(e) || Vo(e) || cc(e) ? e : void 0;
          }
          function WJ(e) {
            return e.flags & 4194304 ? RE(e) : void 0;
          }
          function RE(e) {
            return HJ(e) ? e : xr2(e, RE);
          }
          function VJ(e, t6) {
            return Ke3(e.modifiers, (r) => r.kind === t6);
          }
          function HJ(e) {
            return t2(e) && e.keywordToken === 100 && e.name.escapedText === "meta";
          }
          function jE(e, t6, r) {
            return ze(t6, r, e.typeParameters) || ze(t6, r, e.parameters) || G2(t6, e.type);
          }
          function JE(e, t6, r) {
            return ze(t6, r, e.types);
          }
          function FE(e, t6, r) {
            return G2(t6, e.type);
          }
          function BE(e, t6, r) {
            return ze(t6, r, e.elements);
          }
          function qE(e, t6, r) {
            return G2(t6, e.expression) || G2(t6, e.questionDotToken) || ze(t6, r, e.typeArguments) || ze(t6, r, e.arguments);
          }
          function UE(e, t6, r) {
            return ze(t6, r, e.statements);
          }
          function zE(e, t6, r) {
            return G2(t6, e.label);
          }
          function WE(e, t6, r) {
            return ze(t6, r, e.modifiers) || G2(t6, e.name) || ze(t6, r, e.typeParameters) || ze(t6, r, e.heritageClauses) || ze(t6, r, e.members);
          }
          function VE(e, t6, r) {
            return ze(t6, r, e.elements);
          }
          function HE(e, t6, r) {
            return G2(t6, e.propertyName) || G2(t6, e.name);
          }
          function GE(e, t6, r) {
            return G2(t6, e.tagName) || ze(t6, r, e.typeArguments) || G2(t6, e.attributes);
          }
          function Xo(e, t6, r) {
            return G2(t6, e.type);
          }
          function $E(e, t6, r) {
            return G2(t6, e.tagName) || (e.isNameFirst ? G2(t6, e.name) || G2(t6, e.typeExpression) : G2(t6, e.typeExpression) || G2(t6, e.name)) || (typeof e.comment == "string" ? void 0 : ze(t6, r, e.comment));
          }
          function Yo(e, t6, r) {
            return G2(t6, e.tagName) || G2(t6, e.typeExpression) || (typeof e.comment == "string" ? void 0 : ze(t6, r, e.comment));
          }
          function P2(e, t6, r) {
            return G2(t6, e.name);
          }
          function Gs(e, t6, r) {
            return G2(t6, e.tagName) || (typeof e.comment == "string" ? void 0 : ze(t6, r, e.comment));
          }
          function GJ(e, t6, r) {
            return G2(t6, e.expression);
          }
          function xr2(e, t6, r) {
            if (e === void 0 || e.kind <= 162)
              return;
            let s = o7[e.kind];
            return s === void 0 ? void 0 : s(e, t6, r);
          }
          function D2(e, t6, r) {
            let s = KE(e), f10 = [];
            for (; f10.length < s.length; )
              f10.push(e);
            for (; s.length !== 0; ) {
              let x10 = s.pop(), w6 = f10.pop();
              if (ir2(x10)) {
                if (r) {
                  let A6 = r(x10, w6);
                  if (A6) {
                    if (A6 === "skip")
                      continue;
                    return A6;
                  }
                }
                for (let A6 = x10.length - 1; A6 >= 0; --A6)
                  s.push(x10[A6]), f10.push(w6);
              } else {
                let A6 = t6(x10, w6);
                if (A6) {
                  if (A6 === "skip")
                    continue;
                  return A6;
                }
                if (x10.kind >= 163)
                  for (let g9 of KE(x10))
                    s.push(g9), f10.push(x10);
              }
            }
          }
          function KE(e) {
            let t6 = [];
            return xr2(e, r, r), t6;
            function r(s) {
              t6.unshift(s);
            }
          }
          function XE(e) {
            e.externalModuleIndicator = ou(e);
          }
          function YE(e, t6, r) {
            let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, f10 = arguments.length > 4 ? arguments[4] : void 0;
            var x10, w6;
            (x10 = rs) == null || x10.push(rs.Phase.Parse, "createSourceFile", { path: e }, true), DT("beforeParse");
            let A6;
            Dp.logStartParseSourceFile(e);
            let { languageVersion: g9, setExternalModuleIndicator: B, impliedNodeFormat: N10 } = typeof r == "object" ? r : { languageVersion: r };
            if (g9 === 100)
              A6 = Ci.parseSourceFile(e, t6, g9, void 0, s, 6, yn);
            else {
              let X2 = N10 === void 0 ? B : (F2) => (F2.impliedNodeFormat = N10, (B || XE)(F2));
              A6 = Ci.parseSourceFile(e, t6, g9, void 0, s, f10, X2);
            }
            return Dp.logStopParseSourceFile(), DT("afterParse"), B5("Parse", "beforeParse", "afterParse"), (w6 = rs) == null || w6.pop(), A6;
          }
          function $J(e, t6) {
            return Ci.parseIsolatedEntityName(e, t6);
          }
          function KJ(e, t6) {
            return Ci.parseJsonText(e, t6);
          }
          function Qo(e) {
            return e.externalModuleIndicator !== void 0;
          }
          function k2(e, t6, r) {
            let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, f10 = Sd.updateSourceFile(e, t6, r, s);
            return f10.flags |= e.flags & 6291456, f10;
          }
          function XJ(e, t6, r) {
            let s = Ci.JSDocParser.parseIsolatedJSDocComment(e, t6, r);
            return s && s.jsDoc && Ci.fixupParentReferences(s.jsDoc), s;
          }
          function YJ(e, t6, r) {
            return Ci.JSDocParser.parseJSDocTypeExpressionForTests(e, t6, r);
          }
          function QE(e) {
            return da(e, Rv) || ns(e, ".ts") && Fi(sl(e), ".d.");
          }
          function QJ(e, t6, r, s) {
            if (e) {
              if (e === "import")
                return 99;
              if (e === "require")
                return 1;
              s(t6, r - t6, ve.resolution_mode_should_be_either_require_or_import);
            }
          }
          function ZE(e, t6) {
            let r = [];
            for (let s of Ao(t6, 0) || Bt) {
              let f10 = t6.substring(s.pos, s.end);
              eF(r, s, f10);
            }
            e.pragmas = /* @__PURE__ */ new Map();
            for (let s of r) {
              if (e.pragmas.has(s.name)) {
                let f10 = e.pragmas.get(s.name);
                f10 instanceof Array ? f10.push(s.args) : e.pragmas.set(s.name, [f10, s.args]);
                continue;
              }
              e.pragmas.set(s.name, s.args);
            }
          }
          function e7(e, t6) {
            e.checkJsDirective = void 0, e.referencedFiles = [], e.typeReferenceDirectives = [], e.libReferenceDirectives = [], e.amdDependencies = [], e.hasNoDefaultLib = false, e.pragmas.forEach((r, s) => {
              switch (s) {
                case "reference": {
                  let f10 = e.referencedFiles, x10 = e.typeReferenceDirectives, w6 = e.libReferenceDirectives;
                  c(en(r), (A6) => {
                    let { types: g9, lib: B, path: N10, ["resolution-mode"]: X2 } = A6.arguments;
                    if (A6.arguments["no-default-lib"])
                      e.hasNoDefaultLib = true;
                    else if (g9) {
                      let F2 = QJ(X2, g9.pos, g9.end, t6);
                      x10.push(Object.assign({ pos: g9.pos, end: g9.end, fileName: g9.value }, F2 ? { resolutionMode: F2 } : {}));
                    } else
                      B ? w6.push({ pos: B.pos, end: B.end, fileName: B.value }) : N10 ? f10.push({ pos: N10.pos, end: N10.end, fileName: N10.value }) : t6(A6.range.pos, A6.range.end - A6.range.pos, ve.Invalid_reference_directive_syntax);
                  });
                  break;
                }
                case "amd-dependency": {
                  e.amdDependencies = Ze2(en(r), (f10) => ({ name: f10.arguments.name, path: f10.arguments.path }));
                  break;
                }
                case "amd-module": {
                  if (r instanceof Array)
                    for (let f10 of r)
                      e.moduleName && t6(f10.range.pos, f10.range.end - f10.range.pos, ve.An_AMD_module_cannot_have_multiple_name_assignments), e.moduleName = f10.arguments.name;
                  else
                    e.moduleName = r.arguments.name;
                  break;
                }
                case "ts-nocheck":
                case "ts-check": {
                  c(en(r), (f10) => {
                    (!e.checkJsDirective || f10.range.pos > e.checkJsDirective.pos) && (e.checkJsDirective = { enabled: s === "ts-check", end: f10.range.end, pos: f10.range.pos });
                  });
                  break;
                }
                case "jsx":
                case "jsxfrag":
                case "jsximportsource":
                case "jsxruntime":
                  return;
                default:
                  Y3.fail("Unhandled pragma kind");
              }
            });
          }
          function ZJ(e) {
            if (xd.has(e))
              return xd.get(e);
            let t6 = new RegExp(`(\\s${e}\\s*=\\s*)(?:(?:'([^']*)')|(?:"([^"]*)"))`, "im");
            return xd.set(e, t6), t6;
          }
          function eF(e, t6, r) {
            let s = t6.kind === 2 && _7.exec(r);
            if (s) {
              let x10 = s[1].toLowerCase(), w6 = Vp[x10];
              if (!w6 || !(w6.kind & 1))
                return;
              if (w6.args) {
                let A6 = {};
                for (let g9 of w6.args) {
                  let N10 = ZJ(g9.name).exec(r);
                  if (!N10 && !g9.optional)
                    return;
                  if (N10) {
                    let X2 = N10[2] || N10[3];
                    if (g9.captureSpan) {
                      let F2 = t6.pos + N10.index + N10[1].length + 1;
                      A6[g9.name] = { value: X2, pos: F2, end: F2 + X2.length };
                    } else
                      A6[g9.name] = X2;
                  }
                }
                e.push({ name: x10, args: { arguments: A6, range: t6 } });
              } else
                e.push({ name: x10, args: { arguments: {}, range: t6 } });
              return;
            }
            let f10 = t6.kind === 2 && c7.exec(r);
            if (f10)
              return t7(e, t6, 2, f10);
            if (t6.kind === 3) {
              let x10 = /@(\S+)(\s+.*)?$/gim, w6;
              for (; w6 = x10.exec(r); )
                t7(e, t6, 4, w6);
            }
          }
          function t7(e, t6, r, s) {
            if (!s)
              return;
            let f10 = s[1].toLowerCase(), x10 = Vp[f10];
            if (!x10 || !(x10.kind & r))
              return;
            let w6 = s[2], A6 = tF(x10, w6);
            A6 !== "fail" && e.push({ name: f10, args: { arguments: A6, range: t6 } });
          }
          function tF(e, t6) {
            if (!t6)
              return {};
            if (!e.args)
              return {};
            let r = Pp(t6).split(/\s+/), s = {};
            for (let f10 = 0; f10 < e.args.length; f10++) {
              let x10 = e.args[f10];
              if (!r[f10] && !x10.optional)
                return "fail";
              if (x10.captureSpan)
                return Y3.fail("Capture spans not yet implemented for non-xml pragmas");
              s[x10.name] = r[f10];
            }
            return s;
          }
          function Hi(e, t6) {
            return e.kind !== t6.kind ? false : e.kind === 79 ? e.escapedText === t6.escapedText : e.kind === 108 ? true : e.name.escapedText === t6.name.escapedText && Hi(e.expression, t6.expression);
          }
          var r7, n7, i7, a7, s7, I2, dc, o7, Ci, Sd, xd, _7, c7, rF = D({ "src/compiler/parser.ts"() {
            "use strict";
            nn(), nn(), IT(), I2 = { createBaseSourceFileNode: (e) => new (s7 || (s7 = lr2.getSourceFileConstructor()))(e, -1, -1), createBaseIdentifierNode: (e) => new (i7 || (i7 = lr2.getIdentifierConstructor()))(e, -1, -1), createBasePrivateIdentifierNode: (e) => new (a7 || (a7 = lr2.getPrivateIdentifierConstructor()))(e, -1, -1), createBaseTokenNode: (e) => new (n7 || (n7 = lr2.getTokenConstructor()))(e, -1, -1), createBaseNode: (e) => new (r7 || (r7 = lr2.getNodeConstructor()))(e, -1, -1) }, dc = Zf(1, I2), o7 = { [163]: function(t6, r, s) {
              return G2(r, t6.left) || G2(r, t6.right);
            }, [165]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.constraint) || G2(r, t6.default) || G2(r, t6.expression);
            }, [300]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.exclamationToken) || G2(r, t6.equalsToken) || G2(r, t6.objectAssignmentInitializer);
            }, [301]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [166]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.dotDotDotToken) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.type) || G2(r, t6.initializer);
            }, [169]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.exclamationToken) || G2(r, t6.type) || G2(r, t6.initializer);
            }, [168]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.type) || G2(r, t6.initializer);
            }, [299]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.exclamationToken) || G2(r, t6.initializer);
            }, [257]: function(t6, r, s) {
              return G2(r, t6.name) || G2(r, t6.exclamationToken) || G2(r, t6.type) || G2(r, t6.initializer);
            }, [205]: function(t6, r, s) {
              return G2(r, t6.dotDotDotToken) || G2(r, t6.propertyName) || G2(r, t6.name) || G2(r, t6.initializer);
            }, [178]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type);
            }, [182]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type);
            }, [181]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type);
            }, [176]: jE, [177]: jE, [171]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.asteriskToken) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.exclamationToken) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.body);
            }, [170]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.questionToken) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type);
            }, [173]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.body);
            }, [174]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.body);
            }, [175]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.body);
            }, [259]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.asteriskToken) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.body);
            }, [215]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.asteriskToken) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.body);
            }, [216]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || ze(r, s, t6.typeParameters) || ze(r, s, t6.parameters) || G2(r, t6.type) || G2(r, t6.equalsGreaterThanToken) || G2(r, t6.body);
            }, [172]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.body);
            }, [180]: function(t6, r, s) {
              return G2(r, t6.typeName) || ze(r, s, t6.typeArguments);
            }, [179]: function(t6, r, s) {
              return G2(r, t6.assertsModifier) || G2(r, t6.parameterName) || G2(r, t6.type);
            }, [183]: function(t6, r, s) {
              return G2(r, t6.exprName) || ze(r, s, t6.typeArguments);
            }, [184]: function(t6, r, s) {
              return ze(r, s, t6.members);
            }, [185]: function(t6, r, s) {
              return G2(r, t6.elementType);
            }, [186]: function(t6, r, s) {
              return ze(r, s, t6.elements);
            }, [189]: JE, [190]: JE, [191]: function(t6, r, s) {
              return G2(r, t6.checkType) || G2(r, t6.extendsType) || G2(r, t6.trueType) || G2(r, t6.falseType);
            }, [192]: function(t6, r, s) {
              return G2(r, t6.typeParameter);
            }, [202]: function(t6, r, s) {
              return G2(r, t6.argument) || G2(r, t6.assertions) || G2(r, t6.qualifier) || ze(r, s, t6.typeArguments);
            }, [298]: function(t6, r, s) {
              return G2(r, t6.assertClause);
            }, [193]: FE, [195]: FE, [196]: function(t6, r, s) {
              return G2(r, t6.objectType) || G2(r, t6.indexType);
            }, [197]: function(t6, r, s) {
              return G2(r, t6.readonlyToken) || G2(r, t6.typeParameter) || G2(r, t6.nameType) || G2(r, t6.questionToken) || G2(r, t6.type) || ze(r, s, t6.members);
            }, [198]: function(t6, r, s) {
              return G2(r, t6.literal);
            }, [199]: function(t6, r, s) {
              return G2(r, t6.dotDotDotToken) || G2(r, t6.name) || G2(r, t6.questionToken) || G2(r, t6.type);
            }, [203]: BE, [204]: BE, [206]: function(t6, r, s) {
              return ze(r, s, t6.elements);
            }, [207]: function(t6, r, s) {
              return ze(r, s, t6.properties);
            }, [208]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.questionDotToken) || G2(r, t6.name);
            }, [209]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.questionDotToken) || G2(r, t6.argumentExpression);
            }, [210]: qE, [211]: qE, [212]: function(t6, r, s) {
              return G2(r, t6.tag) || G2(r, t6.questionDotToken) || ze(r, s, t6.typeArguments) || G2(r, t6.template);
            }, [213]: function(t6, r, s) {
              return G2(r, t6.type) || G2(r, t6.expression);
            }, [214]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [217]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [218]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [219]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [221]: function(t6, r, s) {
              return G2(r, t6.operand);
            }, [226]: function(t6, r, s) {
              return G2(r, t6.asteriskToken) || G2(r, t6.expression);
            }, [220]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [222]: function(t6, r, s) {
              return G2(r, t6.operand);
            }, [223]: function(t6, r, s) {
              return G2(r, t6.left) || G2(r, t6.operatorToken) || G2(r, t6.right);
            }, [231]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.type);
            }, [232]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [235]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.type);
            }, [233]: function(t6, r, s) {
              return G2(r, t6.name);
            }, [224]: function(t6, r, s) {
              return G2(r, t6.condition) || G2(r, t6.questionToken) || G2(r, t6.whenTrue) || G2(r, t6.colonToken) || G2(r, t6.whenFalse);
            }, [227]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [238]: UE, [265]: UE, [308]: function(t6, r, s) {
              return ze(r, s, t6.statements) || G2(r, t6.endOfFileToken);
            }, [240]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.declarationList);
            }, [258]: function(t6, r, s) {
              return ze(r, s, t6.declarations);
            }, [241]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [242]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.thenStatement) || G2(r, t6.elseStatement);
            }, [243]: function(t6, r, s) {
              return G2(r, t6.statement) || G2(r, t6.expression);
            }, [244]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.statement);
            }, [245]: function(t6, r, s) {
              return G2(r, t6.initializer) || G2(r, t6.condition) || G2(r, t6.incrementor) || G2(r, t6.statement);
            }, [246]: function(t6, r, s) {
              return G2(r, t6.initializer) || G2(r, t6.expression) || G2(r, t6.statement);
            }, [247]: function(t6, r, s) {
              return G2(r, t6.awaitModifier) || G2(r, t6.initializer) || G2(r, t6.expression) || G2(r, t6.statement);
            }, [248]: zE, [249]: zE, [250]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [251]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.statement);
            }, [252]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.caseBlock);
            }, [266]: function(t6, r, s) {
              return ze(r, s, t6.clauses);
            }, [292]: function(t6, r, s) {
              return G2(r, t6.expression) || ze(r, s, t6.statements);
            }, [293]: function(t6, r, s) {
              return ze(r, s, t6.statements);
            }, [253]: function(t6, r, s) {
              return G2(r, t6.label) || G2(r, t6.statement);
            }, [254]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [255]: function(t6, r, s) {
              return G2(r, t6.tryBlock) || G2(r, t6.catchClause) || G2(r, t6.finallyBlock);
            }, [295]: function(t6, r, s) {
              return G2(r, t6.variableDeclaration) || G2(r, t6.block);
            }, [167]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [260]: WE, [228]: WE, [261]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || ze(r, s, t6.heritageClauses) || ze(r, s, t6.members);
            }, [262]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || ze(r, s, t6.typeParameters) || G2(r, t6.type);
            }, [263]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || ze(r, s, t6.members);
            }, [302]: function(t6, r, s) {
              return G2(r, t6.name) || G2(r, t6.initializer);
            }, [264]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.body);
            }, [268]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name) || G2(r, t6.moduleReference);
            }, [269]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.importClause) || G2(r, t6.moduleSpecifier) || G2(r, t6.assertClause);
            }, [270]: function(t6, r, s) {
              return G2(r, t6.name) || G2(r, t6.namedBindings);
            }, [296]: function(t6, r, s) {
              return ze(r, s, t6.elements);
            }, [297]: function(t6, r, s) {
              return G2(r, t6.name) || G2(r, t6.value);
            }, [267]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.name);
            }, [271]: function(t6, r, s) {
              return G2(r, t6.name);
            }, [277]: function(t6, r, s) {
              return G2(r, t6.name);
            }, [272]: VE, [276]: VE, [275]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.exportClause) || G2(r, t6.moduleSpecifier) || G2(r, t6.assertClause);
            }, [273]: HE, [278]: HE, [274]: function(t6, r, s) {
              return ze(r, s, t6.modifiers) || G2(r, t6.expression);
            }, [225]: function(t6, r, s) {
              return G2(r, t6.head) || ze(r, s, t6.templateSpans);
            }, [236]: function(t6, r, s) {
              return G2(r, t6.expression) || G2(r, t6.literal);
            }, [200]: function(t6, r, s) {
              return G2(r, t6.head) || ze(r, s, t6.templateSpans);
            }, [201]: function(t6, r, s) {
              return G2(r, t6.type) || G2(r, t6.literal);
            }, [164]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [294]: function(t6, r, s) {
              return ze(r, s, t6.types);
            }, [230]: function(t6, r, s) {
              return G2(r, t6.expression) || ze(r, s, t6.typeArguments);
            }, [280]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [279]: function(t6, r, s) {
              return ze(r, s, t6.modifiers);
            }, [357]: function(t6, r, s) {
              return ze(r, s, t6.elements);
            }, [281]: function(t6, r, s) {
              return G2(r, t6.openingElement) || ze(r, s, t6.children) || G2(r, t6.closingElement);
            }, [285]: function(t6, r, s) {
              return G2(r, t6.openingFragment) || ze(r, s, t6.children) || G2(r, t6.closingFragment);
            }, [282]: GE, [283]: GE, [289]: function(t6, r, s) {
              return ze(r, s, t6.properties);
            }, [288]: function(t6, r, s) {
              return G2(r, t6.name) || G2(r, t6.initializer);
            }, [290]: function(t6, r, s) {
              return G2(r, t6.expression);
            }, [291]: function(t6, r, s) {
              return G2(r, t6.dotDotDotToken) || G2(r, t6.expression);
            }, [284]: function(t6, r, s) {
              return G2(r, t6.tagName);
            }, [187]: Xo, [188]: Xo, [312]: Xo, [318]: Xo, [317]: Xo, [319]: Xo, [321]: Xo, [320]: function(t6, r, s) {
              return ze(r, s, t6.parameters) || G2(r, t6.type);
            }, [323]: function(t6, r, s) {
              return (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment)) || ze(r, s, t6.tags);
            }, [350]: function(t6, r, s) {
              return G2(r, t6.tagName) || G2(r, t6.name) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment));
            }, [313]: function(t6, r, s) {
              return G2(r, t6.name);
            }, [314]: function(t6, r, s) {
              return G2(r, t6.left) || G2(r, t6.right);
            }, [344]: $E, [351]: $E, [333]: function(t6, r, s) {
              return G2(r, t6.tagName) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment));
            }, [332]: function(t6, r, s) {
              return G2(r, t6.tagName) || G2(r, t6.class) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment));
            }, [331]: function(t6, r, s) {
              return G2(r, t6.tagName) || G2(r, t6.class) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment));
            }, [348]: function(t6, r, s) {
              return G2(r, t6.tagName) || G2(r, t6.constraint) || ze(r, s, t6.typeParameters) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment));
            }, [349]: function(t6, r, s) {
              return G2(r, t6.tagName) || (t6.typeExpression && t6.typeExpression.kind === 312 ? G2(r, t6.typeExpression) || G2(r, t6.fullName) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment)) : G2(r, t6.fullName) || G2(r, t6.typeExpression) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment)));
            }, [341]: function(t6, r, s) {
              return G2(r, t6.tagName) || G2(r, t6.fullName) || G2(r, t6.typeExpression) || (typeof t6.comment == "string" ? void 0 : ze(r, s, t6.comment));
            }, [345]: Yo, [347]: Yo, [346]: Yo, [343]: Yo, [353]: Yo, [352]: Yo, [342]: Yo, [326]: function(t6, r, s) {
              return c(t6.typeParameters, r) || c(t6.parameters, r) || G2(r, t6.type);
            }, [327]: P2, [328]: P2, [329]: P2, [325]: function(t6, r, s) {
              return c(t6.jsDocPropertyTags, r);
            }, [330]: Gs, [335]: Gs, [336]: Gs, [337]: Gs, [338]: Gs, [339]: Gs, [334]: Gs, [340]: Gs, [356]: GJ }, ((e) => {
              var t6 = Po(99, true), r = 20480, s, f10, x10, w6, A6;
              function g9(u) {
                return oi++, u;
              }
              var B = { createBaseSourceFileNode: (u) => g9(new A6(u, 0, 0)), createBaseIdentifierNode: (u) => g9(new x10(u, 0, 0)), createBasePrivateIdentifierNode: (u) => g9(new w6(u, 0, 0)), createBaseTokenNode: (u) => g9(new f10(u, 0, 0)), createBaseNode: (u) => g9(new s(u, 0, 0)) }, N10 = Zf(11, B), { createNodeArray: X2, createNumericLiteral: F2, createStringLiteral: $, createLiteralLikeNode: ae, createIdentifier: Te2, createPrivateIdentifier: Se2, createToken: Ye2, createArrayLiteralExpression: Ne2, createObjectLiteralExpression: oe2, createPropertyAccessExpression: Ve2, createPropertyAccessChain: pt2, createElementAccessExpression: Gt, createElementAccessChain: Nt, createCallExpression: Xt, createCallChain: er2, createNewExpression: Tn, createParenthesizedExpression: Hr2, createBlock: Gi, createVariableStatement: pn, createExpressionStatement: fn, createIfStatement: Ut, createWhileStatement: kn, createForStatement: an, createForOfStatement: mr2, createVariableDeclaration: $i, createVariableDeclarationList: dn } = N10, Ur2, Gr2, _r2, Sn, In, pr2, Zt, Or2, Nn, ar2, oi, cr2, $r2, hr2, On, nr2, br2 = true, Kr2 = false;
              function wa(u, b, O10, j6) {
                let z = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, re2 = arguments.length > 5 ? arguments[5] : void 0, Ee2 = arguments.length > 6 ? arguments[6] : void 0;
                var qe;
                if (re2 = Nx(u, re2), re2 === 6) {
                  let $e2 = Ki(u, b, O10, j6, z);
                  return convertToObjectWorker($e2, (qe = $e2.statements[0]) == null ? void 0 : qe.expression, $e2.parseDiagnostics, false, void 0, void 0), $e2.referencedFiles = Bt, $e2.typeReferenceDirectives = Bt, $e2.libReferenceDirectives = Bt, $e2.amdDependencies = Bt, $e2.hasNoDefaultLib = false, $e2.pragmas = V1, $e2;
                }
                Mn(u, b, O10, j6, re2);
                let We2 = Ca(O10, z, re2, Ee2 || XE);
                return _i(), We2;
              }
              e.parseSourceFile = wa;
              function $n(u, b) {
                Mn("", u, b, void 0, 1), _e();
                let O10 = Ys(true), j6 = T() === 1 && !Zt.length;
                return _i(), j6 ? O10 : void 0;
              }
              e.parseIsolatedEntityName = $n;
              function Ki(u, b) {
                let O10 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2, j6 = arguments.length > 3 ? arguments[3] : void 0, z = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                Mn(u, b, O10, j6, 6), Gr2 = nr2, _e();
                let re2 = L(), Ee2, qe;
                if (T() === 1)
                  Ee2 = Er2([], re2, re2), qe = sn();
                else {
                  let lt2;
                  for (; T() !== 1; ) {
                    let At;
                    switch (T()) {
                      case 22:
                        At = ah();
                        break;
                      case 110:
                      case 95:
                      case 104:
                        At = sn();
                        break;
                      case 40:
                        wt(() => _e() === 8 && _e() !== 58) ? At = qm() : At = Xu();
                        break;
                      case 8:
                      case 10:
                        if (wt(() => _e() !== 58)) {
                          At = Di();
                          break;
                        }
                      default:
                        At = Xu();
                        break;
                    }
                    lt2 && ir2(lt2) ? lt2.push(At) : lt2 ? lt2 = [lt2, At] : (lt2 = At, T() !== 1 && Dt(ve.Unexpected_token));
                  }
                  let Jt = ir2(lt2) ? Q2(Ne2(lt2), re2) : Y3.checkDefined(lt2), Lt = fn(Jt);
                  Q2(Lt, re2), Ee2 = Er2([Lt], re2), qe = ea(1, ve.Unexpected_token);
                }
                let We2 = Kt(u, 2, 6, false, Ee2, qe, Gr2, yn);
                z && ft(We2), We2.nodeCount = oi, We2.identifierCount = $r2, We2.identifiers = cr2, We2.parseDiagnostics = qs(Zt, We2), Or2 && (We2.jsDocDiagnostics = qs(Or2, We2));
                let $e2 = We2;
                return _i(), $e2;
              }
              e.parseJsonText = Ki;
              function Mn(u, b, O10, j6, z) {
                switch (s = lr2.getNodeConstructor(), f10 = lr2.getTokenConstructor(), x10 = lr2.getIdentifierConstructor(), w6 = lr2.getPrivateIdentifierConstructor(), A6 = lr2.getSourceFileConstructor(), Ur2 = Un(u), _r2 = b, Sn = O10, Nn = j6, In = z, pr2 = sv(z), Zt = [], hr2 = 0, cr2 = /* @__PURE__ */ new Map(), $r2 = 0, oi = 0, Gr2 = 0, br2 = true, In) {
                  case 1:
                  case 2:
                    nr2 = 262144;
                    break;
                  case 6:
                    nr2 = 67371008;
                    break;
                  default:
                    nr2 = 0;
                    break;
                }
                Kr2 = false, t6.setText(_r2), t6.setOnError(U2), t6.setScriptTarget(Sn), t6.setLanguageVariant(pr2);
              }
              function _i() {
                t6.clearCommentDirectives(), t6.setText(""), t6.setOnError(void 0), _r2 = void 0, Sn = void 0, Nn = void 0, In = void 0, pr2 = void 0, Gr2 = 0, Zt = void 0, Or2 = void 0, hr2 = 0, cr2 = void 0, On = void 0, br2 = true;
              }
              function Ca(u, b, O10, j6) {
                let z = QE(Ur2);
                z && (nr2 |= 16777216), Gr2 = nr2, _e();
                let re2 = Kn(0, on);
                Y3.assert(T() === 1);
                let Ee2 = He2(sn()), qe = Kt(Ur2, u, O10, z, re2, Ee2, Gr2, j6);
                return ZE(qe, _r2), e7(qe, We2), qe.commentDirectives = t6.getCommentDirectives(), qe.nodeCount = oi, qe.identifierCount = $r2, qe.identifiers = cr2, qe.parseDiagnostics = qs(Zt, qe), Or2 && (qe.jsDocDiagnostics = qs(Or2, qe)), b && ft(qe), qe;
                function We2($e2, lt2, Jt) {
                  Zt.push(Ro(Ur2, $e2, lt2, Jt));
                }
              }
              function St(u, b) {
                return b ? He2(u) : u;
              }
              let ue2 = false;
              function He2(u) {
                Y3.assert(!u.jsDoc);
                let b = qt(I3(u, _r2), (O10) => Vh.parseJSDocComment(u, O10.pos, O10.end - O10.pos));
                return b.length && (u.jsDoc = b), ue2 && (ue2 = false, u.flags |= 268435456), u;
              }
              function _t(u) {
                let b = Nn, O10 = Sd.createSyntaxCursor(u);
                Nn = { currentNode: lt2 };
                let j6 = [], z = Zt;
                Zt = [];
                let re2 = 0, Ee2 = We2(u.statements, 0);
                for (; Ee2 !== -1; ) {
                  let Jt = u.statements[re2], Lt = u.statements[Ee2];
                  jr2(j6, u.statements, re2, Ee2), re2 = $e2(u.statements, Ee2);
                  let At = he(z, (Fn) => Fn.start >= Jt.pos), kr2 = At >= 0 ? he(z, (Fn) => Fn.start >= Lt.pos, At) : -1;
                  At >= 0 && jr2(Zt, z, At, kr2 >= 0 ? kr2 : void 0), Rn(() => {
                    let Fn = nr2;
                    for (nr2 |= 32768, t6.setTextPos(Lt.pos), _e(); T() !== 1; ) {
                      let di = t6.getStartPos(), Ii = vc(0, on);
                      if (j6.push(Ii), di === t6.getStartPos() && _e(), re2 >= 0) {
                        let _n = u.statements[re2];
                        if (Ii.end === _n.pos)
                          break;
                        Ii.end > _n.pos && (re2 = $e2(u.statements, re2 + 1));
                      }
                    }
                    nr2 = Fn;
                  }, 2), Ee2 = re2 >= 0 ? We2(u.statements, re2) : -1;
                }
                if (re2 >= 0) {
                  let Jt = u.statements[re2];
                  jr2(j6, u.statements, re2);
                  let Lt = he(z, (At) => At.start >= Jt.pos);
                  Lt >= 0 && jr2(Zt, z, Lt);
                }
                return Nn = b, N10.updateSourceFile(u, Rt(X2(j6), u.statements));
                function qe(Jt) {
                  return !(Jt.flags & 32768) && !!(Jt.transformFlags & 67108864);
                }
                function We2(Jt, Lt) {
                  for (let At = Lt; At < Jt.length; At++)
                    if (qe(Jt[At]))
                      return At;
                  return -1;
                }
                function $e2(Jt, Lt) {
                  for (let At = Lt; At < Jt.length; At++)
                    if (!qe(Jt[At]))
                      return At;
                  return -1;
                }
                function lt2(Jt) {
                  let Lt = O10.currentNode(Jt);
                  return br2 && Lt && qe(Lt) && (Lt.intersectsChange = true), Lt;
                }
              }
              function ft(u) {
                Vx(u, true);
              }
              e.fixupParentReferences = ft;
              function Kt(u, b, O10, j6, z, re2, Ee2, qe) {
                let We2 = N10.createSourceFile(z, re2, Ee2);
                return $f(We2, 0, _r2.length), $e2(We2), !j6 && Qo(We2) && We2.transformFlags & 67108864 && (We2 = _t(We2), $e2(We2)), We2;
                function $e2(lt2) {
                  lt2.text = _r2, lt2.bindDiagnostics = [], lt2.bindSuggestionDiagnostics = void 0, lt2.languageVersion = b, lt2.fileName = u, lt2.languageVariant = sv(O10), lt2.isDeclarationFile = j6, lt2.scriptKind = O10, qe(lt2), lt2.setExternalModuleIndicator = qe;
                }
              }
              function zt(u, b) {
                u ? nr2 |= b : nr2 &= ~b;
              }
              function xe2(u) {
                zt(u, 4096);
              }
              function Le2(u) {
                zt(u, 8192);
              }
              function Re2(u) {
                zt(u, 16384);
              }
              function ot2(u) {
                zt(u, 32768);
              }
              function Ct(u, b) {
                let O10 = u & nr2;
                if (O10) {
                  zt(false, O10);
                  let j6 = b();
                  return zt(true, O10), j6;
                }
                return b();
              }
              function Mt(u, b) {
                let O10 = u & ~nr2;
                if (O10) {
                  zt(true, O10);
                  let j6 = b();
                  return zt(false, O10), j6;
                }
                return b();
              }
              function It(u) {
                return Ct(4096, u);
              }
              function Mr2(u) {
                return Mt(4096, u);
              }
              function gr2(u) {
                return Ct(65536, u);
              }
              function Ln(u) {
                return Mt(65536, u);
              }
              function ys(u) {
                return Mt(8192, u);
              }
              function ci(u) {
                return Mt(16384, u);
              }
              function Xi(u) {
                return Mt(32768, u);
              }
              function Aa(u) {
                return Ct(32768, u);
              }
              function vs(u) {
                return Mt(40960, u);
              }
              function $s(u) {
                return Ct(40960, u);
              }
              function li(u) {
                return (nr2 & u) !== 0;
              }
              function Yi2() {
                return li(8192);
              }
              function Qi() {
                return li(4096);
              }
              function bs() {
                return li(65536);
              }
              function Ai() {
                return li(16384);
              }
              function xn() {
                return li(32768);
              }
              function Dt(u, b) {
                return Z(t6.getTokenPos(), t6.getTextPos(), u, b);
              }
              function Pi(u, b, O10, j6) {
                let z = Cn(Zt), re2;
                return (!z || u !== z.start) && (re2 = Ro(Ur2, u, b, O10, j6), Zt.push(re2)), Kr2 = true, re2;
              }
              function Z(u, b, O10, j6) {
                return Pi(u, b - u, O10, j6);
              }
              function ie2(u, b, O10) {
                Z(u.pos, u.end, b, O10);
              }
              function U2(u, b) {
                Pi(t6.getTextPos(), b, u);
              }
              function L() {
                return t6.getStartPos();
              }
              function fe2() {
                return t6.hasPrecedingJSDocComment();
              }
              function T() {
                return ar2;
              }
              function it() {
                return ar2 = t6.scan();
              }
              function mt(u) {
                return _e(), u();
              }
              function _e() {
                return ba(ar2) && (t6.hasUnicodeEscape() || t6.hasExtendedUnicodeEscape()) && Z(t6.getTokenPos(), t6.getTextPos(), ve.Keywords_cannot_contain_escape_characters), it();
              }
              function Ge2() {
                return ar2 = t6.scanJsDocToken();
              }
              function bt() {
                return ar2 = t6.reScanGreaterToken();
              }
              function jt() {
                return ar2 = t6.reScanSlashToken();
              }
              function Yt(u) {
                return ar2 = t6.reScanTemplateToken(u);
              }
              function $t() {
                return ar2 = t6.reScanTemplateHeadOrNoSubstitutionTemplate();
              }
              function Wt() {
                return ar2 = t6.reScanLessThanToken();
              }
              function Xr() {
                return ar2 = t6.reScanHashToken();
              }
              function Dr2() {
                return ar2 = t6.scanJsxIdentifier();
              }
              function Lr() {
                return ar2 = t6.scanJsxToken();
              }
              function yr2() {
                return ar2 = t6.scanJsxAttributeValue();
              }
              function Rn(u, b) {
                let O10 = ar2, j6 = Zt.length, z = Kr2, re2 = nr2, Ee2 = b !== 0 ? t6.lookAhead(u) : t6.tryScan(u);
                return Y3.assert(re2 === nr2), (!Ee2 || b !== 0) && (ar2 = O10, b !== 2 && (Zt.length = j6), Kr2 = z), Ee2;
              }
              function wt(u) {
                return Rn(u, 1);
              }
              function Tr3(u) {
                return Rn(u, 0);
              }
              function Tt() {
                return T() === 79 ? true : T() > 116;
              }
              function kt() {
                return T() === 79 ? true : T() === 125 && Yi2() || T() === 133 && xn() ? false : T() > 116;
              }
              function de2(u, b) {
                let O10 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                return T() === u ? (O10 && _e(), true) : (b ? Dt(b) : Dt(ve._0_expected, Br2(u)), false);
              }
              let jn = Object.keys(cl).filter((u) => u.length > 2);
              function Zi(u) {
                var b;
                if (Y8(u)) {
                  Z(Ar2(_r2, u.template.pos), u.template.end, ve.Module_declaration_names_may_only_use_or_quoted_strings);
                  return;
                }
                let O10 = yt(u) ? qr2(u) : void 0;
                if (!O10 || !vy(O10, Sn)) {
                  Dt(ve._0_expected, Br2(26));
                  return;
                }
                let j6 = Ar2(_r2, u.pos);
                switch (O10) {
                  case "const":
                  case "let":
                  case "var":
                    Z(j6, u.end, ve.Variable_declaration_not_allowed_at_this_location);
                    return;
                  case "declare":
                    return;
                  case "interface":
                    Pa(ve.Interface_name_cannot_be_0, ve.Interface_must_be_given_a_name, 18);
                    return;
                  case "is":
                    Z(j6, t6.getTextPos(), ve.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                    return;
                  case "module":
                  case "namespace":
                    Pa(ve.Namespace_name_cannot_be_0, ve.Namespace_must_be_given_a_name, 18);
                    return;
                  case "type":
                    Pa(ve.Type_alias_name_cannot_be_0, ve.Type_alias_must_be_given_a_name, 63);
                    return;
                }
                let z = (b = Ep(O10, jn, (re2) => re2)) != null ? b : e_(O10);
                if (z) {
                  Z(j6, u.end, ve.Unknown_keyword_or_identifier_Did_you_mean_0, z);
                  return;
                }
                T() !== 0 && Z(j6, u.end, ve.Unexpected_keyword_or_identifier);
              }
              function Pa(u, b, O10) {
                T() === O10 ? Dt(b) : Dt(u, t6.getTokenValue());
              }
              function e_(u) {
                for (let b of jn)
                  if (u.length > b.length + 2 && Pn(u, b))
                    return `${b} ${u.slice(b.length)}`;
              }
              function mc(u, b, O10) {
                if (T() === 59 && !t6.hasPrecedingLineBreak()) {
                  Dt(ve.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);
                  return;
                }
                if (T() === 20) {
                  Dt(ve.Cannot_start_a_function_call_in_a_type_annotation), _e();
                  return;
                }
                if (b && !ka()) {
                  O10 ? Dt(ve._0_expected, Br2(26)) : Dt(ve.Expected_for_property_initializer);
                  return;
                }
                if (!t_()) {
                  if (O10) {
                    Dt(ve._0_expected, Br2(26));
                    return;
                  }
                  Zi(u);
                }
              }
              function Da(u) {
                return T() === u ? (Ge2(), true) : (Dt(ve._0_expected, Br2(u)), false);
              }
              function Ts(u, b, O10, j6) {
                if (T() === b) {
                  _e();
                  return;
                }
                let z = Dt(ve._0_expected, Br2(b));
                O10 && z && Rl(z, Ro(Ur2, j6, 1, ve.The_parser_expected_to_find_a_1_to_match_the_0_token_here, Br2(u), Br2(b)));
              }
              function Ot(u) {
                return T() === u ? (_e(), true) : false;
              }
              function dr2(u) {
                if (T() === u)
                  return sn();
              }
              function Dd(u) {
                if (T() === u)
                  return Id();
              }
              function ea(u, b, O10) {
                return dr2(u) || Jn(u, false, b || ve._0_expected, O10 || Br2(u));
              }
              function kd(u) {
                return Dd(u) || Jn(u, false, ve._0_expected, Br2(u));
              }
              function sn() {
                let u = L(), b = T();
                return _e(), Q2(Ye2(b), u);
              }
              function Id() {
                let u = L(), b = T();
                return Ge2(), Q2(Ye2(b), u);
              }
              function ka() {
                return T() === 26 ? true : T() === 19 || T() === 1 || t6.hasPrecedingLineBreak();
              }
              function t_() {
                return ka() ? (T() === 26 && _e(), true) : false;
              }
              function En() {
                return t_() || de2(26);
              }
              function Er2(u, b, O10, j6) {
                let z = X2(u, j6);
                return Us(z, b, O10 != null ? O10 : t6.getStartPos()), z;
              }
              function Q2(u, b, O10) {
                return Us(u, b, O10 != null ? O10 : t6.getStartPos()), nr2 && (u.flags |= nr2), Kr2 && (Kr2 = false, u.flags |= 131072), u;
              }
              function Jn(u, b, O10, j6) {
                b ? Pi(t6.getStartPos(), 0, O10, j6) : O10 && Dt(O10, j6);
                let z = L(), re2 = u === 79 ? Te2("", void 0) : yl(u) ? N10.createTemplateLiteralLikeNode(u, "", "", void 0) : u === 8 ? F2("", void 0) : u === 10 ? $("", void 0) : u === 279 ? N10.createMissingDeclaration() : Ye2(u);
                return Q2(re2, z);
              }
              function Ia(u) {
                let b = cr2.get(u);
                return b === void 0 && cr2.set(u, b = u), b;
              }
              function Ss(u, b, O10) {
                if (u) {
                  $r2++;
                  let qe = L(), We2 = T(), $e2 = Ia(t6.getTokenValue()), lt2 = t6.hasExtendedUnicodeEscape();
                  return it(), Q2(Te2($e2, We2, lt2), qe);
                }
                if (T() === 80)
                  return Dt(O10 || ve.Private_identifiers_are_not_allowed_outside_class_bodies), Ss(true);
                if (T() === 0 && t6.tryScan(() => t6.reScanInvalidIdentifier() === 79))
                  return Ss(true);
                $r2++;
                let j6 = T() === 1, z = t6.isReservedWord(), re2 = t6.getTokenText(), Ee2 = z ? ve.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here : ve.Identifier_expected;
                return Jn(79, j6, b || Ee2, re2);
              }
              function hc(u) {
                return Ss(Tt(), void 0, u);
              }
              function wr2(u, b) {
                return Ss(kt(), u, b);
              }
              function zr2(u) {
                return Ss(fr2(T()), u);
              }
              function xs() {
                return fr2(T()) || T() === 10 || T() === 8;
              }
              function Nd() {
                return fr2(T()) || T() === 10;
              }
              function R2(u) {
                if (T() === 10 || T() === 8) {
                  let b = Di();
                  return b.text = Ia(b.text), b;
                }
                return u && T() === 22 ? j2() : T() === 80 ? gc() : zr2();
              }
              function Es() {
                return R2(true);
              }
              function j2() {
                let u = L();
                de2(22);
                let b = It(Sr2);
                return de2(23), Q2(N10.createComputedPropertyName(b), u);
              }
              function gc() {
                let u = L(), b = Se2(Ia(t6.getTokenValue()));
                return _e(), Q2(b, u);
              }
              function Ks(u) {
                return T() === u && Tr3(Od);
              }
              function uu() {
                return _e(), t6.hasPrecedingLineBreak() ? false : ta();
              }
              function Od() {
                switch (T()) {
                  case 85:
                    return _e() === 92;
                  case 93:
                    return _e(), T() === 88 ? wt(Ld) : T() === 154 ? wt(J22) : r_();
                  case 88:
                    return Ld();
                  case 124:
                  case 137:
                  case 151:
                    return _e(), ta();
                  default:
                    return uu();
                }
              }
              function r_() {
                return T() === 59 || T() !== 41 && T() !== 128 && T() !== 18 && ta();
              }
              function J22() {
                return _e(), r_();
              }
              function Md() {
                return Wi(T()) && Tr3(Od);
              }
              function ta() {
                return T() === 22 || T() === 18 || T() === 41 || T() === 25 || xs();
              }
              function Ld() {
                return _e(), T() === 84 || T() === 98 || T() === 118 || T() === 59 || T() === 126 && wt(gh) || T() === 132 && wt(yh);
              }
              function Xs(u, b) {
                if (mu(u))
                  return true;
                switch (u) {
                  case 0:
                  case 1:
                  case 3:
                    return !(T() === 26 && b) && vh();
                  case 2:
                    return T() === 82 || T() === 88;
                  case 4:
                    return wt(om);
                  case 5:
                    return wt(Jb) || T() === 26 && !b;
                  case 6:
                    return T() === 22 || xs();
                  case 12:
                    switch (T()) {
                      case 22:
                      case 41:
                      case 25:
                      case 24:
                        return true;
                      default:
                        return xs();
                    }
                  case 18:
                    return xs();
                  case 9:
                    return T() === 22 || T() === 25 || xs();
                  case 24:
                    return Nd();
                  case 7:
                    return T() === 18 ? wt(Rd) : b ? kt() && !fu() : Fu() && !fu();
                  case 8:
                    return tp();
                  case 10:
                    return T() === 27 || T() === 25 || tp();
                  case 19:
                    return T() === 101 || T() === 85 || kt();
                  case 15:
                    switch (T()) {
                      case 27:
                      case 24:
                        return true;
                    }
                  case 11:
                    return T() === 25 || La2();
                  case 16:
                    return Ec(false);
                  case 17:
                    return Ec(true);
                  case 20:
                  case 21:
                    return T() === 27 || eo();
                  case 22:
                    return Oc2();
                  case 23:
                    return fr2(T());
                  case 13:
                    return fr2(T()) || T() === 18;
                  case 14:
                    return true;
                }
                return Y3.fail("Non-exhaustive case in 'isListElement'.");
              }
              function Rd() {
                if (Y3.assert(T() === 18), _e() === 19) {
                  let u = _e();
                  return u === 27 || u === 18 || u === 94 || u === 117;
                }
                return true;
              }
              function yc() {
                return _e(), kt();
              }
              function pu() {
                return _e(), fr2(T());
              }
              function F22() {
                return _e(), qT(T());
              }
              function fu() {
                return T() === 117 || T() === 94 ? wt(jd) : false;
              }
              function jd() {
                return _e(), La2();
              }
              function Jd() {
                return _e(), eo();
              }
              function Na(u) {
                if (T() === 1)
                  return true;
                switch (u) {
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                  case 6:
                  case 12:
                  case 9:
                  case 23:
                  case 24:
                    return T() === 19;
                  case 3:
                    return T() === 19 || T() === 82 || T() === 88;
                  case 7:
                    return T() === 18 || T() === 94 || T() === 117;
                  case 8:
                    return B2();
                  case 19:
                    return T() === 31 || T() === 20 || T() === 18 || T() === 94 || T() === 117;
                  case 11:
                    return T() === 21 || T() === 26;
                  case 15:
                  case 21:
                  case 10:
                    return T() === 23;
                  case 17:
                  case 16:
                  case 18:
                    return T() === 21 || T() === 23;
                  case 20:
                    return T() !== 27;
                  case 22:
                    return T() === 18 || T() === 19;
                  case 13:
                    return T() === 31 || T() === 43;
                  case 14:
                    return T() === 29 && wt(Xb);
                  default:
                    return false;
                }
              }
              function B2() {
                return !!(ka() || jm(T()) || T() === 38);
              }
              function du() {
                for (let u = 0; u < 25; u++)
                  if (hr2 & 1 << u && (Xs(u, true) || Na(u)))
                    return true;
                return false;
              }
              function Kn(u, b) {
                let O10 = hr2;
                hr2 |= 1 << u;
                let j6 = [], z = L();
                for (; !Na(u); ) {
                  if (Xs(u, false)) {
                    j6.push(vc(u, b));
                    continue;
                  }
                  if (bu(u))
                    break;
                }
                return hr2 = O10, Er2(j6, z);
              }
              function vc(u, b) {
                let O10 = mu(u);
                return O10 ? hu(O10) : b();
              }
              function mu(u, b) {
                var O10;
                if (!Nn || !q22(u) || Kr2)
                  return;
                let j6 = Nn.currentNode(b != null ? b : t6.getStartPos());
                if (!(va(j6) || j6.intersectsChange || Ky(j6) || (j6.flags & 50720768) !== nr2) && Fd(j6, u))
                  return Af(j6) && ((O10 = j6.jsDoc) != null && O10.jsDocCache) && (j6.jsDoc.jsDocCache = void 0), j6;
              }
              function hu(u) {
                return t6.setTextPos(u.end), _e(), u;
              }
              function q22(u) {
                switch (u) {
                  case 5:
                  case 2:
                  case 0:
                  case 1:
                  case 3:
                  case 6:
                  case 4:
                  case 8:
                  case 17:
                  case 16:
                    return true;
                }
                return false;
              }
              function Fd(u, b) {
                switch (b) {
                  case 5:
                    return Bd(u);
                  case 2:
                    return gu(u);
                  case 0:
                  case 1:
                  case 3:
                    return qd(u);
                  case 6:
                    return yu(u);
                  case 4:
                    return Ud(u);
                  case 8:
                    return vu(u);
                  case 17:
                  case 16:
                    return zd(u);
                }
                return false;
              }
              function Bd(u) {
                if (u)
                  switch (u.kind) {
                    case 173:
                    case 178:
                    case 174:
                    case 175:
                    case 169:
                    case 237:
                      return true;
                    case 171:
                      let b = u;
                      return !(b.name.kind === 79 && b.name.escapedText === "constructor");
                  }
                return false;
              }
              function gu(u) {
                if (u)
                  switch (u.kind) {
                    case 292:
                    case 293:
                      return true;
                  }
                return false;
              }
              function qd(u) {
                if (u)
                  switch (u.kind) {
                    case 259:
                    case 240:
                    case 238:
                    case 242:
                    case 241:
                    case 254:
                    case 250:
                    case 252:
                    case 249:
                    case 248:
                    case 246:
                    case 247:
                    case 245:
                    case 244:
                    case 251:
                    case 239:
                    case 255:
                    case 253:
                    case 243:
                    case 256:
                    case 269:
                    case 268:
                    case 275:
                    case 274:
                    case 264:
                    case 260:
                    case 261:
                    case 263:
                    case 262:
                      return true;
                  }
                return false;
              }
              function yu(u) {
                return u.kind === 302;
              }
              function Ud(u) {
                if (u)
                  switch (u.kind) {
                    case 177:
                    case 170:
                    case 178:
                    case 168:
                    case 176:
                      return true;
                  }
                return false;
              }
              function vu(u) {
                return u.kind !== 257 ? false : u.initializer === void 0;
              }
              function zd(u) {
                return u.kind !== 166 ? false : u.initializer === void 0;
              }
              function bu(u) {
                return U22(u), du() ? true : (_e(), false);
              }
              function U22(u) {
                switch (u) {
                  case 0:
                    return T() === 88 ? Dt(ve._0_expected, Br2(93)) : Dt(ve.Declaration_or_statement_expected);
                  case 1:
                    return Dt(ve.Declaration_or_statement_expected);
                  case 2:
                    return Dt(ve.case_or_default_expected);
                  case 3:
                    return Dt(ve.Statement_expected);
                  case 18:
                  case 4:
                    return Dt(ve.Property_or_signature_expected);
                  case 5:
                    return Dt(ve.Unexpected_token_A_constructor_method_accessor_or_property_was_expected);
                  case 6:
                    return Dt(ve.Enum_member_expected);
                  case 7:
                    return Dt(ve.Expression_expected);
                  case 8:
                    return ba(T()) ? Dt(ve._0_is_not_allowed_as_a_variable_declaration_name, Br2(T())) : Dt(ve.Variable_declaration_expected);
                  case 9:
                    return Dt(ve.Property_destructuring_pattern_expected);
                  case 10:
                    return Dt(ve.Array_element_destructuring_pattern_expected);
                  case 11:
                    return Dt(ve.Argument_expression_expected);
                  case 12:
                    return Dt(ve.Property_assignment_expected);
                  case 15:
                    return Dt(ve.Expression_or_comma_expected);
                  case 17:
                    return Dt(ve.Parameter_declaration_expected);
                  case 16:
                    return ba(T()) ? Dt(ve._0_is_not_allowed_as_a_parameter_name, Br2(T())) : Dt(ve.Parameter_declaration_expected);
                  case 19:
                    return Dt(ve.Type_parameter_declaration_expected);
                  case 20:
                    return Dt(ve.Type_argument_expected);
                  case 21:
                    return Dt(ve.Type_expected);
                  case 22:
                    return Dt(ve.Unexpected_token_expected);
                  case 23:
                    return Dt(ve.Identifier_expected);
                  case 13:
                    return Dt(ve.Identifier_expected);
                  case 14:
                    return Dt(ve.Identifier_expected);
                  case 24:
                    return Dt(ve.Identifier_or_string_literal_expected);
                  case 25:
                    return Y3.fail("ParsingContext.Count used as a context");
                  default:
                    Y3.assertNever(u);
                }
              }
              function mn(u, b, O10) {
                let j6 = hr2;
                hr2 |= 1 << u;
                let z = [], re2 = L(), Ee2 = -1;
                for (; ; ) {
                  if (Xs(u, false)) {
                    let qe = t6.getStartPos(), We2 = vc(u, b);
                    if (!We2) {
                      hr2 = j6;
                      return;
                    }
                    if (z.push(We2), Ee2 = t6.getTokenPos(), Ot(27))
                      continue;
                    if (Ee2 = -1, Na(u))
                      break;
                    de2(27, z2(u)), O10 && T() === 26 && !t6.hasPrecedingLineBreak() && _e(), qe === t6.getStartPos() && _e();
                    continue;
                  }
                  if (Na(u) || bu(u))
                    break;
                }
                return hr2 = j6, Er2(z, re2, void 0, Ee2 >= 0);
              }
              function z2(u) {
                return u === 6 ? ve.An_enum_member_name_must_be_followed_by_a_or : void 0;
              }
              function ui() {
                let u = Er2([], L());
                return u.isMissingList = true, u;
              }
              function W2(u) {
                return !!u.isMissingList;
              }
              function Oa(u, b, O10, j6) {
                if (de2(O10)) {
                  let z = mn(u, b);
                  return de2(j6), z;
                }
                return ui();
              }
              function Ys(u, b) {
                let O10 = L(), j6 = u ? zr2(b) : wr2(b);
                for (; Ot(24) && T() !== 29; )
                  j6 = Q2(N10.createQualifiedName(j6, bc(u, false)), O10);
                return j6;
              }
              function Tu(u, b) {
                return Q2(N10.createQualifiedName(u, b), u.pos);
              }
              function bc(u, b) {
                if (t6.hasPrecedingLineBreak() && fr2(T()) && wt(Qu))
                  return Jn(79, true, ve.Identifier_expected);
                if (T() === 80) {
                  let O10 = gc();
                  return b ? O10 : Jn(79, true, ve.Identifier_expected);
                }
                return u ? zr2() : wr2();
              }
              function Su(u) {
                let b = L(), O10 = [], j6;
                do
                  j6 = H2(u), O10.push(j6);
                while (j6.literal.kind === 16);
                return Er2(O10, b);
              }
              function Wd(u) {
                let b = L();
                return Q2(N10.createTemplateExpression(Hd(u), Su(u)), b);
              }
              function xu() {
                let u = L();
                return Q2(N10.createTemplateLiteralType(Hd(false), Vd()), u);
              }
              function Vd() {
                let u = L(), b = [], O10;
                do
                  O10 = V2(), b.push(O10);
                while (O10.literal.kind === 16);
                return Er2(b, u);
              }
              function V2() {
                let u = L();
                return Q2(N10.createTemplateLiteralTypeSpan(sr2(), Eu(false)), u);
              }
              function Eu(u) {
                return T() === 19 ? (Yt(u), Tc()) : ea(17, ve._0_expected, Br2(19));
              }
              function H2(u) {
                let b = L();
                return Q2(N10.createTemplateSpan(It(Sr2), Eu(u)), b);
              }
              function Di() {
                return n_(T());
              }
              function Hd(u) {
                u && $t();
                let b = n_(T());
                return Y3.assert(b.kind === 15, "Template head has wrong token kind"), b;
              }
              function Tc() {
                let u = n_(T());
                return Y3.assert(u.kind === 16 || u.kind === 17, "Template fragment has wrong token kind"), u;
              }
              function Gd(u) {
                let b = u === 14 || u === 17, O10 = t6.getTokenText();
                return O10.substring(1, O10.length - (t6.isUnterminated() ? 0 : b ? 1 : 2));
              }
              function n_(u) {
                let b = L(), O10 = yl(u) ? N10.createTemplateLiteralLikeNode(u, t6.getTokenValue(), Gd(u), t6.getTokenFlags() & 2048) : u === 8 ? F2(t6.getTokenValue(), t6.getNumericLiteralFlags()) : u === 10 ? $(t6.getTokenValue(), void 0, t6.hasExtendedUnicodeEscape()) : ky(u) ? ae(u, t6.getTokenValue()) : Y3.fail();
                return t6.hasExtendedUnicodeEscape() && (O10.hasExtendedUnicodeEscape = true), t6.isUnterminated() && (O10.isUnterminated = true), _e(), Q2(O10, b);
              }
              function wu() {
                return Ys(true, ve.Type_expected);
              }
              function Qs() {
                if (!t6.hasPrecedingLineBreak() && Wt() === 29)
                  return Oa(20, sr2, 29, 31);
              }
              function Sc() {
                let u = L();
                return Q2(N10.createTypeReferenceNode(wu(), Qs()), u);
              }
              function Cu(u) {
                switch (u.kind) {
                  case 180:
                    return va(u.typeName);
                  case 181:
                  case 182: {
                    let { parameters: b, type: O10 } = u;
                    return W2(b) || Cu(O10);
                  }
                  case 193:
                    return Cu(u.type);
                  default:
                    return false;
                }
              }
              function G22(u) {
                return _e(), Q2(N10.createTypePredicateNode(void 0, u, sr2()), u.pos);
              }
              function $d() {
                let u = L();
                return _e(), Q2(N10.createThisTypeNode(), u);
              }
              function Kd() {
                let u = L();
                return _e(), Q2(N10.createJSDocAllType(), u);
              }
              function $2() {
                let u = L();
                return _e(), Q2(N10.createJSDocNonNullableType(Lu(), false), u);
              }
              function Xd() {
                let u = L();
                return _e(), T() === 27 || T() === 19 || T() === 21 || T() === 31 || T() === 63 || T() === 51 ? Q2(N10.createJSDocUnknownType(), u) : Q2(N10.createJSDocNullableType(sr2(), false), u);
              }
              function K2() {
                let u = L(), b = fe2();
                if (wt(qh)) {
                  _e();
                  let O10 = ra(36), j6 = pi(58, false);
                  return St(Q2(N10.createJSDocFunctionType(O10, j6), u), b);
                }
                return Q2(N10.createTypeReferenceNode(zr2(), void 0), u);
              }
              function Yd() {
                let u = L(), b;
                return (T() === 108 || T() === 103) && (b = zr2(), de2(58)), Q2(N10.createParameterDeclaration(void 0, void 0, b, void 0, xc(), void 0), u);
              }
              function xc() {
                t6.setInJSDocType(true);
                let u = L();
                if (Ot(142)) {
                  let j6 = N10.createJSDocNamepathType(void 0);
                  e:
                    for (; ; )
                      switch (T()) {
                        case 19:
                        case 1:
                        case 27:
                        case 5:
                          break e;
                        default:
                          Ge2();
                      }
                  return t6.setInJSDocType(false), Q2(j6, u);
                }
                let b = Ot(25), O10 = Ju();
                return t6.setInJSDocType(false), b && (O10 = Q2(N10.createJSDocVariadicType(O10), u)), T() === 63 ? (_e(), Q2(N10.createJSDocOptionalType(O10), u)) : O10;
              }
              function X22() {
                let u = L();
                de2(112);
                let b = Ys(true), O10 = t6.hasPrecedingLineBreak() ? void 0 : Nc2();
                return Q2(N10.createTypeQueryNode(b, O10), u);
              }
              function Qd() {
                let u = L(), b = ki(false, true), O10 = wr2(), j6, z;
                Ot(94) && (eo() || !La2() ? j6 = sr2() : z = Wu());
                let re2 = Ot(63) ? sr2() : void 0, Ee2 = N10.createTypeParameterDeclaration(b, O10, j6, re2);
                return Ee2.expression = z, Q2(Ee2, u);
              }
              function Xn() {
                if (T() === 29)
                  return Oa(19, Qd, 29, 31);
              }
              function Ec(u) {
                return T() === 25 || tp() || Wi(T()) || T() === 59 || eo(!u);
              }
              function Zd(u) {
                let b = no(ve.Private_identifiers_cannot_be_used_as_parameters);
                return hf(b) === 0 && !Ke3(u) && Wi(T()) && _e(), b;
              }
              function em() {
                return Tt() || T() === 22 || T() === 18;
              }
              function Au(u) {
                return Pu(u);
              }
              function tm(u) {
                return Pu(u, false);
              }
              function Pu(u) {
                let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, O10 = L(), j6 = fe2(), z = u ? Xi(() => ki(true)) : Aa(() => ki(true));
                if (T() === 108) {
                  let We2 = N10.createParameterDeclaration(z, void 0, Ss(true), void 0, Ma(), void 0), $e2 = pa(z);
                  return $e2 && ie2($e2, ve.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters), St(Q2(We2, O10), j6);
                }
                let re2 = br2;
                br2 = false;
                let Ee2 = dr2(25);
                if (!b && !em())
                  return;
                let qe = St(Q2(N10.createParameterDeclaration(z, Ee2, Zd(z), dr2(57), Ma(), Ra()), O10), j6);
                return br2 = re2, qe;
              }
              function pi(u, b) {
                if (rm(u, b))
                  return gr2(Ju);
              }
              function rm(u, b) {
                return u === 38 ? (de2(u), true) : Ot(58) ? true : b && T() === 38 ? (Dt(ve._0_expected, Br2(58)), _e(), true) : false;
              }
              function wc(u, b) {
                let O10 = Yi2(), j6 = xn();
                Le2(!!(u & 1)), ot2(!!(u & 2));
                let z = u & 32 ? mn(17, Yd) : mn(16, () => b ? Au(j6) : tm(j6));
                return Le2(O10), ot2(j6), z;
              }
              function ra(u) {
                if (!de2(20))
                  return ui();
                let b = wc(u, true);
                return de2(21), b;
              }
              function i_() {
                Ot(27) || En();
              }
              function nm(u) {
                let b = L(), O10 = fe2();
                u === 177 && de2(103);
                let j6 = Xn(), z = ra(4), re2 = pi(58, true);
                i_();
                let Ee2 = u === 176 ? N10.createCallSignature(j6, z, re2) : N10.createConstructSignature(j6, z, re2);
                return St(Q2(Ee2, b), O10);
              }
              function im() {
                return T() === 22 && wt(Zs);
              }
              function Zs() {
                if (_e(), T() === 25 || T() === 23)
                  return true;
                if (Wi(T())) {
                  if (_e(), kt())
                    return true;
                } else if (kt())
                  _e();
                else
                  return false;
                return T() === 58 || T() === 27 ? true : T() !== 57 ? false : (_e(), T() === 58 || T() === 27 || T() === 23);
              }
              function am(u, b, O10) {
                let j6 = Oa(16, () => Au(false), 22, 23), z = Ma();
                i_();
                let re2 = N10.createIndexSignature(O10, j6, z);
                return St(Q2(re2, u), b);
              }
              function sm(u, b, O10) {
                let j6 = Es(), z = dr2(57), re2;
                if (T() === 20 || T() === 29) {
                  let Ee2 = Xn(), qe = ra(4), We2 = pi(58, true);
                  re2 = N10.createMethodSignature(O10, j6, z, Ee2, qe, We2);
                } else {
                  let Ee2 = Ma();
                  re2 = N10.createPropertySignature(O10, j6, z, Ee2), T() === 63 && (re2.initializer = Ra());
                }
                return i_(), St(Q2(re2, u), b);
              }
              function om() {
                if (T() === 20 || T() === 29 || T() === 137 || T() === 151)
                  return true;
                let u = false;
                for (; Wi(T()); )
                  u = true, _e();
                return T() === 22 ? true : (xs() && (u = true, _e()), u ? T() === 20 || T() === 29 || T() === 57 || T() === 58 || T() === 27 || ka() : false);
              }
              function Du() {
                if (T() === 20 || T() === 29)
                  return nm(176);
                if (T() === 103 && wt(a_))
                  return nm(177);
                let u = L(), b = fe2(), O10 = ki(false);
                return Ks(137) ? Fa(u, b, O10, 174, 4) : Ks(151) ? Fa(u, b, O10, 175, 4) : im() ? am(u, b, O10) : sm(u, b, O10);
              }
              function a_() {
                return _e(), T() === 20 || T() === 29;
              }
              function Y22() {
                return _e() === 24;
              }
              function ku() {
                switch (_e()) {
                  case 20:
                  case 29:
                  case 24:
                    return true;
                }
                return false;
              }
              function Q22() {
                let u = L();
                return Q2(N10.createTypeLiteralNode(Iu()), u);
              }
              function Iu() {
                let u;
                return de2(18) ? (u = Kn(4, Du), de2(19)) : u = ui(), u;
              }
              function Z2() {
                return _e(), T() === 39 || T() === 40 ? _e() === 146 : (T() === 146 && _e(), T() === 22 && yc() && _e() === 101);
              }
              function _m() {
                let u = L(), b = zr2();
                de2(101);
                let O10 = sr2();
                return Q2(N10.createTypeParameterDeclaration(void 0, b, O10, void 0), u);
              }
              function eb() {
                let u = L();
                de2(18);
                let b;
                (T() === 146 || T() === 39 || T() === 40) && (b = sn(), b.kind !== 146 && de2(146)), de2(22);
                let O10 = _m(), j6 = Ot(128) ? sr2() : void 0;
                de2(23);
                let z;
                (T() === 57 || T() === 39 || T() === 40) && (z = sn(), z.kind !== 57 && de2(57));
                let re2 = Ma();
                En();
                let Ee2 = Kn(4, Du);
                return de2(19), Q2(N10.createMappedTypeNode(b, O10, j6, z, re2, Ee2), u);
              }
              function Nu() {
                let u = L();
                if (Ot(25))
                  return Q2(N10.createRestTypeNode(sr2()), u);
                let b = sr2();
                if (uE(b) && b.pos === b.type.pos) {
                  let O10 = N10.createOptionalTypeNode(b.type);
                  return Rt(O10, b), O10.flags = b.flags, O10;
                }
                return b;
              }
              function cm() {
                return _e() === 58 || T() === 57 && _e() === 58;
              }
              function lm() {
                return T() === 25 ? fr2(_e()) && cm() : fr2(T()) && cm();
              }
              function tb() {
                if (wt(lm)) {
                  let u = L(), b = fe2(), O10 = dr2(25), j6 = zr2(), z = dr2(57);
                  de2(58);
                  let re2 = Nu(), Ee2 = N10.createNamedTupleMember(O10, j6, z, re2);
                  return St(Q2(Ee2, u), b);
                }
                return Nu();
              }
              function um() {
                let u = L();
                return Q2(N10.createTupleTypeNode(Oa(21, tb, 22, 23)), u);
              }
              function rb() {
                let u = L();
                de2(20);
                let b = sr2();
                return de2(21), Q2(N10.createParenthesizedType(b), u);
              }
              function pm() {
                let u;
                if (T() === 126) {
                  let b = L();
                  _e();
                  let O10 = Q2(Ye2(126), b);
                  u = Er2([O10], b);
                }
                return u;
              }
              function fm() {
                let u = L(), b = fe2(), O10 = pm(), j6 = Ot(103);
                Y3.assert(!O10 || j6, "Per isStartOfFunctionOrConstructorType, a function type cannot have modifiers.");
                let z = Xn(), re2 = ra(4), Ee2 = pi(38, false), qe = j6 ? N10.createConstructorTypeNode(O10, z, re2, Ee2) : N10.createFunctionTypeNode(z, re2, Ee2);
                return St(Q2(qe, u), b);
              }
              function Ou() {
                let u = sn();
                return T() === 24 ? void 0 : u;
              }
              function dm(u) {
                let b = L();
                u && _e();
                let O10 = T() === 110 || T() === 95 || T() === 104 ? sn() : n_(T());
                return u && (O10 = Q2(N10.createPrefixUnaryExpression(40, O10), b)), Q2(N10.createLiteralTypeNode(O10), b);
              }
              function mm() {
                return _e(), T() === 100;
              }
              function nb() {
                let u = L(), b = t6.getTokenPos();
                de2(18);
                let O10 = t6.hasPrecedingLineBreak();
                de2(130), de2(58);
                let j6 = _p(true);
                if (!de2(19)) {
                  let z = Cn(Zt);
                  z && z.code === ve._0_expected.code && Rl(z, Ro(Ur2, b, 1, ve.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                }
                return Q2(N10.createImportTypeAssertionContainer(j6, O10), u);
              }
              function Mu() {
                Gr2 |= 2097152;
                let u = L(), b = Ot(112);
                de2(100), de2(20);
                let O10 = sr2(), j6;
                Ot(27) && (j6 = nb()), de2(21);
                let z = Ot(24) ? wu() : void 0, re2 = Qs();
                return Q2(N10.createImportTypeNode(O10, j6, z, re2, b), u);
              }
              function hm() {
                return _e(), T() === 8 || T() === 9;
              }
              function Lu() {
                switch (T()) {
                  case 131:
                  case 157:
                  case 152:
                  case 148:
                  case 160:
                  case 153:
                  case 134:
                  case 155:
                  case 144:
                  case 149:
                    return Tr3(Ou) || Sc();
                  case 66:
                    t6.reScanAsteriskEqualsToken();
                  case 41:
                    return Kd();
                  case 60:
                    t6.reScanQuestionToken();
                  case 57:
                    return Xd();
                  case 98:
                    return K2();
                  case 53:
                    return $2();
                  case 14:
                  case 10:
                  case 8:
                  case 9:
                  case 110:
                  case 95:
                  case 104:
                    return dm();
                  case 40:
                    return wt(hm) ? dm(true) : Sc();
                  case 114:
                    return sn();
                  case 108: {
                    let u = $d();
                    return T() === 140 && !t6.hasPrecedingLineBreak() ? G22(u) : u;
                  }
                  case 112:
                    return wt(mm) ? Mu() : X22();
                  case 18:
                    return wt(Z2) ? eb() : Q22();
                  case 22:
                    return um();
                  case 20:
                    return rb();
                  case 100:
                    return Mu();
                  case 129:
                    return wt(Qu) ? Cm() : Sc();
                  case 15:
                    return xu();
                  default:
                    return Sc();
                }
              }
              function eo(u) {
                switch (T()) {
                  case 131:
                  case 157:
                  case 152:
                  case 148:
                  case 160:
                  case 134:
                  case 146:
                  case 153:
                  case 156:
                  case 114:
                  case 155:
                  case 104:
                  case 108:
                  case 112:
                  case 144:
                  case 18:
                  case 22:
                  case 29:
                  case 51:
                  case 50:
                  case 103:
                  case 10:
                  case 8:
                  case 9:
                  case 110:
                  case 95:
                  case 149:
                  case 41:
                  case 57:
                  case 53:
                  case 25:
                  case 138:
                  case 100:
                  case 129:
                  case 14:
                  case 15:
                    return true;
                  case 98:
                    return !u;
                  case 40:
                    return !u && wt(hm);
                  case 20:
                    return !u && wt(gm);
                  default:
                    return kt();
                }
              }
              function gm() {
                return _e(), T() === 21 || Ec(false) || eo();
              }
              function ym() {
                let u = L(), b = Lu();
                for (; !t6.hasPrecedingLineBreak(); )
                  switch (T()) {
                    case 53:
                      _e(), b = Q2(N10.createJSDocNonNullableType(b, true), u);
                      break;
                    case 57:
                      if (wt(Jd))
                        return b;
                      _e(), b = Q2(N10.createJSDocNullableType(b, true), u);
                      break;
                    case 22:
                      if (de2(22), eo()) {
                        let O10 = sr2();
                        de2(23), b = Q2(N10.createIndexedAccessTypeNode(b, O10), u);
                      } else
                        de2(23), b = Q2(N10.createArrayTypeNode(b), u);
                      break;
                    default:
                      return b;
                  }
                return b;
              }
              function vm(u) {
                let b = L();
                return de2(u), Q2(N10.createTypeOperatorNode(u, Tm()), b);
              }
              function ib() {
                if (Ot(94)) {
                  let u = Ln(sr2);
                  if (bs() || T() !== 57)
                    return u;
                }
              }
              function bm() {
                let u = L(), b = wr2(), O10 = Tr3(ib), j6 = N10.createTypeParameterDeclaration(void 0, b, O10);
                return Q2(j6, u);
              }
              function ab() {
                let u = L();
                return de2(138), Q2(N10.createInferTypeNode(bm()), u);
              }
              function Tm() {
                let u = T();
                switch (u) {
                  case 141:
                  case 156:
                  case 146:
                    return vm(u);
                  case 138:
                    return ab();
                }
                return gr2(ym);
              }
              function Cc(u) {
                if (ju()) {
                  let b = fm(), O10;
                  return $l(b) ? O10 = u ? ve.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type : ve.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type : O10 = u ? ve.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type : ve.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type, ie2(b, O10), b;
                }
              }
              function Sm(u, b, O10) {
                let j6 = L(), z = u === 51, re2 = Ot(u), Ee2 = re2 && Cc(z) || b();
                if (T() === u || re2) {
                  let qe = [Ee2];
                  for (; Ot(u); )
                    qe.push(Cc(z) || b());
                  Ee2 = Q2(O10(Er2(qe, j6)), j6);
                }
                return Ee2;
              }
              function Ru() {
                return Sm(50, Tm, N10.createIntersectionTypeNode);
              }
              function sb() {
                return Sm(51, Ru, N10.createUnionTypeNode);
              }
              function xm() {
                return _e(), T() === 103;
              }
              function ju() {
                return T() === 29 || T() === 20 && wt(Em) ? true : T() === 103 || T() === 126 && wt(xm);
              }
              function ob() {
                if (Wi(T()) && ki(false), kt() || T() === 108)
                  return _e(), true;
                if (T() === 22 || T() === 18) {
                  let u = Zt.length;
                  return no(), u === Zt.length;
                }
                return false;
              }
              function Em() {
                return _e(), !!(T() === 21 || T() === 25 || ob() && (T() === 58 || T() === 27 || T() === 57 || T() === 63 || T() === 21 && (_e(), T() === 38)));
              }
              function Ju() {
                let u = L(), b = kt() && Tr3(wm), O10 = sr2();
                return b ? Q2(N10.createTypePredicateNode(void 0, b, O10), u) : O10;
              }
              function wm() {
                let u = wr2();
                if (T() === 140 && !t6.hasPrecedingLineBreak())
                  return _e(), u;
              }
              function Cm() {
                let u = L(), b = ea(129), O10 = T() === 108 ? $d() : wr2(), j6 = Ot(140) ? sr2() : void 0;
                return Q2(N10.createTypePredicateNode(b, O10, j6), u);
              }
              function sr2() {
                if (nr2 & 40960)
                  return Ct(40960, sr2);
                if (ju())
                  return fm();
                let u = L(), b = sb();
                if (!bs() && !t6.hasPrecedingLineBreak() && Ot(94)) {
                  let O10 = Ln(sr2);
                  de2(57);
                  let j6 = gr2(sr2);
                  de2(58);
                  let z = gr2(sr2);
                  return Q2(N10.createConditionalTypeNode(b, O10, j6, z), u);
                }
                return b;
              }
              function Ma() {
                return Ot(58) ? sr2() : void 0;
              }
              function Fu() {
                switch (T()) {
                  case 108:
                  case 106:
                  case 104:
                  case 110:
                  case 95:
                  case 8:
                  case 9:
                  case 10:
                  case 14:
                  case 15:
                  case 20:
                  case 22:
                  case 18:
                  case 98:
                  case 84:
                  case 103:
                  case 43:
                  case 68:
                  case 79:
                    return true;
                  case 100:
                    return wt(ku);
                  default:
                    return kt();
                }
              }
              function La2() {
                if (Fu())
                  return true;
                switch (T()) {
                  case 39:
                  case 40:
                  case 54:
                  case 53:
                  case 89:
                  case 112:
                  case 114:
                  case 45:
                  case 46:
                  case 29:
                  case 133:
                  case 125:
                  case 80:
                  case 59:
                    return true;
                  default:
                    return Jm() ? true : kt();
                }
              }
              function Am() {
                return T() !== 18 && T() !== 98 && T() !== 84 && T() !== 59 && La2();
              }
              function Sr2() {
                let u = Ai();
                u && Re2(false);
                let b = L(), O10 = Yr2(true), j6;
                for (; j6 = dr2(27); )
                  O10 = Uu(O10, j6, Yr2(true), b);
                return u && Re2(true), O10;
              }
              function Ra() {
                return Ot(63) ? Yr2(true) : void 0;
              }
              function Yr2(u) {
                if (Pm())
                  return Dm();
                let b = cb(u) || Mm(u);
                if (b)
                  return b;
                let O10 = L(), j6 = s_(0);
                return j6.kind === 79 && T() === 38 ? km(O10, j6, u, void 0) : Do(j6) && G_(bt()) ? Uu(j6, sn(), Yr2(u), O10) : lb(j6, O10, u);
              }
              function Pm() {
                return T() === 125 ? Yi2() ? true : wt(Zu) : false;
              }
              function _b() {
                return _e(), !t6.hasPrecedingLineBreak() && kt();
              }
              function Dm() {
                let u = L();
                return _e(), !t6.hasPrecedingLineBreak() && (T() === 41 || La2()) ? Q2(N10.createYieldExpression(dr2(41), Yr2(true)), u) : Q2(N10.createYieldExpression(void 0, void 0), u);
              }
              function km(u, b, O10, j6) {
                Y3.assert(T() === 38, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
                let z = N10.createParameterDeclaration(void 0, void 0, b, void 0, void 0, void 0);
                Q2(z, b.pos);
                let re2 = Er2([z], z.pos, z.end), Ee2 = ea(38), qe = Bu(!!j6, O10), We2 = N10.createArrowFunction(j6, void 0, re2, void 0, Ee2, qe);
                return He2(Q2(We2, u));
              }
              function cb(u) {
                let b = Im();
                if (b !== 0)
                  return b === 1 ? Rm(true, true) : Tr3(() => Om(u));
              }
              function Im() {
                return T() === 20 || T() === 29 || T() === 132 ? wt(Nm) : T() === 38 ? 1 : 0;
              }
              function Nm() {
                if (T() === 132 && (_e(), t6.hasPrecedingLineBreak() || T() !== 20 && T() !== 29))
                  return 0;
                let u = T(), b = _e();
                if (u === 20) {
                  if (b === 21)
                    switch (_e()) {
                      case 38:
                      case 58:
                      case 18:
                        return 1;
                      default:
                        return 0;
                    }
                  if (b === 22 || b === 18)
                    return 2;
                  if (b === 25)
                    return 1;
                  if (Wi(b) && b !== 132 && wt(yc))
                    return _e() === 128 ? 0 : 1;
                  if (!kt() && b !== 108)
                    return 0;
                  switch (_e()) {
                    case 58:
                      return 1;
                    case 57:
                      return _e(), T() === 58 || T() === 27 || T() === 63 || T() === 21 ? 1 : 0;
                    case 27:
                    case 63:
                    case 21:
                      return 2;
                  }
                  return 0;
                } else
                  return Y3.assert(u === 29), !kt() && T() !== 85 ? 0 : pr2 === 1 ? wt(() => {
                    Ot(85);
                    let j6 = _e();
                    if (j6 === 94)
                      switch (_e()) {
                        case 63:
                        case 31:
                        case 43:
                          return false;
                        default:
                          return true;
                      }
                    else if (j6 === 27 || j6 === 63)
                      return true;
                    return false;
                  }) ? 1 : 0 : 2;
              }
              function Om(u) {
                let b = t6.getTokenPos();
                if (On != null && On.has(b))
                  return;
                let O10 = Rm(false, u);
                return O10 || (On || (On = /* @__PURE__ */ new Set())).add(b), O10;
              }
              function Mm(u) {
                if (T() === 132 && wt(Lm) === 1) {
                  let b = L(), O10 = sp(), j6 = s_(0);
                  return km(b, j6, u, O10);
                }
              }
              function Lm() {
                if (T() === 132) {
                  if (_e(), t6.hasPrecedingLineBreak() || T() === 38)
                    return 0;
                  let u = s_(0);
                  if (!t6.hasPrecedingLineBreak() && u.kind === 79 && T() === 38)
                    return 1;
                }
                return 0;
              }
              function Rm(u, b) {
                let O10 = L(), j6 = fe2(), z = sp(), re2 = Ke3(z, Ul) ? 2 : 0, Ee2 = Xn(), qe;
                if (de2(20)) {
                  if (u)
                    qe = wc(re2, u);
                  else {
                    let di = wc(re2, u);
                    if (!di)
                      return;
                    qe = di;
                  }
                  if (!de2(21) && !u)
                    return;
                } else {
                  if (!u)
                    return;
                  qe = ui();
                }
                let We2 = T() === 58, $e2 = pi(58, false);
                if ($e2 && !u && Cu($e2))
                  return;
                let lt2 = $e2;
                for (; (lt2 == null ? void 0 : lt2.kind) === 193; )
                  lt2 = lt2.type;
                let Jt = lt2 && dd(lt2);
                if (!u && T() !== 38 && (Jt || T() !== 18))
                  return;
                let Lt = T(), At = ea(38), kr2 = Lt === 38 || Lt === 18 ? Bu(Ke3(z, Ul), b) : wr2();
                if (!b && We2 && T() !== 58)
                  return;
                let Fn = N10.createArrowFunction(z, Ee2, qe, $e2, At, kr2);
                return St(Q2(Fn, O10), j6);
              }
              function Bu(u, b) {
                if (T() === 18)
                  return Dc(u ? 2 : 0);
                if (T() !== 26 && T() !== 98 && T() !== 84 && vh() && !Am())
                  return Dc(16 | (u ? 2 : 0));
                let O10 = br2;
                br2 = false;
                let j6 = u ? Xi(() => Yr2(b)) : Aa(() => Yr2(b));
                return br2 = O10, j6;
              }
              function lb(u, b, O10) {
                let j6 = dr2(57);
                if (!j6)
                  return u;
                let z;
                return Q2(N10.createConditionalExpression(u, j6, Ct(r, () => Yr2(false)), z = ea(58), xl(z) ? Yr2(O10) : Jn(79, false, ve._0_expected, Br2(58))), b);
              }
              function s_(u) {
                let b = L(), O10 = Wu();
                return qu(u, O10, b);
              }
              function jm(u) {
                return u === 101 || u === 162;
              }
              function qu(u, b, O10) {
                for (; ; ) {
                  bt();
                  let j6 = Dl(T());
                  if (!(T() === 42 ? j6 >= u : j6 > u) || T() === 101 && Qi())
                    break;
                  if (T() === 128 || T() === 150) {
                    if (t6.hasPrecedingLineBreak())
                      break;
                    {
                      let re2 = T();
                      _e(), b = re2 === 150 ? Fm(b, sr2()) : Bm2(b, sr2());
                    }
                  } else
                    b = Uu(b, sn(), s_(j6), O10);
                }
                return b;
              }
              function Jm() {
                return Qi() && T() === 101 ? false : Dl(T()) > 0;
              }
              function Fm(u, b) {
                return Q2(N10.createSatisfiesExpression(u, b), u.pos);
              }
              function Uu(u, b, O10, j6) {
                return Q2(N10.createBinaryExpression(u, b, O10), j6);
              }
              function Bm2(u, b) {
                return Q2(N10.createAsExpression(u, b), u.pos);
              }
              function qm() {
                let u = L();
                return Q2(N10.createPrefixUnaryExpression(T(), mt(na)), u);
              }
              function Um() {
                let u = L();
                return Q2(N10.createDeleteExpression(mt(na)), u);
              }
              function ub() {
                let u = L();
                return Q2(N10.createTypeOfExpression(mt(na)), u);
              }
              function zm2() {
                let u = L();
                return Q2(N10.createVoidExpression(mt(na)), u);
              }
              function pb() {
                return T() === 133 ? xn() ? true : wt(Zu) : false;
              }
              function zu() {
                let u = L();
                return Q2(N10.createAwaitExpression(mt(na)), u);
              }
              function Wu() {
                if (Wm()) {
                  let O10 = L(), j6 = Vm();
                  return T() === 42 ? qu(Dl(T()), j6, O10) : j6;
                }
                let u = T(), b = na();
                if (T() === 42) {
                  let O10 = Ar2(_r2, b.pos), { end: j6 } = b;
                  b.kind === 213 ? Z(O10, j6, ve.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses) : Z(O10, j6, ve.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, Br2(u));
                }
                return b;
              }
              function na() {
                switch (T()) {
                  case 39:
                  case 40:
                  case 54:
                  case 53:
                    return qm();
                  case 89:
                    return Um();
                  case 112:
                    return ub();
                  case 114:
                    return zm2();
                  case 29:
                    return pr2 === 1 ? o_(true) : Zm();
                  case 133:
                    if (pb())
                      return zu();
                  default:
                    return Vm();
                }
              }
              function Wm() {
                switch (T()) {
                  case 39:
                  case 40:
                  case 54:
                  case 53:
                  case 89:
                  case 112:
                  case 114:
                  case 133:
                    return false;
                  case 29:
                    if (pr2 !== 1)
                      return false;
                  default:
                    return true;
                }
              }
              function Vm() {
                if (T() === 45 || T() === 46) {
                  let b = L();
                  return Q2(N10.createPrefixUnaryExpression(T(), mt(to)), b);
                } else if (pr2 === 1 && T() === 29 && wt(F22))
                  return o_(true);
                let u = to();
                if (Y3.assert(Do(u)), (T() === 45 || T() === 46) && !t6.hasPrecedingLineBreak()) {
                  let b = T();
                  return _e(), Q2(N10.createPostfixUnaryExpression(u, b), u.pos);
                }
                return u;
              }
              function to() {
                let u = L(), b;
                return T() === 100 ? wt(a_) ? (Gr2 |= 2097152, b = sn()) : wt(Y22) ? (_e(), _e(), b = Q2(N10.createMetaProperty(100, zr2()), u), Gr2 |= 4194304) : b = Hm() : b = T() === 106 ? Vu() : Hm(), $u(u, b);
              }
              function Hm() {
                let u = L(), b = Ku();
                return Ja(u, b, true);
              }
              function Vu() {
                let u = L(), b = sn();
                if (T() === 29) {
                  let O10 = L(), j6 = Tr3(Pc);
                  j6 !== void 0 && (Z(O10, L(), ve.super_may_not_use_type_arguments), __() || (b = N10.createExpressionWithTypeArguments(b, j6)));
                }
                return T() === 20 || T() === 24 || T() === 22 ? b : (ea(24, ve.super_must_be_followed_by_an_argument_list_or_member_access), Q2(Ve2(b, bc(true, true)), u));
              }
              function o_(u, b, O10) {
                let j6 = L(), z = Km(u), re2;
                if (z.kind === 283) {
                  let Ee2 = $m(z), qe, We2 = Ee2[Ee2.length - 1];
                  if ((We2 == null ? void 0 : We2.kind) === 281 && !Hi(We2.openingElement.tagName, We2.closingElement.tagName) && Hi(z.tagName, We2.closingElement.tagName)) {
                    let $e2 = We2.children.end, lt2 = Q2(N10.createJsxElement(We2.openingElement, We2.children, Q2(N10.createJsxClosingElement(Q2(Te2(""), $e2, $e2)), $e2, $e2)), We2.openingElement.pos, $e2);
                    Ee2 = Er2([...Ee2.slice(0, Ee2.length - 1), lt2], Ee2.pos, $e2), qe = We2.closingElement;
                  } else
                    qe = Qm(z, u), Hi(z.tagName, qe.tagName) || (O10 && tu(O10) && Hi(qe.tagName, O10.tagName) ? ie2(z.tagName, ve.JSX_element_0_has_no_corresponding_closing_tag, B_(_r2, z.tagName)) : ie2(qe.tagName, ve.Expected_corresponding_JSX_closing_tag_for_0, B_(_r2, z.tagName)));
                  re2 = Q2(N10.createJsxElement(z, Ee2, qe), j6);
                } else
                  z.kind === 286 ? re2 = Q2(N10.createJsxFragment(z, $m(z), gb(u)), j6) : (Y3.assert(z.kind === 282), re2 = z);
                if (u && T() === 29) {
                  let Ee2 = typeof b > "u" ? re2.pos : b, qe = Tr3(() => o_(true, Ee2));
                  if (qe) {
                    let We2 = Jn(27, false);
                    return $f(We2, qe.pos, 0), Z(Ar2(_r2, Ee2), qe.end, ve.JSX_expressions_must_have_one_parent_element), Q2(N10.createBinaryExpression(re2, We2, qe), j6);
                  }
                }
                return re2;
              }
              function fb() {
                let u = L(), b = N10.createJsxText(t6.getTokenValue(), ar2 === 12);
                return ar2 = t6.scanJsxToken(), Q2(b, u);
              }
              function Gm2(u, b) {
                switch (b) {
                  case 1:
                    if (u2(u))
                      ie2(u, ve.JSX_fragment_has_no_corresponding_closing_tag);
                    else {
                      let O10 = u.tagName, j6 = Ar2(_r2, O10.pos);
                      Z(j6, O10.end, ve.JSX_element_0_has_no_corresponding_closing_tag, B_(_r2, u.tagName));
                    }
                    return;
                  case 30:
                  case 7:
                    return;
                  case 11:
                  case 12:
                    return fb();
                  case 18:
                    return Xm(false);
                  case 29:
                    return o_(false, void 0, u);
                  default:
                    return Y3.assertNever(b);
                }
              }
              function $m(u) {
                let b = [], O10 = L(), j6 = hr2;
                for (hr2 |= 1 << 14; ; ) {
                  let z = Gm2(u, ar2 = t6.reScanJsxToken());
                  if (!z || (b.push(z), tu(u) && (z == null ? void 0 : z.kind) === 281 && !Hi(z.openingElement.tagName, z.closingElement.tagName) && Hi(u.tagName, z.closingElement.tagName)))
                    break;
                }
                return hr2 = j6, Er2(b, O10);
              }
              function db() {
                let u = L();
                return Q2(N10.createJsxAttributes(Kn(13, mb)), u);
              }
              function Km(u) {
                let b = L();
                if (de2(29), T() === 31)
                  return Lr(), Q2(N10.createJsxOpeningFragment(), b);
                let O10 = Ac(), j6 = nr2 & 262144 ? void 0 : Nc2(), z = db(), re2;
                return T() === 31 ? (Lr(), re2 = N10.createJsxOpeningElement(O10, j6, z)) : (de2(43), de2(31, void 0, false) && (u ? _e() : Lr()), re2 = N10.createJsxSelfClosingElement(O10, j6, z)), Q2(re2, b);
              }
              function Ac() {
                let u = L();
                Dr2();
                let b = T() === 108 ? sn() : zr2();
                for (; Ot(24); )
                  b = Q2(Ve2(b, bc(true, false)), u);
                return b;
              }
              function Xm(u) {
                let b = L();
                if (!de2(18))
                  return;
                let O10, j6;
                return T() !== 19 && (O10 = dr2(25), j6 = Sr2()), u ? de2(19) : de2(19, void 0, false) && Lr(), Q2(N10.createJsxExpression(O10, j6), b);
              }
              function mb() {
                if (T() === 18)
                  return hb();
                Dr2();
                let u = L();
                return Q2(N10.createJsxAttribute(zr2(), Ym()), u);
              }
              function Ym() {
                if (T() === 63) {
                  if (yr2() === 10)
                    return Di();
                  if (T() === 18)
                    return Xm(true);
                  if (T() === 29)
                    return o_(true);
                  Dt(ve.or_JSX_element_expected);
                }
              }
              function hb() {
                let u = L();
                de2(18), de2(25);
                let b = Sr2();
                return de2(19), Q2(N10.createJsxSpreadAttribute(b), u);
              }
              function Qm(u, b) {
                let O10 = L();
                de2(30);
                let j6 = Ac();
                return de2(31, void 0, false) && (b || !Hi(u.tagName, j6) ? _e() : Lr()), Q2(N10.createJsxClosingElement(j6), O10);
              }
              function gb(u) {
                let b = L();
                return de2(30), de2(31, ve.Expected_corresponding_closing_tag_for_JSX_fragment, false) && (u ? _e() : Lr()), Q2(N10.createJsxJsxClosingFragment(), b);
              }
              function Zm() {
                Y3.assert(pr2 !== 1, "Type assertions should never be parsed in JSX; they should be parsed as comparisons or JSX elements/fragments.");
                let u = L();
                de2(29);
                let b = sr2();
                de2(31);
                let O10 = na();
                return Q2(N10.createTypeAssertion(b, O10), u);
              }
              function yb() {
                return _e(), fr2(T()) || T() === 22 || __();
              }
              function eh() {
                return T() === 28 && wt(yb);
              }
              function Hu(u) {
                if (u.flags & 32)
                  return true;
                if (Uo(u)) {
                  let b = u.expression;
                  for (; Uo(b) && !(b.flags & 32); )
                    b = b.expression;
                  if (b.flags & 32) {
                    for (; Uo(u); )
                      u.flags |= 32, u = u.expression;
                    return true;
                  }
                }
                return false;
              }
              function fi(u, b, O10) {
                let j6 = bc(true, true), z = O10 || Hu(b), re2 = z ? pt2(b, O10, j6) : Ve2(b, j6);
                if (z && vn(re2.name) && ie2(re2.name, ve.An_optional_chain_cannot_contain_private_identifiers), e2(b) && b.typeArguments) {
                  let Ee2 = b.typeArguments.pos - 1, qe = Ar2(_r2, b.typeArguments.end) + 1;
                  Z(Ee2, qe, ve.An_instantiation_expression_cannot_be_followed_by_a_property_access);
                }
                return Q2(re2, u);
              }
              function ja(u, b, O10) {
                let j6;
                if (T() === 23)
                  j6 = Jn(79, true, ve.An_element_access_expression_should_take_an_argument);
                else {
                  let re2 = It(Sr2);
                  Ta(re2) && (re2.text = Ia(re2.text)), j6 = re2;
                }
                de2(23);
                let z = O10 || Hu(b) ? Nt(b, O10, j6) : Gt(b, j6);
                return Q2(z, u);
              }
              function Ja(u, b, O10) {
                for (; ; ) {
                  let j6, z = false;
                  if (O10 && eh() ? (j6 = ea(28), z = fr2(T())) : z = Ot(24), z) {
                    b = fi(u, b, j6);
                    continue;
                  }
                  if ((j6 || !Ai()) && Ot(22)) {
                    b = ja(u, b, j6);
                    continue;
                  }
                  if (__()) {
                    b = !j6 && b.kind === 230 ? Gu(u, b.expression, j6, b.typeArguments) : Gu(u, b, j6, void 0);
                    continue;
                  }
                  if (!j6) {
                    if (T() === 53 && !t6.hasPrecedingLineBreak()) {
                      _e(), b = Q2(N10.createNonNullExpression(b), u);
                      continue;
                    }
                    let re2 = Tr3(Pc);
                    if (re2) {
                      b = Q2(N10.createExpressionWithTypeArguments(b, re2), u);
                      continue;
                    }
                  }
                  return b;
                }
              }
              function __() {
                return T() === 14 || T() === 15;
              }
              function Gu(u, b, O10, j6) {
                let z = N10.createTaggedTemplateExpression(b, j6, T() === 14 ? ($t(), Di()) : Wd(true));
                return (O10 || b.flags & 32) && (z.flags |= 32), z.questionDotToken = O10, Q2(z, u);
              }
              function $u(u, b) {
                for (; ; ) {
                  b = Ja(u, b, true);
                  let O10, j6 = dr2(28);
                  if (j6 && (O10 = Tr3(Pc), __())) {
                    b = Gu(u, b, j6, O10);
                    continue;
                  }
                  if (O10 || T() === 20) {
                    !j6 && b.kind === 230 && (O10 = b.typeArguments, b = b.expression);
                    let z = th(), re2 = j6 || Hu(b) ? er2(b, j6, O10, z) : Xt(b, O10, z);
                    b = Q2(re2, u);
                    continue;
                  }
                  if (j6) {
                    let z = Jn(79, false, ve.Identifier_expected);
                    b = Q2(pt2(b, j6, z), u);
                  }
                  break;
                }
                return b;
              }
              function th() {
                de2(20);
                let u = mn(11, ih);
                return de2(21), u;
              }
              function Pc() {
                if (nr2 & 262144 || Wt() !== 29)
                  return;
                _e();
                let u = mn(20, sr2);
                if (bt() === 31)
                  return _e(), u && vb() ? u : void 0;
              }
              function vb() {
                switch (T()) {
                  case 20:
                  case 14:
                  case 15:
                    return true;
                  case 29:
                  case 31:
                  case 39:
                  case 40:
                    return false;
                }
                return t6.hasPrecedingLineBreak() || Jm() || !La2();
              }
              function Ku() {
                switch (T()) {
                  case 8:
                  case 9:
                  case 10:
                  case 14:
                    return Di();
                  case 108:
                  case 106:
                  case 104:
                  case 110:
                  case 95:
                    return sn();
                  case 20:
                    return bb();
                  case 22:
                    return ah();
                  case 18:
                    return Xu();
                  case 132:
                    if (!wt(yh))
                      break;
                    return Yu();
                  case 59:
                    return Ub();
                  case 84:
                    return Ih();
                  case 98:
                    return Yu();
                  case 103:
                    return Tb();
                  case 43:
                  case 68:
                    if (jt() === 13)
                      return Di();
                    break;
                  case 15:
                    return Wd(false);
                  case 80:
                    return gc();
                }
                return wr2(ve.Expression_expected);
              }
              function bb() {
                let u = L(), b = fe2();
                de2(20);
                let O10 = It(Sr2);
                return de2(21), St(Q2(Hr2(O10), u), b);
              }
              function rh() {
                let u = L();
                de2(25);
                let b = Yr2(true);
                return Q2(N10.createSpreadElement(b), u);
              }
              function nh() {
                return T() === 25 ? rh() : T() === 27 ? Q2(N10.createOmittedExpression(), L()) : Yr2(true);
              }
              function ih() {
                return Ct(r, nh);
              }
              function ah() {
                let u = L(), b = t6.getTokenPos(), O10 = de2(22), j6 = t6.hasPrecedingLineBreak(), z = mn(15, nh);
                return Ts(22, 23, O10, b), Q2(Ne2(z, j6), u);
              }
              function sh() {
                let u = L(), b = fe2();
                if (dr2(25)) {
                  let lt2 = Yr2(true);
                  return St(Q2(N10.createSpreadAssignment(lt2), u), b);
                }
                let O10 = ki(true);
                if (Ks(137))
                  return Fa(u, b, O10, 174, 0);
                if (Ks(151))
                  return Fa(u, b, O10, 175, 0);
                let j6 = dr2(41), z = kt(), re2 = Es(), Ee2 = dr2(57), qe = dr2(53);
                if (j6 || T() === 20 || T() === 29)
                  return Ah(u, b, O10, j6, re2, Ee2, qe);
                let We2;
                if (z && T() !== 58) {
                  let lt2 = dr2(63), Jt = lt2 ? It(() => Yr2(true)) : void 0;
                  We2 = N10.createShorthandPropertyAssignment(re2, Jt), We2.equalsToken = lt2;
                } else {
                  de2(58);
                  let lt2 = It(() => Yr2(true));
                  We2 = N10.createPropertyAssignment(re2, lt2);
                }
                return We2.modifiers = O10, We2.questionToken = Ee2, We2.exclamationToken = qe, St(Q2(We2, u), b);
              }
              function Xu() {
                let u = L(), b = t6.getTokenPos(), O10 = de2(18), j6 = t6.hasPrecedingLineBreak(), z = mn(12, sh, true);
                return Ts(18, 19, O10, b), Q2(oe2(z, j6), u);
              }
              function Yu() {
                let u = Ai();
                Re2(false);
                let b = L(), O10 = fe2(), j6 = ki(false);
                de2(98);
                let z = dr2(41), re2 = z ? 1 : 0, Ee2 = Ke3(j6, Ul) ? 2 : 0, qe = re2 && Ee2 ? vs(ro) : re2 ? ys(ro) : Ee2 ? Xi(ro) : ro(), We2 = Xn(), $e2 = ra(re2 | Ee2), lt2 = pi(58, false), Jt = Dc(re2 | Ee2);
                Re2(u);
                let Lt = N10.createFunctionExpression(j6, z, qe, We2, $e2, lt2, Jt);
                return St(Q2(Lt, b), O10);
              }
              function ro() {
                return Tt() ? hc() : void 0;
              }
              function Tb() {
                let u = L();
                if (de2(103), Ot(24)) {
                  let re2 = zr2();
                  return Q2(N10.createMetaProperty(103, re2), u);
                }
                let b = L(), O10 = Ja(b, Ku(), false), j6;
                O10.kind === 230 && (j6 = O10.typeArguments, O10 = O10.expression), T() === 28 && Dt(ve.Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0, B_(_r2, O10));
                let z = T() === 20 ? th() : void 0;
                return Q2(Tn(O10, j6, z), u);
              }
              function ws(u, b) {
                let O10 = L(), j6 = fe2(), z = t6.getTokenPos(), re2 = de2(18, b);
                if (re2 || u) {
                  let Ee2 = t6.hasPrecedingLineBreak(), qe = Kn(1, on);
                  Ts(18, 19, re2, z);
                  let We2 = St(Q2(Gi(qe, Ee2), O10), j6);
                  return T() === 63 && (Dt(ve.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses), _e()), We2;
                } else {
                  let Ee2 = ui();
                  return St(Q2(Gi(Ee2, void 0), O10), j6);
                }
              }
              function Dc(u, b) {
                let O10 = Yi2();
                Le2(!!(u & 1));
                let j6 = xn();
                ot2(!!(u & 2));
                let z = br2;
                br2 = false;
                let re2 = Ai();
                re2 && Re2(false);
                let Ee2 = ws(!!(u & 16), b);
                return re2 && Re2(true), br2 = z, Le2(O10), ot2(j6), Ee2;
              }
              function oh() {
                let u = L(), b = fe2();
                return de2(26), St(Q2(N10.createEmptyStatement(), u), b);
              }
              function Sb() {
                let u = L(), b = fe2();
                de2(99);
                let O10 = t6.getTokenPos(), j6 = de2(20), z = It(Sr2);
                Ts(20, 21, j6, O10);
                let re2 = on(), Ee2 = Ot(91) ? on() : void 0;
                return St(Q2(Ut(z, re2, Ee2), u), b);
              }
              function _h() {
                let u = L(), b = fe2();
                de2(90);
                let O10 = on();
                de2(115);
                let j6 = t6.getTokenPos(), z = de2(20), re2 = It(Sr2);
                return Ts(20, 21, z, j6), Ot(26), St(Q2(N10.createDoStatement(O10, re2), u), b);
              }
              function xb() {
                let u = L(), b = fe2();
                de2(115);
                let O10 = t6.getTokenPos(), j6 = de2(20), z = It(Sr2);
                Ts(20, 21, j6, O10);
                let re2 = on();
                return St(Q2(kn(z, re2), u), b);
              }
              function ch() {
                let u = L(), b = fe2();
                de2(97);
                let O10 = dr2(133);
                de2(20);
                let j6;
                T() !== 26 && (T() === 113 || T() === 119 || T() === 85 ? j6 = Eh(true) : j6 = Mr2(Sr2));
                let z;
                if (O10 ? de2(162) : Ot(162)) {
                  let re2 = It(() => Yr2(true));
                  de2(21), z = mr2(O10, j6, re2, on());
                } else if (Ot(101)) {
                  let re2 = It(Sr2);
                  de2(21), z = N10.createForInStatement(j6, re2, on());
                } else {
                  de2(26);
                  let re2 = T() !== 26 && T() !== 21 ? It(Sr2) : void 0;
                  de2(26);
                  let Ee2 = T() !== 21 ? It(Sr2) : void 0;
                  de2(21), z = an(j6, re2, Ee2, on());
                }
                return St(Q2(z, u), b);
              }
              function lh(u) {
                let b = L(), O10 = fe2();
                de2(u === 249 ? 81 : 86);
                let j6 = ka() ? void 0 : wr2();
                En();
                let z = u === 249 ? N10.createBreakStatement(j6) : N10.createContinueStatement(j6);
                return St(Q2(z, b), O10);
              }
              function uh() {
                let u = L(), b = fe2();
                de2(105);
                let O10 = ka() ? void 0 : It(Sr2);
                return En(), St(Q2(N10.createReturnStatement(O10), u), b);
              }
              function Eb() {
                let u = L(), b = fe2();
                de2(116);
                let O10 = t6.getTokenPos(), j6 = de2(20), z = It(Sr2);
                Ts(20, 21, j6, O10);
                let re2 = Mt(33554432, on);
                return St(Q2(N10.createWithStatement(z, re2), u), b);
              }
              function wb() {
                let u = L(), b = fe2();
                de2(82);
                let O10 = It(Sr2);
                de2(58);
                let j6 = Kn(3, on);
                return St(Q2(N10.createCaseClause(O10, j6), u), b);
              }
              function ph() {
                let u = L();
                de2(88), de2(58);
                let b = Kn(3, on);
                return Q2(N10.createDefaultClause(b), u);
              }
              function Cb() {
                return T() === 82 ? wb() : ph();
              }
              function fh() {
                let u = L();
                de2(18);
                let b = Kn(2, Cb);
                return de2(19), Q2(N10.createCaseBlock(b), u);
              }
              function Ab() {
                let u = L(), b = fe2();
                de2(107), de2(20);
                let O10 = It(Sr2);
                de2(21);
                let j6 = fh();
                return St(Q2(N10.createSwitchStatement(O10, j6), u), b);
              }
              function dh() {
                let u = L(), b = fe2();
                de2(109);
                let O10 = t6.hasPrecedingLineBreak() ? void 0 : It(Sr2);
                return O10 === void 0 && ($r2++, O10 = Q2(Te2(""), L())), t_() || Zi(O10), St(Q2(N10.createThrowStatement(O10), u), b);
              }
              function Pb() {
                let u = L(), b = fe2();
                de2(111);
                let O10 = ws(false), j6 = T() === 83 ? mh() : void 0, z;
                return (!j6 || T() === 96) && (de2(96, ve.catch_or_finally_expected), z = ws(false)), St(Q2(N10.createTryStatement(O10, j6, z), u), b);
              }
              function mh() {
                let u = L();
                de2(83);
                let b;
                Ot(20) ? (b = Ic(), de2(21)) : b = void 0;
                let O10 = ws(false);
                return Q2(N10.createCatchClause(b, O10), u);
              }
              function Db() {
                let u = L(), b = fe2();
                return de2(87), En(), St(Q2(N10.createDebuggerStatement(), u), b);
              }
              function hh() {
                let u = L(), b = fe2(), O10, j6 = T() === 20, z = It(Sr2);
                return yt(z) && Ot(58) ? O10 = N10.createLabeledStatement(z, on()) : (t_() || Zi(z), O10 = fn(z), j6 && (b = false)), St(Q2(O10, u), b);
              }
              function Qu() {
                return _e(), fr2(T()) && !t6.hasPrecedingLineBreak();
              }
              function gh() {
                return _e(), T() === 84 && !t6.hasPrecedingLineBreak();
              }
              function yh() {
                return _e(), T() === 98 && !t6.hasPrecedingLineBreak();
              }
              function Zu() {
                return _e(), (fr2(T()) || T() === 8 || T() === 9 || T() === 10) && !t6.hasPrecedingLineBreak();
              }
              function kb() {
                for (; ; )
                  switch (T()) {
                    case 113:
                    case 119:
                    case 85:
                    case 98:
                    case 84:
                    case 92:
                      return true;
                    case 118:
                    case 154:
                      return _b();
                    case 142:
                    case 143:
                      return Ob();
                    case 126:
                    case 127:
                    case 132:
                    case 136:
                    case 121:
                    case 122:
                    case 123:
                    case 146:
                      if (_e(), t6.hasPrecedingLineBreak())
                        return false;
                      continue;
                    case 159:
                      return _e(), T() === 18 || T() === 79 || T() === 93;
                    case 100:
                      return _e(), T() === 10 || T() === 41 || T() === 18 || fr2(T());
                    case 93:
                      let u = _e();
                      if (u === 154 && (u = wt(_e)), u === 63 || u === 41 || u === 18 || u === 88 || u === 128 || u === 59)
                        return true;
                      continue;
                    case 124:
                      _e();
                      continue;
                    default:
                      return false;
                  }
              }
              function c_() {
                return wt(kb);
              }
              function vh() {
                switch (T()) {
                  case 59:
                  case 26:
                  case 18:
                  case 113:
                  case 119:
                  case 98:
                  case 84:
                  case 92:
                  case 99:
                  case 90:
                  case 115:
                  case 97:
                  case 86:
                  case 81:
                  case 105:
                  case 116:
                  case 107:
                  case 109:
                  case 111:
                  case 87:
                  case 83:
                  case 96:
                    return true;
                  case 100:
                    return c_() || wt(ku);
                  case 85:
                  case 93:
                    return c_();
                  case 132:
                  case 136:
                  case 118:
                  case 142:
                  case 143:
                  case 154:
                  case 159:
                    return true;
                  case 127:
                  case 123:
                  case 121:
                  case 122:
                  case 124:
                  case 146:
                    return c_() || !wt(Qu);
                  default:
                    return La2();
                }
              }
              function bh() {
                return _e(), Tt() || T() === 18 || T() === 22;
              }
              function Ib() {
                return wt(bh);
              }
              function on() {
                switch (T()) {
                  case 26:
                    return oh();
                  case 18:
                    return ws(false);
                  case 113:
                    return rp(L(), fe2(), void 0);
                  case 119:
                    if (Ib())
                      return rp(L(), fe2(), void 0);
                    break;
                  case 98:
                    return np(L(), fe2(), void 0);
                  case 84:
                    return Nh(L(), fe2(), void 0);
                  case 99:
                    return Sb();
                  case 90:
                    return _h();
                  case 115:
                    return xb();
                  case 97:
                    return ch();
                  case 86:
                    return lh(248);
                  case 81:
                    return lh(249);
                  case 105:
                    return uh();
                  case 116:
                    return Eb();
                  case 107:
                    return Ab();
                  case 109:
                    return dh();
                  case 111:
                  case 83:
                  case 96:
                    return Pb();
                  case 87:
                    return Db();
                  case 59:
                    return ep();
                  case 132:
                  case 118:
                  case 154:
                  case 142:
                  case 143:
                  case 136:
                  case 85:
                  case 92:
                  case 93:
                  case 100:
                  case 121:
                  case 122:
                  case 123:
                  case 126:
                  case 127:
                  case 124:
                  case 146:
                  case 159:
                    if (c_())
                      return ep();
                    break;
                }
                return hh();
              }
              function Th2(u) {
                return u.kind === 136;
              }
              function ep() {
                let u = L(), b = fe2(), O10 = ki(true);
                if (Ke3(O10, Th2)) {
                  let z = Nb(u);
                  if (z)
                    return z;
                  for (let re2 of O10)
                    re2.flags |= 16777216;
                  return Mt(16777216, () => l_(u, b, O10));
                } else
                  return l_(u, b, O10);
              }
              function Nb(u) {
                return Mt(16777216, () => {
                  let b = mu(hr2, u);
                  if (b)
                    return hu(b);
                });
              }
              function l_(u, b, O10) {
                switch (T()) {
                  case 113:
                  case 119:
                  case 85:
                    return rp(u, b, O10);
                  case 98:
                    return np(u, b, O10);
                  case 84:
                    return Nh(u, b, O10);
                  case 118:
                    return Hb(u, b, O10);
                  case 154:
                    return Gb(u, b, O10);
                  case 92:
                    return Kb(u, b, O10);
                  case 159:
                  case 142:
                  case 143:
                    return Fh(u, b, O10);
                  case 100:
                    return Qb(u, b, O10);
                  case 93:
                    switch (_e(), T()) {
                      case 88:
                      case 63:
                        return _6(u, b, O10);
                      case 128:
                        return Yb(u, b, O10);
                      default:
                        return o6(u, b, O10);
                    }
                  default:
                    if (O10) {
                      let j6 = Jn(279, true, ve.Declaration_expected);
                      return Gf(j6, u), j6.modifiers = O10, j6;
                    }
                    return;
                }
              }
              function Ob() {
                return _e(), !t6.hasPrecedingLineBreak() && (kt() || T() === 10);
              }
              function kc(u, b) {
                if (T() !== 18) {
                  if (u & 4) {
                    i_();
                    return;
                  }
                  if (ka()) {
                    En();
                    return;
                  }
                }
                return Dc(u, b);
              }
              function Mb() {
                let u = L();
                if (T() === 27)
                  return Q2(N10.createOmittedExpression(), u);
                let b = dr2(25), O10 = no(), j6 = Ra();
                return Q2(N10.createBindingElement(b, void 0, O10, j6), u);
              }
              function Sh() {
                let u = L(), b = dr2(25), O10 = Tt(), j6 = Es(), z;
                O10 && T() !== 58 ? (z = j6, j6 = void 0) : (de2(58), z = no());
                let re2 = Ra();
                return Q2(N10.createBindingElement(b, j6, z, re2), u);
              }
              function Lb() {
                let u = L();
                de2(18);
                let b = mn(9, Sh);
                return de2(19), Q2(N10.createObjectBindingPattern(b), u);
              }
              function xh() {
                let u = L();
                de2(22);
                let b = mn(10, Mb);
                return de2(23), Q2(N10.createArrayBindingPattern(b), u);
              }
              function tp() {
                return T() === 18 || T() === 22 || T() === 80 || Tt();
              }
              function no(u) {
                return T() === 22 ? xh() : T() === 18 ? Lb() : hc(u);
              }
              function Rb() {
                return Ic(true);
              }
              function Ic(u) {
                let b = L(), O10 = fe2(), j6 = no(ve.Private_identifiers_are_not_allowed_in_variable_declarations), z;
                u && j6.kind === 79 && T() === 53 && !t6.hasPrecedingLineBreak() && (z = sn());
                let re2 = Ma(), Ee2 = jm(T()) ? void 0 : Ra(), qe = $i(j6, z, re2, Ee2);
                return St(Q2(qe, b), O10);
              }
              function Eh(u) {
                let b = L(), O10 = 0;
                switch (T()) {
                  case 113:
                    break;
                  case 119:
                    O10 |= 1;
                    break;
                  case 85:
                    O10 |= 2;
                    break;
                  default:
                    Y3.fail();
                }
                _e();
                let j6;
                if (T() === 162 && wt(wh))
                  j6 = ui();
                else {
                  let z = Qi();
                  xe2(u), j6 = mn(8, u ? Ic : Rb), xe2(z);
                }
                return Q2(dn(j6, O10), b);
              }
              function wh() {
                return yc() && _e() === 21;
              }
              function rp(u, b, O10) {
                let j6 = Eh(false);
                En();
                let z = pn(O10, j6);
                return St(Q2(z, u), b);
              }
              function np(u, b, O10) {
                let j6 = xn(), z = Vn(O10);
                de2(98);
                let re2 = dr2(41), Ee2 = z & 1024 ? ro() : hc(), qe = re2 ? 1 : 0, We2 = z & 512 ? 2 : 0, $e2 = Xn();
                z & 1 && ot2(true);
                let lt2 = ra(qe | We2), Jt = pi(58, false), Lt = kc(qe | We2, ve.or_expected);
                ot2(j6);
                let At = N10.createFunctionDeclaration(O10, re2, Ee2, $e2, lt2, Jt, Lt);
                return St(Q2(At, u), b);
              }
              function jb() {
                if (T() === 135)
                  return de2(135);
                if (T() === 10 && wt(_e) === 20)
                  return Tr3(() => {
                    let u = Di();
                    return u.text === "constructor" ? u : void 0;
                  });
              }
              function Ch(u, b, O10) {
                return Tr3(() => {
                  if (jb()) {
                    let j6 = Xn(), z = ra(0), re2 = pi(58, false), Ee2 = kc(0, ve.or_expected), qe = N10.createConstructorDeclaration(O10, z, Ee2);
                    return qe.typeParameters = j6, qe.type = re2, St(Q2(qe, u), b);
                  }
                });
              }
              function Ah(u, b, O10, j6, z, re2, Ee2, qe) {
                let We2 = j6 ? 1 : 0, $e2 = Ke3(O10, Ul) ? 2 : 0, lt2 = Xn(), Jt = ra(We2 | $e2), Lt = pi(58, false), At = kc(We2 | $e2, qe), kr2 = N10.createMethodDeclaration(O10, j6, z, re2, lt2, Jt, Lt, At);
                return kr2.exclamationToken = Ee2, St(Q2(kr2, u), b);
              }
              function ip(u, b, O10, j6, z) {
                let re2 = !z && !t6.hasPrecedingLineBreak() ? dr2(53) : void 0, Ee2 = Ma(), qe = Ct(45056, Ra);
                mc(j6, Ee2, qe);
                let We2 = N10.createPropertyDeclaration(O10, j6, z || re2, Ee2, qe);
                return St(Q2(We2, u), b);
              }
              function Ph(u, b, O10) {
                let j6 = dr2(41), z = Es(), re2 = dr2(57);
                return j6 || T() === 20 || T() === 29 ? Ah(u, b, O10, j6, z, re2, void 0, ve.or_expected) : ip(u, b, O10, z, re2);
              }
              function Fa(u, b, O10, j6, z) {
                let re2 = Es(), Ee2 = Xn(), qe = ra(0), We2 = pi(58, false), $e2 = kc(z), lt2 = j6 === 174 ? N10.createGetAccessorDeclaration(O10, re2, qe, We2, $e2) : N10.createSetAccessorDeclaration(O10, re2, qe, $e2);
                return lt2.typeParameters = Ee2, ic(lt2) && (lt2.type = We2), St(Q2(lt2, u), b);
              }
              function Jb() {
                let u;
                if (T() === 59)
                  return true;
                for (; Wi(T()); ) {
                  if (u = T(), VS(u))
                    return true;
                  _e();
                }
                if (T() === 41 || (xs() && (u = T(), _e()), T() === 22))
                  return true;
                if (u !== void 0) {
                  if (!ba(u) || u === 151 || u === 137)
                    return true;
                  switch (T()) {
                    case 20:
                    case 29:
                    case 53:
                    case 58:
                    case 63:
                    case 57:
                      return true;
                    default:
                      return ka();
                  }
                }
                return false;
              }
              function Fb(u, b, O10) {
                ea(124);
                let j6 = Dh(), z = St(Q2(N10.createClassStaticBlockDeclaration(j6), u), b);
                return z.modifiers = O10, z;
              }
              function Dh() {
                let u = Yi2(), b = xn();
                Le2(false), ot2(true);
                let O10 = ws(false);
                return Le2(u), ot2(b), O10;
              }
              function Bb() {
                if (xn() && T() === 133) {
                  let u = L(), b = wr2(ve.Expression_expected);
                  _e();
                  let O10 = Ja(u, b, true);
                  return $u(u, O10);
                }
                return to();
              }
              function kh() {
                let u = L();
                if (!Ot(59))
                  return;
                let b = ci(Bb);
                return Q2(N10.createDecorator(b), u);
              }
              function ap(u, b, O10) {
                let j6 = L(), z = T();
                if (T() === 85 && b) {
                  if (!Tr3(uu))
                    return;
                } else {
                  if (O10 && T() === 124 && wt(Mc))
                    return;
                  if (u && T() === 124)
                    return;
                  if (!Md())
                    return;
                }
                return Q2(Ye2(z), j6);
              }
              function ki(u, b, O10) {
                let j6 = L(), z, re2, Ee2, qe = false, We2 = false, $e2 = false;
                if (u && T() === 59)
                  for (; re2 = kh(); )
                    z = tr2(z, re2);
                for (; Ee2 = ap(qe, b, O10); )
                  Ee2.kind === 124 && (qe = true), z = tr2(z, Ee2), We2 = true;
                if (We2 && u && T() === 59)
                  for (; re2 = kh(); )
                    z = tr2(z, re2), $e2 = true;
                if ($e2)
                  for (; Ee2 = ap(qe, b, O10); )
                    Ee2.kind === 124 && (qe = true), z = tr2(z, Ee2);
                return z && Er2(z, j6);
              }
              function sp() {
                let u;
                if (T() === 132) {
                  let b = L();
                  _e();
                  let O10 = Q2(Ye2(132), b);
                  u = Er2([O10], b);
                }
                return u;
              }
              function qb() {
                let u = L();
                if (T() === 26)
                  return _e(), Q2(N10.createSemicolonClassElement(), u);
                let b = fe2(), O10 = ki(true, true, true);
                if (T() === 124 && wt(Mc))
                  return Fb(u, b, O10);
                if (Ks(137))
                  return Fa(u, b, O10, 174, 0);
                if (Ks(151))
                  return Fa(u, b, O10, 175, 0);
                if (T() === 135 || T() === 10) {
                  let j6 = Ch(u, b, O10);
                  if (j6)
                    return j6;
                }
                if (im())
                  return am(u, b, O10);
                if (fr2(T()) || T() === 10 || T() === 8 || T() === 41 || T() === 22)
                  if (Ke3(O10, Th2)) {
                    for (let z of O10)
                      z.flags |= 16777216;
                    return Mt(16777216, () => Ph(u, b, O10));
                  } else
                    return Ph(u, b, O10);
                if (O10) {
                  let j6 = Jn(79, true, ve.Declaration_expected);
                  return ip(u, b, O10, j6, void 0);
                }
                return Y3.fail("Should not have attempted to parse class member declaration.");
              }
              function Ub() {
                let u = L(), b = fe2(), O10 = ki(true);
                if (T() === 84)
                  return op(u, b, O10, 228);
                let j6 = Jn(279, true, ve.Expression_expected);
                return Gf(j6, u), j6.modifiers = O10, j6;
              }
              function Ih() {
                return op(L(), fe2(), void 0, 228);
              }
              function Nh(u, b, O10) {
                return op(u, b, O10, 260);
              }
              function op(u, b, O10, j6) {
                let z = xn();
                de2(84);
                let re2 = Oh(), Ee2 = Xn();
                Ke3(O10, N8) && ot2(true);
                let qe = Mh(), We2;
                de2(18) ? (We2 = Vb(), de2(19)) : We2 = ui(), ot2(z);
                let $e2 = j6 === 260 ? N10.createClassDeclaration(O10, re2, Ee2, qe, We2) : N10.createClassExpression(O10, re2, Ee2, qe, We2);
                return St(Q2($e2, u), b);
              }
              function Oh() {
                return Tt() && !zb() ? Ss(Tt()) : void 0;
              }
              function zb() {
                return T() === 117 && wt(pu);
              }
              function Mh() {
                if (Oc2())
                  return Kn(22, Lh);
              }
              function Lh() {
                let u = L(), b = T();
                Y3.assert(b === 94 || b === 117), _e();
                let O10 = mn(7, Wb);
                return Q2(N10.createHeritageClause(b, O10), u);
              }
              function Wb() {
                let u = L(), b = to();
                if (b.kind === 230)
                  return b;
                let O10 = Nc2();
                return Q2(N10.createExpressionWithTypeArguments(b, O10), u);
              }
              function Nc2() {
                return T() === 29 ? Oa(20, sr2, 29, 31) : void 0;
              }
              function Oc2() {
                return T() === 94 || T() === 117;
              }
              function Vb() {
                return Kn(5, qb);
              }
              function Hb(u, b, O10) {
                de2(118);
                let j6 = wr2(), z = Xn(), re2 = Mh(), Ee2 = Iu(), qe = N10.createInterfaceDeclaration(O10, j6, z, re2, Ee2);
                return St(Q2(qe, u), b);
              }
              function Gb(u, b, O10) {
                de2(154);
                let j6 = wr2(), z = Xn();
                de2(63);
                let re2 = T() === 139 && Tr3(Ou) || sr2();
                En();
                let Ee2 = N10.createTypeAliasDeclaration(O10, j6, z, re2);
                return St(Q2(Ee2, u), b);
              }
              function $b() {
                let u = L(), b = fe2(), O10 = Es(), j6 = It(Ra);
                return St(Q2(N10.createEnumMember(O10, j6), u), b);
              }
              function Kb(u, b, O10) {
                de2(92);
                let j6 = wr2(), z;
                de2(18) ? (z = $s(() => mn(6, $b)), de2(19)) : z = ui();
                let re2 = N10.createEnumDeclaration(O10, j6, z);
                return St(Q2(re2, u), b);
              }
              function Rh() {
                let u = L(), b;
                return de2(18) ? (b = Kn(1, on), de2(19)) : b = ui(), Q2(N10.createModuleBlock(b), u);
              }
              function jh(u, b, O10, j6) {
                let z = j6 & 16, re2 = wr2(), Ee2 = Ot(24) ? jh(L(), false, void 0, 4 | z) : Rh(), qe = N10.createModuleDeclaration(O10, re2, Ee2, j6);
                return St(Q2(qe, u), b);
              }
              function Jh(u, b, O10) {
                let j6 = 0, z;
                T() === 159 ? (z = wr2(), j6 |= 1024) : (z = Di(), z.text = Ia(z.text));
                let re2;
                T() === 18 ? re2 = Rh() : En();
                let Ee2 = N10.createModuleDeclaration(O10, z, re2, j6);
                return St(Q2(Ee2, u), b);
              }
              function Fh(u, b, O10) {
                let j6 = 0;
                if (T() === 159)
                  return Jh(u, b, O10);
                if (Ot(143))
                  j6 |= 16;
                else if (de2(142), T() === 10)
                  return Jh(u, b, O10);
                return jh(u, b, O10, j6);
              }
              function Bh() {
                return T() === 147 && wt(qh);
              }
              function qh() {
                return _e() === 20;
              }
              function Mc() {
                return _e() === 18;
              }
              function Xb() {
                return _e() === 43;
              }
              function Yb(u, b, O10) {
                de2(128), de2(143);
                let j6 = wr2();
                En();
                let z = N10.createNamespaceExportDeclaration(j6);
                return z.modifiers = O10, St(Q2(z, u), b);
              }
              function Qb(u, b, O10) {
                de2(100);
                let j6 = t6.getStartPos(), z;
                kt() && (z = wr2());
                let re2 = false;
                if (T() !== 158 && (z == null ? void 0 : z.escapedText) === "type" && (kt() || Zb()) && (re2 = true, z = kt() ? wr2() : void 0), z && !e6())
                  return t62(u, b, O10, z, re2);
                let Ee2;
                (z || T() === 41 || T() === 18) && (Ee2 = r6(z, j6, re2), de2(158));
                let qe = Lc(), We2;
                T() === 130 && !t6.hasPrecedingLineBreak() && (We2 = _p()), En();
                let $e2 = N10.createImportDeclaration(O10, Ee2, qe, We2);
                return St(Q2($e2, u), b);
              }
              function Uh() {
                let u = L(), b = fr2(T()) ? zr2() : n_(10);
                de2(58);
                let O10 = Yr2(true);
                return Q2(N10.createAssertEntry(b, O10), u);
              }
              function _p(u) {
                let b = L();
                u || de2(130);
                let O10 = t6.getTokenPos();
                if (de2(18)) {
                  let j6 = t6.hasPrecedingLineBreak(), z = mn(24, Uh, true);
                  if (!de2(19)) {
                    let re2 = Cn(Zt);
                    re2 && re2.code === ve._0_expected.code && Rl(re2, Ro(Ur2, O10, 1, ve.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                  }
                  return Q2(N10.createAssertClause(z, j6), b);
                } else {
                  let j6 = Er2([], L(), void 0, false);
                  return Q2(N10.createAssertClause(j6, false), b);
                }
              }
              function Zb() {
                return T() === 41 || T() === 18;
              }
              function e6() {
                return T() === 27 || T() === 158;
              }
              function t62(u, b, O10, j6, z) {
                de2(63);
                let re2 = cp();
                En();
                let Ee2 = N10.createImportEqualsDeclaration(O10, z, j6, re2);
                return St(Q2(Ee2, u), b);
              }
              function r6(u, b, O10) {
                let j6;
                return (!u || Ot(27)) && (j6 = T() === 41 ? Rc2() : zh(272)), Q2(N10.createImportClause(O10, u, j6), b);
              }
              function cp() {
                return Bh() ? n6() : Ys(false);
              }
              function n6() {
                let u = L();
                de2(147), de2(20);
                let b = Lc();
                return de2(21), Q2(N10.createExternalModuleReference(b), u);
              }
              function Lc() {
                if (T() === 10) {
                  let u = Di();
                  return u.text = Ia(u.text), u;
                } else
                  return Sr2();
              }
              function Rc2() {
                let u = L();
                de2(41), de2(128);
                let b = wr2();
                return Q2(N10.createNamespaceImport(b), u);
              }
              function zh(u) {
                let b = L(), O10 = u === 272 ? N10.createNamedImports(Oa(23, a6, 18, 19)) : N10.createNamedExports(Oa(23, i6, 18, 19));
                return Q2(O10, b);
              }
              function i6() {
                let u = fe2();
                return St(Ba(278), u);
              }
              function a6() {
                return Ba(273);
              }
              function Ba(u) {
                let b = L(), O10 = ba(T()) && !kt(), j6 = t6.getTokenPos(), z = t6.getTextPos(), re2 = false, Ee2, qe = true, We2 = zr2();
                if (We2.escapedText === "type")
                  if (T() === 128) {
                    let Jt = zr2();
                    if (T() === 128) {
                      let Lt = zr2();
                      fr2(T()) ? (re2 = true, Ee2 = Jt, We2 = lt2(), qe = false) : (Ee2 = We2, We2 = Lt, qe = false);
                    } else
                      fr2(T()) ? (Ee2 = We2, qe = false, We2 = lt2()) : (re2 = true, We2 = Jt);
                  } else
                    fr2(T()) && (re2 = true, We2 = lt2());
                qe && T() === 128 && (Ee2 = We2, de2(128), We2 = lt2()), u === 273 && O10 && Z(j6, z, ve.Identifier_expected);
                let $e2 = u === 273 ? N10.createImportSpecifier(re2, Ee2, We2) : N10.createExportSpecifier(re2, Ee2, We2);
                return Q2($e2, b);
                function lt2() {
                  return O10 = ba(T()) && !kt(), j6 = t6.getTokenPos(), z = t6.getTextPos(), zr2();
                }
              }
              function s6(u) {
                return Q2(N10.createNamespaceExport(zr2()), u);
              }
              function o6(u, b, O10) {
                let j6 = xn();
                ot2(true);
                let z, re2, Ee2, qe = Ot(154), We2 = L();
                Ot(41) ? (Ot(128) && (z = s6(We2)), de2(158), re2 = Lc()) : (z = zh(276), (T() === 158 || T() === 10 && !t6.hasPrecedingLineBreak()) && (de2(158), re2 = Lc())), re2 && T() === 130 && !t6.hasPrecedingLineBreak() && (Ee2 = _p()), En(), ot2(j6);
                let $e2 = N10.createExportDeclaration(O10, qe, z, re2, Ee2);
                return St(Q2($e2, u), b);
              }
              function _6(u, b, O10) {
                let j6 = xn();
                ot2(true);
                let z;
                Ot(63) ? z = true : de2(88);
                let re2 = Yr2(true);
                En(), ot2(j6);
                let Ee2 = N10.createExportAssignment(O10, z, re2);
                return St(Q2(Ee2, u), b);
              }
              let io;
              ((u) => {
                u[u.SourceElements = 0] = "SourceElements", u[u.BlockStatements = 1] = "BlockStatements", u[u.SwitchClauses = 2] = "SwitchClauses", u[u.SwitchClauseStatements = 3] = "SwitchClauseStatements", u[u.TypeMembers = 4] = "TypeMembers", u[u.ClassMembers = 5] = "ClassMembers", u[u.EnumMembers = 6] = "EnumMembers", u[u.HeritageClauseElement = 7] = "HeritageClauseElement", u[u.VariableDeclarations = 8] = "VariableDeclarations", u[u.ObjectBindingElements = 9] = "ObjectBindingElements", u[u.ArrayBindingElements = 10] = "ArrayBindingElements", u[u.ArgumentExpressions = 11] = "ArgumentExpressions", u[u.ObjectLiteralMembers = 12] = "ObjectLiteralMembers", u[u.JsxAttributes = 13] = "JsxAttributes", u[u.JsxChildren = 14] = "JsxChildren", u[u.ArrayLiteralMembers = 15] = "ArrayLiteralMembers", u[u.Parameters = 16] = "Parameters", u[u.JSDocParameters = 17] = "JSDocParameters", u[u.RestProperties = 18] = "RestProperties", u[u.TypeParameters = 19] = "TypeParameters", u[u.TypeArguments = 20] = "TypeArguments", u[u.TupleElementTypes = 21] = "TupleElementTypes", u[u.HeritageClauses = 22] = "HeritageClauses", u[u.ImportOrExportSpecifiers = 23] = "ImportOrExportSpecifiers", u[u.AssertEntries = 24] = "AssertEntries", u[u.Count = 25] = "Count";
              })(io || (io = {}));
              let Wh;
              ((u) => {
                u[u.False = 0] = "False", u[u.True = 1] = "True", u[u.Unknown = 2] = "Unknown";
              })(Wh || (Wh = {}));
              let Vh;
              ((u) => {
                function b($e2, lt2, Jt) {
                  Mn("file.js", $e2, 99, void 0, 1), t6.setText($e2, lt2, Jt), ar2 = t6.scan();
                  let Lt = O10(), At = Kt("file.js", 99, 1, false, [], Ye2(1), 0, yn), kr2 = qs(Zt, At);
                  return Or2 && (At.jsDocDiagnostics = qs(Or2, At)), _i(), Lt ? { jsDocTypeExpression: Lt, diagnostics: kr2 } : void 0;
                }
                u.parseJSDocTypeExpressionForTests = b;
                function O10($e2) {
                  let lt2 = L(), Jt = ($e2 ? Ot : de2)(18), Lt = Mt(8388608, xc);
                  (!$e2 || Jt) && Da(19);
                  let At = N10.createJSDocTypeExpression(Lt);
                  return ft(At), Q2(At, lt2);
                }
                u.parseJSDocTypeExpression = O10;
                function j6() {
                  let $e2 = L(), lt2 = Ot(18), Jt = L(), Lt = Ys(false);
                  for (; T() === 80; )
                    Xr(), Ge2(), Lt = Q2(N10.createJSDocMemberName(Lt, wr2()), Jt);
                  lt2 && Da(19);
                  let At = N10.createJSDocNameReference(Lt);
                  return ft(At), Q2(At, $e2);
                }
                u.parseJSDocNameReference = j6;
                function z($e2, lt2, Jt) {
                  Mn("", $e2, 99, void 0, 1);
                  let Lt = Mt(8388608, () => We2(lt2, Jt)), kr2 = qs(Zt, { languageVariant: 0, text: $e2 });
                  return _i(), Lt ? { jsDoc: Lt, diagnostics: kr2 } : void 0;
                }
                u.parseIsolatedJSDocComment = z;
                function re2($e2, lt2, Jt) {
                  let Lt = ar2, At = Zt.length, kr2 = Kr2, Fn = Mt(8388608, () => We2(lt2, Jt));
                  return Sa(Fn, $e2), nr2 & 262144 && (Or2 || (Or2 = []), Or2.push(...Zt)), ar2 = Lt, Zt.length = At, Kr2 = kr2, Fn;
                }
                u.parseJSDocComment = re2;
                let Ee2;
                (($e2) => {
                  $e2[$e2.BeginningOfLine = 0] = "BeginningOfLine", $e2[$e2.SawAsterisk = 1] = "SawAsterisk", $e2[$e2.SavingComments = 2] = "SavingComments", $e2[$e2.SavingBackticks = 3] = "SavingBackticks";
                })(Ee2 || (Ee2 = {}));
                let qe;
                (($e2) => {
                  $e2[$e2.Property = 1] = "Property", $e2[$e2.Parameter = 2] = "Parameter", $e2[$e2.CallbackParameter = 4] = "CallbackParameter";
                })(qe || (qe = {}));
                function We2() {
                  let $e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, lt2 = arguments.length > 1 ? arguments[1] : void 0, Jt = _r2, Lt = lt2 === void 0 ? Jt.length : $e2 + lt2;
                  if (lt2 = Lt - $e2, Y3.assert($e2 >= 0), Y3.assert($e2 <= Lt), Y3.assert(Lt <= Jt.length), !LE(Jt, $e2))
                    return;
                  let At, kr2, Fn, di, Ii, _n = [], qa = [];
                  return t6.scanRange($e2 + 3, lt2 - 5, () => {
                    let se = 1, Me2, Ce2 = $e2 - (Jt.lastIndexOf(`
`, $e2) + 1) + 4;
                    function Ue2(vt) {
                      Me2 || (Me2 = Ce2), _n.push(vt), Ce2 += vt.length;
                    }
                    for (Ge2(); u_(5); )
                      ;
                    u_(4) && (se = 0, Ce2 = 0);
                    e:
                      for (; ; ) {
                        switch (T()) {
                          case 59:
                            se === 0 || se === 1 ? (lp(_n), Ii || (Ii = L()), za(up(Ce2)), se = 0, Me2 = void 0) : Ue2(t6.getTokenText());
                            break;
                          case 4:
                            _n.push(t6.getTokenText()), se = 0, Ce2 = 0;
                            break;
                          case 41:
                            let vt = t6.getTokenText();
                            se === 1 || se === 2 ? (se = 2, Ue2(vt)) : (se = 1, Ce2 += vt.length);
                            break;
                          case 5:
                            let Vt2 = t6.getTokenText();
                            se === 2 ? _n.push(Vt2) : Me2 !== void 0 && Ce2 + Vt2.length > Me2 && _n.push(Vt2.slice(Me2 - Ce2)), Ce2 += Vt2.length;
                            break;
                          case 1:
                            break e;
                          case 18:
                            se = 2;
                            let Rr = t6.getStartPos(), gn = t6.getTextPos() - 1, mi = $h(gn);
                            if (mi) {
                              di || Hh(_n), qa.push(Q2(N10.createJSDocText(_n.join("")), di != null ? di : $e2, Rr)), qa.push(mi), _n = [], di = t6.getTextPos();
                              break;
                            }
                          default:
                            se = 2, Ue2(t6.getTokenText());
                            break;
                        }
                        Ge2();
                      }
                    lp(_n), qa.length && _n.length && qa.push(Q2(N10.createJSDocText(_n.join("")), di != null ? di : $e2, Ii)), qa.length && At && Y3.assertIsDefined(Ii, "having parsed tags implies that the end of the comment span should be set");
                    let Qe2 = At && Er2(At, kr2, Fn);
                    return Q2(N10.createJSDocComment(qa.length ? Er2(qa, $e2, Ii) : _n.length ? _n.join("") : void 0, Qe2), $e2, Lt);
                  });
                  function Hh(se) {
                    for (; se.length && (se[0] === `
` || se[0] === "\r"); )
                      se.shift();
                  }
                  function lp(se) {
                    for (; se.length && se[se.length - 1].trim() === ""; )
                      se.pop();
                  }
                  function Gh() {
                    for (; ; ) {
                      if (Ge2(), T() === 1)
                        return true;
                      if (!(T() === 5 || T() === 4))
                        return false;
                    }
                  }
                  function wn() {
                    if (!((T() === 5 || T() === 4) && wt(Gh)))
                      for (; T() === 5 || T() === 4; )
                        Ge2();
                  }
                  function Ua() {
                    if ((T() === 5 || T() === 4) && wt(Gh))
                      return "";
                    let se = t6.hasPrecedingLineBreak(), Me2 = false, Ce2 = "";
                    for (; se && T() === 41 || T() === 5 || T() === 4; )
                      Ce2 += t6.getTokenText(), T() === 4 ? (se = true, Me2 = true, Ce2 = "") : T() === 41 && (se = false), Ge2();
                    return Me2 ? Ce2 : "";
                  }
                  function up(se) {
                    Y3.assert(T() === 59);
                    let Me2 = t6.getTokenPos();
                    Ge2();
                    let Ce2 = ao(void 0), Ue2 = Ua(), Qe2;
                    switch (Ce2.escapedText) {
                      case "author":
                        Qe2 = V(Me2, Ce2, se, Ue2);
                        break;
                      case "implements":
                        Qe2 = et(Me2, Ce2, se, Ue2);
                        break;
                      case "augments":
                      case "extends":
                        Qe2 = ht(Me2, Ce2, se, Ue2);
                        break;
                      case "class":
                      case "constructor":
                        Qe2 = Oi(Me2, N10.createJSDocClassTag, Ce2, se, Ue2);
                        break;
                      case "public":
                        Qe2 = Oi(Me2, N10.createJSDocPublicTag, Ce2, se, Ue2);
                        break;
                      case "private":
                        Qe2 = Oi(Me2, N10.createJSDocPrivateTag, Ce2, se, Ue2);
                        break;
                      case "protected":
                        Qe2 = Oi(Me2, N10.createJSDocProtectedTag, Ce2, se, Ue2);
                        break;
                      case "readonly":
                        Qe2 = Oi(Me2, N10.createJSDocReadonlyTag, Ce2, se, Ue2);
                        break;
                      case "override":
                        Qe2 = Oi(Me2, N10.createJSDocOverrideTag, Ce2, se, Ue2);
                        break;
                      case "deprecated":
                        ue2 = true, Qe2 = Oi(Me2, N10.createJSDocDeprecatedTag, Ce2, se, Ue2);
                        break;
                      case "this":
                        Qe2 = qB(Me2, Ce2, se, Ue2);
                        break;
                      case "enum":
                        Qe2 = UB(Me2, Ce2, se, Ue2);
                        break;
                      case "arg":
                      case "argument":
                      case "param":
                        return Xh(Me2, Ce2, 2, se);
                      case "return":
                      case "returns":
                        Qe2 = o(Me2, Ce2, se, Ue2);
                        break;
                      case "template":
                        Qe2 = QB(Me2, Ce2, se, Ue2);
                        break;
                      case "type":
                        Qe2 = l(Me2, Ce2, se, Ue2);
                        break;
                      case "typedef":
                        Qe2 = zB(Me2, Ce2, se, Ue2);
                        break;
                      case "callback":
                        Qe2 = VB(Me2, Ce2, se, Ue2);
                        break;
                      case "overload":
                        Qe2 = HB(Me2, Ce2, se, Ue2);
                        break;
                      case "satisfies":
                        Qe2 = hn(Me2, Ce2, se, Ue2);
                        break;
                      case "see":
                        Qe2 = p(Me2, Ce2, se, Ue2);
                        break;
                      case "exception":
                      case "throws":
                        Qe2 = k(Me2, Ce2, se, Ue2);
                        break;
                      default:
                        Qe2 = Qt(Me2, Ce2, se, Ue2);
                        break;
                    }
                    return Qe2;
                  }
                  function Qr2(se, Me2, Ce2, Ue2) {
                    return Ue2 || (Ce2 += Me2 - se), jc(Ce2, Ue2.slice(Ce2));
                  }
                  function jc(se, Me2) {
                    let Ce2 = L(), Ue2 = [], Qe2 = [], vt, Vt2 = 0, Rr = true, gn;
                    function mi(hi) {
                      gn || (gn = se), Ue2.push(hi), se += hi.length;
                    }
                    Me2 !== void 0 && (Me2 !== "" && mi(Me2), Vt2 = 1);
                    let Va = T();
                    e:
                      for (; ; ) {
                        switch (Va) {
                          case 4:
                            Vt2 = 0, Ue2.push(t6.getTokenText()), se = 0;
                            break;
                          case 59:
                            if (Vt2 === 3 || Vt2 === 2 && (!Rr || wt(Cs))) {
                              Ue2.push(t6.getTokenText());
                              break;
                            }
                            t6.setTextPos(t6.getTextPos() - 1);
                          case 1:
                            break e;
                          case 5:
                            if (Vt2 === 2 || Vt2 === 3)
                              mi(t6.getTokenText());
                            else {
                              let so = t6.getTokenText();
                              gn !== void 0 && se + so.length > gn && Ue2.push(so.slice(gn - se)), se += so.length;
                            }
                            break;
                          case 18:
                            Vt2 = 2;
                            let hi = t6.getStartPos(), pp = t6.getTextPos() - 1, fp = $h(pp);
                            fp ? (Qe2.push(Q2(N10.createJSDocText(Ue2.join("")), vt != null ? vt : Ce2, hi)), Qe2.push(fp), Ue2 = [], vt = t6.getTextPos()) : mi(t6.getTokenText());
                            break;
                          case 61:
                            Vt2 === 3 ? Vt2 = 2 : Vt2 = 3, mi(t6.getTokenText());
                            break;
                          case 41:
                            if (Vt2 === 0) {
                              Vt2 = 1, se += 1;
                              break;
                            }
                          default:
                            Vt2 !== 3 && (Vt2 = 2), mi(t6.getTokenText());
                            break;
                        }
                        Rr = T() === 5, Va = Ge2();
                      }
                    if (Hh(Ue2), lp(Ue2), Qe2.length)
                      return Ue2.length && Qe2.push(Q2(N10.createJSDocText(Ue2.join("")), vt != null ? vt : Ce2)), Er2(Qe2, Ce2, t6.getTextPos());
                    if (Ue2.length)
                      return Ue2.join("");
                  }
                  function Cs() {
                    let se = Ge2();
                    return se === 5 || se === 4;
                  }
                  function $h(se) {
                    let Me2 = Tr3(Kh);
                    if (!Me2)
                      return;
                    Ge2(), wn();
                    let Ce2 = L(), Ue2 = fr2(T()) ? Ys(true) : void 0;
                    if (Ue2)
                      for (; T() === 80; )
                        Xr(), Ge2(), Ue2 = Q2(N10.createJSDocMemberName(Ue2, wr2()), Ce2);
                    let Qe2 = [];
                    for (; T() !== 19 && T() !== 4 && T() !== 1; )
                      Qe2.push(t6.getTokenText()), Ge2();
                    let vt = Me2 === "link" ? N10.createJSDocLink : Me2 === "linkcode" ? N10.createJSDocLinkCode : N10.createJSDocLinkPlain;
                    return Q2(vt(Ue2, Qe2.join("")), se, t6.getTextPos());
                  }
                  function Kh() {
                    if (Ua(), T() === 18 && Ge2() === 59 && fr2(Ge2())) {
                      let se = t6.getTokenValue();
                      if (xt(se))
                        return se;
                    }
                  }
                  function xt(se) {
                    return se === "link" || se === "linkcode" || se === "linkplain";
                  }
                  function Qt(se, Me2, Ce2, Ue2) {
                    return Q2(N10.createJSDocUnknownTag(Me2, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function za(se) {
                    se && (At ? At.push(se) : (At = [se], kr2 = se.pos), Fn = se.end);
                  }
                  function Wa() {
                    return Ua(), T() === 18 ? O10() : void 0;
                  }
                  function c6() {
                    let se = u_(22);
                    se && wn();
                    let Me2 = u_(61), Ce2 = ZB();
                    return Me2 && kd(61), se && (wn(), dr2(63) && Sr2(), de2(23)), { name: Ce2, isBracketed: se };
                  }
                  function Yn(se) {
                    switch (se.kind) {
                      case 149:
                        return true;
                      case 185:
                        return Yn(se.elementType);
                      default:
                        return ac(se) && yt(se.typeName) && se.typeName.escapedText === "Object" && !se.typeArguments;
                    }
                  }
                  function Xh(se, Me2, Ce2, Ue2) {
                    let Qe2 = Wa(), vt = !Qe2;
                    Ua();
                    let { name: Vt2, isBracketed: Rr } = c6(), gn = Ua();
                    vt && !wt(Kh) && (Qe2 = Wa());
                    let mi = Qr2(se, L(), Ue2, gn), Va = Ce2 !== 4 && n9(Qe2, Vt2, Ce2, Ue2);
                    Va && (Qe2 = Va, vt = true);
                    let hi = Ce2 === 1 ? N10.createJSDocPropertyTag(Me2, Vt2, Rr, Qe2, vt, mi) : N10.createJSDocParameterTag(Me2, Vt2, Rr, Qe2, vt, mi);
                    return Q2(hi, se);
                  }
                  function n9(se, Me2, Ce2, Ue2) {
                    if (se && Yn(se.type)) {
                      let Qe2 = L(), vt, Vt2;
                      for (; vt = Tr3(() => u6(Ce2, Ue2, Me2)); )
                        (vt.kind === 344 || vt.kind === 351) && (Vt2 = tr2(Vt2, vt));
                      if (Vt2) {
                        let Rr = Q2(N10.createJSDocTypeLiteral(Vt2, se.type.kind === 185), Qe2);
                        return Q2(N10.createJSDocTypeExpression(Rr), Qe2);
                      }
                    }
                  }
                  function o(se, Me2, Ce2, Ue2) {
                    Ke3(At, b2) && Z(Me2.pos, t6.getTokenPos(), ve._0_tag_already_specified, Me2.escapedText);
                    let Qe2 = Wa();
                    return Q2(N10.createJSDocReturnTag(Me2, Qe2, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function l(se, Me2, Ce2, Ue2) {
                    Ke3(At, au) && Z(Me2.pos, t6.getTokenPos(), ve._0_tag_already_specified, Me2.escapedText);
                    let Qe2 = O10(true), vt = Ce2 !== void 0 && Ue2 !== void 0 ? Qr2(se, L(), Ce2, Ue2) : void 0;
                    return Q2(N10.createJSDocTypeTag(Me2, Qe2, vt), se);
                  }
                  function p(se, Me2, Ce2, Ue2) {
                    let vt = T() === 22 || wt(() => Ge2() === 59 && fr2(Ge2()) && xt(t6.getTokenValue())) ? void 0 : j6(), Vt2 = Ce2 !== void 0 && Ue2 !== void 0 ? Qr2(se, L(), Ce2, Ue2) : void 0;
                    return Q2(N10.createJSDocSeeTag(Me2, vt, Vt2), se);
                  }
                  function k(se, Me2, Ce2, Ue2) {
                    let Qe2 = Wa(), vt = Qr2(se, L(), Ce2, Ue2);
                    return Q2(N10.createJSDocThrowsTag(Me2, Qe2, vt), se);
                  }
                  function V(se, Me2, Ce2, Ue2) {
                    let Qe2 = L(), vt = we2(), Vt2 = t6.getStartPos(), Rr = Qr2(se, Vt2, Ce2, Ue2);
                    Rr || (Vt2 = t6.getStartPos());
                    let gn = typeof Rr != "string" ? Er2(Ft([Q2(vt, Qe2, Vt2)], Rr), Qe2) : vt.text + Rr;
                    return Q2(N10.createJSDocAuthorTag(Me2, gn), se);
                  }
                  function we2() {
                    let se = [], Me2 = false, Ce2 = t6.getToken();
                    for (; Ce2 !== 1 && Ce2 !== 4; ) {
                      if (Ce2 === 29)
                        Me2 = true;
                      else {
                        if (Ce2 === 59 && !Me2)
                          break;
                        if (Ce2 === 31 && Me2) {
                          se.push(t6.getTokenText()), t6.setTextPos(t6.getTokenPos() + 1);
                          break;
                        }
                      }
                      se.push(t6.getTokenText()), Ce2 = Ge2();
                    }
                    return N10.createJSDocText(se.join(""));
                  }
                  function et(se, Me2, Ce2, Ue2) {
                    let Qe2 = Ni();
                    return Q2(N10.createJSDocImplementsTag(Me2, Qe2, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function ht(se, Me2, Ce2, Ue2) {
                    let Qe2 = Ni();
                    return Q2(N10.createJSDocAugmentsTag(Me2, Qe2, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function hn(se, Me2, Ce2, Ue2) {
                    let Qe2 = O10(false), vt = Ce2 !== void 0 && Ue2 !== void 0 ? Qr2(se, L(), Ce2, Ue2) : void 0;
                    return Q2(N10.createJSDocSatisfiesTag(Me2, Qe2, vt), se);
                  }
                  function Ni() {
                    let se = Ot(18), Me2 = L(), Ce2 = ia(), Ue2 = Nc2(), Qe2 = N10.createExpressionWithTypeArguments(Ce2, Ue2), vt = Q2(Qe2, Me2);
                    return se && de2(19), vt;
                  }
                  function ia() {
                    let se = L(), Me2 = ao();
                    for (; Ot(24); ) {
                      let Ce2 = ao();
                      Me2 = Q2(Ve2(Me2, Ce2), se);
                    }
                    return Me2;
                  }
                  function Oi(se, Me2, Ce2, Ue2, Qe2) {
                    return Q2(Me2(Ce2, Qr2(se, L(), Ue2, Qe2)), se);
                  }
                  function qB(se, Me2, Ce2, Ue2) {
                    let Qe2 = O10(true);
                    return wn(), Q2(N10.createJSDocThisTag(Me2, Qe2, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function UB(se, Me2, Ce2, Ue2) {
                    let Qe2 = O10(true);
                    return wn(), Q2(N10.createJSDocEnumTag(Me2, Qe2, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function zB(se, Me2, Ce2, Ue2) {
                    var Qe2;
                    let vt = Wa();
                    Ua();
                    let Vt2 = l6();
                    wn();
                    let Rr = jc(Ce2), gn;
                    if (!vt || Yn(vt.type)) {
                      let Va, hi, pp, fp = false;
                      for (; Va = Tr3(() => $B(Ce2)); )
                        if (fp = true, Va.kind === 347)
                          if (hi) {
                            let so = Dt(ve.A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags);
                            so && Rl(so, Ro(Ur2, 0, 0, ve.The_tag_was_first_specified_here));
                            break;
                          } else
                            hi = Va;
                        else
                          pp = tr2(pp, Va);
                      if (fp) {
                        let so = vt && vt.type.kind === 185, eq = N10.createJSDocTypeLiteral(pp, so);
                        vt = hi && hi.typeExpression && !Yn(hi.typeExpression.type) ? hi.typeExpression : Q2(eq, se), gn = vt.end;
                      }
                    }
                    gn = gn || Rr !== void 0 ? L() : ((Qe2 = Vt2 != null ? Vt2 : vt) != null ? Qe2 : Me2).end, Rr || (Rr = Qr2(se, gn, Ce2, Ue2));
                    let mi = N10.createJSDocTypedefTag(Me2, vt, Vt2, Rr);
                    return Q2(mi, se, gn);
                  }
                  function l6(se) {
                    let Me2 = t6.getTokenPos();
                    if (!fr2(T()))
                      return;
                    let Ce2 = ao();
                    if (Ot(24)) {
                      let Ue2 = l6(true), Qe2 = N10.createModuleDeclaration(void 0, Ce2, Ue2, se ? 4 : void 0);
                      return Q2(Qe2, Me2);
                    }
                    return se && (Ce2.flags |= 2048), Ce2;
                  }
                  function WB(se) {
                    let Me2 = L(), Ce2, Ue2;
                    for (; Ce2 = Tr3(() => u6(4, se)); )
                      Ue2 = tr2(Ue2, Ce2);
                    return Er2(Ue2 || [], Me2);
                  }
                  function j7(se, Me2) {
                    let Ce2 = WB(Me2), Ue2 = Tr3(() => {
                      if (u_(59)) {
                        let Qe2 = up(Me2);
                        if (Qe2 && Qe2.kind === 345)
                          return Qe2;
                      }
                    });
                    return Q2(N10.createJSDocSignature(void 0, Ce2, Ue2), se);
                  }
                  function VB(se, Me2, Ce2, Ue2) {
                    let Qe2 = l6();
                    wn();
                    let vt = jc(Ce2), Vt2 = j7(se, Ce2);
                    vt || (vt = Qr2(se, L(), Ce2, Ue2));
                    let Rr = vt !== void 0 ? L() : Vt2.end;
                    return Q2(N10.createJSDocCallbackTag(Me2, Vt2, Qe2, vt), se, Rr);
                  }
                  function HB(se, Me2, Ce2, Ue2) {
                    wn();
                    let Qe2 = jc(Ce2), vt = j7(se, Ce2);
                    Qe2 || (Qe2 = Qr2(se, L(), Ce2, Ue2));
                    let Vt2 = Qe2 !== void 0 ? L() : vt.end;
                    return Q2(N10.createJSDocOverloadTag(Me2, vt, Qe2), se, Vt2);
                  }
                  function GB(se, Me2) {
                    for (; !yt(se) || !yt(Me2); )
                      if (!yt(se) && !yt(Me2) && se.right.escapedText === Me2.right.escapedText)
                        se = se.left, Me2 = Me2.left;
                      else
                        return false;
                    return se.escapedText === Me2.escapedText;
                  }
                  function $B(se) {
                    return u6(1, se);
                  }
                  function u6(se, Me2, Ce2) {
                    let Ue2 = true, Qe2 = false;
                    for (; ; )
                      switch (Ge2()) {
                        case 59:
                          if (Ue2) {
                            let vt = KB(se, Me2);
                            return vt && (vt.kind === 344 || vt.kind === 351) && se !== 4 && Ce2 && (yt(vt.name) || !GB(Ce2, vt.name.left)) ? false : vt;
                          }
                          Qe2 = false;
                          break;
                        case 4:
                          Ue2 = true, Qe2 = false;
                          break;
                        case 41:
                          Qe2 && (Ue2 = false), Qe2 = true;
                          break;
                        case 79:
                          Ue2 = false;
                          break;
                        case 1:
                          return false;
                      }
                  }
                  function KB(se, Me2) {
                    Y3.assert(T() === 59);
                    let Ce2 = t6.getStartPos();
                    Ge2();
                    let Ue2 = ao();
                    wn();
                    let Qe2;
                    switch (Ue2.escapedText) {
                      case "type":
                        return se === 1 && l(Ce2, Ue2);
                      case "prop":
                      case "property":
                        Qe2 = 1;
                        break;
                      case "arg":
                      case "argument":
                      case "param":
                        Qe2 = 6;
                        break;
                      default:
                        return false;
                    }
                    return se & Qe2 ? Xh(Ce2, Ue2, se, Me2) : false;
                  }
                  function XB() {
                    let se = L(), Me2 = u_(22);
                    Me2 && wn();
                    let Ce2 = ao(ve.Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces), Ue2;
                    if (Me2 && (wn(), de2(63), Ue2 = Mt(8388608, xc), de2(23)), !va(Ce2))
                      return Q2(N10.createTypeParameterDeclaration(void 0, Ce2, void 0, Ue2), se);
                  }
                  function YB() {
                    let se = L(), Me2 = [];
                    do {
                      wn();
                      let Ce2 = XB();
                      Ce2 !== void 0 && Me2.push(Ce2), Ua();
                    } while (u_(27));
                    return Er2(Me2, se);
                  }
                  function QB(se, Me2, Ce2, Ue2) {
                    let Qe2 = T() === 18 ? O10() : void 0, vt = YB();
                    return Q2(N10.createJSDocTemplateTag(Me2, Qe2, vt, Qr2(se, L(), Ce2, Ue2)), se);
                  }
                  function u_(se) {
                    return T() === se ? (Ge2(), true) : false;
                  }
                  function ZB() {
                    let se = ao();
                    for (Ot(22) && de2(23); Ot(24); ) {
                      let Me2 = ao();
                      Ot(22) && de2(23), se = Tu(se, Me2);
                    }
                    return se;
                  }
                  function ao(se) {
                    if (!fr2(T()))
                      return Jn(79, !se, se || ve.Identifier_expected);
                    $r2++;
                    let Me2 = t6.getTokenPos(), Ce2 = t6.getTextPos(), Ue2 = T(), Qe2 = Ia(t6.getTokenValue()), vt = Q2(Te2(Qe2, Ue2), Me2, Ce2);
                    return Ge2(), vt;
                  }
                }
              })(Vh = e.JSDocParser || (e.JSDocParser = {}));
            })(Ci || (Ci = {})), ((e) => {
              function t6($, ae, Te2, Se2) {
                if (Se2 = Se2 || Y3.shouldAssert(2), N10($, ae, Te2, Se2), cS(Te2))
                  return $;
                if ($.statements.length === 0)
                  return Ci.parseSourceFile($.fileName, ae, $.languageVersion, void 0, true, $.scriptKind, $.setExternalModuleIndicator);
                let Ye2 = $;
                Y3.assert(!Ye2.hasBeenIncrementallyParsed), Ye2.hasBeenIncrementallyParsed = true, Ci.fixupParentReferences(Ye2);
                let Ne2 = $.text, oe2 = X2($), Ve2 = g9($, Te2);
                N10($, ae, Ve2, Se2), Y3.assert(Ve2.span.start <= Te2.span.start), Y3.assert(Ir2(Ve2.span) === Ir2(Te2.span)), Y3.assert(Ir2(R_(Ve2)) === Ir2(R_(Te2)));
                let pt2 = R_(Ve2).length - Ve2.span.length;
                A6(Ye2, Ve2.span.start, Ir2(Ve2.span), Ir2(R_(Ve2)), pt2, Ne2, ae, Se2);
                let Gt = Ci.parseSourceFile($.fileName, ae, $.languageVersion, oe2, true, $.scriptKind, $.setExternalModuleIndicator);
                return Gt.commentDirectives = r($.commentDirectives, Gt.commentDirectives, Ve2.span.start, Ir2(Ve2.span), pt2, Ne2, ae, Se2), Gt.impliedNodeFormat = $.impliedNodeFormat, Gt;
              }
              e.updateSourceFile = t6;
              function r($, ae, Te2, Se2, Ye2, Ne2, oe2, Ve2) {
                if (!$)
                  return ae;
                let pt2, Gt = false;
                for (let Xt of $) {
                  let { range: er2, type: Tn } = Xt;
                  if (er2.end < Te2)
                    pt2 = tr2(pt2, Xt);
                  else if (er2.pos > Se2) {
                    Nt();
                    let Hr2 = { range: { pos: er2.pos + Ye2, end: er2.end + Ye2 }, type: Tn };
                    pt2 = tr2(pt2, Hr2), Ve2 && Y3.assert(Ne2.substring(er2.pos, er2.end) === oe2.substring(Hr2.range.pos, Hr2.range.end));
                  }
                }
                return Nt(), pt2;
                function Nt() {
                  Gt || (Gt = true, pt2 ? ae && pt2.push(...ae) : pt2 = ae);
                }
              }
              function s($, ae, Te2, Se2, Ye2, Ne2) {
                ae ? Ve2($) : oe2($);
                return;
                function oe2(pt2) {
                  let Gt = "";
                  if (Ne2 && f10(pt2) && (Gt = Se2.substring(pt2.pos, pt2.end)), pt2._children && (pt2._children = void 0), Us(pt2, pt2.pos + Te2, pt2.end + Te2), Ne2 && f10(pt2) && Y3.assert(Gt === Ye2.substring(pt2.pos, pt2.end)), xr2(pt2, oe2, Ve2), ya(pt2))
                    for (let Nt of pt2.jsDoc)
                      oe2(Nt);
                  w6(pt2, Ne2);
                }
                function Ve2(pt2) {
                  pt2._children = void 0, Us(pt2, pt2.pos + Te2, pt2.end + Te2);
                  for (let Gt of pt2)
                    oe2(Gt);
                }
              }
              function f10($) {
                switch ($.kind) {
                  case 10:
                  case 8:
                  case 79:
                    return true;
                }
                return false;
              }
              function x10($, ae, Te2, Se2, Ye2) {
                Y3.assert($.end >= ae, "Adjusting an element that was entirely before the change range"), Y3.assert($.pos <= Te2, "Adjusting an element that was entirely after the change range"), Y3.assert($.pos <= $.end);
                let Ne2 = Math.min($.pos, Se2), oe2 = $.end >= Te2 ? $.end + Ye2 : Math.min($.end, Se2);
                Y3.assert(Ne2 <= oe2), $.parent && (Y3.assertGreaterThanOrEqual(Ne2, $.parent.pos), Y3.assertLessThanOrEqual(oe2, $.parent.end)), Us($, Ne2, oe2);
              }
              function w6($, ae) {
                if (ae) {
                  let Te2 = $.pos, Se2 = (Ye2) => {
                    Y3.assert(Ye2.pos >= Te2), Te2 = Ye2.end;
                  };
                  if (ya($))
                    for (let Ye2 of $.jsDoc)
                      Se2(Ye2);
                  xr2($, Se2), Y3.assert(Te2 <= $.end);
                }
              }
              function A6($, ae, Te2, Se2, Ye2, Ne2, oe2, Ve2) {
                pt2($);
                return;
                function pt2(Nt) {
                  if (Y3.assert(Nt.pos <= Nt.end), Nt.pos > Te2) {
                    s(Nt, false, Ye2, Ne2, oe2, Ve2);
                    return;
                  }
                  let Xt = Nt.end;
                  if (Xt >= ae) {
                    if (Nt.intersectsChange = true, Nt._children = void 0, x10(Nt, ae, Te2, Se2, Ye2), xr2(Nt, pt2, Gt), ya(Nt))
                      for (let er2 of Nt.jsDoc)
                        pt2(er2);
                    w6(Nt, Ve2);
                    return;
                  }
                  Y3.assert(Xt < ae);
                }
                function Gt(Nt) {
                  if (Y3.assert(Nt.pos <= Nt.end), Nt.pos > Te2) {
                    s(Nt, true, Ye2, Ne2, oe2, Ve2);
                    return;
                  }
                  let Xt = Nt.end;
                  if (Xt >= ae) {
                    Nt.intersectsChange = true, Nt._children = void 0, x10(Nt, ae, Te2, Se2, Ye2);
                    for (let er2 of Nt)
                      pt2(er2);
                    return;
                  }
                  Y3.assert(Xt < ae);
                }
              }
              function g9($, ae) {
                let Se2 = ae.span.start;
                for (let oe2 = 0; Se2 > 0 && oe2 <= 1; oe2++) {
                  let Ve2 = B($, Se2);
                  Y3.assert(Ve2.pos <= Se2);
                  let pt2 = Ve2.pos;
                  Se2 = Math.max(0, pt2 - 1);
                }
                let Ye2 = ha(Se2, Ir2(ae.span)), Ne2 = ae.newLength + (ae.span.start - Se2);
                return Zp(Ye2, Ne2);
              }
              function B($, ae) {
                let Te2 = $, Se2;
                if (xr2($, Ne2), Se2) {
                  let oe2 = Ye2(Se2);
                  oe2.pos > Te2.pos && (Te2 = oe2);
                }
                return Te2;
                function Ye2(oe2) {
                  for (; ; ) {
                    let Ve2 = mx(oe2);
                    if (Ve2)
                      oe2 = Ve2;
                    else
                      return oe2;
                  }
                }
                function Ne2(oe2) {
                  if (!va(oe2))
                    if (oe2.pos <= ae) {
                      if (oe2.pos >= Te2.pos && (Te2 = oe2), ae < oe2.end)
                        return xr2(oe2, Ne2), true;
                      Y3.assert(oe2.end <= ae), Se2 = oe2;
                    } else
                      return Y3.assert(oe2.pos > ae), true;
                }
              }
              function N10($, ae, Te2, Se2) {
                let Ye2 = $.text;
                if (Te2 && (Y3.assert(Ye2.length - Te2.span.length + Te2.newLength === ae.length), Se2 || Y3.shouldAssert(3))) {
                  let Ne2 = Ye2.substr(0, Te2.span.start), oe2 = ae.substr(0, Te2.span.start);
                  Y3.assert(Ne2 === oe2);
                  let Ve2 = Ye2.substring(Ir2(Te2.span), Ye2.length), pt2 = ae.substring(Ir2(R_(Te2)), ae.length);
                  Y3.assert(Ve2 === pt2);
                }
              }
              function X2($) {
                let ae = $.statements, Te2 = 0;
                Y3.assert(Te2 < ae.length);
                let Se2 = ae[Te2], Ye2 = -1;
                return { currentNode(oe2) {
                  return oe2 !== Ye2 && (Se2 && Se2.end === oe2 && Te2 < ae.length - 1 && (Te2++, Se2 = ae[Te2]), (!Se2 || Se2.pos !== oe2) && Ne2(oe2)), Ye2 = oe2, Y3.assert(!Se2 || Se2.pos === oe2), Se2;
                } };
                function Ne2(oe2) {
                  ae = void 0, Te2 = -1, Se2 = void 0, xr2($, Ve2, pt2);
                  return;
                  function Ve2(Gt) {
                    return oe2 >= Gt.pos && oe2 < Gt.end ? (xr2(Gt, Ve2, pt2), true) : false;
                  }
                  function pt2(Gt) {
                    if (oe2 >= Gt.pos && oe2 < Gt.end)
                      for (let Nt = 0; Nt < Gt.length; Nt++) {
                        let Xt = Gt[Nt];
                        if (Xt) {
                          if (Xt.pos === oe2)
                            return ae = Gt, Te2 = Nt, Se2 = Xt, true;
                          if (Xt.pos < oe2 && oe2 < Xt.end)
                            return xr2(Xt, Ve2, pt2), true;
                        }
                      }
                    return false;
                  }
                }
              }
              e.createSyntaxCursor = X2;
              let F2;
              (($) => {
                $[$.Value = -1] = "Value";
              })(F2 || (F2 = {}));
            })(Sd || (Sd = {})), xd = /* @__PURE__ */ new Map(), _7 = /^\/\/\/\s*<(\S+)\s.*?\/>/im, c7 = /^\/\/\/?\s*@(\S+)\s*(.*)\s*$/im;
          } }), nF = () => {
          }, iF = () => {
          }, aF = () => {
          }, sF = () => {
          }, oF = () => {
          }, _F = () => {
          }, cF = () => {
          }, lF = () => {
          }, uF = () => {
          }, pF = () => {
          }, fF = () => {
          }, dF = () => {
          }, mF = () => {
          }, hF = () => {
          }, gF = () => {
          }, yF = () => {
          }, vF = () => {
          }, bF = () => {
          }, TF = () => {
          }, SF = () => {
          }, xF = () => {
          }, EF = () => {
          }, wF = () => {
          }, CF = () => {
          }, AF = () => {
          }, PF = () => {
          }, DF = () => {
          }, kF = () => {
          }, IF = () => {
          }, NF = () => {
          }, OF = () => {
          }, MF = () => {
          }, LF = () => {
          }, RF = () => {
          }, jF = () => {
          }, JF = () => {
          }, FF = () => {
          }, BF = () => {
          }, qF = () => {
          }, UF = () => {
          }, zF = () => {
          }, WF = () => {
          }, VF = () => {
          }, HF = () => {
          }, GF = () => {
          }, $F = () => {
          }, nn = D({ "src/compiler/_namespaces/ts.ts"() {
            "use strict";
            E(), L5(), PT(), R5(), j5(), F5(), U5(), NT(), W5(), sA(), oA(), hA(), iD(), OL(), ML(), LL(), RL(), KL(), XL(), YL(), Pj(), qJ(), UJ(), rF(), nF(), iF(), aF(), sF(), _F(), cF(), lF(), uF(), pF(), fF(), dF(), mF(), hF(), gF(), yF(), vF(), bF(), TF(), SF(), xF(), EF(), wF(), CF(), AF(), PF(), DF(), kF(), IF(), NF(), OF(), MF(), LF(), RF(), jF(), JF(), FF(), BF(), qF(), UF(), zF(), WF(), VF(), HF(), GF(), $F(), oF(), IT();
          } }), l7 = () => {
          }, KF = () => {
          }, u7 = () => {
          }, Zo, u7 = () => {
            PT(), Zo = Po(99, true);
          }, XF = () => {
          }, YF = () => {
          }, QF = () => {
          }, ZF = () => {
          }, eB = () => {
          }, tB = () => {
          }, rB = () => {
          }, nB = () => {
          }, iB = () => {
          }, aB = () => {
          }, p7 = () => {
          }, f7 = () => {
          };
          function d7(e, t6, r, s) {
            let f10 = gl(e) ? new wd(e, t6, r) : e === 79 ? new Ad(79, t6, r) : e === 80 ? new Pd(80, t6, r) : new O2(e, t6, r);
            return f10.parent = s, f10.flags = s.flags & 50720768, f10;
          }
          function sB(e, t6) {
            if (!gl(e.kind))
              return Bt;
            let r = [];
            if (c3(e))
              return e.forEachChild((w6) => {
                r.push(w6);
              }), r;
            Zo.setText((t6 || e.getSourceFile()).text);
            let s = e.pos, f10 = (w6) => {
              _u(r, s, w6.pos, e), r.push(w6), s = w6.end;
            }, x10 = (w6) => {
              _u(r, s, w6.pos, e), r.push(oB(w6, e)), s = w6.end;
            };
            return c(e.jsDoc, f10), s = e.pos, e.forEachChild(f10, x10), _u(r, s, e.end, e), Zo.setText(void 0), r;
          }
          function _u(e, t6, r, s) {
            for (Zo.setTextPos(t6); t6 < r; ) {
              let f10 = Zo.scan(), x10 = Zo.getTextPos();
              if (x10 <= r) {
                if (f10 === 79) {
                  if (Qx(s))
                    continue;
                  Y3.fail(`Did not expect ${Y3.formatSyntaxKind(s.kind)} to have an Identifier in its trivia`);
                }
                e.push(d7(f10, t6, x10, s));
              }
              if (t6 = x10, f10 === 1)
                break;
            }
          }
          function oB(e, t6) {
            let r = d7(354, e.pos, e.end, t6);
            r._children = [];
            let s = e.pos;
            for (let f10 of e)
              _u(r._children, s, f10.pos, t6), r._children.push(f10), s = f10.end;
            return _u(r._children, s, e.end, t6), r;
          }
          function m7(e) {
            return hl(e).some((t6) => t6.tagName.text === "inheritDoc" || t6.tagName.text === "inheritdoc");
          }
          function Ed(e, t6) {
            if (!e)
              return Bt;
            let r = ts_JsDoc_exports.getJsDocTagsFromDeclarations(e, t6);
            if (t6 && (r.length === 0 || e.some(m7))) {
              let s = /* @__PURE__ */ new Set();
              for (let f10 of e) {
                let x10 = h7(t6, f10, (w6) => {
                  var A6;
                  if (!s.has(w6))
                    return s.add(w6), f10.kind === 174 || f10.kind === 175 ? w6.getContextualJsDocTags(f10, t6) : ((A6 = w6.declarations) == null ? void 0 : A6.length) === 1 ? w6.getJsDocTags() : void 0;
                });
                x10 && (r = [...x10, ...r]);
              }
            }
            return r;
          }
          function cu(e, t6) {
            if (!e)
              return Bt;
            let r = ts_JsDoc_exports.getJsDocCommentsFromDeclarations(e, t6);
            if (t6 && (r.length === 0 || e.some(m7))) {
              let s = /* @__PURE__ */ new Set();
              for (let f10 of e) {
                let x10 = h7(t6, f10, (w6) => {
                  if (!s.has(w6))
                    return s.add(w6), f10.kind === 174 || f10.kind === 175 ? w6.getContextualDocumentationComment(f10, t6) : w6.getDocumentationComment(t6);
                });
                x10 && (r = r.length === 0 ? x10.slice() : x10.concat(lineBreakPart(), r));
              }
            }
            return r;
          }
          function h7(e, t6, r) {
            var s;
            let f10 = ((s = t6.parent) == null ? void 0 : s.kind) === 173 ? t6.parent.parent : t6.parent;
            if (!f10)
              return;
            let x10 = Lf(t6);
            return q2(h4(f10), (w6) => {
              let A6 = e.getTypeAtLocation(w6), g9 = x10 && A6.symbol ? e.getTypeOfSymbol(A6.symbol) : A6, B = e.getPropertyOfType(g9, t6.symbol.name);
              return B ? r(B) : void 0;
            });
          }
          function _B() {
            return { getNodeConstructor: () => wd, getTokenConstructor: () => O2, getIdentifierConstructor: () => Ad, getPrivateIdentifierConstructor: () => Pd, getSourceFileConstructor: () => P7, getSymbolConstructor: () => w7, getTypeConstructor: () => C7, getSignatureConstructor: () => A7, getSourceMapSourceConstructor: () => D7 };
          }
          function lu(e) {
            let t6 = true;
            for (let s in e)
              if (Jr(e, s) && !g7(s)) {
                t6 = false;
                break;
              }
            if (t6)
              return e;
            let r = {};
            for (let s in e)
              if (Jr(e, s)) {
                let f10 = g7(s) ? s : s.charAt(0).toLowerCase() + s.substr(1);
                r[f10] = e[s];
              }
            return r;
          }
          function g7(e) {
            return !e.length || e.charAt(0) === e.charAt(0).toLowerCase();
          }
          function cB(e) {
            return e ? Ze2(e, (t6) => t6.text).join("") : "";
          }
          function y7() {
            return { target: 1, jsx: 1 };
          }
          function v7() {
            return ts_codefix_exports.getSupportedErrorCodes();
          }
          function b7(e, t6, r) {
            e.version = r, e.scriptSnapshot = t6;
          }
          function N2(e, t6, r, s, f10, x10) {
            let w6 = YE(e, getSnapshotText(t6), r, f10, x10);
            return b7(w6, t6, s), w6;
          }
          function T7(e, t6, r, s, f10) {
            if (s && r !== e.version) {
              let w6, A6 = s.span.start !== 0 ? e.text.substr(0, s.span.start) : "", g9 = Ir2(s.span) !== e.text.length ? e.text.substr(Ir2(s.span)) : "";
              if (s.newLength === 0)
                w6 = A6 && g9 ? A6 + g9 : A6 || g9;
              else {
                let N10 = t6.getText(s.span.start, s.span.start + s.newLength);
                w6 = A6 && g9 ? A6 + N10 + g9 : A6 ? A6 + N10 : N10 + g9;
              }
              let B = k2(e, w6, s, f10);
              return b7(B, t6, r), B.nameTable = void 0, e !== B && e.scriptSnapshot && (e.scriptSnapshot.dispose && e.scriptSnapshot.dispose(), e.scriptSnapshot = void 0), B;
            }
            let x10 = { languageVersion: e.languageVersion, impliedNodeFormat: e.impliedNodeFormat, setExternalModuleIndicator: e.setExternalModuleIndicator };
            return N2(e.fileName, t6, x10, r, true, e.scriptKind);
          }
          function lB(e) {
            let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createDocumentRegistry(e.useCaseSensitiveFileNames && e.useCaseSensitiveFileNames(), e.getCurrentDirectory()), r = arguments.length > 2 ? arguments[2] : void 0;
            var s;
            let f10;
            r === void 0 ? f10 = 0 : typeof r == "boolean" ? f10 = r ? 2 : 0 : f10 = r;
            let x10 = new k7(e), w6, A6, g9 = 0, B = e.getCancellationToken ? new N7(e.getCancellationToken()) : I7, N10 = e.getCurrentDirectory();
            vx((s = e.getLocalizedDiagnosticMessages) == null ? void 0 : s.bind(e));
            function X2(Z) {
              e.log && e.log(Z);
            }
            let F2 = J0(e), $ = wp(F2), ae = getSourceMapper({ useCaseSensitiveFileNames: () => F2, getCurrentDirectory: () => N10, getProgram: Ye2, fileExists: le(e, e.fileExists), readFile: le(e, e.readFile), getDocumentPositionMapper: le(e, e.getDocumentPositionMapper), getSourceFileLike: le(e, e.getSourceFileLike), log: X2 });
            function Te2(Z) {
              let ie2 = w6.getSourceFile(Z);
              if (!ie2) {
                let U2 = new Error(`Could not find source file: '${Z}'.`);
                throw U2.ProgramFiles = w6.getSourceFiles().map((L) => L.fileName), U2;
              }
              return ie2;
            }
            function Se2() {
              var Z, ie2, U2;
              if (Y3.assert(f10 !== 2), e.getProjectVersion) {
                let Tt = e.getProjectVersion();
                if (Tt) {
                  if (A6 === Tt && !((Z = e.hasChangedAutomaticTypeDirectiveNames) != null && Z.call(e)))
                    return;
                  A6 = Tt;
                }
              }
              let L = e.getTypeRootsVersion ? e.getTypeRootsVersion() : 0;
              g9 !== L && (X2("TypeRoots version has changed; provide new program"), w6 = void 0, g9 = L);
              let fe2 = e.getScriptFileNames().slice(), T = e.getCompilationSettings() || y7(), it = e.hasInvalidatedResolutions || w_, mt = le(e, e.hasChangedAutomaticTypeDirectiveNames), _e = (ie2 = e.getProjectReferences) == null ? void 0 : ie2.call(e), Ge2, bt = { getSourceFile: wt, getSourceFileByPath: Tr3, getCancellationToken: () => B, getCanonicalFileName: $, useCaseSensitiveFileNames: () => F2, getNewLine: () => ox(T), getDefaultLibFileName: (Tt) => e.getDefaultLibFileName(Tt), writeFile: yn, getCurrentDirectory: () => N10, fileExists: (Tt) => e.fileExists(Tt), readFile: (Tt) => e.readFile && e.readFile(Tt), getSymlinkCache: le(e, e.getSymlinkCache), realpath: le(e, e.realpath), directoryExists: (Tt) => sx(Tt, e), getDirectories: (Tt) => e.getDirectories ? e.getDirectories(Tt) : [], readDirectory: (Tt, kt, de2, jn, Zi) => (Y3.checkDefined(e.readDirectory, "'LanguageServiceHost.readDirectory' must be implemented to correctly process 'projectReferences'"), e.readDirectory(Tt, kt, de2, jn, Zi)), onReleaseOldSourceFile: Rn, onReleaseParsedCommandLine: yr2, hasInvalidatedResolutions: it, hasChangedAutomaticTypeDirectiveNames: mt, trace: le(e, e.trace), resolveModuleNames: le(e, e.resolveModuleNames), getModuleResolutionCache: le(e, e.getModuleResolutionCache), createHash: le(e, e.createHash), resolveTypeReferenceDirectives: le(e, e.resolveTypeReferenceDirectives), resolveModuleNameLiterals: le(e, e.resolveModuleNameLiterals), resolveTypeReferenceDirectiveReferences: le(e, e.resolveTypeReferenceDirectiveReferences), useSourceOfProjectReferenceRedirect: le(e, e.useSourceOfProjectReferenceRedirect), getParsedCommandLine: Dr2 }, jt = bt.getSourceFile, { getSourceFileWithCache: Yt } = changeCompilerHostLikeToUseCache(bt, (Tt) => Ui(Tt, N10, $), function() {
                for (var Tt = arguments.length, kt = new Array(Tt), de2 = 0; de2 < Tt; de2++)
                  kt[de2] = arguments[de2];
                return jt.call(bt, ...kt);
              });
              bt.getSourceFile = Yt, (U2 = e.setCompilerHost) == null || U2.call(e, bt);
              let $t = { useCaseSensitiveFileNames: F2, fileExists: (Tt) => bt.fileExists(Tt), readFile: (Tt) => bt.readFile(Tt), readDirectory: function() {
                return bt.readDirectory(...arguments);
              }, trace: bt.trace, getCurrentDirectory: bt.getCurrentDirectory, onUnRecoverableConfigFileDiagnostic: yn }, Wt = t6.getKeyForCompilationSettings(T);
              if (isProgramUptoDate(w6, fe2, T, (Tt, kt) => e.getScriptVersion(kt), (Tt) => bt.fileExists(Tt), it, mt, Dr2, _e))
                return;
              let Xr = { rootNames: fe2, options: T, host: bt, oldProgram: w6, projectReferences: _e };
              w6 = createProgram(Xr), bt = void 0, Ge2 = void 0, ae.clearCache(), w6.getTypeChecker();
              return;
              function Dr2(Tt) {
                let kt = Ui(Tt, N10, $), de2 = Ge2 == null ? void 0 : Ge2.get(kt);
                if (de2 !== void 0)
                  return de2 || void 0;
                let jn = e.getParsedCommandLine ? e.getParsedCommandLine(Tt) : Lr(Tt);
                return (Ge2 || (Ge2 = /* @__PURE__ */ new Map())).set(kt, jn || false), jn;
              }
              function Lr(Tt) {
                let kt = wt(Tt, 100);
                if (kt)
                  return kt.path = Ui(Tt, N10, $), kt.resolvedPath = kt.path, kt.originalFileName = kt.fileName, parseJsonSourceFileConfigFileContent(kt, $t, as(ma(Tt), N10), void 0, as(Tt, N10));
              }
              function yr2(Tt, kt, de2) {
                var jn;
                e.getParsedCommandLine ? (jn = e.onReleaseParsedCommandLine) == null || jn.call(e, Tt, kt, de2) : kt && Rn(kt.sourceFile, de2);
              }
              function Rn(Tt, kt) {
                let de2 = t6.getKeyForCompilationSettings(kt);
                t6.releaseDocumentWithKey(Tt.resolvedPath, de2, Tt.scriptKind, Tt.impliedNodeFormat);
              }
              function wt(Tt, kt, de2, jn) {
                return Tr3(Tt, Ui(Tt, N10, $), kt, de2, jn);
              }
              function Tr3(Tt, kt, de2, jn, Zi) {
                Y3.assert(bt, "getOrCreateSourceFileByPath called after typical CompilerHost lifetime, check the callstack something with a reference to an old host.");
                let Pa = e.getScriptSnapshot(Tt);
                if (!Pa)
                  return;
                let e_ = getScriptKind(Tt, e), mc = e.getScriptVersion(Tt);
                if (!Zi) {
                  let Da = w6 && w6.getSourceFileByPath(kt);
                  if (Da) {
                    if (e_ === Da.scriptKind)
                      return t6.updateDocumentWithKey(Tt, kt, e, Wt, Pa, mc, e_, de2);
                    t6.releaseDocumentWithKey(Da.resolvedPath, t6.getKeyForCompilationSettings(w6.getCompilerOptions()), Da.scriptKind, Da.impliedNodeFormat);
                  }
                }
                return t6.acquireDocumentWithKey(Tt, kt, e, Wt, Pa, mc, e_, de2);
              }
            }
            function Ye2() {
              if (f10 === 2) {
                Y3.assert(w6 === void 0);
                return;
              }
              return Se2(), w6;
            }
            function Ne2() {
              var Z;
              return (Z = e.getPackageJsonAutoImportProvider) == null ? void 0 : Z.call(e);
            }
            function oe2(Z, ie2) {
              let U2 = w6.getTypeChecker(), L = fe2();
              if (!L)
                return false;
              for (let it of Z)
                for (let mt of it.references) {
                  let _e = T(mt);
                  if (Y3.assertIsDefined(_e), ie2.has(mt) || ts_FindAllReferences_exports.isDeclarationOfSymbol(_e, L)) {
                    ie2.add(mt), mt.isDefinition = true;
                    let Ge2 = getMappedDocumentSpan(mt, ae, le(e, e.fileExists));
                    Ge2 && ie2.add(Ge2);
                  } else
                    mt.isDefinition = false;
                }
              return true;
              function fe2() {
                for (let it of Z)
                  for (let mt of it.references) {
                    if (ie2.has(mt)) {
                      let Ge2 = T(mt);
                      return Y3.assertIsDefined(Ge2), U2.getSymbolAtLocation(Ge2);
                    }
                    let _e = getMappedDocumentSpan(mt, ae, le(e, e.fileExists));
                    if (_e && ie2.has(_e)) {
                      let Ge2 = T(_e);
                      if (Ge2)
                        return U2.getSymbolAtLocation(Ge2);
                    }
                  }
              }
              function T(it) {
                let mt = w6.getSourceFile(it.fileName);
                if (!mt)
                  return;
                let _e = getTouchingPropertyName(mt, it.textSpan.start);
                return ts_FindAllReferences_exports.Core.getAdjustedNode(_e, { use: ts_FindAllReferences_exports.FindReferencesUse.References });
              }
            }
            function Ve2() {
              w6 = void 0;
            }
            function pt2() {
              if (w6) {
                let Z = t6.getKeyForCompilationSettings(w6.getCompilerOptions());
                c(w6.getSourceFiles(), (ie2) => t6.releaseDocumentWithKey(ie2.resolvedPath, Z, ie2.scriptKind, ie2.impliedNodeFormat)), w6 = void 0;
              }
              e = void 0;
            }
            function Gt(Z) {
              return Se2(), w6.getSyntacticDiagnostics(Te2(Z), B).slice();
            }
            function Nt(Z) {
              Se2();
              let ie2 = Te2(Z), U2 = w6.getSemanticDiagnostics(ie2, B);
              if (!cv(w6.getCompilerOptions()))
                return U2.slice();
              let L = w6.getDeclarationDiagnostics(ie2, B);
              return [...U2, ...L];
            }
            function Xt(Z) {
              return Se2(), computeSuggestionDiagnostics(Te2(Z), w6, B);
            }
            function er2() {
              return Se2(), [...w6.getOptionsDiagnostics(B), ...w6.getGlobalDiagnostics(B)];
            }
            function Tn(Z, ie2) {
              let U2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emptyOptions, L = arguments.length > 3 ? arguments[3] : void 0, fe2 = Object.assign(Object.assign({}, U2), {}, { includeCompletionsForModuleExports: U2.includeCompletionsForModuleExports || U2.includeExternalModuleExports, includeCompletionsWithInsertText: U2.includeCompletionsWithInsertText || U2.includeInsertTextCompletions });
              return Se2(), ts_Completions_exports.getCompletionsAtPosition(e, w6, X2, Te2(Z), ie2, fe2, U2.triggerCharacter, U2.triggerKind, B, L && ts_formatting_exports.getFormatContext(L, e), U2.includeSymbol);
            }
            function Hr2(Z, ie2, U2, L, fe2) {
              let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : emptyOptions, it = arguments.length > 6 ? arguments[6] : void 0;
              return Se2(), ts_Completions_exports.getCompletionEntryDetails(w6, X2, Te2(Z), ie2, { name: U2, source: fe2, data: it }, e, L && ts_formatting_exports.getFormatContext(L, e), T, B);
            }
            function Gi(Z, ie2, U2, L) {
              let fe2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : emptyOptions;
              return Se2(), ts_Completions_exports.getCompletionEntrySymbol(w6, X2, Te2(Z), ie2, { name: U2, source: L }, e, fe2);
            }
            function pn(Z, ie2) {
              Se2();
              let U2 = Te2(Z), L = getTouchingPropertyName(U2, ie2);
              if (L === U2)
                return;
              let fe2 = w6.getTypeChecker(), T = fn(L), it = mB(T, fe2);
              if (!it || fe2.isUnknownSymbol(it)) {
                let jt = Ut(U2, T, ie2) ? fe2.getTypeAtLocation(T) : void 0;
                return jt && { kind: "", kindModifiers: "", textSpan: createTextSpanFromNode(T, U2), displayParts: fe2.runWithCancellationToken(B, (Yt) => typeToDisplayParts(Yt, jt, getContainerNode(T))), documentation: jt.symbol ? jt.symbol.getDocumentationComment(fe2) : void 0, tags: jt.symbol ? jt.symbol.getJsDocTags(fe2) : void 0 };
              }
              let { symbolKind: mt, displayParts: _e, documentation: Ge2, tags: bt } = fe2.runWithCancellationToken(B, (jt) => ts_SymbolDisplay_exports.getSymbolDisplayPartsDocumentationAndSymbolKind(jt, it, U2, getContainerNode(T), T));
              return { kind: mt, kindModifiers: ts_SymbolDisplay_exports.getSymbolModifiers(fe2, it), textSpan: createTextSpanFromNode(T, U2), displayParts: _e, documentation: Ge2, tags: bt };
            }
            function fn(Z) {
              return X8(Z.parent) && Z.pos === Z.parent.pos ? Z.parent.expression : $v(Z.parent) && Z.pos === Z.parent.pos || o0(Z.parent) && Z.parent.name === Z ? Z.parent : Z;
            }
            function Ut(Z, ie2, U2) {
              switch (ie2.kind) {
                case 79:
                  return !isLabelName(ie2) && !isTagName(ie2) && !jS(ie2.parent);
                case 208:
                case 163:
                  return !isInComment(Z, U2);
                case 108:
                case 194:
                case 106:
                case 199:
                  return true;
                case 233:
                  return o0(ie2);
                default:
                  return false;
              }
            }
            function kn(Z, ie2, U2, L) {
              return Se2(), ts_GoToDefinition_exports.getDefinitionAtPosition(w6, Te2(Z), ie2, U2, L);
            }
            function an(Z, ie2) {
              return Se2(), ts_GoToDefinition_exports.getDefinitionAndBoundSpan(w6, Te2(Z), ie2);
            }
            function mr2(Z, ie2) {
              return Se2(), ts_GoToDefinition_exports.getTypeDefinitionAtPosition(w6.getTypeChecker(), Te2(Z), ie2);
            }
            function $i(Z, ie2) {
              return Se2(), ts_FindAllReferences_exports.getImplementationsAtPosition(w6, B, w6.getSourceFiles(), Te2(Z), ie2);
            }
            function dn(Z, ie2) {
              return ne2(Ur2(Z, ie2, [Z]), (U2) => U2.highlightSpans.map((L) => Object.assign(Object.assign({ fileName: U2.fileName, textSpan: L.textSpan, isWriteAccess: L.kind === "writtenReference" }, L.isInString && { isInString: true }), L.contextSpan && { contextSpan: L.contextSpan })));
            }
            function Ur2(Z, ie2, U2) {
              let L = Un(Z);
              Y3.assert(U2.some((it) => Un(it) === L)), Se2();
              let fe2 = qt(U2, (it) => w6.getSourceFile(it)), T = Te2(Z);
              return DocumentHighlights.getDocumentHighlights(w6, B, T, ie2, fe2);
            }
            function Gr2(Z, ie2, U2, L, fe2) {
              Se2();
              let T = Te2(Z), it = getAdjustedRenameLocation(getTouchingPropertyName(T, ie2));
              if (ts_Rename_exports.nodeIsEligibleForRename(it))
                if (yt(it) && (tu(it.parent) || sE(it.parent)) && P4(it.escapedText)) {
                  let { openingElement: mt, closingElement: _e } = it.parent.parent;
                  return [mt, _e].map((Ge2) => {
                    let bt = createTextSpanFromNode(Ge2.tagName, T);
                    return Object.assign({ fileName: T.fileName, textSpan: bt }, ts_FindAllReferences_exports.toContextSpan(bt, T, Ge2.parent));
                  });
                } else
                  return Sn(it, ie2, { findInStrings: U2, findInComments: L, providePrefixAndSuffixTextForRename: fe2, use: ts_FindAllReferences_exports.FindReferencesUse.Rename }, (mt, _e, Ge2) => ts_FindAllReferences_exports.toRenameLocation(mt, _e, Ge2, fe2 || false));
            }
            function _r2(Z, ie2) {
              return Se2(), Sn(getTouchingPropertyName(Te2(Z), ie2), ie2, { use: ts_FindAllReferences_exports.FindReferencesUse.References }, ts_FindAllReferences_exports.toReferenceEntry);
            }
            function Sn(Z, ie2, U2, L) {
              Se2();
              let fe2 = U2 && U2.use === ts_FindAllReferences_exports.FindReferencesUse.Rename ? w6.getSourceFiles().filter((T) => !w6.isSourceFileDefaultLibrary(T)) : w6.getSourceFiles();
              return ts_FindAllReferences_exports.findReferenceOrRenameEntries(w6, B, fe2, Z, ie2, U2, L);
            }
            function In(Z, ie2) {
              return Se2(), ts_FindAllReferences_exports.findReferencedSymbols(w6, B, w6.getSourceFiles(), Te2(Z), ie2);
            }
            function pr2(Z) {
              return Se2(), ts_FindAllReferences_exports.Core.getReferencesForFileName(Z, w6, w6.getSourceFiles()).map(ts_FindAllReferences_exports.toReferenceEntry);
            }
            function Zt(Z, ie2, U2) {
              let L = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              Se2();
              let fe2 = U2 ? [Te2(U2)] : w6.getSourceFiles();
              return getNavigateToItems(fe2, w6.getTypeChecker(), B, Z, ie2, L);
            }
            function Or2(Z, ie2, U2) {
              Se2();
              let L = Te2(Z), fe2 = e.getCustomTransformers && e.getCustomTransformers();
              return getFileEmitOutput(w6, L, !!ie2, B, fe2, U2);
            }
            function Nn(Z, ie2) {
              let { triggerReason: U2 } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emptyOptions;
              Se2();
              let L = Te2(Z);
              return ts_SignatureHelp_exports.getSignatureHelpItems(w6, L, ie2, U2, B);
            }
            function ar2(Z) {
              return x10.getCurrentSourceFile(Z);
            }
            function oi(Z, ie2, U2) {
              let L = x10.getCurrentSourceFile(Z), fe2 = getTouchingPropertyName(L, ie2);
              if (fe2 === L)
                return;
              switch (fe2.kind) {
                case 208:
                case 163:
                case 10:
                case 95:
                case 110:
                case 104:
                case 106:
                case 108:
                case 194:
                case 79:
                  break;
                default:
                  return;
              }
              let T = fe2;
              for (; ; )
                if (isRightSideOfPropertyAccess(T) || isRightSideOfQualifiedName(T))
                  T = T.parent;
                else if (isNameOfModuleDeclaration(T))
                  if (T.parent.parent.kind === 264 && T.parent.parent.body === T.parent)
                    T = T.parent.parent.name;
                  else
                    break;
                else
                  break;
              return ha(T.getStart(), fe2.getEnd());
            }
            function cr2(Z, ie2) {
              let U2 = x10.getCurrentSourceFile(Z);
              return ts_BreakpointResolver_exports.spanInSourceFileAtLocation(U2, ie2);
            }
            function $r2(Z) {
              return getNavigationBarItems(x10.getCurrentSourceFile(Z), B);
            }
            function hr2(Z) {
              return getNavigationTree(x10.getCurrentSourceFile(Z), B);
            }
            function On(Z, ie2, U2) {
              return Se2(), (U2 || "original") === "2020" ? ts_classifier_exports.v2020.getSemanticClassifications(w6, B, Te2(Z), ie2) : getSemanticClassifications(w6.getTypeChecker(), B, Te2(Z), w6.getClassifiableNames(), ie2);
            }
            function nr2(Z, ie2, U2) {
              return Se2(), (U2 || "original") === "original" ? getEncodedSemanticClassifications(w6.getTypeChecker(), B, Te2(Z), w6.getClassifiableNames(), ie2) : ts_classifier_exports.v2020.getEncodedSemanticClassifications(w6, B, Te2(Z), ie2);
            }
            function br2(Z, ie2) {
              return getSyntacticClassifications(B, x10.getCurrentSourceFile(Z), ie2);
            }
            function Kr2(Z, ie2) {
              return getEncodedSyntacticClassifications(B, x10.getCurrentSourceFile(Z), ie2);
            }
            function wa(Z) {
              let ie2 = x10.getCurrentSourceFile(Z);
              return ts_OutliningElementsCollector_exports.collectElements(ie2, B);
            }
            let $n = new Map(Object.entries({ [18]: 19, [20]: 21, [22]: 23, [31]: 29 }));
            $n.forEach((Z, ie2) => $n.set(Z.toString(), Number(ie2)));
            function Ki(Z, ie2) {
              let U2 = x10.getCurrentSourceFile(Z), L = getTouchingToken(U2, ie2), fe2 = L.getStart(U2) === ie2 ? $n.get(L.kind.toString()) : void 0, T = fe2 && findChildOfKind(L.parent, fe2, U2);
              return T ? [createTextSpanFromNode(L, U2), createTextSpanFromNode(T, U2)].sort((it, mt) => it.start - mt.start) : Bt;
            }
            function Mn(Z, ie2, U2) {
              let L = ts(), fe2 = lu(U2), T = x10.getCurrentSourceFile(Z);
              X2("getIndentationAtPosition: getCurrentSourceFile: " + (ts() - L)), L = ts();
              let it = ts_formatting_exports.SmartIndenter.getIndentation(ie2, T, fe2);
              return X2("getIndentationAtPosition: computeIndentation  : " + (ts() - L)), it;
            }
            function _i(Z, ie2, U2, L) {
              let fe2 = x10.getCurrentSourceFile(Z);
              return ts_formatting_exports.formatSelection(ie2, U2, fe2, ts_formatting_exports.getFormatContext(lu(L), e));
            }
            function Ca(Z, ie2) {
              return ts_formatting_exports.formatDocument(x10.getCurrentSourceFile(Z), ts_formatting_exports.getFormatContext(lu(ie2), e));
            }
            function St(Z, ie2, U2, L) {
              let fe2 = x10.getCurrentSourceFile(Z), T = ts_formatting_exports.getFormatContext(lu(L), e);
              if (!isInComment(fe2, ie2))
                switch (U2) {
                  case "{":
                    return ts_formatting_exports.formatOnOpeningCurly(ie2, fe2, T);
                  case "}":
                    return ts_formatting_exports.formatOnClosingCurly(ie2, fe2, T);
                  case ";":
                    return ts_formatting_exports.formatOnSemicolon(ie2, fe2, T);
                  case `
`:
                    return ts_formatting_exports.formatOnEnter(ie2, fe2, T);
                }
              return [];
            }
            function ue2(Z, ie2, U2, L, fe2) {
              let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : emptyOptions;
              Se2();
              let it = Te2(Z), mt = ha(ie2, U2), _e = ts_formatting_exports.getFormatContext(fe2, e);
              return ne2(ji(L, fa, Vr2), (Ge2) => (B.throwIfCancellationRequested(), ts_codefix_exports.getFixes({ errorCode: Ge2, sourceFile: it, span: mt, program: w6, host: e, cancellationToken: B, formatContext: _e, preferences: T })));
            }
            function He2(Z, ie2, U2) {
              let L = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : emptyOptions;
              Se2(), Y3.assert(Z.type === "file");
              let fe2 = Te2(Z.fileName), T = ts_formatting_exports.getFormatContext(U2, e);
              return ts_codefix_exports.getAllFixes({ fixId: ie2, sourceFile: fe2, program: w6, host: e, cancellationToken: B, formatContext: T, preferences: L });
            }
            function _t(Z, ie2) {
              let U2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emptyOptions;
              var L;
              Se2(), Y3.assert(Z.type === "file");
              let fe2 = Te2(Z.fileName), T = ts_formatting_exports.getFormatContext(ie2, e), it = (L = Z.mode) != null ? L : Z.skipDestructiveCodeActions ? "SortAndCombine" : "All";
              return ts_OrganizeImports_exports.organizeImports(fe2, T, e, w6, U2, it);
            }
            function ft(Z, ie2, U2) {
              let L = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : emptyOptions;
              return getEditsForFileRename(Ye2(), Z, ie2, e, ts_formatting_exports.getFormatContext(U2, e), L, ae);
            }
            function Kt(Z, ie2) {
              let U2 = typeof Z == "string" ? ie2 : Z;
              return ir2(U2) ? Promise.all(U2.map((L) => zt(L))) : zt(U2);
            }
            function zt(Z) {
              let ie2 = (U2) => Ui(U2, N10, $);
              return Y3.assertEqual(Z.type, "install package"), e.installPackage ? e.installPackage({ fileName: ie2(Z.file), packageName: Z.packageName }) : Promise.reject("Host does not implement `installPackage`");
            }
            function xe2(Z, ie2, U2, L) {
              let fe2 = L ? ts_formatting_exports.getFormatContext(L, e).options : void 0;
              return ts_JsDoc_exports.getDocCommentTemplateAtPosition(getNewLineOrDefaultFromHost(e, fe2), x10.getCurrentSourceFile(Z), ie2, U2);
            }
            function Le2(Z, ie2, U2) {
              if (U2 === 60)
                return false;
              let L = x10.getCurrentSourceFile(Z);
              if (isInString(L, ie2))
                return false;
              if (isInsideJsxElementOrAttribute(L, ie2))
                return U2 === 123;
              if (isInTemplateString(L, ie2))
                return false;
              switch (U2) {
                case 39:
                case 34:
                case 96:
                  return !isInComment(L, ie2);
              }
              return true;
            }
            function Re2(Z, ie2) {
              let U2 = x10.getCurrentSourceFile(Z), L = findPrecedingToken(ie2, U2);
              if (!L)
                return;
              let fe2 = L.kind === 31 && tu(L.parent) ? L.parent.parent : td(L) && l2(L.parent) ? L.parent : void 0;
              if (fe2 && gr2(fe2))
                return { newText: `</${fe2.openingElement.tagName.getText(U2)}>` };
              let T = L.kind === 31 && u2(L.parent) ? L.parent.parent : td(L) && pd(L.parent) ? L.parent : void 0;
              if (T && Ln(T))
                return { newText: "</>" };
            }
            function ot2(Z, ie2) {
              return { lineStarts: Z.getLineStarts(), firstLine: Z.getLineAndCharacterOfPosition(ie2.pos).line, lastLine: Z.getLineAndCharacterOfPosition(ie2.end).line };
            }
            function Ct(Z, ie2, U2) {
              let L = x10.getCurrentSourceFile(Z), fe2 = [], { lineStarts: T, firstLine: it, lastLine: mt } = ot2(L, ie2), _e = U2 || false, Ge2 = Number.MAX_VALUE, bt = /* @__PURE__ */ new Map(), jt = new RegExp(/\S/), Yt = isInsideJsxElement(L, T[it]), $t = Yt ? "{/*" : "//";
              for (let Wt = it; Wt <= mt; Wt++) {
                let Xr = L.text.substring(T[Wt], L.getLineEndOfPosition(T[Wt])), Dr2 = jt.exec(Xr);
                Dr2 && (Ge2 = Math.min(Ge2, Dr2.index), bt.set(Wt.toString(), Dr2.index), Xr.substr(Dr2.index, $t.length) !== $t && (_e = U2 === void 0 || U2));
              }
              for (let Wt = it; Wt <= mt; Wt++) {
                if (it !== mt && T[Wt] === ie2.end)
                  continue;
                let Xr = bt.get(Wt.toString());
                Xr !== void 0 && (Yt ? fe2.push.apply(fe2, Mt(Z, { pos: T[Wt] + Ge2, end: L.getLineEndOfPosition(T[Wt]) }, _e, Yt)) : _e ? fe2.push({ newText: $t, span: { length: 0, start: T[Wt] + Ge2 } }) : L.text.substr(T[Wt] + Xr, $t.length) === $t && fe2.push({ newText: "", span: { length: $t.length, start: T[Wt] + Xr } }));
              }
              return fe2;
            }
            function Mt(Z, ie2, U2, L) {
              var fe2;
              let T = x10.getCurrentSourceFile(Z), it = [], { text: mt } = T, _e = false, Ge2 = U2 || false, bt = [], { pos: jt } = ie2, Yt = L !== void 0 ? L : isInsideJsxElement(T, jt), $t = Yt ? "{/*" : "/*", Wt = Yt ? "*/}" : "*/", Xr = Yt ? "\\{\\/\\*" : "\\/\\*", Dr2 = Yt ? "\\*\\/\\}" : "\\*\\/";
              for (; jt <= ie2.end; ) {
                let Lr = mt.substr(jt, $t.length) === $t ? $t.length : 0, yr2 = isInComment(T, jt + Lr);
                if (yr2)
                  Yt && (yr2.pos--, yr2.end++), bt.push(yr2.pos), yr2.kind === 3 && bt.push(yr2.end), _e = true, jt = yr2.end + 1;
                else {
                  let Rn = mt.substring(jt, ie2.end).search(`(${Xr})|(${Dr2})`);
                  Ge2 = U2 !== void 0 ? U2 : Ge2 || !isTextWhiteSpaceLike(mt, jt, Rn === -1 ? ie2.end : jt + Rn), jt = Rn === -1 ? ie2.end + 1 : jt + Rn + Wt.length;
                }
              }
              if (Ge2 || !_e) {
                ((fe2 = isInComment(T, ie2.pos)) == null ? void 0 : fe2.kind) !== 2 && Qn(bt, ie2.pos, Vr2), Qn(bt, ie2.end, Vr2);
                let Lr = bt[0];
                mt.substr(Lr, $t.length) !== $t && it.push({ newText: $t, span: { length: 0, start: Lr } });
                for (let yr2 = 1; yr2 < bt.length - 1; yr2++)
                  mt.substr(bt[yr2] - Wt.length, Wt.length) !== Wt && it.push({ newText: Wt, span: { length: 0, start: bt[yr2] } }), mt.substr(bt[yr2], $t.length) !== $t && it.push({ newText: $t, span: { length: 0, start: bt[yr2] } });
                it.length % 2 !== 0 && it.push({ newText: Wt, span: { length: 0, start: bt[bt.length - 1] } });
              } else
                for (let Lr of bt) {
                  let yr2 = Lr - Wt.length > 0 ? Lr - Wt.length : 0, Rn = mt.substr(yr2, Wt.length) === Wt ? Wt.length : 0;
                  it.push({ newText: "", span: { length: $t.length, start: Lr - Rn } });
                }
              return it;
            }
            function It(Z, ie2) {
              let U2 = x10.getCurrentSourceFile(Z), { firstLine: L, lastLine: fe2 } = ot2(U2, ie2);
              return L === fe2 && ie2.pos !== ie2.end ? Mt(Z, ie2, true) : Ct(Z, ie2, true);
            }
            function Mr2(Z, ie2) {
              let U2 = x10.getCurrentSourceFile(Z), L = [], { pos: fe2 } = ie2, { end: T } = ie2;
              fe2 === T && (T += isInsideJsxElement(U2, fe2) ? 2 : 1);
              for (let it = fe2; it <= T; it++) {
                let mt = isInComment(U2, it);
                if (mt) {
                  switch (mt.kind) {
                    case 2:
                      L.push.apply(L, Ct(Z, { end: mt.end, pos: mt.pos + 1 }, false));
                      break;
                    case 3:
                      L.push.apply(L, Mt(Z, { end: mt.end, pos: mt.pos + 1 }, false));
                  }
                  it = mt.end + 1;
                }
              }
              return L;
            }
            function gr2(Z) {
              let { openingElement: ie2, closingElement: U2, parent: L } = Z;
              return !Hi(ie2.tagName, U2.tagName) || l2(L) && Hi(ie2.tagName, L.openingElement.tagName) && gr2(L);
            }
            function Ln(Z) {
              let { closingFragment: ie2, parent: U2 } = Z;
              return !!(ie2.flags & 131072) || pd(U2) && Ln(U2);
            }
            function ys(Z, ie2, U2) {
              let L = x10.getCurrentSourceFile(Z), fe2 = ts_formatting_exports.getRangeOfEnclosingComment(L, ie2);
              return fe2 && (!U2 || fe2.kind === 3) ? createTextSpanFromRange(fe2) : void 0;
            }
            function ci(Z, ie2) {
              Se2();
              let U2 = Te2(Z);
              B.throwIfCancellationRequested();
              let L = U2.text, fe2 = [];
              if (ie2.length > 0 && !_e(U2.fileName)) {
                let Ge2 = it(), bt;
                for (; bt = Ge2.exec(L); ) {
                  B.throwIfCancellationRequested();
                  let jt = 3;
                  Y3.assert(bt.length === ie2.length + jt);
                  let Yt = bt[1], $t = bt.index + Yt.length;
                  if (!isInComment(U2, $t))
                    continue;
                  let Wt;
                  for (let Dr2 = 0; Dr2 < ie2.length; Dr2++)
                    bt[Dr2 + jt] && (Wt = ie2[Dr2]);
                  if (Wt === void 0)
                    return Y3.fail();
                  if (mt(L.charCodeAt($t + Wt.text.length)))
                    continue;
                  let Xr = bt[2];
                  fe2.push({ descriptor: Wt, message: Xr, position: $t });
                }
              }
              return fe2;
              function T(Ge2) {
                return Ge2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
              }
              function it() {
                let Ge2 = /(?:\/\/+\s*)/.source, bt = /(?:\/\*+\s*)/.source, Yt = "(" + /(?:^(?:\s|\*)*)/.source + "|" + Ge2 + "|" + bt + ")", $t = "(?:" + Ze2(ie2, (yr2) => "(" + T(yr2.text) + ")").join("|") + ")", Wt = /(?:$|\*\/)/.source, Xr = /(?:.*?)/.source, Dr2 = "(" + $t + Xr + ")", Lr = Yt + Dr2 + Wt;
                return new RegExp(Lr, "gim");
              }
              function mt(Ge2) {
                return Ge2 >= 97 && Ge2 <= 122 || Ge2 >= 65 && Ge2 <= 90 || Ge2 >= 48 && Ge2 <= 57;
              }
              function _e(Ge2) {
                return Fi(Ge2, "/node_modules/");
              }
            }
            function Xi(Z, ie2, U2) {
              return Se2(), ts_Rename_exports.getRenameInfo(w6, Te2(Z), ie2, U2 || {});
            }
            function Aa(Z, ie2, U2, L, fe2, T) {
              let [it, mt] = typeof ie2 == "number" ? [ie2, void 0] : [ie2.pos, ie2.end];
              return { file: Z, startPosition: it, endPosition: mt, program: Ye2(), host: e, formatContext: ts_formatting_exports.getFormatContext(L, e), cancellationToken: B, preferences: U2, triggerReason: fe2, kind: T };
            }
            function vs(Z, ie2, U2) {
              return { file: Z, program: Ye2(), host: e, span: ie2, preferences: U2, cancellationToken: B };
            }
            function $s(Z, ie2) {
              return ts_SmartSelectionRange_exports.getSmartSelectionRange(ie2, x10.getCurrentSourceFile(Z));
            }
            function li(Z, ie2) {
              let U2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emptyOptions, L = arguments.length > 3 ? arguments[3] : void 0, fe2 = arguments.length > 4 ? arguments[4] : void 0;
              Se2();
              let T = Te2(Z);
              return ts_refactor_exports.getApplicableRefactors(Aa(T, ie2, U2, emptyOptions, L, fe2));
            }
            function Yi2(Z, ie2, U2, L, fe2) {
              let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : emptyOptions;
              Se2();
              let it = Te2(Z);
              return ts_refactor_exports.getEditsForRefactor(Aa(it, U2, T, ie2), L, fe2);
            }
            function Qi(Z, ie2) {
              return ie2 === 0 ? { line: 0, character: 0 } : ae.toLineColumnOffset(Z, ie2);
            }
            function bs(Z, ie2) {
              Se2();
              let U2 = ts_CallHierarchy_exports.resolveCallHierarchyDeclaration(w6, getTouchingPropertyName(Te2(Z), ie2));
              return U2 && mapOneOrMany(U2, (L) => ts_CallHierarchy_exports.createCallHierarchyItem(w6, L));
            }
            function Ai(Z, ie2) {
              Se2();
              let U2 = Te2(Z), L = firstOrOnly(ts_CallHierarchy_exports.resolveCallHierarchyDeclaration(w6, ie2 === 0 ? U2 : getTouchingPropertyName(U2, ie2)));
              return L ? ts_CallHierarchy_exports.getIncomingCalls(w6, L, B) : [];
            }
            function xn(Z, ie2) {
              Se2();
              let U2 = Te2(Z), L = firstOrOnly(ts_CallHierarchy_exports.resolveCallHierarchyDeclaration(w6, ie2 === 0 ? U2 : getTouchingPropertyName(U2, ie2)));
              return L ? ts_CallHierarchy_exports.getOutgoingCalls(w6, L) : [];
            }
            function Dt(Z, ie2) {
              let U2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emptyOptions;
              Se2();
              let L = Te2(Z);
              return ts_InlayHints_exports.provideInlayHints(vs(L, ie2, U2));
            }
            let Pi = { dispose: pt2, cleanupSemanticCache: Ve2, getSyntacticDiagnostics: Gt, getSemanticDiagnostics: Nt, getSuggestionDiagnostics: Xt, getCompilerOptionsDiagnostics: er2, getSyntacticClassifications: br2, getSemanticClassifications: On, getEncodedSyntacticClassifications: Kr2, getEncodedSemanticClassifications: nr2, getCompletionsAtPosition: Tn, getCompletionEntryDetails: Hr2, getCompletionEntrySymbol: Gi, getSignatureHelpItems: Nn, getQuickInfoAtPosition: pn, getDefinitionAtPosition: kn, getDefinitionAndBoundSpan: an, getImplementationAtPosition: $i, getTypeDefinitionAtPosition: mr2, getReferencesAtPosition: _r2, findReferences: In, getFileReferences: pr2, getOccurrencesAtPosition: dn, getDocumentHighlights: Ur2, getNameOrDottedNameSpan: oi, getBreakpointStatementAtPosition: cr2, getNavigateToItems: Zt, getRenameInfo: Xi, getSmartSelectionRange: $s, findRenameLocations: Gr2, getNavigationBarItems: $r2, getNavigationTree: hr2, getOutliningSpans: wa, getTodoComments: ci, getBraceMatchingAtPosition: Ki, getIndentationAtPosition: Mn, getFormattingEditsForRange: _i, getFormattingEditsForDocument: Ca, getFormattingEditsAfterKeystroke: St, getDocCommentTemplateAtPosition: xe2, isValidBraceCompletionAtPosition: Le2, getJsxClosingTagAtPosition: Re2, getSpanOfEnclosingComment: ys, getCodeFixesAtPosition: ue2, getCombinedCodeFix: He2, applyCodeActionCommand: Kt, organizeImports: _t, getEditsForFileRename: ft, getEmitOutput: Or2, getNonBoundSourceFile: ar2, getProgram: Ye2, getCurrentProgram: () => w6, getAutoImportProvider: Ne2, updateIsDefinitionOfReferencedSymbols: oe2, getApplicableRefactors: li, getEditsForRefactor: Yi2, toLineColumnOffset: Qi, getSourceMapper: () => ae, clearSourceMapperCache: () => ae.clearCache(), prepareCallHierarchy: bs, provideCallHierarchyIncomingCalls: Ai, provideCallHierarchyOutgoingCalls: xn, toggleLineComment: Ct, toggleMultilineComment: Mt, commentSelection: It, uncommentSelection: Mr2, provideInlayHints: Dt, getSupportedCodeFixes: v7 };
            switch (f10) {
              case 0:
                break;
              case 1:
                M2.forEach((Z) => Pi[Z] = () => {
                  throw new Error(`LanguageService Operation: ${Z} not allowed in LanguageServiceMode.PartialSemantic`);
                });
                break;
              case 2:
                M7.forEach((Z) => Pi[Z] = () => {
                  throw new Error(`LanguageService Operation: ${Z} not allowed in LanguageServiceMode.Syntactic`);
                });
                break;
              default:
                Y3.assertNever(f10);
            }
            return Pi;
          }
          function uB(e) {
            return e.nameTable || pB(e), e.nameTable;
          }
          function pB(e) {
            let t6 = e.nameTable = /* @__PURE__ */ new Map();
            e.forEachChild(function r(s) {
              if (yt(s) && !isTagName(s) && s.escapedText || Ta(s) && fB(s)) {
                let f10 = b4(s);
                t6.set(f10, t6.get(f10) === void 0 ? s.pos : -1);
              } else if (vn(s)) {
                let f10 = s.escapedText;
                t6.set(f10, t6.get(f10) === void 0 ? s.pos : -1);
              }
              if (xr2(s, r), ya(s))
                for (let f10 of s.jsDoc)
                  xr2(f10, r);
            });
          }
          function fB(e) {
            return c4(e) || e.parent.kind === 280 || hB(e) || l4(e);
          }
          function S7(e) {
            let t6 = dB(e);
            return t6 && (Hs(t6.parent) || p2(t6.parent)) ? t6 : void 0;
          }
          function dB(e) {
            switch (e.kind) {
              case 10:
              case 14:
              case 8:
                if (e.parent.kind === 164)
                  return Wy(e.parent.parent) ? e.parent.parent : void 0;
              case 79:
                return Wy(e.parent) && (e.parent.parent.kind === 207 || e.parent.parent.kind === 289) && e.parent.name === e ? e.parent : void 0;
            }
          }
          function mB(e, t6) {
            let r = S7(e);
            if (r) {
              let s = t6.getContextualType(r.parent), f10 = s && x7(r, t6, s, false);
              if (f10 && f10.length === 1)
                return fo2(f10);
            }
            return t6.getSymbolAtLocation(e);
          }
          function x7(e, t6, r, s) {
            let f10 = getNameFromPropertyName(e.name);
            if (!f10)
              return Bt;
            if (!r.isUnion()) {
              let w6 = r.getProperty(f10);
              return w6 ? [w6] : Bt;
            }
            let x10 = qt(r.types, (w6) => (Hs(e.parent) || p2(e.parent)) && t6.isTypeInvalidDueToUnionDiscriminant(w6, e.parent) ? void 0 : w6.getProperty(f10));
            if (s && (x10.length === 0 || x10.length === r.types.length)) {
              let w6 = r.getProperty(f10);
              if (w6)
                return [w6];
            }
            return x10.length === 0 ? qt(r.types, (w6) => w6.getProperty(f10)) : x10;
          }
          function hB(e) {
            return e && e.parent && e.parent.kind === 209 && e.parent.argumentExpression === e;
          }
          function gB(e) {
            if (iy)
              return tn(ma(Un(iy.getExecutingFilePath())), aS(e));
            throw new Error("getDefaultLibFilePath is only supported when consumed as a node module. ");
          }
          var E7, wd, Cd, w7, O2, Ad, Pd, C7, A7, P7, D7, k7, I7, N7, O7, M2, M7, yB = D({ "src/services/services.ts"() {
            "use strict";
            L2(), L2(), p7(), f7(), E7 = "0.8", wd = class {
              constructor(e, t6, r) {
                this.pos = t6, this.end = r, this.flags = 0, this.modifierFlagsCache = 0, this.transformFlags = 0, this.parent = void 0, this.kind = e;
              }
              assertHasRealPosition(e) {
                Y3.assert(!hs(this.pos) && !hs(this.end), e || "Node must have a real position for this operation");
              }
              getSourceFile() {
                return Si(this);
              }
              getStart(e, t6) {
                return this.assertHasRealPosition(), Io(this, e, t6);
              }
              getFullStart() {
                return this.assertHasRealPosition(), this.pos;
              }
              getEnd() {
                return this.assertHasRealPosition(), this.end;
              }
              getWidth(e) {
                return this.assertHasRealPosition(), this.getEnd() - this.getStart(e);
              }
              getFullWidth() {
                return this.assertHasRealPosition(), this.end - this.pos;
              }
              getLeadingTriviaWidth(e) {
                return this.assertHasRealPosition(), this.getStart(e) - this.pos;
              }
              getFullText(e) {
                return this.assertHasRealPosition(), (e || this.getSourceFile()).text.substring(this.pos, this.end);
              }
              getText(e) {
                return this.assertHasRealPosition(), e || (e = this.getSourceFile()), e.text.substring(this.getStart(e), this.getEnd());
              }
              getChildCount(e) {
                return this.getChildren(e).length;
              }
              getChildAt(e, t6) {
                return this.getChildren(t6)[e];
              }
              getChildren(e) {
                return this.assertHasRealPosition("Node without a real position cannot be scanned and thus has no token nodes - use forEachChild and collect the result if that's fine"), this._children || (this._children = sB(this, e));
              }
              getFirstToken(e) {
                this.assertHasRealPosition();
                let t6 = this.getChildren(e);
                if (!t6.length)
                  return;
                let r = Ae2(t6, (s) => s.kind < 312 || s.kind > 353);
                return r.kind < 163 ? r : r.getFirstToken(e);
              }
              getLastToken(e) {
                this.assertHasRealPosition();
                let t6 = this.getChildren(e), r = Cn(t6);
                if (r)
                  return r.kind < 163 ? r : r.getLastToken(e);
              }
              forEachChild(e, t6) {
                return xr2(this, e, t6);
              }
            }, Cd = class {
              constructor(e, t6) {
                this.pos = e, this.end = t6, this.flags = 0, this.modifierFlagsCache = 0, this.transformFlags = 0, this.parent = void 0;
              }
              getSourceFile() {
                return Si(this);
              }
              getStart(e, t6) {
                return Io(this, e, t6);
              }
              getFullStart() {
                return this.pos;
              }
              getEnd() {
                return this.end;
              }
              getWidth(e) {
                return this.getEnd() - this.getStart(e);
              }
              getFullWidth() {
                return this.end - this.pos;
              }
              getLeadingTriviaWidth(e) {
                return this.getStart(e) - this.pos;
              }
              getFullText(e) {
                return (e || this.getSourceFile()).text.substring(this.pos, this.end);
              }
              getText(e) {
                return e || (e = this.getSourceFile()), e.text.substring(this.getStart(e), this.getEnd());
              }
              getChildCount() {
                return this.getChildren().length;
              }
              getChildAt(e) {
                return this.getChildren()[e];
              }
              getChildren() {
                return this.kind === 1 && this.jsDoc || Bt;
              }
              getFirstToken() {
              }
              getLastToken() {
              }
              forEachChild() {
              }
            }, w7 = class {
              constructor(e, t6) {
                this.id = 0, this.mergeId = 0, this.flags = e, this.escapedName = t6;
              }
              getFlags() {
                return this.flags;
              }
              get name() {
                return rf(this);
              }
              getEscapedName() {
                return this.escapedName;
              }
              getName() {
                return this.name;
              }
              getDeclarations() {
                return this.declarations;
              }
              getDocumentationComment(e) {
                if (!this.documentationComment)
                  if (this.documentationComment = Bt, !this.declarations && $y(this) && this.links.target && $y(this.links.target) && this.links.target.links.tupleLabelDeclaration) {
                    let t6 = this.links.target.links.tupleLabelDeclaration;
                    this.documentationComment = cu([t6], e);
                  } else
                    this.documentationComment = cu(this.declarations, e);
                return this.documentationComment;
              }
              getContextualDocumentationComment(e, t6) {
                if (e) {
                  if (Tl(e) && (this.contextualGetAccessorDocumentationComment || (this.contextualGetAccessorDocumentationComment = cu(ee2(this.declarations, Tl), t6)), I(this.contextualGetAccessorDocumentationComment)))
                    return this.contextualGetAccessorDocumentationComment;
                  if (bl(e) && (this.contextualSetAccessorDocumentationComment || (this.contextualSetAccessorDocumentationComment = cu(ee2(this.declarations, bl), t6)), I(this.contextualSetAccessorDocumentationComment)))
                    return this.contextualSetAccessorDocumentationComment;
                }
                return this.getDocumentationComment(t6);
              }
              getJsDocTags(e) {
                return this.tags === void 0 && (this.tags = Ed(this.declarations, e)), this.tags;
              }
              getContextualJsDocTags(e, t6) {
                if (e) {
                  if (Tl(e) && (this.contextualGetAccessorTags || (this.contextualGetAccessorTags = Ed(ee2(this.declarations, Tl), t6)), I(this.contextualGetAccessorTags)))
                    return this.contextualGetAccessorTags;
                  if (bl(e) && (this.contextualSetAccessorTags || (this.contextualSetAccessorTags = Ed(ee2(this.declarations, bl), t6)), I(this.contextualSetAccessorTags)))
                    return this.contextualSetAccessorTags;
                }
                return this.getJsDocTags(t6);
              }
            }, O2 = class extends Cd {
              constructor(e, t6, r) {
                super(t6, r), this.kind = e;
              }
            }, Ad = class extends Cd {
              constructor(e, t6, r) {
                super(t6, r), this.kind = 79;
              }
              get text() {
                return qr2(this);
              }
            }, Ad.prototype.kind = 79, Pd = class extends Cd {
              constructor(e, t6, r) {
                super(t6, r), this.kind = 80;
              }
              get text() {
                return qr2(this);
              }
            }, Pd.prototype.kind = 80, C7 = class {
              constructor(e, t6) {
                this.checker = e, this.flags = t6;
              }
              getFlags() {
                return this.flags;
              }
              getSymbol() {
                return this.symbol;
              }
              getProperties() {
                return this.checker.getPropertiesOfType(this);
              }
              getProperty(e) {
                return this.checker.getPropertyOfType(this, e);
              }
              getApparentProperties() {
                return this.checker.getAugmentedPropertiesOfType(this);
              }
              getCallSignatures() {
                return this.checker.getSignaturesOfType(this, 0);
              }
              getConstructSignatures() {
                return this.checker.getSignaturesOfType(this, 1);
              }
              getStringIndexType() {
                return this.checker.getIndexTypeOfType(this, 0);
              }
              getNumberIndexType() {
                return this.checker.getIndexTypeOfType(this, 1);
              }
              getBaseTypes() {
                return this.isClassOrInterface() ? this.checker.getBaseTypes(this) : void 0;
              }
              isNullableType() {
                return this.checker.isNullableType(this);
              }
              getNonNullableType() {
                return this.checker.getNonNullableType(this);
              }
              getNonOptionalType() {
                return this.checker.getNonOptionalType(this);
              }
              getConstraint() {
                return this.checker.getBaseConstraintOfType(this);
              }
              getDefault() {
                return this.checker.getDefaultFromTypeParameter(this);
              }
              isUnion() {
                return !!(this.flags & 1048576);
              }
              isIntersection() {
                return !!(this.flags & 2097152);
              }
              isUnionOrIntersection() {
                return !!(this.flags & 3145728);
              }
              isLiteral() {
                return !!(this.flags & 2432);
              }
              isStringLiteral() {
                return !!(this.flags & 128);
              }
              isNumberLiteral() {
                return !!(this.flags & 256);
              }
              isTypeParameter() {
                return !!(this.flags & 262144);
              }
              isClassOrInterface() {
                return !!(Bf(this) & 3);
              }
              isClass() {
                return !!(Bf(this) & 1);
              }
              isIndexType() {
                return !!(this.flags & 4194304);
              }
              get typeArguments() {
                if (Bf(this) & 4)
                  return this.checker.getTypeArguments(this);
              }
            }, A7 = class {
              constructor(e, t6) {
                this.checker = e, this.flags = t6;
              }
              getDeclaration() {
                return this.declaration;
              }
              getTypeParameters() {
                return this.typeParameters;
              }
              getParameters() {
                return this.parameters;
              }
              getReturnType() {
                return this.checker.getReturnTypeOfSignature(this);
              }
              getTypeParameterAtPosition(e) {
                let t6 = this.checker.getParameterType(this, e);
                if (t6.isIndexType() && Kx(t6.type)) {
                  let r = t6.type.getConstraint();
                  if (r)
                    return this.checker.getIndexType(r);
                }
                return t6;
              }
              getDocumentationComment() {
                return this.documentationComment || (this.documentationComment = cu(Cp(this.declaration), this.checker));
              }
              getJsDocTags() {
                return this.jsDocTags || (this.jsDocTags = Ed(Cp(this.declaration), this.checker));
              }
            }, P7 = class extends wd {
              constructor(e, t6, r) {
                super(e, t6, r), this.kind = 308;
              }
              update(e, t6) {
                return k2(this, e, t6);
              }
              getLineAndCharacterOfPosition(e) {
                return Ls(this, e);
              }
              getLineStarts() {
                return ss(this);
              }
              getPositionOfLineAndCharacter(e, t6, r) {
                return dy(ss(this), e, t6, this.text, r);
              }
              getLineEndOfPosition(e) {
                let { line: t6 } = this.getLineAndCharacterOfPosition(e), r = this.getLineStarts(), s;
                t6 + 1 >= r.length && (s = this.getEnd()), s || (s = r[t6 + 1] - 1);
                let f10 = this.getFullText();
                return f10[s] === `
` && f10[s - 1] === "\r" ? s - 1 : s;
              }
              getNamedDeclarations() {
                return this.namedDeclarations || (this.namedDeclarations = this.computeNamedDeclarations()), this.namedDeclarations;
              }
              computeNamedDeclarations() {
                let e = Be2();
                return this.forEachChild(f10), e;
                function t6(x10) {
                  let w6 = s(x10);
                  w6 && e.add(w6, x10);
                }
                function r(x10) {
                  let w6 = e.get(x10);
                  return w6 || e.set(x10, w6 = []), w6;
                }
                function s(x10) {
                  let w6 = Ey(x10);
                  return w6 && (Ws(w6) && bn(w6.expression) ? w6.expression.name.text : vl(w6) ? getNameFromPropertyName(w6) : void 0);
                }
                function f10(x10) {
                  switch (x10.kind) {
                    case 259:
                    case 215:
                    case 171:
                    case 170:
                      let w6 = x10, A6 = s(w6);
                      if (A6) {
                        let N10 = r(A6), X2 = Cn(N10);
                        X2 && w6.parent === X2.parent && w6.symbol === X2.symbol ? w6.body && !X2.body && (N10[N10.length - 1] = w6) : N10.push(w6);
                      }
                      xr2(x10, f10);
                      break;
                    case 260:
                    case 228:
                    case 261:
                    case 262:
                    case 263:
                    case 264:
                    case 268:
                    case 278:
                    case 273:
                    case 270:
                    case 271:
                    case 174:
                    case 175:
                    case 184:
                      t6(x10), xr2(x10, f10);
                      break;
                    case 166:
                      if (!rn(x10, 16476))
                        break;
                    case 257:
                    case 205: {
                      let N10 = x10;
                      if (df(N10.name)) {
                        xr2(N10.name, f10);
                        break;
                      }
                      N10.initializer && f10(N10.initializer);
                    }
                    case 302:
                    case 169:
                    case 168:
                      t6(x10);
                      break;
                    case 275:
                      let g9 = x10;
                      g9.exportClause && (iE(g9.exportClause) ? c(g9.exportClause.elements, f10) : f10(g9.exportClause.name));
                      break;
                    case 269:
                      let B = x10.importClause;
                      B && (B.name && t6(B.name), B.namedBindings && (B.namedBindings.kind === 271 ? t6(B.namedBindings) : c(B.namedBindings.elements, f10)));
                      break;
                    case 223:
                      ps(x10) !== 0 && t6(x10);
                    default:
                      xr2(x10, f10);
                  }
                }
              }
            }, D7 = class {
              constructor(e, t6, r) {
                this.fileName = e, this.text = t6, this.skipTrivia = r;
              }
              getLineAndCharacterOfPosition(e) {
                return Ls(this, e);
              }
            }, k7 = class {
              constructor(e) {
                this.host = e;
              }
              getCurrentSourceFile(e) {
                var t6, r, s, f10, x10, w6, A6, g9;
                let B = this.host.getScriptSnapshot(e);
                if (!B)
                  throw new Error("Could not find file: '" + e + "'.");
                let N10 = getScriptKind(e, this.host), X2 = this.host.getScriptVersion(e), F2;
                if (this.currentFileName !== e) {
                  let $ = { languageVersion: 99, impliedNodeFormat: getImpliedNodeFormatForFile(Ui(e, this.host.getCurrentDirectory(), ((s = (r = (t6 = this.host).getCompilerHost) == null ? void 0 : r.call(t6)) == null ? void 0 : s.getCanonicalFileName) || D4(this.host)), (g9 = (A6 = (w6 = (x10 = (f10 = this.host).getCompilerHost) == null ? void 0 : x10.call(f10)) == null ? void 0 : w6.getModuleResolutionCache) == null ? void 0 : A6.call(w6)) == null ? void 0 : g9.getPackageJsonInfoCache(), this.host, this.host.getCompilationSettings()), setExternalModuleIndicator: Ex(this.host.getCompilationSettings()) };
                  F2 = N2(e, B, $, X2, true, N10);
                } else if (this.currentFileVersion !== X2) {
                  let $ = B.getChangeRange(this.currentFileScriptSnapshot);
                  F2 = T7(this.currentSourceFile, B, X2, $);
                }
                return F2 && (this.currentFileVersion = X2, this.currentFileName = e, this.currentFileScriptSnapshot = B, this.currentSourceFile = F2), this.currentSourceFile;
              }
            }, I7 = { isCancellationRequested: w_, throwIfCancellationRequested: yn }, N7 = class {
              constructor(e) {
                this.cancellationToken = e;
              }
              isCancellationRequested() {
                return this.cancellationToken.isCancellationRequested();
              }
              throwIfCancellationRequested() {
                var e;
                if (this.isCancellationRequested())
                  throw (e = rs) == null || e.instant(rs.Phase.Session, "cancellationThrown", { kind: "CancellationTokenObject" }), new Rp();
              }
            }, O7 = class {
              constructor(e) {
                let t6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;
                this.hostCancellationToken = e, this.throttleWaitMilliseconds = t6, this.lastCancellationCheckTime = 0;
              }
              isCancellationRequested() {
                let e = ts();
                return Math.abs(e - this.lastCancellationCheckTime) >= this.throttleWaitMilliseconds ? (this.lastCancellationCheckTime = e, this.hostCancellationToken.isCancellationRequested()) : false;
              }
              throwIfCancellationRequested() {
                var e;
                if (this.isCancellationRequested())
                  throw (e = rs) == null || e.instant(rs.Phase.Session, "cancellationThrown", { kind: "ThrottledCancellationToken" }), new Rp();
              }
            }, M2 = ["getSemanticDiagnostics", "getSuggestionDiagnostics", "getCompilerOptionsDiagnostics", "getSemanticClassifications", "getEncodedSemanticClassifications", "getCodeFixesAtPosition", "getCombinedCodeFix", "applyCodeActionCommand", "organizeImports", "getEditsForFileRename", "getEmitOutput", "getApplicableRefactors", "getEditsForRefactor", "prepareCallHierarchy", "provideCallHierarchyIncomingCalls", "provideCallHierarchyOutgoingCalls", "provideInlayHints", "getSupportedCodeFixes"], M7 = [...M2, "getCompletionsAtPosition", "getCompletionEntryDetails", "getCompletionEntrySymbol", "getSignatureHelpItems", "getQuickInfoAtPosition", "getDefinitionAtPosition", "getDefinitionAndBoundSpan", "getImplementationAtPosition", "getTypeDefinitionAtPosition", "getReferencesAtPosition", "findReferences", "getOccurrencesAtPosition", "getDocumentHighlights", "getNavigateToItems", "getRenameInfo", "findRenameLocations", "getApplicableRefactors"], gx(_B());
          } }), vB = () => {
          }, bB = () => {
          }, TB = () => {
          }, SB = () => {
          }, xB = () => {
          }, EB = () => {
          }, wB = () => {
          }, CB = () => {
          }, AB = () => {
          }, PB = () => {
          }, DB = () => {
          }, kB = () => {
          }, IB = () => {
          }, NB = () => {
          }, OB = () => {
          }, MB = () => {
          }, LB = () => {
          }, RB = () => {
          }, jB = () => {
          }, JB = () => {
          }, L2 = D({ "src/services/_namespaces/ts.ts"() {
            "use strict";
            nn(), l7(), KF(), u7(), XF(), YF(), QF(), ZF(), eB(), tB(), rB(), nB(), iB(), aB(), yB(), vB(), bB(), TB(), SB(), xB(), EB(), wB(), CB(), AB(), PB(), DB(), p7(), f7(), kB(), IB(), NB(), OB(), MB(), LB(), RB(), jB(), JB();
          } }), FB = () => {
          }, L7 = {};
          y(L7, { ANONYMOUS: () => ANONYMOUS, AccessFlags: () => Cg, AssertionLevel: () => $1, AssignmentDeclarationKind: () => Mg, AssignmentKind: () => Sv, Associativity: () => Ev, BreakpointResolver: () => ts_BreakpointResolver_exports, BuilderFileEmit: () => BuilderFileEmit, BuilderProgramKind: () => BuilderProgramKind, BuilderState: () => BuilderState, BundleFileSectionKind: () => ty, CallHierarchy: () => ts_CallHierarchy_exports, CharacterCodes: () => $g, CheckFlags: () => Tg, CheckMode: () => CheckMode, ClassificationType: () => ClassificationType, ClassificationTypeNames: () => ClassificationTypeNames, CommentDirectiveType: () => ig2, Comparison: () => d2, CompletionInfoFlags: () => CompletionInfoFlags, CompletionTriggerKind: () => CompletionTriggerKind, Completions: () => ts_Completions_exports, ConfigFileProgramReloadLevel: () => ConfigFileProgramReloadLevel, ContextFlags: () => pg, CoreServicesShimHostAdapter: () => CoreServicesShimHostAdapter, Debug: () => Y3, DiagnosticCategory: () => qp, Diagnostics: () => ve, DocumentHighlights: () => DocumentHighlights, ElementFlags: () => wg, EmitFlags: () => Wp, EmitHint: () => Qg, EmitOnly: () => og, EndOfLineState: () => EndOfLineState, EnumKind: () => bg, ExitStatus: () => cg, ExportKind: () => ExportKind, Extension: () => Kg, ExternalEmitHelpers: () => Yg, FileIncludeKind: () => ag, FilePreprocessingDiagnosticsKind: () => sg, FileSystemEntryKind: () => FileSystemEntryKind, FileWatcherEventKind: () => FileWatcherEventKind, FindAllReferences: () => ts_FindAllReferences_exports, FlattenLevel: () => FlattenLevel, FlowFlags: () => il, ForegroundColorEscapeSequences: () => ForegroundColorEscapeSequences, FunctionFlags: () => xv, GeneratedIdentifierFlags: () => rg, GetLiteralTextFlags: () => vv, GoToDefinition: () => ts_GoToDefinition_exports, HighlightSpanKind: () => HighlightSpanKind, ImportKind: () => ImportKind, ImportsNotUsedAsValues: () => Ug, IndentStyle: () => IndentStyle, IndexKind: () => Dg, InferenceFlags: () => Ng, InferencePriority: () => Ig, InlayHintKind: () => InlayHintKind, InlayHints: () => ts_InlayHints_exports, InternalEmitFlags: () => Xg, InternalSymbolName: () => Sg, InvalidatedProjectKind: () => InvalidatedProjectKind, JsDoc: () => ts_JsDoc_exports, JsTyping: () => ts_JsTyping_exports, JsxEmit: () => qg, JsxFlags: () => tg, JsxReferenceKind: () => Ag, LanguageServiceMode: () => LanguageServiceMode, LanguageServiceShimHostAdapter: () => LanguageServiceShimHostAdapter, LanguageVariant: () => Hg, LexicalEnvironmentFlags: () => ey, ListFormat: () => ry, LogLevel: () => Y1, MemberOverrideStatus: () => lg, ModifierFlags: () => Mp, ModuleDetectionKind: () => Rg, ModuleInstanceState: () => ModuleInstanceState, ModuleKind: () => Bg2, ModuleResolutionKind: () => Lg, ModuleSpecifierEnding: () => jv, NavigateTo: () => ts_NavigateTo_exports, NavigationBar: () => ts_NavigationBar_exports, NewLineKind: () => zg, NodeBuilderFlags: () => fg, NodeCheckFlags: () => xg, NodeFactoryFlags: () => Fv, NodeFlags: () => Op, NodeResolutionFeatures: () => NodeResolutionFeatures, ObjectFlags: () => Fp, OperationCanceledException: () => Rp, OperatorPrecedence: () => wv, OrganizeImports: () => ts_OrganizeImports_exports, OrganizeImportsMode: () => OrganizeImportsMode, OuterExpressionKinds: () => Zg, OutliningElementsCollector: () => ts_OutliningElementsCollector_exports, OutliningSpanKind: () => OutliningSpanKind, OutputFileType: () => OutputFileType, PackageJsonAutoImportPreference: () => PackageJsonAutoImportPreference, PackageJsonDependencyGroup: () => PackageJsonDependencyGroup, PatternMatchKind: () => PatternMatchKind, PollingInterval: () => PollingInterval, PollingWatchKind: () => Fg, PragmaKindFlags: () => ny, PrivateIdentifierKind: () => PrivateIdentifierKind, ProcessLevel: () => ProcessLevel, QuotePreference: () => QuotePreference, RelationComparisonResult: () => Lp, Rename: () => ts_Rename_exports, ScriptElementKind: () => ScriptElementKind, ScriptElementKindModifier: () => ScriptElementKindModifier, ScriptKind: () => Wg, ScriptSnapshot: () => ScriptSnapshot, ScriptTarget: () => Vg, SemanticClassificationFormat: () => SemanticClassificationFormat, SemanticMeaning: () => SemanticMeaning, SemicolonPreference: () => SemicolonPreference, SignatureCheckMode: () => SignatureCheckMode, SignatureFlags: () => Bp, SignatureHelp: () => ts_SignatureHelp_exports, SignatureKind: () => Pg, SmartSelectionRange: () => ts_SmartSelectionRange_exports, SnippetKind: () => zp, SortKind: () => H1, StructureIsReused: () => _g, SymbolAccessibility: () => hg, SymbolDisplay: () => ts_SymbolDisplay_exports, SymbolDisplayPartKind: () => SymbolDisplayPartKind, SymbolFlags: () => jp, SymbolFormatFlags: () => mg, SyntaxKind: () => Np, SyntheticSymbolKind: () => gg, Ternary: () => Og, ThrottledCancellationToken: () => O7, TokenClass: () => TokenClass, TokenFlags: () => ng, TransformFlags: () => Up, TypeFacts: () => TypeFacts, TypeFlags: () => Jp, TypeFormatFlags: () => dg, TypeMapKind: () => kg2, TypePredicateKind: () => yg, TypeReferenceSerializationKind: () => vg, TypeScriptServicesFactory: () => TypeScriptServicesFactory, UnionReduction: () => ug, UpToDateStatusType: () => UpToDateStatusType, VarianceFlags: () => Eg, Version: () => Version, VersionRange: () => VersionRange, WatchDirectoryFlags: () => Gg, WatchDirectoryKind: () => Jg, WatchFileKind: () => jg, WatchLogLevel: () => WatchLogLevel, WatchType: () => WatchType, accessPrivateIdentifier: () => accessPrivateIdentifier, addEmitFlags: () => addEmitFlags, addEmitHelper: () => addEmitHelper, addEmitHelpers: () => addEmitHelpers, addInternalEmitFlags: () => addInternalEmitFlags, addNodeFactoryPatcher: () => jL, addObjectAllocatorPatcher: () => sM, addRange: () => jr2, addRelatedInfo: () => Rl, addSyntheticLeadingComment: () => addSyntheticLeadingComment, addSyntheticTrailingComment: () => addSyntheticTrailingComment, addToSeen: () => GO, advancedAsyncSuperHelper: () => advancedAsyncSuperHelper, affectsDeclarationPathOptionDeclarations: () => affectsDeclarationPathOptionDeclarations, affectsEmitOptionDeclarations: () => affectsEmitOptionDeclarations, allKeysStartWithDot: () => allKeysStartWithDot, altDirectorySeparator: () => py, and: () => E5, append: () => tr2, appendIfUnique: () => g_, arrayFrom: () => Za, arrayIsEqualTo: () => Hc, arrayIsHomogeneous: () => fL, arrayIsSorted: () => Wc, arrayOf: () => yo, arrayReverseIterator: () => y_, arrayToMap: () => Zc, arrayToMultiMap: () => bo, arrayToNumericMap: () => Os, arraysEqual: () => ke2, assertType: () => C5, assign: () => vo, assignHelper: () => assignHelper, asyncDelegator: () => asyncDelegator, asyncGeneratorHelper: () => asyncGeneratorHelper, asyncSuperHelper: () => asyncSuperHelper, asyncValues: () => asyncValues, attachFileToDiagnostics: () => qs, awaitHelper: () => awaitHelper, awaiterHelper: () => awaiterHelper, base64decode: () => mO, base64encode: () => dO, binarySearch: () => Ya, binarySearchKey: () => b_, bindSourceFile: () => bindSourceFile, breakIntoCharacterSpans: () => breakIntoCharacterSpans, breakIntoWordSpans: () => breakIntoWordSpans, buildLinkParts: () => buildLinkParts, buildOpts: () => buildOpts, buildOverload: () => buildOverload, bundlerModuleNameResolver: () => bundlerModuleNameResolver, canBeConvertedToAsync: () => canBeConvertedToAsync, canHaveDecorators: () => ME, canHaveExportModifier: () => AL, canHaveFlowNode: () => jI, canHaveIllegalDecorators: () => rJ, canHaveIllegalModifiers: () => nJ, canHaveIllegalType: () => tJ, canHaveIllegalTypeParameters: () => IE, canHaveJSDoc: () => Af, canHaveLocals: () => zP, canHaveModifiers: () => fc, canHaveSymbol: () => UP, canJsonReportNoInputFiles: () => canJsonReportNoInputFiles, canProduceDiagnostics: () => canProduceDiagnostics, canUsePropertyAccess: () => PL, canWatchDirectoryOrFile: () => canWatchDirectoryOrFile, cartesianProduct: () => P5, cast: () => ti, chainBundle: () => chainBundle, chainDiagnosticMessages: () => lM, changeAnyExtension: () => RT, changeCompilerHostLikeToUseCache: () => changeCompilerHostLikeToUseCache, changeExtension: () => KM, changesAffectModuleResolution: () => cD, changesAffectingProgramStructure: () => lD, childIsDecorated: () => h0, classElementOrClassElementParameterIsDecorated: () => sI, classOrConstructorParameterIsDecorated: () => aI, classPrivateFieldGetHelper: () => classPrivateFieldGetHelper, classPrivateFieldInHelper: () => classPrivateFieldInHelper, classPrivateFieldSetHelper: () => classPrivateFieldSetHelper, classicNameResolver: () => classicNameResolver, classifier: () => ts_classifier_exports, cleanExtendedConfigCache: () => cleanExtendedConfigCache, clear: () => nt, clearMap: () => qO, clearSharedExtendedConfigFileWatcher: () => clearSharedExtendedConfigFileWatcher, climbPastPropertyAccess: () => climbPastPropertyAccess, climbPastPropertyOrElementAccess: () => climbPastPropertyOrElementAccess, clone: () => E_, cloneCompilerOptions: () => cloneCompilerOptions, closeFileWatcher: () => MO, closeFileWatcherOf: () => closeFileWatcherOf, codefix: () => ts_codefix_exports, collapseTextChangeRangesAcrossMultipleVersions: () => CA, collectExternalModuleInfo: () => collectExternalModuleInfo, combine: () => $c, combinePaths: () => tn, commentPragmas: () => Vp, commonOptionsWithBuild: () => commonOptionsWithBuild, commonPackageFolders: () => Pv, compact: () => Gc, compareBooleans: () => j1, compareDataObjects: () => px, compareDiagnostics: () => av, compareDiagnosticsSkipRelatedInformation: () => qf, compareEmitHelpers: () => compareEmitHelpers, compareNumberOfDirectorySeparators: () => $M, comparePaths: () => tA, comparePathsCaseInsensitive: () => eA, comparePathsCaseSensitive: () => Z5, comparePatternKeys: () => comparePatternKeys, compareProperties: () => R1, compareStringsCaseInsensitive: () => C_, compareStringsCaseInsensitiveEslintCompatible: () => O1, compareStringsCaseSensitive: () => ri, compareStringsCaseSensitiveUI: () => L1, compareTextSpans: () => I1, compareValues: () => Vr2, compileOnSaveCommandLineOption: () => compileOnSaveCommandLineOption, compilerOptionsAffectDeclarationPath: () => DM, compilerOptionsAffectEmit: () => PM, compilerOptionsAffectSemanticDiagnostics: () => AM, compilerOptionsDidYouMeanDiagnostics: () => compilerOptionsDidYouMeanDiagnostics, compilerOptionsIndicateEsModules: () => compilerOptionsIndicateEsModules, compose: () => k1, computeCommonSourceDirectoryOfFilenames: () => computeCommonSourceDirectoryOfFilenames, computeLineAndCharacterOfPosition: () => my, computeLineOfPosition: () => k_, computeLineStarts: () => Kp, computePositionOfLineAndCharacter: () => dy, computeSignature: () => computeSignature, computeSignatureWithDiagnostics: () => computeSignatureWithDiagnostics, computeSuggestionDiagnostics: () => computeSuggestionDiagnostics, concatenate: () => Ft, concatenateDiagnosticMessageChains: () => uM, consumesNodeCoreModules: () => consumesNodeCoreModules, contains: () => pe2, containsIgnoredPath: () => Hx, containsObjectRestOrSpread: () => A2, containsParseError: () => Ky, containsPath: () => jT, convertCompilerOptionsForTelemetry: () => convertCompilerOptionsForTelemetry, convertCompilerOptionsFromJson: () => convertCompilerOptionsFromJson, convertJsonOption: () => convertJsonOption, convertToBase64: () => ix, convertToObject: () => convertToObject, convertToObjectWorker: () => convertToObjectWorker, convertToOptionsWithAbsolutePaths: () => convertToOptionsWithAbsolutePaths, convertToRelativePath: () => nA, convertToTSConfig: () => convertToTSConfig, convertTypeAcquisitionFromJson: () => convertTypeAcquisitionFromJson, copyComments: () => copyComments, copyEntries: () => dD, copyLeadingComments: () => copyLeadingComments, copyProperties: () => H, copyTrailingAsLeadingComments: () => copyTrailingAsLeadingComments, copyTrailingComments: () => copyTrailingComments, couldStartTrivia: () => pA, countWhere: () => Xe2, createAbstractBuilder: () => createAbstractBuilder, createAccessorPropertyBackingField: () => LJ, createAccessorPropertyGetRedirector: () => RJ, createAccessorPropertySetRedirector: () => jJ, createBaseNodeFactory: () => S8, createBinaryExpressionTrampoline: () => PJ, createBindingHelper: () => createBindingHelper, createBuildInfo: () => createBuildInfo, createBuilderProgram: () => createBuilderProgram, createBuilderProgramUsingProgramBuildInfo: () => createBuilderProgramUsingProgramBuildInfo, createBuilderStatusReporter: () => createBuilderStatusReporter, createCacheWithRedirects: () => createCacheWithRedirects, createCacheableExportInfoMap: () => createCacheableExportInfoMap, createCachedDirectoryStructureHost: () => createCachedDirectoryStructureHost, createClassifier: () => createClassifier, createCommentDirectivesMap: () => JD, createCompilerDiagnostic: () => Ol, createCompilerDiagnosticForInvalidCustomType: () => createCompilerDiagnosticForInvalidCustomType, createCompilerDiagnosticFromMessageChain: () => cM, createCompilerHost: () => createCompilerHost, createCompilerHostFromProgramHost: () => createCompilerHostFromProgramHost, createCompilerHostWorker: () => createCompilerHostWorker, createDetachedDiagnostic: () => Ro, createDiagnosticCollection: () => TN, createDiagnosticForFileFromMessageChain: () => mk, createDiagnosticForNode: () => uk, createDiagnosticForNodeArray: () => pk, createDiagnosticForNodeArrayFromMessageChain: () => dk, createDiagnosticForNodeFromMessageChain: () => fk, createDiagnosticForNodeInSourceFile: () => P3, createDiagnosticForRange: () => gk, createDiagnosticMessageChainFromDiagnostic: () => hk, createDiagnosticReporter: () => createDiagnosticReporter, createDocumentPositionMapper: () => createDocumentPositionMapper, createDocumentRegistry: () => createDocumentRegistry, createDocumentRegistryInternal: () => createDocumentRegistryInternal, createEmitAndSemanticDiagnosticsBuilderProgram: () => createEmitAndSemanticDiagnosticsBuilderProgram, createEmitHelperFactory: () => createEmitHelperFactory, createEmptyExports: () => Dj, createExpressionForJsxElement: () => Ij, createExpressionForJsxFragment: () => Nj, createExpressionForObjectLiteralElementLike: () => Fj, createExpressionForPropertyName: () => vE, createExpressionFromEntityName: () => yE, createExternalHelpersImportDeclarationIfNeeded: () => $j, createFileDiagnostic: () => iv, createFileDiagnosticFromMessageChain: () => r0, createForOfBindingStatement: () => Oj, createGetCanonicalFileName: () => wp, createGetSourceFile: () => createGetSourceFile, createGetSymbolAccessibilityDiagnosticForNode: () => createGetSymbolAccessibilityDiagnosticForNode, createGetSymbolAccessibilityDiagnosticForNodeName: () => createGetSymbolAccessibilityDiagnosticForNodeName, createGetSymbolWalker: () => createGetSymbolWalker, createIncrementalCompilerHost: () => createIncrementalCompilerHost, createIncrementalProgram: () => createIncrementalProgram, createInputFiles: () => VL, createInputFilesWithFilePaths: () => C8, createInputFilesWithFileTexts: () => A8, createJsxFactoryExpression: () => gE, createLanguageService: () => lB, createLanguageServiceSourceFile: () => N2, createMemberAccessForPropertyName: () => hd, createModeAwareCache: () => createModeAwareCache, createModeAwareCacheKey: () => createModeAwareCacheKey, createModuleResolutionCache: () => createModuleResolutionCache, createModuleResolutionLoader: () => createModuleResolutionLoader, createModuleSpecifierResolutionHost: () => createModuleSpecifierResolutionHost, createMultiMap: () => Be2, createNodeConverters: () => x8, createNodeFactory: () => Zf, createOptionNameMap: () => createOptionNameMap, createOverload: () => createOverload, createPackageJsonImportFilter: () => createPackageJsonImportFilter, createPackageJsonInfo: () => createPackageJsonInfo, createParenthesizerRules: () => createParenthesizerRules, createPatternMatcher: () => createPatternMatcher, createPrependNodes: () => createPrependNodes, createPrinter: () => createPrinter, createPrinterWithDefaults: () => createPrinterWithDefaults, createPrinterWithRemoveComments: () => createPrinterWithRemoveComments, createPrinterWithRemoveCommentsNeverAsciiEscape: () => createPrinterWithRemoveCommentsNeverAsciiEscape, createPrinterWithRemoveCommentsOmitTrailingSemicolon: () => createPrinterWithRemoveCommentsOmitTrailingSemicolon, createProgram: () => createProgram, createProgramHost: () => createProgramHost, createPropertyNameNodeForIdentifierOrLiteral: () => EL, createQueue: () => Fr2, createRange: () => Jf, createRedirectedBuilderProgram: () => createRedirectedBuilderProgram, createResolutionCache: () => createResolutionCache, createRuntimeTypeSerializer: () => createRuntimeTypeSerializer, createScanner: () => Po, createSemanticDiagnosticsBuilderProgram: () => createSemanticDiagnosticsBuilderProgram, createSet: () => Cr2, createSolutionBuilder: () => createSolutionBuilder, createSolutionBuilderHost: () => createSolutionBuilderHost, createSolutionBuilderWithWatch: () => createSolutionBuilderWithWatch, createSolutionBuilderWithWatchHost: () => createSolutionBuilderWithWatchHost, createSortedArray: () => zc, createSourceFile: () => YE, createSourceMapGenerator: () => createSourceMapGenerator, createSourceMapSource: () => HL, createSuperAccessVariableStatement: () => createSuperAccessVariableStatement, createSymbolTable: () => oD, createSymlinkCache: () => MM, createSystemWatchFunctions: () => createSystemWatchFunctions, createTextChange: () => createTextChange, createTextChangeFromStartLength: () => createTextChangeFromStartLength, createTextChangeRange: () => Zp, createTextRangeFromNode: () => createTextRangeFromNode, createTextRangeFromSpan: () => createTextRangeFromSpan, createTextSpan: () => L_, createTextSpanFromBounds: () => ha, createTextSpanFromNode: () => createTextSpanFromNode, createTextSpanFromRange: () => createTextSpanFromRange, createTextSpanFromStringLiteralLikeContent: () => createTextSpanFromStringLiteralLikeContent, createTextWriter: () => DN, createTokenRange: () => bO, createTypeChecker: () => createTypeChecker, createTypeReferenceDirectiveResolutionCache: () => createTypeReferenceDirectiveResolutionCache, createTypeReferenceResolutionLoader: () => createTypeReferenceResolutionLoader, createUnderscoreEscapedMultiMap: () => Ht, createUnparsedSourceFile: () => UL, createWatchCompilerHost: () => createWatchCompilerHost2, createWatchCompilerHostOfConfigFile: () => createWatchCompilerHostOfConfigFile, createWatchCompilerHostOfFilesAndCompilerOptions: () => createWatchCompilerHostOfFilesAndCompilerOptions, createWatchFactory: () => createWatchFactory, createWatchHost: () => createWatchHost, createWatchProgram: () => createWatchProgram, createWatchStatusReporter: () => createWatchStatusReporter, createWriteFileMeasuringIO: () => createWriteFileMeasuringIO, declarationNameToString: () => A3, decodeMappings: () => decodeMappings, decodedTextSpanIntersectsWith: () => Sy, decorateHelper: () => decorateHelper, deduplicate: () => ji, defaultIncludeSpec: () => defaultIncludeSpec, defaultInitCompilerOptions: () => defaultInitCompilerOptions, defaultMaximumTruncationLength: () => r8, detectSortCaseSensitivity: () => Vc, diagnosticCategoryName: () => z5, diagnosticToString: () => diagnosticToString, directoryProbablyExists: () => sx, directorySeparator: () => zn, displayPart: () => displayPart, displayPartsToString: () => cB, disposeEmitNodes: () => disposeEmitNodes, documentSpansEqual: () => documentSpansEqual, dumpTracingLegend: () => dumpTracingLegend, elementAt: () => wT, elideNodes: () => IJ, emitComments: () => U4, emitDetachedComments: () => GN, emitFiles: () => emitFiles, emitFilesAndReportErrors: () => emitFilesAndReportErrors, emitFilesAndReportErrorsAndGetExitStatus: () => emitFilesAndReportErrorsAndGetExitStatus, emitModuleKindIsNonNodeESM: () => mM, emitNewLineBeforeLeadingCommentOfPosition: () => HN, emitNewLineBeforeLeadingComments: () => B4, emitNewLineBeforeLeadingCommentsOfPosition: () => q4, emitSkippedWithNoDiagnostics: () => emitSkippedWithNoDiagnostics, emitUsingBuildInfo: () => emitUsingBuildInfo, emptyArray: () => Bt, emptyFileSystemEntries: () => T8, emptyMap: () => V1, emptyOptions: () => emptyOptions, emptySet: () => ET, endsWith: () => es, ensurePathIsNonModuleName: () => _y, ensureScriptKind: () => Nx, ensureTrailingDirectorySeparator: () => wo, entityNameToString: () => ls, enumerateInsertsAndDeletes: () => A5, equalOwnProperties: () => S_, equateStringsCaseInsensitive: () => Ms, equateStringsCaseSensitive: () => To, equateValues: () => fa, esDecorateHelper: () => esDecorateHelper, escapeJsxAttributeString: () => A4, escapeLeadingUnderscores: () => vi, escapeNonAsciiString: () => Of, escapeSnippetText: () => xL, escapeString: () => Nf, every: () => me2, expandPreOrPostfixIncrementOrDecrementExpression: () => Bj, explainFiles: () => explainFiles, explainIfFileIsRedirectAndImpliedFormat: () => explainIfFileIsRedirectAndImpliedFormat, exportAssignmentIsAlias: () => I0, exportStarHelper: () => exportStarHelper, expressionResultIsUnused: () => gL, extend: () => S, extendsHelper: () => extendsHelper, extensionFromPath: () => QM, extensionIsTS: () => qx, externalHelpersModuleNameText: () => Kf, factory: () => si, fileExtensionIs: () => ns, fileExtensionIsOneOf: () => da, fileIncludeReasonToDiagnostics: () => fileIncludeReasonToDiagnostics, filter: () => ee2, filterMutate: () => je2, filterSemanticDiagnostics: () => filterSemanticDiagnostics, find: () => Ae2, findAncestor: () => zi, findBestPatternMatch: () => TT, findChildOfKind: () => findChildOfKind, findComputedPropertyNameCacheAssignment: () => JJ, findConfigFile: () => findConfigFile, findContainingList: () => findContainingList, findDiagnosticForNode: () => findDiagnosticForNode, findFirstNonJsxWhitespaceToken: () => findFirstNonJsxWhitespaceToken, findIndex: () => he, findLast: () => te2, findLastIndex: () => Pe2, findListItemInfo: () => findListItemInfo, findMap: () => R, findModifier: () => findModifier, findNextToken: () => findNextToken, findPackageJson: () => findPackageJson, findPackageJsons: () => findPackageJsons, findPrecedingMatchingToken: () => findPrecedingMatchingToken, findPrecedingToken: () => findPrecedingToken, findSuperStatementIndex: () => findSuperStatementIndex, findTokenOnLeftOfPosition: () => findTokenOnLeftOfPosition, findUseStrictPrologue: () => TE, first: () => fo2, firstDefined: () => q2, firstDefinedIterator: () => W, firstIterator: () => v_, firstOrOnly: () => firstOrOnly, firstOrUndefined: () => pa, firstOrUndefinedIterator: () => Xc, fixupCompilerOptions: () => fixupCompilerOptions, flatMap: () => ne2, flatMapIterator: () => Fe2, flatMapToMutable: () => ge, flatten: () => ct, flattenCommaList: () => BJ, flattenDestructuringAssignment: () => flattenDestructuringAssignment, flattenDestructuringBinding: () => flattenDestructuringBinding, flattenDiagnosticMessageText: () => flattenDiagnosticMessageText, forEach: () => c, forEachAncestor: () => uD, forEachAncestorDirectory: () => FT, forEachChild: () => xr2, forEachChildRecursively: () => D2, forEachEmittedFile: () => forEachEmittedFile, forEachEnclosingBlockScopeContainer: () => ok, forEachEntry: () => pD, forEachExternalModuleToImportFrom: () => forEachExternalModuleToImportFrom, forEachImportClauseDeclaration: () => NI, forEachKey: () => fD, forEachLeadingCommentRange: () => fA, forEachNameInAccessChainWalkingLeft: () => QO, forEachResolvedProjectReference: () => forEachResolvedProjectReference, forEachReturnStatement: () => Pk, forEachRight: () => M, forEachTrailingCommentRange: () => dA, forEachUnique: () => forEachUnique, forEachYieldExpression: () => Dk, forSomeAncestorDirectory: () => WO, formatColorAndReset: () => formatColorAndReset, formatDiagnostic: () => formatDiagnostic, formatDiagnostics: () => formatDiagnostics, formatDiagnosticsWithColorAndContext: () => formatDiagnosticsWithColorAndContext, formatGeneratedName: () => bd, formatGeneratedNamePart: () => C22, formatLocation: () => formatLocation, formatMessage: () => _M, formatStringFromArgs: () => X_, formatting: () => ts_formatting_exports, fullTripleSlashAMDReferencePathRegEx: () => Tv, fullTripleSlashReferencePathRegEx: () => bv, generateDjb2Hash: () => generateDjb2Hash, generateTSConfig: () => generateTSConfig, generatorHelper: () => generatorHelper, getAdjustedReferenceLocation: () => getAdjustedReferenceLocation, getAdjustedRenameLocation: () => getAdjustedRenameLocation, getAliasDeclarationFromName: () => u4, getAllAccessorDeclarations: () => W0, getAllDecoratorsOfClass: () => getAllDecoratorsOfClass, getAllDecoratorsOfClassElement: () => getAllDecoratorsOfClassElement, getAllJSDocTags: () => MS, getAllJSDocTagsOfKind: () => UA, getAllKeys: () => T_, getAllProjectOutputs: () => getAllProjectOutputs, getAllSuperTypeNodes: () => h4, getAllUnscopedEmitHelpers: () => getAllUnscopedEmitHelpers, getAllowJSCompilerOption: () => Ax, getAllowSyntheticDefaultImports: () => TM, getAncestor: () => eN, getAnyExtensionFromPath: () => Gp, getAreDeclarationMapsEnabled: () => bM, getAssignedExpandoInitializer: () => bI, getAssignedName: () => yS, getAssignmentDeclarationKind: () => ps, getAssignmentDeclarationPropertyAccessKind: () => K3, getAssignmentTargetKind: () => o4, getAutomaticTypeDirectiveNames: () => getAutomaticTypeDirectiveNames, getBaseFileName: () => sl, getBinaryOperatorPrecedence: () => Dl, getBuildInfo: () => getBuildInfo, getBuildInfoFileVersionMap: () => getBuildInfoFileVersionMap, getBuildInfoText: () => getBuildInfoText, getBuildOrderFromAnyBuildOrder: () => getBuildOrderFromAnyBuildOrder, getBuilderCreationParameters: () => getBuilderCreationParameters, getBuilderFileEmit: () => getBuilderFileEmit, getCheckFlags: () => ux, getClassExtendsHeritageElement: () => d4, getClassLikeDeclarationOfSymbol: () => dx, getCombinedLocalAndExportSymbolFlags: () => jO, getCombinedModifierFlags: () => ef, getCombinedNodeFlags: () => tf2, getCombinedNodeFlagsAlwaysIncludeJSDoc: () => PA, getCommentRange: () => getCommentRange, getCommonSourceDirectory: () => getCommonSourceDirectory, getCommonSourceDirectoryOfConfig: () => getCommonSourceDirectoryOfConfig, getCompilerOptionValue: () => uv, getCompilerOptionsDiffValue: () => getCompilerOptionsDiffValue, getConditions: () => getConditions, getConfigFileParsingDiagnostics: () => getConfigFileParsingDiagnostics, getConstantValue: () => getConstantValue, getContainerNode: () => getContainerNode, getContainingClass: () => Vk, getContainingClassStaticBlock: () => Hk, getContainingFunction: () => zk, getContainingFunctionDeclaration: () => Wk, getContainingFunctionOrClassStaticBlock: () => Gk, getContainingNodeArray: () => yL, getContainingObjectLiteralElement: () => S7, getContextualTypeFromParent: () => getContextualTypeFromParent, getContextualTypeFromParentOrAncestorTypeNode: () => getContextualTypeFromParentOrAncestorTypeNode, getCurrentTime: () => getCurrentTime, getDeclarationDiagnostics: () => getDeclarationDiagnostics, getDeclarationEmitExtensionForPath: () => O4, getDeclarationEmitOutputFilePath: () => ON, getDeclarationEmitOutputFilePathWorker: () => N4, getDeclarationFromName: () => XI, getDeclarationModifierFlagsFromSymbol: () => LO, getDeclarationOfKind: () => aD, getDeclarationsOfKind: () => sD, getDeclaredExpandoInitializer: () => yI, getDecorators: () => kA, getDefaultCompilerOptions: () => y7, getDefaultExportInfoWorker: () => getDefaultExportInfoWorker, getDefaultFormatCodeSettings: () => getDefaultFormatCodeSettings, getDefaultLibFileName: () => aS, getDefaultLibFilePath: () => gB, getDefaultLikeExportInfo: () => getDefaultLikeExportInfo, getDiagnosticText: () => getDiagnosticText, getDiagnosticsWithinSpan: () => getDiagnosticsWithinSpan, getDirectoryPath: () => ma, getDocumentPositionMapper: () => getDocumentPositionMapper, getESModuleInterop: () => ov, getEditsForFileRename: () => getEditsForFileRename, getEffectiveBaseTypeNode: () => f4, getEffectiveConstraintOfTypeParameter: () => HA, getEffectiveContainerForJSDocTemplateTag: () => FI, getEffectiveImplementsTypeNodes: () => m4, getEffectiveInitializer: () => V3, getEffectiveJSDocHost: () => A0, getEffectiveModifierFlags: () => Rf, getEffectiveModifierFlagsAlwaysIncludeJSDoc: () => K4, getEffectiveModifierFlagsNoCache: () => Y4, getEffectiveReturnTypeNode: () => zN, getEffectiveSetAccessorTypeAnnotationNode: () => VN, getEffectiveTypeAnnotationNode: () => V0, getEffectiveTypeParameterDeclarations: () => VA, getEffectiveTypeRoots: () => getEffectiveTypeRoots, getElementOrPropertyAccessArgumentExpressionOrName: () => Cf, getElementOrPropertyAccessName: () => Fs, getElementsOfBindingOrAssignmentPattern: () => kE, getEmitDeclarations: () => cv, getEmitFlags: () => xi, getEmitHelpers: () => getEmitHelpers, getEmitModuleDetectionKind: () => wx, getEmitModuleKind: () => Ei, getEmitModuleResolutionKind: () => Ml, getEmitScriptTarget: () => Uf, getEnclosingBlockScopeContainer: () => Zy, getEncodedSemanticClassifications: () => getEncodedSemanticClassifications, getEncodedSyntacticClassifications: () => getEncodedSyntacticClassifications, getEndLinePosition: () => d3, getEntityNameFromTypeNode: () => nI, getEntrypointsFromPackageJsonInfo: () => getEntrypointsFromPackageJsonInfo, getErrorCountForSummary: () => getErrorCountForSummary, getErrorSpanForNode: () => i0, getErrorSummaryText: () => getErrorSummaryText, getEscapedTextOfIdentifierOrLiteral: () => b4, getExpandoInitializer: () => U_, getExportAssignmentExpression: () => p4, getExportInfoMap: () => getExportInfoMap, getExportNeedsImportStarHelper: () => getExportNeedsImportStarHelper, getExpressionAssociativity: () => yN, getExpressionPrecedence: () => vN, getExternalHelpersModuleName: () => EE, getExternalModuleImportEqualsDeclarationExpression: () => _I, getExternalModuleName: () => E0, getExternalModuleNameFromDeclaration: () => IN, getExternalModuleNameFromPath: () => F0, getExternalModuleNameLiteral: () => Xj, getExternalModuleRequireArgument: () => cI, getFallbackOptions: () => getFallbackOptions, getFileEmitOutput: () => getFileEmitOutput, getFileMatcherPatterns: () => Ix, getFileNamesFromConfigSpecs: () => getFileNamesFromConfigSpecs, getFileWatcherEventKind: () => getFileWatcherEventKind, getFilesInErrorForSummary: () => getFilesInErrorForSummary, getFirstConstructorWithBody: () => R4, getFirstIdentifier: () => iO, getFirstNonSpaceCharacterPosition: () => getFirstNonSpaceCharacterPosition, getFirstProjectOutput: () => getFirstProjectOutput, getFixableErrorSpanExpression: () => getFixableErrorSpanExpression, getFormatCodeSettingsForWriting: () => getFormatCodeSettingsForWriting, getFullWidth: () => hf, getFunctionFlags: () => sN, getHeritageClause: () => Pf, getHostSignatureFromJSDoc: () => C0, getIdentifierAutoGenerate: () => getIdentifierAutoGenerate, getIdentifierGeneratedImportReference: () => getIdentifierGeneratedImportReference, getIdentifierTypeArguments: () => getIdentifierTypeArguments, getImmediatelyInvokedFunctionExpression: () => Qk, getImpliedNodeFormatForFile: () => getImpliedNodeFormatForFile, getImpliedNodeFormatForFileWorker: () => getImpliedNodeFormatForFileWorker, getImportNeedsImportDefaultHelper: () => getImportNeedsImportDefaultHelper, getImportNeedsImportStarHelper: () => getImportNeedsImportStarHelper, getIndentSize: () => Oo, getIndentString: () => j0, getInitializedVariables: () => NO, getInitializerOfBinaryExpression: () => X3, getInitializerOfBindingOrAssignmentElement: () => AE, getInterfaceBaseTypeNodes: () => g4, getInternalEmitFlags: () => zD, getInvokedExpression: () => iI, getIsolatedModules: () => zf, getJSDocAugmentsTag: () => ES, getJSDocClassTag: () => NA, getJSDocCommentRanges: () => I3, getJSDocCommentsAndTags: () => r4, getJSDocDeprecatedTag: () => jA, getJSDocDeprecatedTagNoCache: () => IS, getJSDocEnumTag: () => JA, getJSDocHost: () => s4, getJSDocImplementsTags: () => wS, getJSDocOverrideTagNoCache: () => kS, getJSDocParameterTags: () => of, getJSDocParameterTagsNoCache: () => bS, getJSDocPrivateTag: () => MA, getJSDocPrivateTagNoCache: () => AS, getJSDocProtectedTag: () => LA, getJSDocProtectedTagNoCache: () => PS, getJSDocPublicTag: () => OA, getJSDocPublicTagNoCache: () => CS, getJSDocReadonlyTag: () => RA, getJSDocReadonlyTagNoCache: () => DS, getJSDocReturnTag: () => NS, getJSDocReturnType: () => OS, getJSDocRoot: () => P0, getJSDocSatisfiesExpressionType: () => NL, getJSDocSatisfiesTag: () => wy, getJSDocTags: () => hl, getJSDocTagsNoCache: () => qA, getJSDocTemplateTag: () => BA, getJSDocThisTag: () => FA, getJSDocType: () => cf, getJSDocTypeAliasName: () => w2, getJSDocTypeAssertionType: () => Wj, getJSDocTypeParameterDeclarations: () => F4, getJSDocTypeParameterTags: () => SS, getJSDocTypeParameterTagsNoCache: () => xS, getJSDocTypeTag: () => _f, getJSXImplicitImportBase: () => IM, getJSXRuntimeImport: () => NM, getJSXTransformEnabled: () => kM, getKeyForCompilerOptions: () => getKeyForCompilerOptions, getLanguageVariant: () => sv, getLastChild: () => mx, getLeadingCommentRanges: () => Ao, getLeadingCommentRangesOfNode: () => Ck, getLeftmostAccessExpression: () => rv, getLeftmostExpression: () => ZO, getLineAndCharacterOfPosition: () => Ls, getLineInfo: () => getLineInfo, getLineOfLocalPosition: () => FN, getLineOfLocalPositionFromLineMap: () => ds, getLineStartPositionForPosition: () => getLineStartPositionForPosition, getLineStarts: () => ss, getLinesBetweenPositionAndNextNonWhitespaceCharacter: () => DO, getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter: () => PO, getLinesBetweenPositions: () => I_, getLinesBetweenRangeEndAndRangeStart: () => wO, getLinesBetweenRangeEndPositions: () => CO, getLiteralText: () => WD, getLocalNameForExternalImport: () => Kj, getLocalSymbolForExportDefault: () => cO, getLocaleSpecificMessage: () => Y_, getLocaleTimeString: () => getLocaleTimeString, getMappedContextSpan: () => getMappedContextSpan, getMappedDocumentSpan: () => getMappedDocumentSpan, getMappedLocation: () => getMappedLocation, getMatchedFileSpec: () => getMatchedFileSpec, getMatchedIncludeSpec: () => getMatchedIncludeSpec, getMeaningFromDeclaration: () => getMeaningFromDeclaration, getMeaningFromLocation: () => getMeaningFromLocation, getMembersOfDeclaration: () => Ik, getModeForFileReference: () => getModeForFileReference, getModeForResolutionAtIndex: () => getModeForResolutionAtIndex, getModeForUsageLocation: () => getModeForUsageLocation, getModifiedTime: () => getModifiedTime, getModifiers: () => sf, getModuleInstanceState: () => getModuleInstanceState, getModuleNameStringLiteralAt: () => getModuleNameStringLiteralAt, getModuleSpecifierEndingPreference: () => VM, getModuleSpecifierResolverHost: () => getModuleSpecifierResolverHost, getNameForExportedSymbol: () => getNameForExportedSymbol, getNameFromIndexInfo: () => _k, getNameFromPropertyName: () => getNameFromPropertyName, getNameOfAccessExpression: () => KO, getNameOfCompilerOptionValue: () => getNameOfCompilerOptionValue, getNameOfDeclaration: () => ml, getNameOfExpando: () => xI, getNameOfJSDocTypedef: () => gS, getNameOrArgument: () => $3, getNameTable: () => uB, getNamesForExportedSymbol: () => getNamesForExportedSymbol, getNamespaceDeclarationNode: () => Q3, getNewLineCharacter: () => ox, getNewLineKind: () => getNewLineKind, getNewLineOrDefaultFromHost: () => getNewLineOrDefaultFromHost, getNewTargetContainer: () => Xk, getNextJSDocCommentLocation: () => a4, getNodeForGeneratedName: () => NJ, getNodeId: () => getNodeId, getNodeKind: () => getNodeKind, getNodeModifiers: () => getNodeModifiers, getNodeModulePathParts: () => wL, getNonAssignedNameOfDeclaration: () => Ey, getNonAssignmentOperatorForCompoundAssignment: () => getNonAssignmentOperatorForCompoundAssignment, getNonAugmentationDeclaration: () => E3, getNonDecoratorTokenPosOfNode: () => FD, getNormalizedAbsolutePath: () => as, getNormalizedAbsolutePathWithoutRoot: () => Q5, getNormalizedPathComponents: () => $p, getObjectFlags: () => Bf, getOperator: () => R0, getOperatorAssociativity: () => x4, getOperatorPrecedence: () => E4, getOptionFromName: () => getOptionFromName, getOptionsNameMap: () => getOptionsNameMap, getOrCreateEmitNode: () => getOrCreateEmitNode, getOrCreateExternalHelpersModuleNameIfNeeded: () => wE, getOrUpdate: () => la, getOriginalNode: () => ul, getOriginalNodeId: () => getOriginalNodeId, getOriginalSourceFile: () => gN, getOutputDeclarationFileName: () => getOutputDeclarationFileName, getOutputExtension: () => getOutputExtension, getOutputFileNames: () => getOutputFileNames, getOutputPathsFor: () => getOutputPathsFor, getOutputPathsForBundle: () => getOutputPathsForBundle, getOwnEmitOutputFilePath: () => NN, getOwnKeys: () => ho, getOwnValues: () => go, getPackageJsonInfo: () => getPackageJsonInfo, getPackageJsonTypesVersionsPaths: () => getPackageJsonTypesVersionsPaths, getPackageJsonsVisibleToFile: () => getPackageJsonsVisibleToFile, getPackageNameFromTypesPackageName: () => getPackageNameFromTypesPackageName, getPackageScopeForPath: () => getPackageScopeForPath, getParameterSymbolFromJSDoc: () => JI, getParameterTypeNode: () => CL, getParentNodeInSpan: () => getParentNodeInSpan, getParseTreeNode: () => fl, getParsedCommandLineOfConfigFile: () => getParsedCommandLineOfConfigFile, getPathComponents: () => qi, getPathComponentsRelativeTo: () => ly, getPathFromPathComponents: () => xo, getPathUpdater: () => getPathUpdater, getPathsBasePath: () => LN, getPatternFromSpec: () => BM, getPendingEmitKind: () => getPendingEmitKind, getPositionOfLineAndCharacter: () => lA, getPossibleGenericSignatures: () => getPossibleGenericSignatures, getPossibleOriginalInputExtensionForExtension: () => MN, getPossibleTypeArgumentsInfo: () => getPossibleTypeArgumentsInfo, getPreEmitDiagnostics: () => getPreEmitDiagnostics, getPrecedingNonSpaceCharacterPosition: () => getPrecedingNonSpaceCharacterPosition, getPrivateIdentifier: () => getPrivateIdentifier, getProperties: () => getProperties, getProperty: () => Qc, getPropertyArrayElementValue: () => qk, getPropertyAssignment: () => f0, getPropertyAssignmentAliasLikeExpression: () => ZI, getPropertyNameForPropertyNameNode: () => Df, getPropertyNameForUniqueESSymbol: () => _N, getPropertyNameOfBindingOrAssignmentElement: () => eJ, getPropertySymbolFromBindingElement: () => getPropertySymbolFromBindingElement, getPropertySymbolsFromContextualType: () => x7, getQuoteFromPreference: () => getQuoteFromPreference, getQuotePreference: () => getQuotePreference, getRangesWhere: () => Et, getRefactorContextSpan: () => getRefactorContextSpan, getReferencedFileLocation: () => getReferencedFileLocation, getRegexFromPattern: () => Vf, getRegularExpressionForWildcard: () => Wf, getRegularExpressionsForWildcards: () => pv, getRelativePathFromDirectory: () => JT, getRelativePathFromFile: () => iA, getRelativePathToDirectoryOrUrl: () => uy, getRenameLocation: () => getRenameLocation, getReplacementSpanForContextToken: () => getReplacementSpanForContextToken, getResolutionDiagnostic: () => getResolutionDiagnostic, getResolutionModeOverrideForClause: () => getResolutionModeOverrideForClause, getResolveJsonModule: () => Cx, getResolvePackageJsonExports: () => SM, getResolvePackageJsonImports: () => xM, getResolvedExternalModuleName: () => k4, getResolvedModule: () => hD, getResolvedTypeReferenceDirective: () => vD, getRestIndicatorOfBindingOrAssignmentElement: () => Zj, getRestParameterElementType: () => kk, getRightMostAssignedExpression: () => b0, getRootDeclaration: () => If, getRootLength: () => Bi, getScriptKind: () => getScriptKind, getScriptKindFromFileName: () => Ox, getScriptTargetFeatures: () => getScriptTargetFeatures, getSelectedEffectiveModifierFlags: () => G4, getSelectedSyntacticModifierFlags: () => $4, getSemanticClassifications: () => getSemanticClassifications, getSemanticJsxChildren: () => bN, getSetAccessorTypeAnnotationNode: () => BN, getSetAccessorValueParameter: () => z0, getSetExternalModuleIndicator: () => Ex, getShebang: () => GT, getSingleInitializerOfVariableStatementOrPropertyDeclaration: () => w0, getSingleVariableOfVariableStatement: () => Al, getSnapshotText: () => getSnapshotText, getSnippetElement: () => getSnippetElement, getSourceFileOfModule: () => AD, getSourceFileOfNode: () => Si, getSourceFilePathInNewDir: () => M4, getSourceFilePathInNewDirWorker: () => U0, getSourceFileVersionAsHashFromText: () => getSourceFileVersionAsHashFromText, getSourceFilesToEmit: () => RN, getSourceMapRange: () => getSourceMapRange, getSourceMapper: () => getSourceMapper, getSourceTextOfNodeFromSourceFile: () => No, getSpanOfTokenAtPosition: () => n0, getSpellingSuggestion: () => Ep, getStartPositionOfLine: () => kD, getStartPositionOfRange: () => K_, getStartsOnNewLine: () => getStartsOnNewLine, getStaticPropertiesAndClassStaticBlock: () => getStaticPropertiesAndClassStaticBlock, getStrictOptionValue: () => lv, getStringComparer: () => rl, getSuperCallFromStatement: () => getSuperCallFromStatement, getSuperContainer: () => Yk, getSupportedCodeFixes: () => v7, getSupportedExtensions: () => Mx, getSupportedExtensionsWithJsonIfResolveJsonModule: () => Lx, getSwitchedType: () => getSwitchedType, getSymbolId: () => getSymbolId, getSymbolNameForPrivateIdentifier: () => cN, getSymbolTarget: () => getSymbolTarget, getSyntacticClassifications: () => getSyntacticClassifications, getSyntacticModifierFlags: () => X0, getSyntacticModifierFlagsNoCache: () => Y0, getSynthesizedDeepClone: () => getSynthesizedDeepClone, getSynthesizedDeepCloneWithReplacements: () => getSynthesizedDeepCloneWithReplacements, getSynthesizedDeepClones: () => getSynthesizedDeepClones, getSynthesizedDeepClonesWithReplacements: () => getSynthesizedDeepClonesWithReplacements, getSyntheticLeadingComments: () => getSyntheticLeadingComments, getSyntheticTrailingComments: () => getSyntheticTrailingComments, getTargetLabel: () => getTargetLabel, getTargetOfBindingOrAssignmentElement: () => Ko, getTemporaryModuleResolutionState: () => getTemporaryModuleResolutionState, getTextOfConstantValue: () => HD, getTextOfIdentifierOrLiteral: () => kf, getTextOfJSDocComment: () => zA, getTextOfNode: () => gf, getTextOfNodeFromSourceText: () => B_, getTextOfPropertyName: () => lk, getThisContainer: () => d0, getThisParameter: () => j4, getTokenAtPosition: () => getTokenAtPosition, getTokenPosOfNode: () => Io, getTokenSourceMapRange: () => getTokenSourceMapRange, getTouchingPropertyName: () => getTouchingPropertyName, getTouchingToken: () => getTouchingToken, getTrailingCommentRanges: () => HT, getTrailingSemicolonDeferringWriter: () => kN, getTransformFlagsSubtreeExclusions: () => w8, getTransformers: () => getTransformers, getTsBuildInfoEmitOutputFilePath: () => getTsBuildInfoEmitOutputFilePath, getTsConfigObjectLiteralExpression: () => M3, getTsConfigPropArray: () => L3, getTsConfigPropArrayElementValue: () => Uk, getTypeAnnotationNode: () => UN, getTypeArgumentOrTypeParameterList: () => getTypeArgumentOrTypeParameterList, getTypeKeywordOfTypeOnlyImport: () => getTypeKeywordOfTypeOnlyImport, getTypeNode: () => getTypeNode, getTypeNodeIfAccessible: () => getTypeNodeIfAccessible, getTypeParameterFromJsDoc: () => BI, getTypeParameterOwner: () => AA, getTypesPackageName: () => getTypesPackageName, getUILocale: () => M1, getUniqueName: () => getUniqueName, getUniqueSymbolId: () => getUniqueSymbolId, getUseDefineForClassFields: () => CM, getWatchErrorSummaryDiagnosticMessage: () => getWatchErrorSummaryDiagnosticMessage, getWatchFactory: () => getWatchFactory, group: () => el, groupBy: () => x_, guessIndentation: () => rD, handleNoEmitOptions: () => handleNoEmitOptions, hasAbstractModifier: () => W4, hasAccessorModifier: () => H4, hasAmbientModifier: () => V4, hasChangesInResolutions: () => wD, hasChildOfKind: () => hasChildOfKind, hasContextSensitiveParameters: () => vL, hasDecorators: () => Il, hasDocComment: () => hasDocComment, hasDynamicName: () => v4, hasEffectiveModifier: () => H0, hasEffectiveModifiers: () => XN, hasEffectiveReadonlyModifier: () => $0, hasExtension: () => OT, hasIndexSignature: () => hasIndexSignature, hasInitializer: () => l3, hasInvalidEscape: () => w4, hasJSDocNodes: () => ya, hasJSDocParameterTags: () => IA, hasJSFileExtension: () => dv, hasJsonModuleEmitEnabled: () => hM, hasOnlyExpressionInitializer: () => eD, hasOverrideModifier: () => QN, hasPossibleExternalModuleReference: () => sk, hasProperty: () => Jr, hasPropertyAccessExpressionWithName: () => hasPropertyAccessExpressionWithName, hasQuestionToken: () => OI, hasRecordedExternalHelpers: () => Gj, hasRestParameter: () => nD, hasScopeMarker: () => kP, hasStaticModifier: () => Lf, hasSyntacticModifier: () => rn, hasSyntacticModifiers: () => YN, hasTSFileExtension: () => mv, hasTabstop: () => Qx, hasTrailingDirectorySeparator: () => Hp, hasType: () => ZP, hasTypeArguments: () => qI, hasZeroOrOneAsteriskCharacter: () => OM, helperString: () => helperString, hostGetCanonicalFileName: () => D4, hostUsesCaseSensitiveFileNames: () => J0, idText: () => qr2, identifierIsThisKeyword: () => J4, identifierToKeywordKind: () => dS, identity: () => rr2, identitySourceMapConsumer: () => identitySourceMapConsumer, ignoreSourceNewlines: () => ignoreSourceNewlines, ignoredPaths: () => ignoredPaths, importDefaultHelper: () => importDefaultHelper, importFromModuleSpecifier: () => II, importNameElisionDisabled: () => gM, importStarHelper: () => importStarHelper, indexOfAnyCharCode: () => Je2, indexOfNode: () => UD, indicesOf: () => Wr2, inferredTypesContainingFile: () => inferredTypesContainingFile, insertImports: () => insertImports, insertLeadingStatement: () => Mj, insertSorted: () => Qn, insertStatementAfterCustomPrologue: () => RD, insertStatementAfterStandardPrologue: () => LD, insertStatementsAfterCustomPrologue: () => MD, insertStatementsAfterStandardPrologue: () => OD, intersperse: () => Ie2, introducesArgumentsExoticObject: () => Lk, inverseJsxOptionMap: () => inverseJsxOptionMap, isAbstractConstructorSymbol: () => zO, isAbstractModifier: () => uR, isAccessExpression: () => Lo, isAccessibilityModifier: () => isAccessibilityModifier, isAccessor: () => pf, isAccessorModifier: () => fR, isAliasSymbolDeclaration: () => QI, isAliasableExpression: () => k0, isAmbientModule: () => yf, isAmbientPropertyDeclaration: () => rk, isAnonymousFunctionDefinition: () => H_, isAnyDirectorySeparator: () => ay, isAnyImportOrBareOrAccessedRequire: () => ik, isAnyImportOrReExport: () => bf, isAnyImportSyntax: () => Qy, isAnySupportedFileExtension: () => ZM, isApplicableVersionedTypesKey: () => isApplicableVersionedTypesKey, isArgumentExpressionOfElementAccess: () => isArgumentExpressionOfElementAccess, isArray: () => ir2, isArrayBindingElement: () => gP, isArrayBindingOrAssignmentElement: () => ZS, isArrayBindingOrAssignmentPattern: () => QS, isArrayBindingPattern: () => yR, isArrayLiteralExpression: () => Yl, isArrayLiteralOrObjectLiteralDestructuringPattern: () => isArrayLiteralOrObjectLiteralDestructuringPattern, isArrayTypeNode: () => F8, isArrowFunction: () => sd, isAsExpression: () => CR, isAssertClause: () => $R, isAssertEntry: () => KR, isAssertionExpression: () => PP, isAssertionKey: () => oP, isAssertsKeyword: () => _R, isAssignmentDeclaration: () => v0, isAssignmentExpression: () => ms, isAssignmentOperator: () => G_, isAssignmentPattern: () => KS, isAssignmentTarget: () => UI, isAsteriskToken: () => nR, isAsyncFunction: () => oN, isAsyncModifier: () => Ul, isAutoAccessorPropertyDeclaration: () => $S, isAwaitExpression: () => SR, isAwaitKeyword: () => cR, isBigIntLiteral: () => Uv, isBinaryExpression: () => ur2, isBinaryOperatorToken: () => AJ, isBindableObjectDefinePropertyCall: () => S0, isBindableStaticAccessExpression: () => W_, isBindableStaticElementAccessExpression: () => x0, isBindableStaticNameExpression: () => V_, isBindingElement: () => Xl, isBindingElementOfBareOrAccessedRequire: () => mI, isBindingName: () => uP, isBindingOrAssignmentElement: () => yP, isBindingOrAssignmentPattern: () => vP, isBindingPattern: () => df, isBlock: () => Ql, isBlockOrCatchScoped: () => $D, isBlockScope: () => w3, isBlockScopedContainerTopLevel: () => ZD, isBooleanLiteral: () => pP, isBreakOrContinueStatement: () => YA, isBreakStatement: () => JR, isBuildInfoFile: () => isBuildInfoFile, isBuilderProgram: () => isBuilderProgram2, isBundle: () => cj, isBundleFileTextLike: () => XO, isCallChain: () => Cy, isCallExpression: () => sc, isCallExpressionTarget: () => isCallExpressionTarget, isCallLikeExpression: () => SP, isCallOrNewExpression: () => xP, isCallOrNewExpressionTarget: () => isCallOrNewExpressionTarget, isCallSignatureDeclaration: () => Vv, isCallToHelper: () => isCallToHelper, isCaseBlock: () => VR, isCaseClause: () => sj, isCaseKeyword: () => dR, isCaseOrDefaultClause: () => QP, isCatchClause: () => oj, isCatchClauseVariableDeclaration: () => Gx, isCatchClauseVariableDeclarationOrBindingElement: () => T3, isCheckJsEnabledForFile: () => eL, isChildOfNodeWithKind: () => Ak, isCircularBuildOrder: () => isCircularBuildOrder, isClassDeclaration: () => _c, isClassElement: () => Js, isClassExpression: () => _d, isClassLike: () => bi, isClassMemberModifier: () => VS, isClassOrTypeElement: () => mP, isClassStaticBlockDeclaration: () => Hl, isCollapsedRange: () => vO, isColonToken: () => iR, isCommaExpression: () => gd, isCommaListExpression: () => oc, isCommaSequence: () => zj, isCommaToken: () => I8, isComment: () => isComment, isCommonJsExportPropertyAssignment: () => p0, isCommonJsExportedExpression: () => Ok, isCompoundAssignment: () => isCompoundAssignment, isComputedNonLiteralName: () => ck, isComputedPropertyName: () => Ws, isConciseBody: () => MP, isConditionalExpression: () => xR, isConditionalTypeNode: () => V8, isConstTypeReference: () => jS, isConstructSignatureDeclaration: () => R8, isConstructorDeclaration: () => nc, isConstructorTypeNode: () => Gv, isContextualKeyword: () => N0, isContinueStatement: () => jR, isCustomPrologue: () => Tf, isDebuggerStatement: () => WR, isDeclaration: () => ko, isDeclarationBindingElement: () => Fy, isDeclarationFileName: () => QE, isDeclarationName: () => c4, isDeclarationNameOfEnumOrNamespace: () => IO, isDeclarationReadonly: () => Sk, isDeclarationStatement: () => VP, isDeclarationWithTypeParameterChildren: () => C3, isDeclarationWithTypeParameters: () => nk, isDecorator: () => zl, isDecoratorTarget: () => isDecoratorTarget, isDefaultClause: () => oE, isDefaultImport: () => Z3, isDefaultModifier: () => oR, isDefaultedExpandoInitializer: () => SI, isDeleteExpression: () => bR, isDeleteTarget: () => $I, isDeprecatedDeclaration: () => isDeprecatedDeclaration, isDestructuringAssignment: () => nO, isDiagnosticWithLocation: () => isDiagnosticWithLocation, isDiskPathRoot: () => H5, isDoStatement: () => OR, isDotDotDotToken: () => rR, isDottedName: () => ev, isDynamicName: () => M0, isESSymbolIdentifier: () => pN, isEffectiveExternalModule: () => Yy, isEffectiveModuleDeclaration: () => S3, isEffectiveStrictModeSourceFile: () => tk, isElementAccessChain: () => RS, isElementAccessExpression: () => gs, isEmittedFileOfProgram: () => isEmittedFileOfProgram, isEmptyArrayLiteral: () => _O, isEmptyBindingElement: () => pS, isEmptyBindingPattern: () => uS, isEmptyObjectLiteral: () => oO, isEmptyStatement: () => IR, isEmptyStringLiteral: () => j3, isEndOfDeclarationMarker: () => ej, isEntityName: () => lP, isEntityNameExpression: () => Bs, isEnumConst: () => Tk, isEnumDeclaration: () => i22, isEnumMember: () => cE, isEqualityOperatorKind: () => isEqualityOperatorKind, isEqualsGreaterThanToken: () => sR, isExclamationToken: () => rd, isExcludedFile: () => isExcludedFile, isExclusivelyTypeOnlyImportOrExport: () => isExclusivelyTypeOnlyImportOrExport, isExportAssignment: () => Vo, isExportDeclaration: () => cc, isExportModifier: () => N8, isExportName: () => Uj, isExportNamespaceAsDefaultDeclaration: () => b3, isExportOrDefaultModifier: () => DJ, isExportSpecifier: () => aE, isExportsIdentifier: () => H3, isExportsOrModuleExportsOrAlias: () => isExportsOrModuleExportsOrAlias, isExpression: () => mf, isExpressionNode: () => g0, isExpressionOfExternalModuleImportEqualsDeclaration: () => isExpressionOfExternalModuleImportEqualsDeclaration, isExpressionOfOptionalChainRoot: () => $A, isExpressionStatement: () => Zl, isExpressionWithTypeArguments: () => e2, isExpressionWithTypeArgumentsInClassExtendsClause: () => Z0, isExternalModule: () => Qo, isExternalModuleAugmentation: () => Xy, isExternalModuleImportEqualsDeclaration: () => B3, isExternalModuleIndicator: () => NP, isExternalModuleNameRelative: () => gA, isExternalModuleReference: () => ud, isExternalModuleSymbol: () => isExternalModuleSymbol, isExternalOrCommonJsModule: () => bk, isFileLevelUniqueName: () => m3, isFileProbablyExternalModule: () => ou, isFirstDeclarationOfSymbolParameter: () => isFirstDeclarationOfSymbolParameter, isFixablePromiseHandler: () => isFixablePromiseHandler, isForInOrOfStatement: () => OP, isForInStatement: () => LR, isForInitializer: () => RP, isForOfStatement: () => RR, isForStatement: () => eE, isFunctionBlock: () => O3, isFunctionBody: () => LP, isFunctionDeclaration: () => Wo, isFunctionExpression: () => ad, isFunctionExpressionOrArrowFunction: () => SL, isFunctionLike: () => ga, isFunctionLikeDeclaration: () => HS, isFunctionLikeKind: () => My, isFunctionLikeOrClassStaticBlockDeclaration: () => uf, isFunctionOrConstructorTypeNode: () => hP, isFunctionOrModuleBlock: () => fP, isFunctionSymbol: () => DI, isFunctionTypeNode: () => $l, isFutureReservedKeyword: () => tN, isGeneratedIdentifier: () => cs, isGeneratedPrivateIdentifier: () => Ny, isGetAccessor: () => Tl, isGetAccessorDeclaration: () => Gl, isGetOrSetAccessorDeclaration: () => GA, isGlobalDeclaration: () => isGlobalDeclaration, isGlobalScopeAugmentation: () => vf, isGrammarError: () => ND, isHeritageClause: () => ru, isHoistedFunction: () => _0, isHoistedVariableStatement: () => c0, isIdentifier: () => yt, isIdentifierANonContextualKeyword: () => iN, isIdentifierName: () => YI, isIdentifierOrThisTypeNode: () => aJ, isIdentifierPart: () => Rs, isIdentifierStart: () => Wn, isIdentifierText: () => vy, isIdentifierTypePredicate: () => Fk, isIdentifierTypeReference: () => pL, isIfStatement: () => NR, isIgnoredFileFromWildCardWatching: () => isIgnoredFileFromWildCardWatching, isImplicitGlob: () => Dx, isImportCall: () => s0, isImportClause: () => HR, isImportDeclaration: () => o2, isImportEqualsDeclaration: () => s2, isImportKeyword: () => M8, isImportMeta: () => o0, isImportOrExportSpecifier: () => aP, isImportOrExportSpecifierName: () => isImportOrExportSpecifierName, isImportSpecifier: () => nE, isImportTypeAssertionContainer: () => GR, isImportTypeNode: () => Kl, isImportableFile: () => isImportableFile, isInComment: () => isInComment, isInExpressionContext: () => J32, isInJSDoc: () => q3, isInJSFile: () => Pr, isInJSXText: () => isInJSXText, isInJsonFile: () => pI, isInNonReferenceComment: () => isInNonReferenceComment, isInReferenceComment: () => isInReferenceComment, isInRightSideOfInternalImportEqualsDeclaration: () => isInRightSideOfInternalImportEqualsDeclaration, isInString: () => isInString, isInTemplateString: () => isInTemplateString, isInTopLevelContext: () => Kk, isIncrementalCompilation: () => wM, isIndexSignatureDeclaration: () => Hv, isIndexedAccessTypeNode: () => $8, isInferTypeNode: () => H8, isInfinityOrNaNString: () => bL, isInitializedProperty: () => isInitializedProperty, isInitializedVariable: () => lx, isInsideJsxElement: () => isInsideJsxElement, isInsideJsxElementOrAttribute: () => isInsideJsxElementOrAttribute, isInsideNodeModules: () => isInsideNodeModules, isInsideTemplateLiteral: () => isInsideTemplateLiteral, isInstantiatedModule: () => isInstantiatedModule, isInterfaceDeclaration: () => eu, isInternalDeclaration: () => isInternalDeclaration, isInternalModuleImportEqualsDeclaration: () => lI, isInternalName: () => qj, isIntersectionTypeNode: () => W8, isIntrinsicJsxName: () => P4, isIterationStatement: () => n3, isJSDoc: () => Ho, isJSDocAllType: () => dj, isJSDocAugmentsTag: () => md, isJSDocAuthorTag: () => bj, isJSDocCallbackTag: () => Tj, isJSDocClassTag: () => pE, isJSDocCommentContainingNode: () => c3, isJSDocConstructSignature: () => MI, isJSDocDeprecatedTag: () => v22, isJSDocEnumTag: () => dE, isJSDocFunctionType: () => dd, isJSDocImplementsTag: () => hE, isJSDocIndexSignature: () => dI, isJSDocLikeText: () => LE, isJSDocLink: () => uj, isJSDocLinkCode: () => pj, isJSDocLinkLike: () => Sl, isJSDocLinkPlain: () => fj, isJSDocMemberName: () => uc, isJSDocNameReference: () => fd, isJSDocNamepathType: () => vj, isJSDocNamespaceBody: () => FP, isJSDocNode: () => Uy, isJSDocNonNullableType: () => hj, isJSDocNullableType: () => uE, isJSDocOptionalParameter: () => Zx, isJSDocOptionalType: () => gj, isJSDocOverloadTag: () => y2, isJSDocOverrideTag: () => fE, isJSDocParameterTag: () => pc, isJSDocPrivateTag: () => m2, isJSDocPropertyLikeTag: () => Dy, isJSDocPropertyTag: () => wj, isJSDocProtectedTag: () => h2, isJSDocPublicTag: () => d22, isJSDocReadonlyTag: () => g2, isJSDocReturnTag: () => b2, isJSDocSatisfiesExpression: () => IL, isJSDocSatisfiesTag: () => T2, isJSDocSeeTag: () => Sj, isJSDocSignature: () => iu, isJSDocTag: () => zy, isJSDocTemplateTag: () => Go, isJSDocThisTag: () => mE, isJSDocThrowsTag: () => Cj, isJSDocTypeAlias: () => Cl, isJSDocTypeAssertion: () => xE, isJSDocTypeExpression: () => lE, isJSDocTypeLiteral: () => f2, isJSDocTypeTag: () => au, isJSDocTypedefTag: () => xj, isJSDocUnknownTag: () => Ej, isJSDocUnknownType: () => mj, isJSDocVariadicType: () => yj, isJSXTagName: () => xf, isJsonEqual: () => gv, isJsonSourceFile: () => a0, isJsxAttribute: () => nj, isJsxAttributeLike: () => XP, isJsxAttributes: () => p2, isJsxChild: () => o3, isJsxClosingElement: () => sE, isJsxClosingFragment: () => rj, isJsxElement: () => l2, isJsxExpression: () => aj, isJsxFragment: () => pd, isJsxOpeningElement: () => tu, isJsxOpeningFragment: () => u2, isJsxOpeningLikeElement: () => _3, isJsxOpeningLikeElementTagName: () => isJsxOpeningLikeElementTagName, isJsxSelfClosingElement: () => tj, isJsxSpreadAttribute: () => ij, isJsxTagNameExpression: () => KP, isJsxText: () => td, isJumpStatementTarget: () => isJumpStatementTarget, isKeyword: () => ba, isKnownSymbol: () => lN, isLabelName: () => isLabelName, isLabelOfLabeledStatement: () => isLabelOfLabeledStatement, isLabeledStatement: () => tE, isLateVisibilityPaintedStatement: () => ak, isLeftHandSideExpression: () => Do, isLeftHandSideOfAssignment: () => rO, isLet: () => xk, isLineBreak: () => un, isLiteralComputedPropertyDeclarationName: () => l4, isLiteralExpression: () => Iy, isLiteralExpressionOfObject: () => rP, isLiteralImportTypeNode: () => k3, isLiteralKind: () => ky, isLiteralLikeAccess: () => wf, isLiteralLikeElementAccess: () => wl, isLiteralNameOfPropertyDeclarationOrIndexAccess: () => isLiteralNameOfPropertyDeclarationOrIndexAccess, isLiteralTypeLikeExpression: () => cJ, isLiteralTypeLiteral: () => CP, isLiteralTypeNode: () => Yv, isLocalName: () => E2, isLogicalOperator: () => ZN, isLogicalOrCoalescingAssignmentExpression: () => eO, isLogicalOrCoalescingAssignmentOperator: () => jf, isLogicalOrCoalescingBinaryExpression: () => tO, isLogicalOrCoalescingBinaryOperator: () => Z4, isMappedTypeNode: () => K8, isMemberName: () => js, isMergeDeclarationMarker: () => ZR, isMetaProperty: () => t2, isMethodDeclaration: () => Vl, isMethodOrAccessor: () => Ly, isMethodSignature: () => L8, isMinusToken: () => Wv, isMissingDeclaration: () => YR, isModifier: () => Oy, isModifierKind: () => Wi, isModifierLike: () => ff, isModuleAugmentationExternal: () => x3, isModuleBlock: () => rE, isModuleBody: () => jP, isModuleDeclaration: () => Ea, isModuleExportsAccessExpression: () => T0, isModuleIdentifier: () => G3, isModuleName: () => _J, isModuleOrEnumDeclaration: () => qP, isModuleReference: () => $P, isModuleSpecifierLike: () => isModuleSpecifierLike, isModuleWithStringLiteralName: () => KD, isNameOfFunctionDeclaration: () => isNameOfFunctionDeclaration, isNameOfModuleDeclaration: () => isNameOfModuleDeclaration, isNamedClassElement: () => dP, isNamedDeclaration: () => af, isNamedEvaluation: () => fN, isNamedEvaluationSource: () => S4, isNamedExportBindings: () => QA, isNamedExports: () => iE, isNamedImportBindings: () => BP, isNamedImports: () => XR, isNamedImportsOrExports: () => YO, isNamedTupleMember: () => $v, isNamespaceBody: () => JP, isNamespaceExport: () => ld, isNamespaceExportDeclaration: () => a2, isNamespaceImport: () => _2, isNamespaceReexportDeclaration: () => oI, isNewExpression: () => X8, isNewExpressionTarget: () => isNewExpressionTarget, isNightly: () => PN, isNoSubstitutionTemplateLiteral: () => k8, isNode: () => eP, isNodeArray: () => _s, isNodeArrayMultiLine: () => AO, isNodeDescendantOf: () => KI, isNodeKind: () => gl, isNodeLikeSystem: () => M5, isNodeModulesDirectory: () => aA, isNodeWithPossibleHoistedDeclaration: () => zI, isNonContextualKeyword: () => y4, isNonExportDefaultModifier: () => kJ, isNonGlobalAmbientModule: () => XD, isNonGlobalDeclaration: () => isNonGlobalDeclaration, isNonNullAccess: () => kL, isNonNullChain: () => JS, isNonNullExpression: () => Uo, isNonStaticMethodOrAccessorWithPrivateName: () => isNonStaticMethodOrAccessorWithPrivateName, isNotEmittedOrPartiallyEmittedNode: () => DP, isNotEmittedStatement: () => c2, isNullishCoalesce: () => XA, isNumber: () => gi, isNumericLiteral: () => zs, isNumericLiteralName: () => $x, isObjectBindingElementWithoutPropertyName: () => isObjectBindingElementWithoutPropertyName, isObjectBindingOrAssignmentElement: () => YS, isObjectBindingOrAssignmentPattern: () => XS, isObjectBindingPattern: () => gR, isObjectLiteralElement: () => Wy, isObjectLiteralElementLike: () => jy, isObjectLiteralExpression: () => Hs, isObjectLiteralMethod: () => jk, isObjectLiteralOrClassExpressionMethodOrAccessor: () => Jk, isObjectTypeDeclaration: () => $O, isOctalDigit: () => hy, isOmittedExpression: () => cd, isOptionalChain: () => Ay, isOptionalChainRoot: () => Py, isOptionalDeclaration: () => DL, isOptionalJSDocPropertyLikeTag: () => Yx, isOptionalTypeNode: () => q8, isOuterExpression: () => yd, isOutermostOptionalChain: () => KA, isOverrideModifier: () => pR, isPackedArrayLiteral: () => hL, isParameter: () => Vs, isParameterDeclaration: () => mN, isParameterOrCatchClauseVariable: () => TL, isParameterPropertyDeclaration: () => lS, isParameterPropertyModifier: () => WS, isParenthesizedExpression: () => qo, isParenthesizedTypeNode: () => Kv, isParseTreeNode: () => pl, isPartOfTypeNode: () => l0, isPartOfTypeQuery: () => F3, isPartiallyEmittedExpression: () => Z8, isPatternMatch: () => z1, isPinnedComment: () => v3, isPlainJsFile: () => PD, isPlusToken: () => zv, isPossiblyTypeArgumentPosition: () => isPossiblyTypeArgumentPosition, isPostfixUnaryExpression: () => Q8, isPrefixUnaryExpression: () => od, isPrivateIdentifier: () => vn, isPrivateIdentifierClassElementDeclaration: () => zS, isPrivateIdentifierPropertyAccessExpression: () => cP, isPrivateIdentifierSymbol: () => uN, isProgramBundleEmitBuildInfo: () => isProgramBundleEmitBuildInfo, isProgramUptoDate: () => isProgramUptoDate, isPrologueDirective: () => us, isPropertyAccessChain: () => LS, isPropertyAccessEntityNameExpression: () => rx, isPropertyAccessExpression: () => bn, isPropertyAccessOrQualifiedName: () => TP, isPropertyAccessOrQualifiedNameOrImportTypeNode: () => bP, isPropertyAssignment: () => lc, isPropertyDeclaration: () => Bo, isPropertyName: () => vl, isPropertyNameLiteral: () => L0, isPropertySignature: () => Wl, isProtoSetter: () => T4, isPrototypeAccess: () => Nl, isPrototypePropertyAssignment: () => CI, isPunctuation: () => isPunctuation, isPushOrUnshiftIdentifier: () => dN, isQualifiedName: () => rc, isQuestionDotToken: () => aR, isQuestionOrExclamationToken: () => iJ, isQuestionOrPlusOrMinusToken: () => oJ, isQuestionToken: () => ql, isRawSourceMap: () => isRawSourceMap, isReadonlyKeyword: () => O8, isReadonlyKeywordOrPlusOrMinusToken: () => sJ, isRecognizedTripleSlashComment: () => jD, isReferenceFileLocation: () => isReferenceFileLocation, isReferencedFile: () => isReferencedFile, isRegularExpressionLiteral: () => QL, isRequireCall: () => El, isRequireVariableStatement: () => W3, isRestParameter: () => u3, isRestTypeNode: () => U8, isReturnStatement: () => FR, isReturnStatementWithFixablePromiseHandler: () => isReturnStatementWithFixablePromiseHandler, isRightSideOfAccessExpression: () => nx, isRightSideOfPropertyAccess: () => isRightSideOfPropertyAccess, isRightSideOfQualifiedName: () => isRightSideOfQualifiedName, isRightSideOfQualifiedNameOrPropertyAccess: () => aO, isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName: () => sO, isRootedDiskPath: () => A_, isSameEntityName: () => z_, isSatisfiesExpression: () => AR, isScopeMarker: () => i3, isSemicolonClassElement: () => kR, isSetAccessor: () => bl, isSetAccessorDeclaration: () => ic, isShebangTrivia: () => gy, isShorthandAmbientModuleSymbol: () => YD, isShorthandPropertyAssignment: () => nu, isSignedNumericLiteral: () => O0, isSimpleCopiableExpression: () => isSimpleCopiableExpression, isSimpleInlineableExpression: () => isSimpleInlineableExpression, isSingleOrDoubleQuote: () => hI, isSourceFile: () => wi, isSourceFileFromLibrary: () => isSourceFileFromLibrary, isSourceFileJS: () => y0, isSourceFileNotJS: () => uI, isSourceFileNotJson: () => fI, isSourceMapping: () => isSourceMapping, isSpecialPropertyDeclaration: () => AI, isSpreadAssignment: () => _E, isSpreadElement: () => Zv, isStatement: () => a3, isStatementButNotDeclaration: () => HP, isStatementOrBlock: () => s3, isStatementWithLocals: () => DD, isStatic: () => G0, isStaticModifier: () => lR, isString: () => Ji, isStringAKeyword: () => nN, isStringANonContextualKeyword: () => rN, isStringAndEmptyAnonymousObjectIntersection: () => isStringAndEmptyAnonymousObjectIntersection, isStringDoubleQuoted: () => gI, isStringLiteral: () => Gn, isStringLiteralLike: () => Ti, isStringLiteralOrJsxExpression: () => YP, isStringLiteralOrTemplate: () => isStringLiteralOrTemplate, isStringOrNumericLiteralLike: () => Ta, isStringOrRegularExpressionOrTemplateLiteral: () => isStringOrRegularExpressionOrTemplateLiteral, isStringTextContainingNode: () => _P, isSuperCall: () => Ek, isSuperKeyword: () => nd, isSuperOrSuperProperty: () => Zk, isSuperProperty: () => Sf, isSupportedSourceFileName: () => GM, isSwitchStatement: () => qR, isSyntaxList: () => Aj, isSyntheticExpression: () => PR, isSyntheticReference: () => QR, isTagName: () => isTagName, isTaggedTemplateExpression: () => Y8, isTaggedTemplateTag: () => isTaggedTemplateTag, isTemplateExpression: () => ER, isTemplateHead: () => ZL, isTemplateLiteral: () => EP, isTemplateLiteralKind: () => yl, isTemplateLiteralToken: () => nP, isTemplateLiteralTypeNode: () => hR, isTemplateLiteralTypeSpan: () => mR, isTemplateMiddle: () => eR, isTemplateMiddleOrTemplateTail: () => iP, isTemplateSpan: () => DR, isTemplateTail: () => tR, isTextWhiteSpaceLike: () => isTextWhiteSpaceLike, isThis: () => isThis, isThisContainerOrFunctionBlock: () => $k, isThisIdentifier: () => Mf, isThisInTypeQuery: () => qN, isThisInitializedDeclaration: () => tI, isThisInitializedObjectBindingExpression: () => rI, isThisProperty: () => eI, isThisTypeNode: () => Xv, isThisTypeParameter: () => Kx, isThisTypePredicate: () => Bk, isThrowStatement: () => UR, isToken: () => tP, isTokenKind: () => BS, isTraceEnabled: () => isTraceEnabled, isTransientSymbol: () => $y, isTrivia: () => aN, isTryStatement: () => zR, isTupleTypeNode: () => B8, isTypeAlias: () => LI, isTypeAliasDeclaration: () => n2, isTypeAssertionExpression: () => vR, isTypeDeclaration: () => Xx, isTypeElement: () => Ry, isTypeKeyword: () => isTypeKeyword, isTypeKeywordToken: () => isTypeKeywordToken, isTypeKeywordTokenOrIdentifier: () => isTypeKeywordTokenOrIdentifier, isTypeLiteralNode: () => id, isTypeNode: () => Jy, isTypeNodeKind: () => hx, isTypeOfExpression: () => TR, isTypeOnlyExportDeclaration: () => US, isTypeOnlyImportDeclaration: () => qS, isTypeOnlyImportOrExportDeclaration: () => sP, isTypeOperatorNode: () => G8, isTypeParameterDeclaration: () => Fo, isTypePredicateNode: () => j8, isTypeQueryNode: () => J8, isTypeReferenceNode: () => ac, isTypeReferenceType: () => tD, isUMDExportSymbol: () => VO, isUnaryExpression: () => t3, isUnaryExpressionWithWrite: () => wP, isUnicodeIdentifierStart: () => UT, isUnionTypeNode: () => z8, isUnparsedNode: () => ZA, isUnparsedPrepend: () => _j, isUnparsedSource: () => lj, isUnparsedTextLike: () => FS, isUrl: () => V5, isValidBigIntString: () => zx, isValidESSymbolDeclaration: () => Mk, isValidTypeOnlyAliasUseSite: () => _L, isValueSignatureDeclaration: () => WI, isVarConst: () => D3, isVariableDeclaration: () => Vi, isVariableDeclarationInVariableStatement: () => N3, isVariableDeclarationInitializedToBareOrAccessedRequire: () => Ef, isVariableDeclarationInitializedToRequire: () => U3, isVariableDeclarationList: () => r2, isVariableLike: () => u0, isVariableLikeOrAccessor: () => Nk, isVariableStatement: () => zo, isVoidExpression: () => Qv, isWatchSet: () => OO, isWhileStatement: () => MR, isWhiteSpaceLike: () => os, isWhiteSpaceSingleLine: () => N_, isWithStatement: () => BR, isWriteAccess: () => FO, isWriteOnlyAccess: () => JO, isYieldExpression: () => wR, jsxModeNeedsExplicitImport: () => jsxModeNeedsExplicitImport, keywordPart: () => keywordPart, last: () => Zn, lastOrUndefined: () => Cn, length: () => I, libMap: () => libMap, libs: () => libs, lineBreakPart: () => lineBreakPart, linkNamePart: () => linkNamePart, linkPart: () => linkPart, linkTextPart: () => linkTextPart, listFiles: () => listFiles, loadModuleFromGlobalCache: () => loadModuleFromGlobalCache, loadWithModeAwareCache: () => loadWithModeAwareCache, makeIdentifierFromModuleName: () => GD, makeImport: () => makeImport, makeImportIfNecessary: () => makeImportIfNecessary, makeStringLiteral: () => makeStringLiteral, mangleScopedPackageName: () => mangleScopedPackageName, map: () => Ze2, mapAllOrFail: () => Pt, mapDefined: () => qt, mapDefinedEntries: () => Ri, mapDefinedIterator: () => Zr2, mapEntries: () => be2, mapIterator: () => st2, mapOneOrMany: () => mapOneOrMany, mapToDisplayParts: () => mapToDisplayParts, matchFiles: () => qM, matchPatternOrExact: () => tL, matchedText: () => S5, matchesExclude: () => matchesExclude, maybeBind: () => le, maybeSetLocalizedDiagnosticMessages: () => vx, memoize: () => tl, memoizeCached: () => D1, memoizeOne: () => An, memoizeWeak: () => P1, metadataHelper: () => metadataHelper, min: () => N1, minAndMax: () => nL, missingFileModifiedTime: () => missingFileModifiedTime, modifierToFlag: () => Q0, modifiersToFlags: () => Vn, moduleOptionDeclaration: () => moduleOptionDeclaration, moduleResolutionIsEqualTo: () => TD, moduleResolutionNameAndModeGetter: () => moduleResolutionNameAndModeGetter, moduleResolutionOptionDeclarations: () => moduleResolutionOptionDeclarations, moduleResolutionSupportsPackageJsonExportsAndImports: () => _v, moduleResolutionUsesNodeModules: () => moduleResolutionUsesNodeModules, moduleSpecifiers: () => ts_moduleSpecifiers_exports, moveEmitHelpers: () => moveEmitHelpers, moveRangeEnd: () => gO, moveRangePastDecorators: () => _x, moveRangePastModifiers: () => yO, moveRangePos: () => Ff, moveSyntheticComments: () => moveSyntheticComments, mutateMap: () => UO, mutateMapSkippingNewValues: () => fx, needsParentheses: () => needsParentheses, needsScopeMarker: () => IP, newCaseClauseTracker: () => newCaseClauseTracker, newPrivateEnvironment: () => newPrivateEnvironment, noEmitNotification: () => noEmitNotification, noEmitSubstitution: () => noEmitSubstitution, noTransformers: () => noTransformers, noTruncationMaximumTruncationLength: () => n8, nodeCanBeDecorated: () => R3, nodeHasName: () => hS, nodeIsDecorated: () => q_, nodeIsMissing: () => va, nodeIsPresent: () => xl, nodeIsSynthesized: () => fs, nodeModuleNameResolver: () => nodeModuleNameResolver, nodeModulesPathPart: () => nodeModulesPathPart, nodeNextJsonConfigResolver: () => nodeNextJsonConfigResolver, nodeOrChildIsDecorated: () => m0, nodeOverlapsWithStartEnd: () => nodeOverlapsWithStartEnd, nodePosToString: () => ID, nodeSeenTracker: () => nodeSeenTracker, nodeStartsNewLexicalEnvironment: () => hN, nodeToDisplayParts: () => nodeToDisplayParts, noop: () => yn, noopFileWatcher: () => noopFileWatcher, noopPush: () => CT, normalizePath: () => Un, normalizeSlashes: () => Eo, not: () => w5, notImplemented: () => A1, notImplementedResolver: () => notImplementedResolver, nullNodeConverters: () => nullNodeConverters, nullParenthesizerRules: () => Jv, nullTransformationContext: () => nullTransformationContext, objectAllocator: () => lr2, operatorPart: () => operatorPart, optionDeclarations: () => optionDeclarations, optionMapToObject: () => optionMapToObject, optionsAffectingProgramStructure: () => optionsAffectingProgramStructure, optionsForBuild: () => optionsForBuild, optionsForWatch: () => optionsForWatch, optionsHaveChanges: () => J_, optionsHaveModuleResolutionChanges: () => p3, or: () => W1, orderedRemoveItem: () => J3, orderedRemoveItemAt: () => vT, outFile: () => B0, packageIdToPackageName: () => f3, packageIdToString: () => xD, padLeft: () => D5, padRight: () => k5, paramHelper: () => paramHelper, parameterIsThisKeyword: () => kl, parameterNamePart: () => parameterNamePart, parseBaseNodeFactory: () => I2, parseBigInt: () => oL, parseBuildCommand: () => parseBuildCommand, parseCommandLine: () => parseCommandLine, parseCommandLineWorker: () => parseCommandLineWorker, parseConfigFileTextToJson: () => parseConfigFileTextToJson, parseConfigFileWithSystem: () => parseConfigFileWithSystem, parseConfigHostFromCompilerHostLike: () => parseConfigHostFromCompilerHostLike, parseCustomTypeOption: () => parseCustomTypeOption, parseIsolatedEntityName: () => $J, parseIsolatedJSDocComment: () => XJ, parseJSDocTypeExpressionForTests: () => YJ, parseJsonConfigFileContent: () => parseJsonConfigFileContent, parseJsonSourceFileConfigFileContent: () => parseJsonSourceFileConfigFileContent, parseJsonText: () => KJ, parseListTypeOption: () => parseListTypeOption, parseNodeFactory: () => dc, parseNodeModuleFromPath: () => parseNodeModuleFromPath, parsePackageName: () => parsePackageName, parsePseudoBigInt: () => Hf, parseValidBigInt: () => Ux, patchWriteFileEnsuringDirectory: () => patchWriteFileEnsuringDirectory, pathContainsNodeModules: () => pathContainsNodeModules, pathIsAbsolute: () => sy, pathIsBareSpecifier: () => G5, pathIsRelative: () => So, patternText: () => T5, perfLogger: () => Dp, performIncrementalCompilation: () => performIncrementalCompilation, performance: () => ts_performance_exports, plainJSErrors: () => plainJSErrors, positionBelongsToNode: () => positionBelongsToNode, positionIsASICandidate: () => positionIsASICandidate, positionIsSynthesized: () => hs, positionsAreOnSameLine: () => $_, preProcessFile: () => preProcessFile, probablyUsesSemicolons: () => probablyUsesSemicolons, processCommentPragmas: () => ZE, processPragmasIntoFields: () => e7, processTaggedTemplateExpression: () => processTaggedTemplateExpression, programContainsEsModules: () => programContainsEsModules, programContainsModules: () => programContainsModules, projectReferenceIsEqualTo: () => bD, propKeyHelper: () => propKeyHelper, propertyNamePart: () => propertyNamePart, pseudoBigIntToString: () => yv, punctuationPart: () => punctuationPart, pushIfUnique: () => qn, quote: () => quote, quotePreferenceFromString: () => quotePreferenceFromString, rangeContainsPosition: () => rangeContainsPosition, rangeContainsPositionExclusive: () => rangeContainsPositionExclusive, rangeContainsRange: () => rangeContainsRange, rangeContainsRangeExclusive: () => rangeContainsRangeExclusive, rangeContainsStartEnd: () => rangeContainsStartEnd, rangeEndIsOnSameLineAsRangeStart: () => EO, rangeEndPositionsAreOnSameLine: () => xO, rangeEquals: () => Kc, rangeIsOnSingleLine: () => TO, rangeOfNode: () => iL, rangeOfTypeParameters: () => aL, rangeOverlapsWithStartEnd: () => rangeOverlapsWithStartEnd, rangeStartIsOnSameLineAsRangeEnd: () => cx, rangeStartPositionsAreOnSameLine: () => SO, readBuilderProgram: () => readBuilderProgram, readConfigFile: () => readConfigFile, readHelper: () => readHelper, readJson: () => hO, readJsonConfigFile: () => readJsonConfigFile, readJsonOrUndefined: () => ax, realizeDiagnostics: () => realizeDiagnostics, reduceEachLeadingCommentRange: () => zT, reduceEachTrailingCommentRange: () => WT, reduceLeft: () => Qa, reduceLeftIterator: () => K, reducePathComponents: () => is, refactor: () => ts_refactor_exports, regExpEscape: () => JM, relativeComplement: () => h_, removeAllComments: () => removeAllComments, removeEmitHelper: () => removeEmitHelper, removeExtension: () => Fx, removeFileExtension: () => Ll, removeIgnoredPath: () => removeIgnoredPath, removeMinAndVersionNumbers: () => q1, removeOptionality: () => removeOptionality, removePrefix: () => x5, removeSuffix: () => F1, removeTrailingDirectorySeparator: () => P_, repeatString: () => repeatString, replaceElement: () => ei, resolutionExtensionIsTSOrJson: () => YM, resolveConfigFileProjectName: () => resolveConfigFileProjectName, resolveJSModule: () => resolveJSModule, resolveModuleName: () => resolveModuleName, resolveModuleNameFromCache: () => resolveModuleNameFromCache, resolvePackageNameToPackageJson: () => resolvePackageNameToPackageJson, resolvePath: () => oy, resolveProjectReferencePath: () => resolveProjectReferencePath, resolveTripleslashReference: () => resolveTripleslashReference, resolveTypeReferenceDirective: () => resolveTypeReferenceDirective, resolvingEmptyArray: () => t8, restHelper: () => restHelper, returnFalse: () => w_, returnNoopFileWatcher: () => returnNoopFileWatcher, returnTrue: () => vp, returnUndefined: () => C1, returnsPromise: () => returnsPromise, runInitializersHelper: () => runInitializersHelper, sameFlatMap: () => at3, sameMap: () => tt, sameMapping: () => sameMapping, scanShebangTrivia: () => yy, scanTokenAtPosition: () => yk, scanner: () => Zo, screenStartingMessageCodes: () => screenStartingMessageCodes, semanticDiagnosticsOptionDeclarations: () => semanticDiagnosticsOptionDeclarations, serializeCompilerOptions: () => serializeCompilerOptions, server: () => ts_server_exports, servicesVersion: () => E7, setCommentRange: () => setCommentRange, setConfigFileInOptions: () => setConfigFileInOptions, setConstantValue: () => setConstantValue, setEachParent: () => Q_, setEmitFlags: () => setEmitFlags, setFunctionNameHelper: () => setFunctionNameHelper, setGetSourceFileAsHashVersioned: () => setGetSourceFileAsHashVersioned, setIdentifierAutoGenerate: () => setIdentifierAutoGenerate, setIdentifierGeneratedImportReference: () => setIdentifierGeneratedImportReference, setIdentifierTypeArguments: () => setIdentifierTypeArguments, setInternalEmitFlags: () => setInternalEmitFlags, setLocalizedDiagnosticMessages: () => yx, setModuleDefaultHelper: () => setModuleDefaultHelper, setNodeFlags: () => dL, setObjectAllocator: () => gx, setOriginalNode: () => Dn, setParent: () => Sa, setParentRecursive: () => Vx, setPrivateIdentifier: () => setPrivateIdentifier, setResolvedModule: () => gD, setResolvedTypeReferenceDirective: () => yD, setSnippetElement: () => setSnippetElement, setSourceMapRange: () => setSourceMapRange, setStackTraceLimit: () => setStackTraceLimit, setStartsOnNewLine: () => setStartsOnNewLine, setSyntheticLeadingComments: () => setSyntheticLeadingComments, setSyntheticTrailingComments: () => setSyntheticTrailingComments, setSys: () => setSys, setSysLog: () => setSysLog, setTextRange: () => Rt, setTextRangeEnd: () => Wx, setTextRangePos: () => Gf, setTextRangePosEnd: () => Us, setTextRangePosWidth: () => $f, setTokenSourceMapRange: () => setTokenSourceMapRange, setTypeNode: () => setTypeNode, setUILocale: () => xp, setValueDeclaration: () => PI, shouldAllowImportingTsExtension: () => shouldAllowImportingTsExtension, shouldPreserveConstEnums: () => EM, shouldUseUriStyleNodeCoreModules: () => shouldUseUriStyleNodeCoreModules, showModuleSpecifier: () => HO, signatureHasLiteralTypes: () => signatureHasLiteralTypes, signatureHasRestParameter: () => signatureHasRestParameter, signatureToDisplayParts: () => signatureToDisplayParts, single: () => Yc2, singleElementArray: () => Cp, singleIterator: () => Ka, singleOrMany: () => mo, singleOrUndefined: () => Xa, skipAlias: () => RO, skipAssertions: () => Hj, skipConstraint: () => skipConstraint, skipOuterExpressions: () => $o, skipParentheses: () => Pl, skipPartiallyEmittedExpressions: () => lf, skipTrivia: () => Ar2, skipTypeChecking: () => sL, skipTypeParentheses: () => GI, skipWhile: () => N5, sliceAfter: () => rL, some: () => Ke3, sort: () => Is, sortAndDeduplicate: () => uo, sortAndDeduplicateDiagnostics: () => yA, sourceFileAffectingCompilerOptions: () => sourceFileAffectingCompilerOptions, sourceFileMayBeEmitted: () => q0, sourceMapCommentRegExp: () => sourceMapCommentRegExp, sourceMapCommentRegExpDontCareLineStart: () => sourceMapCommentRegExpDontCareLineStart, spacePart: () => spacePart, spanMap: () => co, spreadArrayHelper: () => spreadArrayHelper, stableSort: () => Ns, startEndContainsRange: () => startEndContainsRange, startEndOverlapsWithStartEnd: () => startEndOverlapsWithStartEnd, startOnNewLine: () => vd, startTracing: () => startTracing, startsWith: () => Pn, startsWithDirectory: () => rA, startsWithUnderscore: () => startsWithUnderscore, startsWithUseStrict: () => SE, stringContains: () => Fi, stringContainsAt: () => stringContainsAt, stringToToken: () => _l, stripQuotes: () => CN, supportedDeclarationExtensions: () => Rv, supportedJSExtensions: () => Mv, supportedJSExtensionsFlat: () => Lv, supportedLocaleDirectories: () => Hy, supportedTSExtensions: () => Jo, supportedTSExtensionsFlat: () => Ov, supportedTSImplementationExtensions: () => b8, suppressLeadingAndTrailingTrivia: () => suppressLeadingAndTrailingTrivia, suppressLeadingTrivia: () => suppressLeadingTrivia, suppressTrailingTrivia: () => suppressTrailingTrivia, symbolEscapedNameNoDefault: () => symbolEscapedNameNoDefault, symbolName: () => rf, symbolNameNoDefault: () => symbolNameNoDefault, symbolPart: () => symbolPart, symbolToDisplayParts: () => symbolToDisplayParts, syntaxMayBeASICandidate: () => syntaxMayBeASICandidate, syntaxRequiresTrailingSemicolonOrASI: () => syntaxRequiresTrailingSemicolonOrASI, sys: () => iy, sysLog: () => sysLog, tagNamesAreEquivalent: () => Hi, takeWhile: () => I5, targetOptionDeclaration: () => targetOptionDeclaration, templateObjectHelper: () => templateObjectHelper, testFormatSettings: () => testFormatSettings, textChangeRangeIsUnchanged: () => cS, textChangeRangeNewSpan: () => R_, textChanges: () => ts_textChanges_exports, textOrKeywordPart: () => textOrKeywordPart, textPart: () => textPart, textRangeContainsPositionInclusive: () => bA, textSpanContainsPosition: () => vA, textSpanContainsTextSpan: () => TA, textSpanEnd: () => Ir2, textSpanIntersection: () => _S, textSpanIntersectsWith: () => EA, textSpanIntersectsWithPosition: () => wA, textSpanIntersectsWithTextSpan: () => xA, textSpanIsEmpty: () => sS, textSpanOverlap: () => oS, textSpanOverlapsWith: () => SA, textSpansEqual: () => textSpansEqual, textToKeywordObj: () => cl, timestamp: () => ts, toArray: () => en, toBuilderFileEmit: () => toBuilderFileEmit, toBuilderStateFileInfoForMultiEmit: () => toBuilderStateFileInfoForMultiEmit, toEditorSettings: () => lu, toFileNameLowerCase: () => Tp, toLowerCase: () => bp, toPath: () => Ui, toProgramEmitPending: () => toProgramEmitPending, tokenIsIdentifierOrKeyword: () => fr2, tokenIsIdentifierOrKeywordOrGreaterThan: () => qT, tokenToString: () => Br2, trace: () => trace, tracing: () => rs, tracingEnabled: () => tracingEnabled, transform: () => transform, transformClassFields: () => transformClassFields, transformDeclarations: () => transformDeclarations, transformECMAScriptModule: () => transformECMAScriptModule, transformES2015: () => transformES2015, transformES2016: () => transformES2016, transformES2017: () => transformES2017, transformES2018: () => transformES2018, transformES2019: () => transformES2019, transformES2020: () => transformES2020, transformES2021: () => transformES2021, transformES5: () => transformES5, transformESDecorators: () => transformESDecorators, transformESNext: () => transformESNext, transformGenerators: () => transformGenerators, transformJsx: () => transformJsx, transformLegacyDecorators: () => transformLegacyDecorators, transformModule: () => transformModule, transformNodeModule: () => transformNodeModule, transformNodes: () => transformNodes, transformSystemModule: () => transformSystemModule, transformTypeScript: () => transformTypeScript, transpile: () => transpile, transpileModule: () => transpileModule, transpileOptionValueCompilerOptions: () => transpileOptionValueCompilerOptions, trimString: () => Pp, trimStringEnd: () => X1, trimStringStart: () => nl, tryAddToSet: () => ua, tryAndIgnoreErrors: () => tryAndIgnoreErrors, tryCast: () => ln, tryDirectoryExists: () => tryDirectoryExists, tryExtractTSExtension: () => uO, tryFileExists: () => tryFileExists, tryGetClassExtendingExpressionWithTypeArguments: () => ex, tryGetClassImplementingOrExtendingExpressionWithTypeArguments: () => tx, tryGetDirectories: () => tryGetDirectories, tryGetExtensionFromPath: () => hv, tryGetImportFromModuleSpecifier: () => Y32, tryGetJSDocSatisfiesTypeNode: () => e8, tryGetModuleNameFromFile: () => CE, tryGetModuleSpecifierFromDeclaration: () => kI, tryGetNativePerformanceHooks: () => J5, tryGetPropertyAccessOrIdentifierToString: () => tv, tryGetPropertyNameOfBindingOrAssignmentElement: () => PE, tryGetSourceMappingURL: () => tryGetSourceMappingURL, tryGetTextOfPropertyName: () => e0, tryIOAndConsumeErrors: () => tryIOAndConsumeErrors, tryParsePattern: () => Bx, tryParsePatterns: () => XM, tryParseRawSourceMap: () => tryParseRawSourceMap, tryReadDirectory: () => tryReadDirectory, tryReadFile: () => tryReadFile, tryRemoveDirectoryPrefix: () => jM, tryRemoveExtension: () => Jx, tryRemovePrefix: () => ST, tryRemoveSuffix: () => B1, typeAcquisitionDeclarations: () => typeAcquisitionDeclarations, typeAliasNamePart: () => typeAliasNamePart, typeDirectiveIsEqualTo: () => ED, typeKeywords: () => typeKeywords, typeParameterNamePart: () => typeParameterNamePart, typeReferenceResolutionNameAndModeGetter: () => typeReferenceResolutionNameAndModeGetter, typeToDisplayParts: () => typeToDisplayParts, unchangedPollThresholds: () => unchangedPollThresholds, unchangedTextChangeRange: () => Vy, unescapeLeadingUnderscores: () => dl, unmangleScopedPackageName: () => unmangleScopedPackageName, unorderedRemoveItem: () => bT, unorderedRemoveItemAt: () => U1, unreachableCodeIsError: () => yM, unusedLabelIsError: () => vM, unwrapInnermostStatementOfLabel: () => Rk, updateErrorForNoInputFiles: () => updateErrorForNoInputFiles, updateLanguageServiceSourceFile: () => T7, updateMissingFilePathsWatch: () => updateMissingFilePathsWatch, updatePackageJsonWatch: () => updatePackageJsonWatch, updateResolutionField: () => updateResolutionField, updateSharedExtendedConfigFileWatcher: () => updateSharedExtendedConfigFileWatcher, updateSourceFile: () => k2, updateWatchingWildcardDirectories: () => updateWatchingWildcardDirectories, usesExtensionsOnImports: () => Rx, usingSingleLineStringWriter: () => mD, utf16EncodeAsString: () => by, validateLocaleAndSetLanguage: () => DA, valuesHelper: () => valuesHelper, version: () => C2, versionMajorMinor: () => m, visitArray: () => visitArray, visitCommaListElements: () => visitCommaListElements, visitEachChild: () => visitEachChild, visitFunctionBody: () => visitFunctionBody, visitIterationBody: () => visitIterationBody, visitLexicalEnvironment: () => visitLexicalEnvironment, visitNode: () => visitNode, visitNodes: () => visitNodes2, visitParameterList: () => visitParameterList, walkUpBindingElementsAndPatterns: () => fS, walkUpLexicalEnvironments: () => walkUpLexicalEnvironments, walkUpOuterExpressions: () => Vj, walkUpParenthesizedExpressions: () => D0, walkUpParenthesizedTypes: () => VI, walkUpParenthesizedTypesAndGetParentAndChild: () => HI, whitespaceOrMapCommentRegExp: () => whitespaceOrMapCommentRegExp, writeCommentRange: () => $N, writeFile: () => jN, writeFileEnsuringDirectories: () => JN, zipToModeAwareCache: () => zipToModeAwareCache, zipWith: () => ce2 });
          var R7 = D({ "src/typescript/_namespaces/ts.ts"() {
            "use strict";
            nn(), l7(), L2(), FB();
          } }), BB = P({ "src/typescript/typescript.ts"(e, t6) {
            R7(), R7(), typeof console < "u" && (Y3.loggingHost = { log(r, s) {
              switch (r) {
                case 1:
                  return console.error(s);
                case 2:
                  return console.warn(s);
                case 3:
                  return console.log(s);
                case 4:
                  return console.log(s);
              }
            } }), t6.exports = L7;
          } });
          _.exports = BB();
        } }), DW = Oe2({ "src/language-js/parse/postprocess/typescript.js"(a, _) {
          "use strict";
          De3();
          var v2 = F9(), h = q9(), D = U9(), P = { AbstractKeyword: 126, SourceFile: 308, PropertyDeclaration: 169 };
          function y(c) {
            for (; c && c.kind !== P.SourceFile; )
              c = c.parent;
            return c;
          }
          function m(c, M) {
            let q2 = y(c), [W, K] = [c.getStart(), c.end].map((ce2) => {
              let { line: Ie2, character: me2 } = q2.getLineAndCharacterOfPosition(ce2);
              return { line: Ie2 + 1, column: me2 };
            });
            D({ loc: { start: W, end: K } }, M);
          }
          function C2(c) {
            let M = vr();
            return [true, false].some((q2) => M.nodeCanBeDecorated(q2, c, c.parent, c.parent.parent));
          }
          function d2(c) {
            let { modifiers: M } = c;
            if (!v2(M))
              return;
            let q2 = vr(), { SyntaxKind: W } = q2;
            for (let K of M)
              q2.isDecorator(K) && !C2(c) && (c.kind === W.MethodDeclaration && !q2.nodeIsPresent(c.body) && m(K, "A decorator can only decorate a method implementation, not an overload."), m(K, "Decorators are not valid here."));
          }
          function E(c, M) {
            c.kind !== P.PropertyDeclaration || c.modifiers && !c.modifiers.some((q2) => q2.kind === P.AbstractKeyword) || c.initializer && M.value === null && D(M, "Abstract property cannot have an initializer");
          }
          function I(c, M) {
            if (!/@|abstract/.test(M.originalText))
              return;
            let { esTreeNodeToTSNodeMap: q2, tsNodeToESTreeNodeMap: W } = c;
            h(c.ast, (K) => {
              let ce2 = q2.get(K);
              if (!ce2)
                return;
              let Ie2 = W.get(ce2);
              Ie2 === K && (d2(ce2), E(ce2, Ie2));
            });
          }
          _.exports = { throwErrorForInvalidNodes: I };
        } }), Ga = Oe2({ "scripts/build/shims/debug.cjs"(a, _) {
          "use strict";
          De3(), _.exports = () => () => {
          };
        } }), h1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/internal/constants.js"(a, _) {
          De3();
          var v2 = "2.0.0", h = 256, D = Number.MAX_SAFE_INTEGER || 9007199254740991, P = 16;
          _.exports = { SEMVER_SPEC_VERSION: v2, MAX_LENGTH: h, MAX_SAFE_INTEGER: D, MAX_SAFE_COMPONENT_LENGTH: P };
        } }), g1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/internal/debug.js"(a, _) {
          De3();
          var v2 = typeof cn == "object" && cn.env && cn.env.NODE_DEBUG && /\bsemver\b/i.test(cn.env.NODE_DEBUG) ? function() {
            for (var h = arguments.length, D = new Array(h), P = 0; P < h; P++)
              D[P] = arguments[P];
            return console.error("SEMVER", ...D);
          } : () => {
          };
          _.exports = v2;
        } }), Bc = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/internal/re.js"(a, _) {
          De3();
          var { MAX_SAFE_COMPONENT_LENGTH: v2 } = h1(), h = g1();
          a = _.exports = {};
          var D = a.re = [], P = a.src = [], y = a.t = {}, m = 0, C2 = (d2, E, I) => {
            let c = m++;
            h(d2, c, E), y[d2] = c, P[c] = E, D[c] = new RegExp(E, I ? "g" : void 0);
          };
          C2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), C2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), C2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), C2("MAINVERSION", `(${P[y.NUMERICIDENTIFIER]})\\.(${P[y.NUMERICIDENTIFIER]})\\.(${P[y.NUMERICIDENTIFIER]})`), C2("MAINVERSIONLOOSE", `(${P[y.NUMERICIDENTIFIERLOOSE]})\\.(${P[y.NUMERICIDENTIFIERLOOSE]})\\.(${P[y.NUMERICIDENTIFIERLOOSE]})`), C2("PRERELEASEIDENTIFIER", `(?:${P[y.NUMERICIDENTIFIER]}|${P[y.NONNUMERICIDENTIFIER]})`), C2("PRERELEASEIDENTIFIERLOOSE", `(?:${P[y.NUMERICIDENTIFIERLOOSE]}|${P[y.NONNUMERICIDENTIFIER]})`), C2("PRERELEASE", `(?:-(${P[y.PRERELEASEIDENTIFIER]}(?:\\.${P[y.PRERELEASEIDENTIFIER]})*))`), C2("PRERELEASELOOSE", `(?:-?(${P[y.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${P[y.PRERELEASEIDENTIFIERLOOSE]})*))`), C2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), C2("BUILD", `(?:\\+(${P[y.BUILDIDENTIFIER]}(?:\\.${P[y.BUILDIDENTIFIER]})*))`), C2("FULLPLAIN", `v?${P[y.MAINVERSION]}${P[y.PRERELEASE]}?${P[y.BUILD]}?`), C2("FULL", `^${P[y.FULLPLAIN]}$`), C2("LOOSEPLAIN", `[v=\\s]*${P[y.MAINVERSIONLOOSE]}${P[y.PRERELEASELOOSE]}?${P[y.BUILD]}?`), C2("LOOSE", `^${P[y.LOOSEPLAIN]}$`), C2("GTLT", "((?:<|>)?=?)"), C2("XRANGEIDENTIFIERLOOSE", `${P[y.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), C2("XRANGEIDENTIFIER", `${P[y.NUMERICIDENTIFIER]}|x|X|\\*`), C2("XRANGEPLAIN", `[v=\\s]*(${P[y.XRANGEIDENTIFIER]})(?:\\.(${P[y.XRANGEIDENTIFIER]})(?:\\.(${P[y.XRANGEIDENTIFIER]})(?:${P[y.PRERELEASE]})?${P[y.BUILD]}?)?)?`), C2("XRANGEPLAINLOOSE", `[v=\\s]*(${P[y.XRANGEIDENTIFIERLOOSE]})(?:\\.(${P[y.XRANGEIDENTIFIERLOOSE]})(?:\\.(${P[y.XRANGEIDENTIFIERLOOSE]})(?:${P[y.PRERELEASELOOSE]})?${P[y.BUILD]}?)?)?`), C2("XRANGE", `^${P[y.GTLT]}\\s*${P[y.XRANGEPLAIN]}$`), C2("XRANGELOOSE", `^${P[y.GTLT]}\\s*${P[y.XRANGEPLAINLOOSE]}$`), C2("COERCE", `(^|[^\\d])(\\d{1,${v2}})(?:\\.(\\d{1,${v2}}))?(?:\\.(\\d{1,${v2}}))?(?:$|[^\\d])`), C2("COERCERTL", P[y.COERCE], true), C2("LONETILDE", "(?:~>?)"), C2("TILDETRIM", `(\\s*)${P[y.LONETILDE]}\\s+`, true), a.tildeTrimReplace = "$1~", C2("TILDE", `^${P[y.LONETILDE]}${P[y.XRANGEPLAIN]}$`), C2("TILDELOOSE", `^${P[y.LONETILDE]}${P[y.XRANGEPLAINLOOSE]}$`), C2("LONECARET", "(?:\\^)"), C2("CARETTRIM", `(\\s*)${P[y.LONECARET]}\\s+`, true), a.caretTrimReplace = "$1^", C2("CARET", `^${P[y.LONECARET]}${P[y.XRANGEPLAIN]}$`), C2("CARETLOOSE", `^${P[y.LONECARET]}${P[y.XRANGEPLAINLOOSE]}$`), C2("COMPARATORLOOSE", `^${P[y.GTLT]}\\s*(${P[y.LOOSEPLAIN]})$|^$`), C2("COMPARATOR", `^${P[y.GTLT]}\\s*(${P[y.FULLPLAIN]})$|^$`), C2("COMPARATORTRIM", `(\\s*)${P[y.GTLT]}\\s*(${P[y.LOOSEPLAIN]}|${P[y.XRANGEPLAIN]})`, true), a.comparatorTrimReplace = "$1$2$3", C2("HYPHENRANGE", `^\\s*(${P[y.XRANGEPLAIN]})\\s+-\\s+(${P[y.XRANGEPLAIN]})\\s*$`), C2("HYPHENRANGELOOSE", `^\\s*(${P[y.XRANGEPLAINLOOSE]})\\s+-\\s+(${P[y.XRANGEPLAINLOOSE]})\\s*$`), C2("STAR", "(<|>)?=?\\s*\\*"), C2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), C2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), y1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/internal/parse-options.js"(a, _) {
          De3();
          var v2 = ["includePrerelease", "loose", "rtl"], h = (D) => D ? typeof D != "object" ? { loose: true } : v2.filter((P) => D[P]).reduce((P, y) => (P[y] = true, P), {}) : {};
          _.exports = h;
        } }), z9 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/internal/identifiers.js"(a, _) {
          De3();
          var v2 = /^[0-9]+$/, h = (P, y) => {
            let m = v2.test(P), C2 = v2.test(y);
            return m && C2 && (P = +P, y = +y), P === y ? 0 : m && !C2 ? -1 : C2 && !m ? 1 : P < y ? -1 : 1;
          }, D = (P, y) => h(y, P);
          _.exports = { compareIdentifiers: h, rcompareIdentifiers: D };
        } }), Bn = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/classes/semver.js"(a, _) {
          De3();
          var v2 = g1(), { MAX_LENGTH: h, MAX_SAFE_INTEGER: D } = h1(), { re: P, t: y } = Bc(), m = y1(), { compareIdentifiers: C2 } = z9(), d2 = class {
            constructor(E, I) {
              if (I = m(I), E instanceof d2) {
                if (E.loose === !!I.loose && E.includePrerelease === !!I.includePrerelease)
                  return E;
                E = E.version;
              } else if (typeof E != "string")
                throw new TypeError(`Invalid Version: ${E}`);
              if (E.length > h)
                throw new TypeError(`version is longer than ${h} characters`);
              v2("SemVer", E, I), this.options = I, this.loose = !!I.loose, this.includePrerelease = !!I.includePrerelease;
              let c = E.trim().match(I.loose ? P[y.LOOSE] : P[y.FULL]);
              if (!c)
                throw new TypeError(`Invalid Version: ${E}`);
              if (this.raw = E, this.major = +c[1], this.minor = +c[2], this.patch = +c[3], this.major > D || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > D || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > D || this.patch < 0)
                throw new TypeError("Invalid patch version");
              c[4] ? this.prerelease = c[4].split(".").map((M) => {
                if (/^[0-9]+$/.test(M)) {
                  let q2 = +M;
                  if (q2 >= 0 && q2 < D)
                    return q2;
                }
                return M;
              }) : this.prerelease = [], this.build = c[5] ? c[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(E) {
              if (v2("SemVer.compare", this.version, this.options, E), !(E instanceof d2)) {
                if (typeof E == "string" && E === this.version)
                  return 0;
                E = new d2(E, this.options);
              }
              return E.version === this.version ? 0 : this.compareMain(E) || this.comparePre(E);
            }
            compareMain(E) {
              return E instanceof d2 || (E = new d2(E, this.options)), C2(this.major, E.major) || C2(this.minor, E.minor) || C2(this.patch, E.patch);
            }
            comparePre(E) {
              if (E instanceof d2 || (E = new d2(E, this.options)), this.prerelease.length && !E.prerelease.length)
                return -1;
              if (!this.prerelease.length && E.prerelease.length)
                return 1;
              if (!this.prerelease.length && !E.prerelease.length)
                return 0;
              let I = 0;
              do {
                let c = this.prerelease[I], M = E.prerelease[I];
                if (v2("prerelease compare", I, c, M), c === void 0 && M === void 0)
                  return 0;
                if (M === void 0)
                  return 1;
                if (c === void 0)
                  return -1;
                if (c === M)
                  continue;
                return C2(c, M);
              } while (++I);
            }
            compareBuild(E) {
              E instanceof d2 || (E = new d2(E, this.options));
              let I = 0;
              do {
                let c = this.build[I], M = E.build[I];
                if (v2("prerelease compare", I, c, M), c === void 0 && M === void 0)
                  return 0;
                if (M === void 0)
                  return 1;
                if (c === void 0)
                  return -1;
                if (c === M)
                  continue;
                return C2(c, M);
              } while (++I);
            }
            inc(E, I) {
              switch (E) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", I);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", I);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", I), this.inc("pre", I);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", I), this.inc("pre", I);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let c = this.prerelease.length;
                    for (; --c >= 0; )
                      typeof this.prerelease[c] == "number" && (this.prerelease[c]++, c = -2);
                    c === -1 && this.prerelease.push(0);
                  }
                  I && (C2(this.prerelease[0], I) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [I, 0]) : this.prerelease = [I, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${E}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          _.exports = d2;
        } }), qc = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/parse.js"(a, _) {
          De3();
          var { MAX_LENGTH: v2 } = h1(), { re: h, t: D } = Bc(), P = Bn(), y = y1(), m = (C2, d2) => {
            if (d2 = y(d2), C2 instanceof P)
              return C2;
            if (typeof C2 != "string" || C2.length > v2 || !(d2.loose ? h[D.LOOSE] : h[D.FULL]).test(C2))
              return null;
            try {
              return new P(C2, d2);
            } catch {
              return null;
            }
          };
          _.exports = m;
        } }), kW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/valid.js"(a, _) {
          De3();
          var v2 = qc(), h = (D, P) => {
            let y = v2(D, P);
            return y ? y.version : null;
          };
          _.exports = h;
        } }), IW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/clean.js"(a, _) {
          De3();
          var v2 = qc(), h = (D, P) => {
            let y = v2(D.trim().replace(/^[=v]+/, ""), P);
            return y ? y.version : null;
          };
          _.exports = h;
        } }), NW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/inc.js"(a, _) {
          De3();
          var v2 = Bn(), h = (D, P, y, m) => {
            typeof y == "string" && (m = y, y = void 0);
            try {
              return new v2(D instanceof v2 ? D.version : D, y).inc(P, m).version;
            } catch {
              return null;
            }
          };
          _.exports = h;
        } }), _a = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/compare.js"(a, _) {
          De3();
          var v2 = Bn(), h = (D, P, y) => new v2(D, y).compare(new v2(P, y));
          _.exports = h;
        } }), sT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/eq.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(D, P, y) === 0;
          _.exports = h;
        } }), OW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/diff.js"(a, _) {
          De3();
          var v2 = qc(), h = sT(), D = (P, y) => {
            if (h(P, y))
              return null;
            {
              let m = v2(P), C2 = v2(y), d2 = m.prerelease.length || C2.prerelease.length, E = d2 ? "pre" : "", I = d2 ? "prerelease" : "";
              for (let c in m)
                if ((c === "major" || c === "minor" || c === "patch") && m[c] !== C2[c])
                  return E + c;
              return I;
            }
          };
          _.exports = D;
        } }), MW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/major.js"(a, _) {
          De3();
          var v2 = Bn(), h = (D, P) => new v2(D, P).major;
          _.exports = h;
        } }), LW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/minor.js"(a, _) {
          De3();
          var v2 = Bn(), h = (D, P) => new v2(D, P).minor;
          _.exports = h;
        } }), RW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/patch.js"(a, _) {
          De3();
          var v2 = Bn(), h = (D, P) => new v2(D, P).patch;
          _.exports = h;
        } }), jW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/prerelease.js"(a, _) {
          De3();
          var v2 = qc(), h = (D, P) => {
            let y = v2(D, P);
            return y && y.prerelease.length ? y.prerelease : null;
          };
          _.exports = h;
        } }), JW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/rcompare.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(P, D, y);
          _.exports = h;
        } }), FW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/compare-loose.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P) => v2(D, P, true);
          _.exports = h;
        } }), oT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/compare-build.js"(a, _) {
          De3();
          var v2 = Bn(), h = (D, P, y) => {
            let m = new v2(D, y), C2 = new v2(P, y);
            return m.compare(C2) || m.compareBuild(C2);
          };
          _.exports = h;
        } }), BW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/sort.js"(a, _) {
          De3();
          var v2 = oT(), h = (D, P) => D.sort((y, m) => v2(y, m, P));
          _.exports = h;
        } }), qW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/rsort.js"(a, _) {
          De3();
          var v2 = oT(), h = (D, P) => D.sort((y, m) => v2(m, y, P));
          _.exports = h;
        } }), v1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/gt.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(D, P, y) > 0;
          _.exports = h;
        } }), _T = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/lt.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(D, P, y) < 0;
          _.exports = h;
        } }), W9 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/neq.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(D, P, y) !== 0;
          _.exports = h;
        } }), cT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/gte.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(D, P, y) >= 0;
          _.exports = h;
        } }), lT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/lte.js"(a, _) {
          De3();
          var v2 = _a(), h = (D, P, y) => v2(D, P, y) <= 0;
          _.exports = h;
        } }), V9 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/cmp.js"(a, _) {
          De3();
          var v2 = sT(), h = W9(), D = v1(), P = cT(), y = _T(), m = lT(), C2 = (d2, E, I, c) => {
            switch (E) {
              case "===":
                return typeof d2 == "object" && (d2 = d2.version), typeof I == "object" && (I = I.version), d2 === I;
              case "!==":
                return typeof d2 == "object" && (d2 = d2.version), typeof I == "object" && (I = I.version), d2 !== I;
              case "":
              case "=":
              case "==":
                return v2(d2, I, c);
              case "!=":
                return h(d2, I, c);
              case ">":
                return D(d2, I, c);
              case ">=":
                return P(d2, I, c);
              case "<":
                return y(d2, I, c);
              case "<=":
                return m(d2, I, c);
              default:
                throw new TypeError(`Invalid operator: ${E}`);
            }
          };
          _.exports = C2;
        } }), UW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/coerce.js"(a, _) {
          De3();
          var v2 = Bn(), h = qc(), { re: D, t: P } = Bc(), y = (m, C2) => {
            if (m instanceof v2)
              return m;
            if (typeof m == "number" && (m = String(m)), typeof m != "string")
              return null;
            C2 = C2 || {};
            let d2 = null;
            if (!C2.rtl)
              d2 = m.match(D[P.COERCE]);
            else {
              let E;
              for (; (E = D[P.COERCERTL].exec(m)) && (!d2 || d2.index + d2[0].length !== m.length); )
                (!d2 || E.index + E[0].length !== d2.index + d2[0].length) && (d2 = E), D[P.COERCERTL].lastIndex = E.index + E[1].length + E[2].length;
              D[P.COERCERTL].lastIndex = -1;
            }
            return d2 === null ? null : h(`${d2[2]}.${d2[3] || "0"}.${d2[4] || "0"}`, C2);
          };
          _.exports = y;
        } }), zW = Oe2({ "node_modules/yallist/iterator.js"(a, _) {
          "use strict";
          De3(), _.exports = function(v2) {
            v2.prototype[Symbol.iterator] = function* () {
              for (let h = this.head; h; h = h.next)
                yield h.value;
            };
          };
        } }), WW = Oe2({ "node_modules/yallist/yallist.js"(a, _) {
          "use strict";
          De3(), _.exports = v2, v2.Node = y, v2.create = v2;
          function v2(m) {
            var C2 = this;
            if (C2 instanceof v2 || (C2 = new v2()), C2.tail = null, C2.head = null, C2.length = 0, m && typeof m.forEach == "function")
              m.forEach(function(I) {
                C2.push(I);
              });
            else if (arguments.length > 0)
              for (var d2 = 0, E = arguments.length; d2 < E; d2++)
                C2.push(arguments[d2]);
            return C2;
          }
          v2.prototype.removeNode = function(m) {
            if (m.list !== this)
              throw new Error("removing node which does not belong to this list");
            var C2 = m.next, d2 = m.prev;
            return C2 && (C2.prev = d2), d2 && (d2.next = C2), m === this.head && (this.head = C2), m === this.tail && (this.tail = d2), m.list.length--, m.next = null, m.prev = null, m.list = null, C2;
          }, v2.prototype.unshiftNode = function(m) {
            if (m !== this.head) {
              m.list && m.list.removeNode(m);
              var C2 = this.head;
              m.list = this, m.next = C2, C2 && (C2.prev = m), this.head = m, this.tail || (this.tail = m), this.length++;
            }
          }, v2.prototype.pushNode = function(m) {
            if (m !== this.tail) {
              m.list && m.list.removeNode(m);
              var C2 = this.tail;
              m.list = this, m.prev = C2, C2 && (C2.next = m), this.tail = m, this.head || (this.head = m), this.length++;
            }
          }, v2.prototype.push = function() {
            for (var m = 0, C2 = arguments.length; m < C2; m++)
              D(this, arguments[m]);
            return this.length;
          }, v2.prototype.unshift = function() {
            for (var m = 0, C2 = arguments.length; m < C2; m++)
              P(this, arguments[m]);
            return this.length;
          }, v2.prototype.pop = function() {
            if (this.tail) {
              var m = this.tail.value;
              return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, m;
            }
          }, v2.prototype.shift = function() {
            if (this.head) {
              var m = this.head.value;
              return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, m;
            }
          }, v2.prototype.forEach = function(m, C2) {
            C2 = C2 || this;
            for (var d2 = this.head, E = 0; d2 !== null; E++)
              m.call(C2, d2.value, E, this), d2 = d2.next;
          }, v2.prototype.forEachReverse = function(m, C2) {
            C2 = C2 || this;
            for (var d2 = this.tail, E = this.length - 1; d2 !== null; E--)
              m.call(C2, d2.value, E, this), d2 = d2.prev;
          }, v2.prototype.get = function(m) {
            for (var C2 = 0, d2 = this.head; d2 !== null && C2 < m; C2++)
              d2 = d2.next;
            if (C2 === m && d2 !== null)
              return d2.value;
          }, v2.prototype.getReverse = function(m) {
            for (var C2 = 0, d2 = this.tail; d2 !== null && C2 < m; C2++)
              d2 = d2.prev;
            if (C2 === m && d2 !== null)
              return d2.value;
          }, v2.prototype.map = function(m, C2) {
            C2 = C2 || this;
            for (var d2 = new v2(), E = this.head; E !== null; )
              d2.push(m.call(C2, E.value, this)), E = E.next;
            return d2;
          }, v2.prototype.mapReverse = function(m, C2) {
            C2 = C2 || this;
            for (var d2 = new v2(), E = this.tail; E !== null; )
              d2.push(m.call(C2, E.value, this)), E = E.prev;
            return d2;
          }, v2.prototype.reduce = function(m, C2) {
            var d2, E = this.head;
            if (arguments.length > 1)
              d2 = C2;
            else if (this.head)
              E = this.head.next, d2 = this.head.value;
            else
              throw new TypeError("Reduce of empty list with no initial value");
            for (var I = 0; E !== null; I++)
              d2 = m(d2, E.value, I), E = E.next;
            return d2;
          }, v2.prototype.reduceReverse = function(m, C2) {
            var d2, E = this.tail;
            if (arguments.length > 1)
              d2 = C2;
            else if (this.tail)
              E = this.tail.prev, d2 = this.tail.value;
            else
              throw new TypeError("Reduce of empty list with no initial value");
            for (var I = this.length - 1; E !== null; I--)
              d2 = m(d2, E.value, I), E = E.prev;
            return d2;
          }, v2.prototype.toArray = function() {
            for (var m = new Array(this.length), C2 = 0, d2 = this.head; d2 !== null; C2++)
              m[C2] = d2.value, d2 = d2.next;
            return m;
          }, v2.prototype.toArrayReverse = function() {
            for (var m = new Array(this.length), C2 = 0, d2 = this.tail; d2 !== null; C2++)
              m[C2] = d2.value, d2 = d2.prev;
            return m;
          }, v2.prototype.slice = function(m, C2) {
            C2 = C2 || this.length, C2 < 0 && (C2 += this.length), m = m || 0, m < 0 && (m += this.length);
            var d2 = new v2();
            if (C2 < m || C2 < 0)
              return d2;
            m < 0 && (m = 0), C2 > this.length && (C2 = this.length);
            for (var E = 0, I = this.head; I !== null && E < m; E++)
              I = I.next;
            for (; I !== null && E < C2; E++, I = I.next)
              d2.push(I.value);
            return d2;
          }, v2.prototype.sliceReverse = function(m, C2) {
            C2 = C2 || this.length, C2 < 0 && (C2 += this.length), m = m || 0, m < 0 && (m += this.length);
            var d2 = new v2();
            if (C2 < m || C2 < 0)
              return d2;
            m < 0 && (m = 0), C2 > this.length && (C2 = this.length);
            for (var E = this.length, I = this.tail; I !== null && E > C2; E--)
              I = I.prev;
            for (; I !== null && E > m; E--, I = I.prev)
              d2.push(I.value);
            return d2;
          }, v2.prototype.splice = function(m, C2) {
            m > this.length && (m = this.length - 1), m < 0 && (m = this.length + m);
            for (var d2 = 0, E = this.head; E !== null && d2 < m; d2++)
              E = E.next;
            for (var I = [], d2 = 0; E && d2 < C2; d2++)
              I.push(E.value), E = this.removeNode(E);
            E === null && (E = this.tail), E !== this.head && E !== this.tail && (E = E.prev);
            for (var d2 = 0; d2 < (arguments.length <= 2 ? 0 : arguments.length - 2); d2++)
              E = h(this, E, d2 + 2 < 2 || arguments.length <= d2 + 2 ? void 0 : arguments[d2 + 2]);
            return I;
          }, v2.prototype.reverse = function() {
            for (var m = this.head, C2 = this.tail, d2 = m; d2 !== null; d2 = d2.prev) {
              var E = d2.prev;
              d2.prev = d2.next, d2.next = E;
            }
            return this.head = C2, this.tail = m, this;
          };
          function h(m, C2, d2) {
            var E = C2 === m.head ? new y(d2, null, C2, m) : new y(d2, C2, C2.next, m);
            return E.next === null && (m.tail = E), E.prev === null && (m.head = E), m.length++, E;
          }
          function D(m, C2) {
            m.tail = new y(C2, m.tail, null, m), m.head || (m.head = m.tail), m.length++;
          }
          function P(m, C2) {
            m.head = new y(C2, null, m.head, m), m.tail || (m.tail = m.head), m.length++;
          }
          function y(m, C2, d2, E) {
            if (!(this instanceof y))
              return new y(m, C2, d2, E);
            this.list = E, this.value = m, C2 ? (C2.next = this, this.prev = C2) : this.prev = null, d2 ? (d2.prev = this, this.next = d2) : this.next = null;
          }
          try {
            zW()(v2);
          } catch {
          }
        } }), VW = Oe2({ "node_modules/lru-cache/index.js"(a, _) {
          "use strict";
          De3();
          var v2 = WW(), h = Symbol("max"), D = Symbol("length"), P = Symbol("lengthCalculator"), y = Symbol("allowStale"), m = Symbol("maxAge"), C2 = Symbol("dispose"), d2 = Symbol("noDisposeOnSet"), E = Symbol("lruList"), I = Symbol("cache"), c = Symbol("updateAgeOnGet"), M = () => 1, q2 = class {
            constructor(te2) {
              if (typeof te2 == "number" && (te2 = { max: te2 }), te2 || (te2 = {}), te2.max && (typeof te2.max != "number" || te2.max < 0))
                throw new TypeError("max must be a non-negative number");
              let he = this[h] = te2.max || 1 / 0, Pe2 = te2.length || M;
              if (this[P] = typeof Pe2 != "function" ? M : Pe2, this[y] = te2.stale || false, te2.maxAge && typeof te2.maxAge != "number")
                throw new TypeError("maxAge must be a number");
              this[m] = te2.maxAge || 0, this[C2] = te2.dispose, this[d2] = te2.noDisposeOnSet || false, this[c] = te2.updateAgeOnGet || false, this.reset();
            }
            set max(te2) {
              if (typeof te2 != "number" || te2 < 0)
                throw new TypeError("max must be a non-negative number");
              this[h] = te2 || 1 / 0, ce2(this);
            }
            get max() {
              return this[h];
            }
            set allowStale(te2) {
              this[y] = !!te2;
            }
            get allowStale() {
              return this[y];
            }
            set maxAge(te2) {
              if (typeof te2 != "number")
                throw new TypeError("maxAge must be a non-negative number");
              this[m] = te2, ce2(this);
            }
            get maxAge() {
              return this[m];
            }
            set lengthCalculator(te2) {
              typeof te2 != "function" && (te2 = M), te2 !== this[P] && (this[P] = te2, this[D] = 0, this[E].forEach((he) => {
                he.length = this[P](he.value, he.key), this[D] += he.length;
              })), ce2(this);
            }
            get lengthCalculator() {
              return this[P];
            }
            get length() {
              return this[D];
            }
            get itemCount() {
              return this[E].length;
            }
            rforEach(te2, he) {
              he = he || this;
              for (let Pe2 = this[E].tail; Pe2 !== null; ) {
                let R = Pe2.prev;
                Ae2(this, te2, Pe2, he), Pe2 = R;
              }
            }
            forEach(te2, he) {
              he = he || this;
              for (let Pe2 = this[E].head; Pe2 !== null; ) {
                let R = Pe2.next;
                Ae2(this, te2, Pe2, he), Pe2 = R;
              }
            }
            keys() {
              return this[E].toArray().map((te2) => te2.key);
            }
            values() {
              return this[E].toArray().map((te2) => te2.value);
            }
            reset() {
              this[C2] && this[E] && this[E].length && this[E].forEach((te2) => this[C2](te2.key, te2.value)), this[I] = /* @__PURE__ */ new Map(), this[E] = new v2(), this[D] = 0;
            }
            dump() {
              return this[E].map((te2) => K(this, te2) ? false : { k: te2.key, v: te2.value, e: te2.now + (te2.maxAge || 0) }).toArray().filter((te2) => te2);
            }
            dumpLru() {
              return this[E];
            }
            set(te2, he, Pe2) {
              if (Pe2 = Pe2 || this[m], Pe2 && typeof Pe2 != "number")
                throw new TypeError("maxAge must be a number");
              let R = Pe2 ? Date.now() : 0, pe2 = this[P](he, te2);
              if (this[I].has(te2)) {
                if (pe2 > this[h])
                  return Ie2(this, this[I].get(te2)), false;
                let Xe2 = this[I].get(te2).value;
                return this[C2] && (this[d2] || this[C2](te2, Xe2.value)), Xe2.now = R, Xe2.maxAge = Pe2, Xe2.value = he, this[D] += pe2 - Xe2.length, Xe2.length = pe2, this.get(te2), ce2(this), true;
              }
              let ke2 = new me2(te2, he, pe2, R, Pe2);
              return ke2.length > this[h] ? (this[C2] && this[C2](te2, he), false) : (this[D] += ke2.length, this[E].unshift(ke2), this[I].set(te2, this[E].head), ce2(this), true);
            }
            has(te2) {
              if (!this[I].has(te2))
                return false;
              let he = this[I].get(te2).value;
              return !K(this, he);
            }
            get(te2) {
              return W(this, te2, true);
            }
            peek(te2) {
              return W(this, te2, false);
            }
            pop() {
              let te2 = this[E].tail;
              return te2 ? (Ie2(this, te2), te2.value) : null;
            }
            del(te2) {
              Ie2(this, this[I].get(te2));
            }
            load(te2) {
              this.reset();
              let he = Date.now();
              for (let Pe2 = te2.length - 1; Pe2 >= 0; Pe2--) {
                let R = te2[Pe2], pe2 = R.e || 0;
                if (pe2 === 0)
                  this.set(R.k, R.v);
                else {
                  let ke2 = pe2 - he;
                  ke2 > 0 && this.set(R.k, R.v, ke2);
                }
              }
            }
            prune() {
              this[I].forEach((te2, he) => W(this, he, false));
            }
          }, W = (te2, he, Pe2) => {
            let R = te2[I].get(he);
            if (R) {
              let pe2 = R.value;
              if (K(te2, pe2)) {
                if (Ie2(te2, R), !te2[y])
                  return;
              } else
                Pe2 && (te2[c] && (R.value.now = Date.now()), te2[E].unshiftNode(R));
              return pe2.value;
            }
          }, K = (te2, he) => {
            if (!he || !he.maxAge && !te2[m])
              return false;
            let Pe2 = Date.now() - he.now;
            return he.maxAge ? Pe2 > he.maxAge : te2[m] && Pe2 > te2[m];
          }, ce2 = (te2) => {
            if (te2[D] > te2[h])
              for (let he = te2[E].tail; te2[D] > te2[h] && he !== null; ) {
                let Pe2 = he.prev;
                Ie2(te2, he), he = Pe2;
              }
          }, Ie2 = (te2, he) => {
            if (he) {
              let Pe2 = he.value;
              te2[C2] && te2[C2](Pe2.key, Pe2.value), te2[D] -= Pe2.length, te2[I].delete(Pe2.key), te2[E].removeNode(he);
            }
          }, me2 = class {
            constructor(te2, he, Pe2, R, pe2) {
              this.key = te2, this.value = he, this.length = Pe2, this.now = R, this.maxAge = pe2 || 0;
            }
          }, Ae2 = (te2, he, Pe2, R) => {
            let pe2 = Pe2.value;
            K(te2, pe2) && (Ie2(te2, Pe2), te2[y] || (pe2 = void 0)), pe2 && he.call(R, pe2.value, pe2.key, te2);
          };
          _.exports = q2;
        } }), ca = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/classes/range.js"(a, _) {
          De3();
          var v2 = class {
            constructor(ee2, je2) {
              if (je2 = P(je2), ee2 instanceof v2)
                return ee2.loose === !!je2.loose && ee2.includePrerelease === !!je2.includePrerelease ? ee2 : new v2(ee2.raw, je2);
              if (ee2 instanceof y)
                return this.raw = ee2.value, this.set = [[ee2]], this.format(), this;
              if (this.options = je2, this.loose = !!je2.loose, this.includePrerelease = !!je2.includePrerelease, this.raw = ee2, this.set = ee2.split("||").map((nt) => this.parseRange(nt.trim())).filter((nt) => nt.length), !this.set.length)
                throw new TypeError(`Invalid SemVer Range: ${ee2}`);
              if (this.set.length > 1) {
                let nt = this.set[0];
                if (this.set = this.set.filter((Ze2) => !q2(Ze2[0])), this.set.length === 0)
                  this.set = [nt];
                else if (this.set.length > 1) {
                  for (let Ze2 of this.set)
                    if (Ze2.length === 1 && W(Ze2[0])) {
                      this.set = [Ze2];
                      break;
                    }
                }
              }
              this.format();
            }
            format() {
              return this.range = this.set.map((ee2) => ee2.join(" ").trim()).join("||").trim(), this.range;
            }
            toString() {
              return this.range;
            }
            parseRange(ee2) {
              ee2 = ee2.trim();
              let nt = `parseRange:${Object.keys(this.options).join(",")}:${ee2}`, Ze2 = D.get(nt);
              if (Ze2)
                return Ze2;
              let st2 = this.options.loose, tt = st2 ? d2[E.HYPHENRANGELOOSE] : d2[E.HYPHENRANGE];
              ee2 = ee2.replace(tt, Je2(this.options.includePrerelease)), m("hyphen replace", ee2), ee2 = ee2.replace(d2[E.COMPARATORTRIM], I), m("comparator trim", ee2), ee2 = ee2.replace(d2[E.TILDETRIM], c), ee2 = ee2.replace(d2[E.CARETTRIM], M), ee2 = ee2.split(/\s+/).join(" ");
              let ct = ee2.split(" ").map((at3) => ce2(at3, this.options)).join(" ").split(/\s+/).map((at3) => ke2(at3, this.options));
              st2 && (ct = ct.filter((at3) => (m("loose invalid filter", at3, this.options), !!at3.match(d2[E.COMPARATORLOOSE])))), m("range list", ct);
              let ne2 = /* @__PURE__ */ new Map(), ge = ct.map((at3) => new y(at3, this.options));
              for (let at3 of ge) {
                if (q2(at3))
                  return [at3];
                ne2.set(at3.value, at3);
              }
              ne2.size > 1 && ne2.has("") && ne2.delete("");
              let Fe2 = [...ne2.values()];
              return D.set(nt, Fe2), Fe2;
            }
            intersects(ee2, je2) {
              if (!(ee2 instanceof v2))
                throw new TypeError("a Range is required");
              return this.set.some((nt) => K(nt, je2) && ee2.set.some((Ze2) => K(Ze2, je2) && nt.every((st2) => Ze2.every((tt) => st2.intersects(tt, je2)))));
            }
            test(ee2) {
              if (!ee2)
                return false;
              if (typeof ee2 == "string")
                try {
                  ee2 = new C2(ee2, this.options);
                } catch {
                  return false;
                }
              for (let je2 = 0; je2 < this.set.length; je2++)
                if (Xe2(this.set[je2], ee2, this.options))
                  return true;
              return false;
            }
          };
          _.exports = v2;
          var h = VW(), D = new h({ max: 1e3 }), P = y1(), y = b1(), m = g1(), C2 = Bn(), { re: d2, t: E, comparatorTrimReplace: I, tildeTrimReplace: c, caretTrimReplace: M } = Bc(), q2 = (ee2) => ee2.value === "<0.0.0-0", W = (ee2) => ee2.value === "", K = (ee2, je2) => {
            let nt = true, Ze2 = ee2.slice(), st2 = Ze2.pop();
            for (; nt && Ze2.length; )
              nt = Ze2.every((tt) => st2.intersects(tt, je2)), st2 = Ze2.pop();
            return nt;
          }, ce2 = (ee2, je2) => (m("comp", ee2, je2), ee2 = te2(ee2, je2), m("caret", ee2), ee2 = me2(ee2, je2), m("tildes", ee2), ee2 = Pe2(ee2, je2), m("xrange", ee2), ee2 = pe2(ee2, je2), m("stars", ee2), ee2), Ie2 = (ee2) => !ee2 || ee2.toLowerCase() === "x" || ee2 === "*", me2 = (ee2, je2) => ee2.trim().split(/\s+/).map((nt) => Ae2(nt, je2)).join(" "), Ae2 = (ee2, je2) => {
            let nt = je2.loose ? d2[E.TILDELOOSE] : d2[E.TILDE];
            return ee2.replace(nt, (Ze2, st2, tt, ct, ne2) => {
              m("tilde", ee2, Ze2, st2, tt, ct, ne2);
              let ge;
              return Ie2(st2) ? ge = "" : Ie2(tt) ? ge = `>=${st2}.0.0 <${+st2 + 1}.0.0-0` : Ie2(ct) ? ge = `>=${st2}.${tt}.0 <${st2}.${+tt + 1}.0-0` : ne2 ? (m("replaceTilde pr", ne2), ge = `>=${st2}.${tt}.${ct}-${ne2} <${st2}.${+tt + 1}.0-0`) : ge = `>=${st2}.${tt}.${ct} <${st2}.${+tt + 1}.0-0`, m("tilde return", ge), ge;
            });
          }, te2 = (ee2, je2) => ee2.trim().split(/\s+/).map((nt) => he(nt, je2)).join(" "), he = (ee2, je2) => {
            m("caret", ee2, je2);
            let nt = je2.loose ? d2[E.CARETLOOSE] : d2[E.CARET], Ze2 = je2.includePrerelease ? "-0" : "";
            return ee2.replace(nt, (st2, tt, ct, ne2, ge) => {
              m("caret", ee2, st2, tt, ct, ne2, ge);
              let Fe2;
              return Ie2(tt) ? Fe2 = "" : Ie2(ct) ? Fe2 = `>=${tt}.0.0${Ze2} <${+tt + 1}.0.0-0` : Ie2(ne2) ? tt === "0" ? Fe2 = `>=${tt}.${ct}.0${Ze2} <${tt}.${+ct + 1}.0-0` : Fe2 = `>=${tt}.${ct}.0${Ze2} <${+tt + 1}.0.0-0` : ge ? (m("replaceCaret pr", ge), tt === "0" ? ct === "0" ? Fe2 = `>=${tt}.${ct}.${ne2}-${ge} <${tt}.${ct}.${+ne2 + 1}-0` : Fe2 = `>=${tt}.${ct}.${ne2}-${ge} <${tt}.${+ct + 1}.0-0` : Fe2 = `>=${tt}.${ct}.${ne2}-${ge} <${+tt + 1}.0.0-0`) : (m("no pr"), tt === "0" ? ct === "0" ? Fe2 = `>=${tt}.${ct}.${ne2}${Ze2} <${tt}.${ct}.${+ne2 + 1}-0` : Fe2 = `>=${tt}.${ct}.${ne2}${Ze2} <${tt}.${+ct + 1}.0-0` : Fe2 = `>=${tt}.${ct}.${ne2} <${+tt + 1}.0.0-0`), m("caret return", Fe2), Fe2;
            });
          }, Pe2 = (ee2, je2) => (m("replaceXRanges", ee2, je2), ee2.split(/\s+/).map((nt) => R(nt, je2)).join(" ")), R = (ee2, je2) => {
            ee2 = ee2.trim();
            let nt = je2.loose ? d2[E.XRANGELOOSE] : d2[E.XRANGE];
            return ee2.replace(nt, (Ze2, st2, tt, ct, ne2, ge) => {
              m("xRange", ee2, Ze2, st2, tt, ct, ne2, ge);
              let Fe2 = Ie2(tt), at3 = Fe2 || Ie2(ct), Pt = at3 || Ie2(ne2), qt = Pt;
              return st2 === "=" && qt && (st2 = ""), ge = je2.includePrerelease ? "-0" : "", Fe2 ? st2 === ">" || st2 === "<" ? Ze2 = "<0.0.0-0" : Ze2 = "*" : st2 && qt ? (at3 && (ct = 0), ne2 = 0, st2 === ">" ? (st2 = ">=", at3 ? (tt = +tt + 1, ct = 0, ne2 = 0) : (ct = +ct + 1, ne2 = 0)) : st2 === "<=" && (st2 = "<", at3 ? tt = +tt + 1 : ct = +ct + 1), st2 === "<" && (ge = "-0"), Ze2 = `${st2 + tt}.${ct}.${ne2}${ge}`) : at3 ? Ze2 = `>=${tt}.0.0${ge} <${+tt + 1}.0.0-0` : Pt && (Ze2 = `>=${tt}.${ct}.0${ge} <${tt}.${+ct + 1}.0-0`), m("xRange return", Ze2), Ze2;
            });
          }, pe2 = (ee2, je2) => (m("replaceStars", ee2, je2), ee2.trim().replace(d2[E.STAR], "")), ke2 = (ee2, je2) => (m("replaceGTE0", ee2, je2), ee2.trim().replace(d2[je2.includePrerelease ? E.GTE0PRE : E.GTE0], "")), Je2 = (ee2) => (je2, nt, Ze2, st2, tt, ct, ne2, ge, Fe2, at3, Pt, qt, Zr2) => (Ie2(Ze2) ? nt = "" : Ie2(st2) ? nt = `>=${Ze2}.0.0${ee2 ? "-0" : ""}` : Ie2(tt) ? nt = `>=${Ze2}.${st2}.0${ee2 ? "-0" : ""}` : ct ? nt = `>=${nt}` : nt = `>=${nt}${ee2 ? "-0" : ""}`, Ie2(Fe2) ? ge = "" : Ie2(at3) ? ge = `<${+Fe2 + 1}.0.0-0` : Ie2(Pt) ? ge = `<${Fe2}.${+at3 + 1}.0-0` : qt ? ge = `<=${Fe2}.${at3}.${Pt}-${qt}` : ee2 ? ge = `<${Fe2}.${at3}.${+Pt + 1}-0` : ge = `<=${ge}`, `${nt} ${ge}`.trim()), Xe2 = (ee2, je2, nt) => {
            for (let Ze2 = 0; Ze2 < ee2.length; Ze2++)
              if (!ee2[Ze2].test(je2))
                return false;
            if (je2.prerelease.length && !nt.includePrerelease) {
              for (let Ze2 = 0; Ze2 < ee2.length; Ze2++)
                if (m(ee2[Ze2].semver), ee2[Ze2].semver !== y.ANY && ee2[Ze2].semver.prerelease.length > 0) {
                  let st2 = ee2[Ze2].semver;
                  if (st2.major === je2.major && st2.minor === je2.minor && st2.patch === je2.patch)
                    return true;
                }
              return false;
            }
            return true;
          };
        } }), b1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/classes/comparator.js"(a, _) {
          De3();
          var v2 = Symbol("SemVer ANY"), h = class {
            static get ANY() {
              return v2;
            }
            constructor(I, c) {
              if (c = D(c), I instanceof h) {
                if (I.loose === !!c.loose)
                  return I;
                I = I.value;
              }
              C2("comparator", I, c), this.options = c, this.loose = !!c.loose, this.parse(I), this.semver === v2 ? this.value = "" : this.value = this.operator + this.semver.version, C2("comp", this);
            }
            parse(I) {
              let c = this.options.loose ? P[y.COMPARATORLOOSE] : P[y.COMPARATOR], M = I.match(c);
              if (!M)
                throw new TypeError(`Invalid comparator: ${I}`);
              this.operator = M[1] !== void 0 ? M[1] : "", this.operator === "=" && (this.operator = ""), M[2] ? this.semver = new d2(M[2], this.options.loose) : this.semver = v2;
            }
            toString() {
              return this.value;
            }
            test(I) {
              if (C2("Comparator.test", I, this.options.loose), this.semver === v2 || I === v2)
                return true;
              if (typeof I == "string")
                try {
                  I = new d2(I, this.options);
                } catch {
                  return false;
                }
              return m(I, this.operator, this.semver, this.options);
            }
            intersects(I, c) {
              if (!(I instanceof h))
                throw new TypeError("a Comparator is required");
              if ((!c || typeof c != "object") && (c = { loose: !!c, includePrerelease: false }), this.operator === "")
                return this.value === "" ? true : new E(I.value, c).test(this.value);
              if (I.operator === "")
                return I.value === "" ? true : new E(this.value, c).test(I.semver);
              let M = (this.operator === ">=" || this.operator === ">") && (I.operator === ">=" || I.operator === ">"), q2 = (this.operator === "<=" || this.operator === "<") && (I.operator === "<=" || I.operator === "<"), W = this.semver.version === I.semver.version, K = (this.operator === ">=" || this.operator === "<=") && (I.operator === ">=" || I.operator === "<="), ce2 = m(this.semver, "<", I.semver, c) && (this.operator === ">=" || this.operator === ">") && (I.operator === "<=" || I.operator === "<"), Ie2 = m(this.semver, ">", I.semver, c) && (this.operator === "<=" || this.operator === "<") && (I.operator === ">=" || I.operator === ">");
              return M || q2 || W && K || ce2 || Ie2;
            }
          };
          _.exports = h;
          var D = y1(), { re: P, t: y } = Bc(), m = V9(), C2 = g1(), d2 = Bn(), E = ca();
        } }), T1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/functions/satisfies.js"(a, _) {
          De3();
          var v2 = ca(), h = (D, P, y) => {
            try {
              P = new v2(P, y);
            } catch {
              return false;
            }
            return P.test(D);
          };
          _.exports = h;
        } }), HW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/to-comparators.js"(a, _) {
          De3();
          var v2 = ca(), h = (D, P) => new v2(D, P).set.map((y) => y.map((m) => m.value).join(" ").trim().split(" "));
          _.exports = h;
        } }), GW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/max-satisfying.js"(a, _) {
          De3();
          var v2 = Bn(), h = ca(), D = (P, y, m) => {
            let C2 = null, d2 = null, E = null;
            try {
              E = new h(y, m);
            } catch {
              return null;
            }
            return P.forEach((I) => {
              E.test(I) && (!C2 || d2.compare(I) === -1) && (C2 = I, d2 = new v2(C2, m));
            }), C2;
          };
          _.exports = D;
        } }), $W = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/min-satisfying.js"(a, _) {
          De3();
          var v2 = Bn(), h = ca(), D = (P, y, m) => {
            let C2 = null, d2 = null, E = null;
            try {
              E = new h(y, m);
            } catch {
              return null;
            }
            return P.forEach((I) => {
              E.test(I) && (!C2 || d2.compare(I) === 1) && (C2 = I, d2 = new v2(C2, m));
            }), C2;
          };
          _.exports = D;
        } }), KW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/min-version.js"(a, _) {
          De3();
          var v2 = Bn(), h = ca(), D = v1(), P = (y, m) => {
            y = new h(y, m);
            let C2 = new v2("0.0.0");
            if (y.test(C2) || (C2 = new v2("0.0.0-0"), y.test(C2)))
              return C2;
            C2 = null;
            for (let d2 = 0; d2 < y.set.length; ++d2) {
              let E = y.set[d2], I = null;
              E.forEach((c) => {
                let M = new v2(c.semver.version);
                switch (c.operator) {
                  case ">":
                    M.prerelease.length === 0 ? M.patch++ : M.prerelease.push(0), M.raw = M.format();
                  case "":
                  case ">=":
                    (!I || D(M, I)) && (I = M);
                    break;
                  case "<":
                  case "<=":
                    break;
                  default:
                    throw new Error(`Unexpected operation: ${c.operator}`);
                }
              }), I && (!C2 || D(C2, I)) && (C2 = I);
            }
            return C2 && y.test(C2) ? C2 : null;
          };
          _.exports = P;
        } }), XW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/valid.js"(a, _) {
          De3();
          var v2 = ca(), h = (D, P) => {
            try {
              return new v2(D, P).range || "*";
            } catch {
              return null;
            }
          };
          _.exports = h;
        } }), uT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/outside.js"(a, _) {
          De3();
          var v2 = Bn(), h = b1(), { ANY: D } = h, P = ca(), y = T1(), m = v1(), C2 = _T(), d2 = lT(), E = cT(), I = (c, M, q2, W) => {
            c = new v2(c, W), M = new P(M, W);
            let K, ce2, Ie2, me2, Ae2;
            switch (q2) {
              case ">":
                K = m, ce2 = d2, Ie2 = C2, me2 = ">", Ae2 = ">=";
                break;
              case "<":
                K = C2, ce2 = E, Ie2 = m, me2 = "<", Ae2 = "<=";
                break;
              default:
                throw new TypeError('Must provide a hilo val of "<" or ">"');
            }
            if (y(c, M, W))
              return false;
            for (let te2 = 0; te2 < M.set.length; ++te2) {
              let he = M.set[te2], Pe2 = null, R = null;
              if (he.forEach((pe2) => {
                pe2.semver === D && (pe2 = new h(">=0.0.0")), Pe2 = Pe2 || pe2, R = R || pe2, K(pe2.semver, Pe2.semver, W) ? Pe2 = pe2 : Ie2(pe2.semver, R.semver, W) && (R = pe2);
              }), Pe2.operator === me2 || Pe2.operator === Ae2 || (!R.operator || R.operator === me2) && ce2(c, R.semver))
                return false;
              if (R.operator === Ae2 && Ie2(c, R.semver))
                return false;
            }
            return true;
          };
          _.exports = I;
        } }), YW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/gtr.js"(a, _) {
          De3();
          var v2 = uT(), h = (D, P, y) => v2(D, P, ">", y);
          _.exports = h;
        } }), QW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/ltr.js"(a, _) {
          De3();
          var v2 = uT(), h = (D, P, y) => v2(D, P, "<", y);
          _.exports = h;
        } }), ZW = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/intersects.js"(a, _) {
          De3();
          var v2 = ca(), h = (D, P, y) => (D = new v2(D, y), P = new v2(P, y), D.intersects(P));
          _.exports = h;
        } }), eV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/simplify.js"(a, _) {
          De3();
          var v2 = T1(), h = _a();
          _.exports = (D, P, y) => {
            let m = [], C2 = null, d2 = null, E = D.sort((q2, W) => h(q2, W, y));
            for (let q2 of E)
              v2(q2, P, y) ? (d2 = q2, C2 || (C2 = q2)) : (d2 && m.push([C2, d2]), d2 = null, C2 = null);
            C2 && m.push([C2, null]);
            let I = [];
            for (let [q2, W] of m)
              q2 === W ? I.push(q2) : !W && q2 === E[0] ? I.push("*") : W ? q2 === E[0] ? I.push(`<=${W}`) : I.push(`${q2} - ${W}`) : I.push(`>=${q2}`);
            let c = I.join(" || "), M = typeof P.raw == "string" ? P.raw : String(P);
            return c.length < M.length ? c : P;
          };
        } }), tV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/ranges/subset.js"(a, _) {
          De3();
          var v2 = ca(), h = b1(), { ANY: D } = h, P = T1(), y = _a(), m = function(I, c) {
            let M = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (I === c)
              return true;
            I = new v2(I, M), c = new v2(c, M);
            let q2 = false;
            e:
              for (let W of I.set) {
                for (let K of c.set) {
                  let ce2 = C2(W, K, M);
                  if (q2 = q2 || ce2 !== null, ce2)
                    continue e;
                }
                if (q2)
                  return false;
              }
            return true;
          }, C2 = (I, c, M) => {
            if (I === c)
              return true;
            if (I.length === 1 && I[0].semver === D) {
              if (c.length === 1 && c[0].semver === D)
                return true;
              M.includePrerelease ? I = [new h(">=0.0.0-0")] : I = [new h(">=0.0.0")];
            }
            if (c.length === 1 && c[0].semver === D) {
              if (M.includePrerelease)
                return true;
              c = [new h(">=0.0.0")];
            }
            let q2 = /* @__PURE__ */ new Set(), W, K;
            for (let R of I)
              R.operator === ">" || R.operator === ">=" ? W = d2(W, R, M) : R.operator === "<" || R.operator === "<=" ? K = E(K, R, M) : q2.add(R.semver);
            if (q2.size > 1)
              return null;
            let ce2;
            if (W && K) {
              if (ce2 = y(W.semver, K.semver, M), ce2 > 0)
                return null;
              if (ce2 === 0 && (W.operator !== ">=" || K.operator !== "<="))
                return null;
            }
            for (let R of q2) {
              if (W && !P(R, String(W), M) || K && !P(R, String(K), M))
                return null;
              for (let pe2 of c)
                if (!P(R, String(pe2), M))
                  return false;
              return true;
            }
            let Ie2, me2, Ae2, te2, he = K && !M.includePrerelease && K.semver.prerelease.length ? K.semver : false, Pe2 = W && !M.includePrerelease && W.semver.prerelease.length ? W.semver : false;
            he && he.prerelease.length === 1 && K.operator === "<" && he.prerelease[0] === 0 && (he = false);
            for (let R of c) {
              if (te2 = te2 || R.operator === ">" || R.operator === ">=", Ae2 = Ae2 || R.operator === "<" || R.operator === "<=", W) {
                if (Pe2 && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === Pe2.major && R.semver.minor === Pe2.minor && R.semver.patch === Pe2.patch && (Pe2 = false), R.operator === ">" || R.operator === ">=") {
                  if (Ie2 = d2(W, R, M), Ie2 === R && Ie2 !== W)
                    return false;
                } else if (W.operator === ">=" && !P(W.semver, String(R), M))
                  return false;
              }
              if (K) {
                if (he && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === he.major && R.semver.minor === he.minor && R.semver.patch === he.patch && (he = false), R.operator === "<" || R.operator === "<=") {
                  if (me2 = E(K, R, M), me2 === R && me2 !== K)
                    return false;
                } else if (K.operator === "<=" && !P(K.semver, String(R), M))
                  return false;
              }
              if (!R.operator && (K || W) && ce2 !== 0)
                return false;
            }
            return !(W && Ae2 && !K && ce2 !== 0 || K && te2 && !W && ce2 !== 0 || Pe2 || he);
          }, d2 = (I, c, M) => {
            if (!I)
              return c;
            let q2 = y(I.semver, c.semver, M);
            return q2 > 0 ? I : q2 < 0 || c.operator === ">" && I.operator === ">=" ? c : I;
          }, E = (I, c, M) => {
            if (!I)
              return c;
            let q2 = y(I.semver, c.semver, M);
            return q2 < 0 ? I : q2 > 0 || c.operator === "<" && I.operator === "<=" ? c : I;
          };
          _.exports = m;
        } }), pT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/semver/index.js"(a, _) {
          De3();
          var v2 = Bc(), h = h1(), D = Bn(), P = z9(), y = qc(), m = kW(), C2 = IW(), d2 = NW(), E = OW(), I = MW(), c = LW(), M = RW(), q2 = jW(), W = _a(), K = JW(), ce2 = FW(), Ie2 = oT(), me2 = BW(), Ae2 = qW(), te2 = v1(), he = _T(), Pe2 = sT(), R = W9(), pe2 = cT(), ke2 = lT(), Je2 = V9(), Xe2 = UW(), ee2 = b1(), je2 = ca(), nt = T1(), Ze2 = HW(), st2 = GW(), tt = $W(), ct = KW(), ne2 = XW(), ge = uT(), Fe2 = YW(), at3 = QW(), Pt = ZW(), qt = eV(), Zr2 = tV();
          _.exports = { parse: y, valid: m, clean: C2, inc: d2, diff: E, major: I, minor: c, patch: M, prerelease: q2, compare: W, rcompare: K, compareLoose: ce2, compareBuild: Ie2, sort: me2, rsort: Ae2, gt: te2, lt: he, eq: Pe2, neq: R, gte: pe2, lte: ke2, cmp: Je2, coerce: Xe2, Comparator: ee2, Range: je2, satisfies: nt, toComparators: Ze2, maxSatisfying: st2, minSatisfying: tt, minVersion: ct, validRange: ne2, outside: ge, gtr: Fe2, ltr: at3, intersects: Pt, simplifyRange: qt, subset: Zr2, SemVer: D, re: v2.re, src: v2.src, tokens: v2.t, SEMVER_SPEC_VERSION: h.SEMVER_SPEC_VERSION, compareIdentifiers: P.compareIdentifiers, rcompareIdentifiers: P.rcompareIdentifiers };
        } }), S1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/version-check.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(C2, d2, E, I) {
            I === void 0 && (I = E);
            var c = Object.getOwnPropertyDescriptor(d2, E);
            (!c || ("get" in c ? !d2.__esModule : c.writable || c.configurable)) && (c = { enumerable: true, get: function() {
              return d2[E];
            } }), Object.defineProperty(C2, I, c);
          } : function(C2, d2, E, I) {
            I === void 0 && (I = E), C2[I] = d2[E];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(C2, d2) {
            Object.defineProperty(C2, "default", { enumerable: true, value: d2 });
          } : function(C2, d2) {
            C2.default = d2;
          }), h = a && a.__importStar || function(C2) {
            if (C2 && C2.__esModule)
              return C2;
            var d2 = {};
            if (C2 != null)
              for (var E in C2)
                E !== "default" && Object.prototype.hasOwnProperty.call(C2, E) && _(d2, C2, E);
            return v2(d2, C2), d2;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.typescriptVersionIsAtLeast = void 0;
          var D = h(pT()), P = h(vr()), y = ["3.7", "3.8", "3.9", "4.0", "4.1", "4.2", "4.3", "4.4", "4.5", "4.6", "4.7", "4.8", "4.9", "5.0"], m = {};
          a.typescriptVersionIsAtLeast = m;
          for (let C2 of y)
            m[C2] = true;
        } }), fT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/getModifiers.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(d2, E, I, c) {
            c === void 0 && (c = I);
            var M = Object.getOwnPropertyDescriptor(E, I);
            (!M || ("get" in M ? !E.__esModule : M.writable || M.configurable)) && (M = { enumerable: true, get: function() {
              return E[I];
            } }), Object.defineProperty(d2, c, M);
          } : function(d2, E, I, c) {
            c === void 0 && (c = I), d2[c] = E[I];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(d2, E) {
            Object.defineProperty(d2, "default", { enumerable: true, value: E });
          } : function(d2, E) {
            d2.default = E;
          }), h = a && a.__importStar || function(d2) {
            if (d2 && d2.__esModule)
              return d2;
            var E = {};
            if (d2 != null)
              for (var I in d2)
                I !== "default" && Object.prototype.hasOwnProperty.call(d2, I) && _(E, d2, I);
            return v2(E, d2), E;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getDecorators = a.getModifiers = void 0;
          var D = h(vr()), P = S1(), y = P.typescriptVersionIsAtLeast["4.8"];
          function m(d2) {
            var E;
            if (d2 != null) {
              if (y) {
                if (D.canHaveModifiers(d2)) {
                  let I = D.getModifiers(d2);
                  return I ? Array.from(I) : void 0;
                }
                return;
              }
              return (E = d2.modifiers) === null || E === void 0 ? void 0 : E.filter((I) => !D.isDecorator(I));
            }
          }
          a.getModifiers = m;
          function C2(d2) {
            var E;
            if (d2 != null) {
              if (y) {
                if (D.canHaveDecorators(d2)) {
                  let I = D.getDecorators(d2);
                  return I ? Array.from(I) : void 0;
                }
                return;
              }
              return (E = d2.decorators) === null || E === void 0 ? void 0 : E.filter(D.isDecorator);
            }
          }
          a.getDecorators = C2;
        } }), rV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/jsx/xhtml-entities.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.xhtmlEntities = void 0, a.xhtmlEntities = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "Â ", iexcl: "Â¡", cent: "Â¢", pound: "Â£", curren: "Â¤", yen: "Â¥", brvbar: "Â¦", sect: "Â§", uml: "Â¨", copy: "Â©", ordf: "Âª", laquo: "Â«", not: "Â¬", shy: "Â­", reg: "Â®", macr: "Â¯", deg: "Â°", plusmn: "Â±", sup2: "Â²", sup3: "Â³", acute: "Â´", micro: "Âµ", para: "Â¶", middot: "Â·", cedil: "Â¸", sup1: "Â¹", ordm: "Âº", raquo: "Â»", frac14: "Â¼", frac12: "Â½", frac34: "Â¾", iquest: "Â¿", Agrave: "Ã", Aacute: "Ã", Acirc: "Ã", Atilde: "Ã", Auml: "Ã", Aring: "Ã", AElig: "Ã", Ccedil: "Ã", Egrave: "Ã", Eacute: "Ã", Ecirc: "Ã", Euml: "Ã", Igrave: "Ã", Iacute: "Ã", Icirc: "Ã", Iuml: "Ã", ETH: "Ã", Ntilde: "Ã", Ograve: "Ã", Oacute: "Ã", Ocirc: "Ã", Otilde: "Ã", Ouml: "Ã", times: "Ã", Oslash: "Ã", Ugrave: "Ã", Uacute: "Ã", Ucirc: "Ã", Uuml: "Ã", Yacute: "Ã", THORN: "Ã", szlig: "Ã", agrave: "Ã ", aacute: "Ã¡", acirc: "Ã¢", atilde: "Ã£", auml: "Ã¤", aring: "Ã¥", aelig: "Ã¦", ccedil: "Ã§", egrave: "Ã¨", eacute: "Ã©", ecirc: "Ãª", euml: "Ã«", igrave: "Ã¬", iacute: "Ã­", icirc: "Ã®", iuml: "Ã¯", eth: "Ã°", ntilde: "Ã±", ograve: "Ã²", oacute: "Ã³", ocirc: "Ã´", otilde: "Ãµ", ouml: "Ã¶", divide: "Ã·", oslash: "Ã¸", ugrave: "Ã¹", uacute: "Ãº", ucirc: "Ã»", uuml: "Ã¼", yacute: "Ã½", thorn: "Ã¾", yuml: "Ã¿", OElig: "Å", oelig: "Å", Scaron: "Å ", scaron: "Å¡", Yuml: "Å¸", fnof: "Æ", circ: "Ë", tilde: "Ë", Alpha: "Î", Beta: "Î", Gamma: "Î", Delta: "Î", Epsilon: "Î", Zeta: "Î", Eta: "Î", Theta: "Î", Iota: "Î", Kappa: "Î", Lambda: "Î", Mu: "Î", Nu: "Î", Xi: "Î", Omicron: "Î", Pi: "Î ", Rho: "Î¡", Sigma: "Î£", Tau: "Î¤", Upsilon: "Î¥", Phi: "Î¦", Chi: "Î§", Psi: "Î¨", Omega: "Î©", alpha: "Î±", beta: "Î²", gamma: "Î³", delta: "Î´", epsilon: "Îµ", zeta: "Î¶", eta: "Î·", theta: "Î¸", iota: "Î¹", kappa: "Îº", lambda: "Î»", mu: "Î¼", nu: "Î½", xi: "Î¾", omicron: "Î¿", pi: "Ï", rho: "Ï", sigmaf: "Ï", sigma: "Ï", tau: "Ï", upsilon: "Ï", phi: "Ï", chi: "Ï", psi: "Ï", omega: "Ï", thetasym: "Ï", upsih: "Ï", piv: "Ï", ensp: "â", emsp: "â", thinsp: "â", zwnj: "â", zwj: "â", lrm: "â", rlm: "â", ndash: "â", mdash: "â", lsquo: "â", rsquo: "â", sbquo: "â", ldquo: "â", rdquo: "â", bdquo: "â", dagger: "â ", Dagger: "â¡", bull: "â¢", hellip: "â¦", permil: "â°", prime: "â²", Prime: "â³", lsaquo: "â¹", rsaquo: "âº", oline: "â¾", frasl: "â", euro: "â¬", image: "â", weierp: "â", real: "â", trade: "â¢", alefsym: "âµ", larr: "â", uarr: "â", rarr: "â", darr: "â", harr: "â", crarr: "âµ", lArr: "â", uArr: "â", rArr: "â", dArr: "â", hArr: "â", forall: "â", part: "â", exist: "â", empty: "â", nabla: "â", isin: "â", notin: "â", ni: "â", prod: "â", sum: "â", minus: "â", lowast: "â", radic: "â", prop: "â", infin: "â", ang: "â ", and: "â§", or: "â¨", cap: "â©", cup: "âª", int: "â«", there4: "â´", sim: "â¼", cong: "â", asymp: "â", ne: "â ", equiv: "â¡", le: "â¤", ge: "â¥", sub: "â", sup: "â", nsub: "â", sube: "â", supe: "â", oplus: "â", otimes: "â", perp: "â¥", sdot: "â", lceil: "â", rceil: "â", lfloor: "â", rfloor: "â", lang: "â©", rang: "âª", loz: "â", spades: "â ", clubs: "â£", hearts: "â¥", diams: "â¦" };
        } }), H9 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/generated/ast-spec.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.AST_TOKEN_TYPES = a.AST_NODE_TYPES = void 0;
          var _;
          (function(h) {
            h.AccessorProperty = "AccessorProperty", h.ArrayExpression = "ArrayExpression", h.ArrayPattern = "ArrayPattern", h.ArrowFunctionExpression = "ArrowFunctionExpression", h.AssignmentExpression = "AssignmentExpression", h.AssignmentPattern = "AssignmentPattern", h.AwaitExpression = "AwaitExpression", h.BinaryExpression = "BinaryExpression", h.BlockStatement = "BlockStatement", h.BreakStatement = "BreakStatement", h.CallExpression = "CallExpression", h.CatchClause = "CatchClause", h.ChainExpression = "ChainExpression", h.ClassBody = "ClassBody", h.ClassDeclaration = "ClassDeclaration", h.ClassExpression = "ClassExpression", h.ConditionalExpression = "ConditionalExpression", h.ContinueStatement = "ContinueStatement", h.DebuggerStatement = "DebuggerStatement", h.Decorator = "Decorator", h.DoWhileStatement = "DoWhileStatement", h.EmptyStatement = "EmptyStatement", h.ExportAllDeclaration = "ExportAllDeclaration", h.ExportDefaultDeclaration = "ExportDefaultDeclaration", h.ExportNamedDeclaration = "ExportNamedDeclaration", h.ExportSpecifier = "ExportSpecifier", h.ExpressionStatement = "ExpressionStatement", h.ForInStatement = "ForInStatement", h.ForOfStatement = "ForOfStatement", h.ForStatement = "ForStatement", h.FunctionDeclaration = "FunctionDeclaration", h.FunctionExpression = "FunctionExpression", h.Identifier = "Identifier", h.IfStatement = "IfStatement", h.ImportAttribute = "ImportAttribute", h.ImportDeclaration = "ImportDeclaration", h.ImportDefaultSpecifier = "ImportDefaultSpecifier", h.ImportExpression = "ImportExpression", h.ImportNamespaceSpecifier = "ImportNamespaceSpecifier", h.ImportSpecifier = "ImportSpecifier", h.JSXAttribute = "JSXAttribute", h.JSXClosingElement = "JSXClosingElement", h.JSXClosingFragment = "JSXClosingFragment", h.JSXElement = "JSXElement", h.JSXEmptyExpression = "JSXEmptyExpression", h.JSXExpressionContainer = "JSXExpressionContainer", h.JSXFragment = "JSXFragment", h.JSXIdentifier = "JSXIdentifier", h.JSXMemberExpression = "JSXMemberExpression", h.JSXNamespacedName = "JSXNamespacedName", h.JSXOpeningElement = "JSXOpeningElement", h.JSXOpeningFragment = "JSXOpeningFragment", h.JSXSpreadAttribute = "JSXSpreadAttribute", h.JSXSpreadChild = "JSXSpreadChild", h.JSXText = "JSXText", h.LabeledStatement = "LabeledStatement", h.Literal = "Literal", h.LogicalExpression = "LogicalExpression", h.MemberExpression = "MemberExpression", h.MetaProperty = "MetaProperty", h.MethodDefinition = "MethodDefinition", h.NewExpression = "NewExpression", h.ObjectExpression = "ObjectExpression", h.ObjectPattern = "ObjectPattern", h.PrivateIdentifier = "PrivateIdentifier", h.Program = "Program", h.Property = "Property", h.PropertyDefinition = "PropertyDefinition", h.RestElement = "RestElement", h.ReturnStatement = "ReturnStatement", h.SequenceExpression = "SequenceExpression", h.SpreadElement = "SpreadElement", h.StaticBlock = "StaticBlock", h.Super = "Super", h.SwitchCase = "SwitchCase", h.SwitchStatement = "SwitchStatement", h.TaggedTemplateExpression = "TaggedTemplateExpression", h.TemplateElement = "TemplateElement", h.TemplateLiteral = "TemplateLiteral", h.ThisExpression = "ThisExpression", h.ThrowStatement = "ThrowStatement", h.TryStatement = "TryStatement", h.UnaryExpression = "UnaryExpression", h.UpdateExpression = "UpdateExpression", h.VariableDeclaration = "VariableDeclaration", h.VariableDeclarator = "VariableDeclarator", h.WhileStatement = "WhileStatement", h.WithStatement = "WithStatement", h.YieldExpression = "YieldExpression", h.TSAbstractAccessorProperty = "TSAbstractAccessorProperty", h.TSAbstractKeyword = "TSAbstractKeyword", h.TSAbstractMethodDefinition = "TSAbstractMethodDefinition", h.TSAbstractPropertyDefinition = "TSAbstractPropertyDefinition", h.TSAnyKeyword = "TSAnyKeyword", h.TSArrayType = "TSArrayType", h.TSAsExpression = "TSAsExpression", h.TSAsyncKeyword = "TSAsyncKeyword", h.TSBigIntKeyword = "TSBigIntKeyword", h.TSBooleanKeyword = "TSBooleanKeyword", h.TSCallSignatureDeclaration = "TSCallSignatureDeclaration", h.TSClassImplements = "TSClassImplements", h.TSConditionalType = "TSConditionalType", h.TSConstructorType = "TSConstructorType", h.TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration", h.TSDeclareFunction = "TSDeclareFunction", h.TSDeclareKeyword = "TSDeclareKeyword", h.TSEmptyBodyFunctionExpression = "TSEmptyBodyFunctionExpression", h.TSEnumDeclaration = "TSEnumDeclaration", h.TSEnumMember = "TSEnumMember", h.TSExportAssignment = "TSExportAssignment", h.TSExportKeyword = "TSExportKeyword", h.TSExternalModuleReference = "TSExternalModuleReference", h.TSFunctionType = "TSFunctionType", h.TSInstantiationExpression = "TSInstantiationExpression", h.TSImportEqualsDeclaration = "TSImportEqualsDeclaration", h.TSImportType = "TSImportType", h.TSIndexedAccessType = "TSIndexedAccessType", h.TSIndexSignature = "TSIndexSignature", h.TSInferType = "TSInferType", h.TSInterfaceBody = "TSInterfaceBody", h.TSInterfaceDeclaration = "TSInterfaceDeclaration", h.TSInterfaceHeritage = "TSInterfaceHeritage", h.TSIntersectionType = "TSIntersectionType", h.TSIntrinsicKeyword = "TSIntrinsicKeyword", h.TSLiteralType = "TSLiteralType", h.TSMappedType = "TSMappedType", h.TSMethodSignature = "TSMethodSignature", h.TSModuleBlock = "TSModuleBlock", h.TSModuleDeclaration = "TSModuleDeclaration", h.TSNamedTupleMember = "TSNamedTupleMember", h.TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration", h.TSNeverKeyword = "TSNeverKeyword", h.TSNonNullExpression = "TSNonNullExpression", h.TSNullKeyword = "TSNullKeyword", h.TSNumberKeyword = "TSNumberKeyword", h.TSObjectKeyword = "TSObjectKeyword", h.TSOptionalType = "TSOptionalType", h.TSParameterProperty = "TSParameterProperty", h.TSPrivateKeyword = "TSPrivateKeyword", h.TSPropertySignature = "TSPropertySignature", h.TSProtectedKeyword = "TSProtectedKeyword", h.TSPublicKeyword = "TSPublicKeyword", h.TSQualifiedName = "TSQualifiedName", h.TSReadonlyKeyword = "TSReadonlyKeyword", h.TSRestType = "TSRestType", h.TSSatisfiesExpression = "TSSatisfiesExpression", h.TSStaticKeyword = "TSStaticKeyword", h.TSStringKeyword = "TSStringKeyword", h.TSSymbolKeyword = "TSSymbolKeyword", h.TSTemplateLiteralType = "TSTemplateLiteralType", h.TSThisType = "TSThisType", h.TSTupleType = "TSTupleType", h.TSTypeAliasDeclaration = "TSTypeAliasDeclaration", h.TSTypeAnnotation = "TSTypeAnnotation", h.TSTypeAssertion = "TSTypeAssertion", h.TSTypeLiteral = "TSTypeLiteral", h.TSTypeOperator = "TSTypeOperator", h.TSTypeParameter = "TSTypeParameter", h.TSTypeParameterDeclaration = "TSTypeParameterDeclaration", h.TSTypeParameterInstantiation = "TSTypeParameterInstantiation", h.TSTypePredicate = "TSTypePredicate", h.TSTypeQuery = "TSTypeQuery", h.TSTypeReference = "TSTypeReference", h.TSUndefinedKeyword = "TSUndefinedKeyword", h.TSUnionType = "TSUnionType", h.TSUnknownKeyword = "TSUnknownKeyword", h.TSVoidKeyword = "TSVoidKeyword";
          })(_ = a.AST_NODE_TYPES || (a.AST_NODE_TYPES = {}));
          var v2;
          (function(h) {
            h.Boolean = "Boolean", h.Identifier = "Identifier", h.JSXIdentifier = "JSXIdentifier", h.JSXText = "JSXText", h.Keyword = "Keyword", h.Null = "Null", h.Numeric = "Numeric", h.Punctuator = "Punctuator", h.RegularExpression = "RegularExpression", h.String = "String", h.Template = "Template", h.Block = "Block", h.Line = "Line";
          })(v2 = a.AST_TOKEN_TYPES || (a.AST_TOKEN_TYPES = {}));
        } }), nV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/lib.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
        } }), iV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/parser-options.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
        } }), aV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/ts-estree.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(D, P, y, m) {
            m === void 0 && (m = y);
            var C2 = Object.getOwnPropertyDescriptor(P, y);
            (!C2 || ("get" in C2 ? !P.__esModule : C2.writable || C2.configurable)) && (C2 = { enumerable: true, get: function() {
              return P[y];
            } }), Object.defineProperty(D, m, C2);
          } : function(D, P, y, m) {
            m === void 0 && (m = y), D[m] = P[y];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(D, P) {
            Object.defineProperty(D, "default", { enumerable: true, value: P });
          } : function(D, P) {
            D.default = P;
          }), h = a && a.__importStar || function(D) {
            if (D && D.__esModule)
              return D;
            var P = {};
            if (D != null)
              for (var y in D)
                y !== "default" && Object.prototype.hasOwnProperty.call(D, y) && _(P, D, y);
            return v2(P, D), P;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.TSESTree = void 0, a.TSESTree = h(H9());
        } }), sV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/index.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(D, P, y, m) {
            m === void 0 && (m = y);
            var C2 = Object.getOwnPropertyDescriptor(P, y);
            (!C2 || ("get" in C2 ? !P.__esModule : C2.writable || C2.configurable)) && (C2 = { enumerable: true, get: function() {
              return P[y];
            } }), Object.defineProperty(D, m, C2);
          } : function(D, P, y, m) {
            m === void 0 && (m = y), D[m] = P[y];
          }), v2 = a && a.__exportStar || function(D, P) {
            for (var y in D)
              y !== "default" && !Object.prototype.hasOwnProperty.call(P, y) && _(P, D, y);
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.AST_TOKEN_TYPES = a.AST_NODE_TYPES = void 0;
          var h = H9();
          Object.defineProperty(a, "AST_NODE_TYPES", { enumerable: true, get: function() {
            return h.AST_NODE_TYPES;
          } }), Object.defineProperty(a, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
            return h.AST_TOKEN_TYPES;
          } }), v2(nV(), a), v2(iV(), a), v2(aV(), a);
        } }), oV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/ts-nodes.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
        } }), _V = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/estree-to-ts-node-types.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
        } }), x1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/index.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(D, P, y, m) {
            m === void 0 && (m = y);
            var C2 = Object.getOwnPropertyDescriptor(P, y);
            (!C2 || ("get" in C2 ? !P.__esModule : C2.writable || C2.configurable)) && (C2 = { enumerable: true, get: function() {
              return P[y];
            } }), Object.defineProperty(D, m, C2);
          } : function(D, P, y, m) {
            m === void 0 && (m = y), D[m] = P[y];
          }), v2 = a && a.__exportStar || function(D, P) {
            for (var y in D)
              y !== "default" && !Object.prototype.hasOwnProperty.call(P, y) && _(P, D, y);
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.TSESTree = a.AST_TOKEN_TYPES = a.AST_NODE_TYPES = void 0;
          var h = sV();
          Object.defineProperty(a, "AST_NODE_TYPES", { enumerable: true, get: function() {
            return h.AST_NODE_TYPES;
          } }), Object.defineProperty(a, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
            return h.AST_TOKEN_TYPES;
          } }), Object.defineProperty(a, "TSESTree", { enumerable: true, get: function() {
            return h.TSESTree;
          } }), v2(oV(), a), v2(_V(), a);
        } }), E1 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/node-utils.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(be2, Ke3, Et, Ft) {
            Ft === void 0 && (Ft = Et);
            var or2 = Object.getOwnPropertyDescriptor(Ke3, Et);
            (!or2 || ("get" in or2 ? !Ke3.__esModule : or2.writable || or2.configurable)) && (or2 = { enumerable: true, get: function() {
              return Ke3[Et];
            } }), Object.defineProperty(be2, Ft, or2);
          } : function(be2, Ke3, Et, Ft) {
            Ft === void 0 && (Ft = Et), be2[Ft] = Ke3[Et];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(be2, Ke3) {
            Object.defineProperty(be2, "default", { enumerable: true, value: Ke3 });
          } : function(be2, Ke3) {
            be2.default = Ke3;
          }), h = a && a.__importStar || function(be2) {
            if (be2 && be2.__esModule)
              return be2;
            var Ke3 = {};
            if (be2 != null)
              for (var Et in be2)
                Et !== "default" && Object.prototype.hasOwnProperty.call(be2, Et) && _(Ke3, be2, Et);
            return v2(Ke3, be2), Ke3;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.isThisInTypeQuery = a.isThisIdentifier = a.identifierIsThisKeyword = a.firstDefined = a.nodeHasTokens = a.createError = a.TSError = a.convertTokens = a.convertToken = a.getTokenType = a.isChildUnwrappableOptionalChain = a.isChainExpression = a.isOptional = a.isComputedProperty = a.unescapeStringLiteralText = a.hasJSXAncestor = a.findFirstMatchingAncestor = a.findNextToken = a.getTSNodeAccessibility = a.getDeclarationKind = a.isJSXToken = a.isToken = a.getRange = a.canContainDirective = a.getLocFor = a.getLineAndCharacterFor = a.getBinaryExpressionType = a.isJSDocComment = a.isComment = a.isComma = a.getLastModifier = a.hasModifier = a.isESTreeClassMember = a.getTextForTokenKind = a.isLogicalOperator = a.isAssignmentOperator = void 0;
          var D = h(vr()), P = fT(), y = rV(), m = x1(), C2 = S1(), d2 = C2.typescriptVersionIsAtLeast["5.0"], E = D.SyntaxKind, I = [E.BarBarToken, E.AmpersandAmpersandToken, E.QuestionQuestionToken];
          function c(be2) {
            return be2.kind >= E.FirstAssignment && be2.kind <= E.LastAssignment;
          }
          a.isAssignmentOperator = c;
          function M(be2) {
            return I.includes(be2.kind);
          }
          a.isLogicalOperator = M;
          function q2(be2) {
            return D.tokenToString(be2);
          }
          a.getTextForTokenKind = q2;
          function W(be2) {
            return be2.kind !== E.SemicolonClassElement;
          }
          a.isESTreeClassMember = W;
          function K(be2, Ke3) {
            let Et = (0, P.getModifiers)(Ke3);
            return (Et == null ? void 0 : Et.some((Ft) => Ft.kind === be2)) === true;
          }
          a.hasModifier = K;
          function ce2(be2) {
            var Ke3;
            let Et = (0, P.getModifiers)(be2);
            return Et == null ? null : (Ke3 = Et[Et.length - 1]) !== null && Ke3 !== void 0 ? Ke3 : null;
          }
          a.getLastModifier = ce2;
          function Ie2(be2) {
            return be2.kind === E.CommaToken;
          }
          a.isComma = Ie2;
          function me2(be2) {
            return be2.kind === E.SingleLineCommentTrivia || be2.kind === E.MultiLineCommentTrivia;
          }
          a.isComment = me2;
          function Ae2(be2) {
            return be2.kind === E.JSDocComment;
          }
          a.isJSDocComment = Ae2;
          function te2(be2) {
            return c(be2) ? m.AST_NODE_TYPES.AssignmentExpression : M(be2) ? m.AST_NODE_TYPES.LogicalExpression : m.AST_NODE_TYPES.BinaryExpression;
          }
          a.getBinaryExpressionType = te2;
          function he(be2, Ke3) {
            let Et = Ke3.getLineAndCharacterOfPosition(be2);
            return { line: Et.line + 1, column: Et.character };
          }
          a.getLineAndCharacterFor = he;
          function Pe2(be2, Ke3, Et) {
            return { start: he(be2, Et), end: he(Ke3, Et) };
          }
          a.getLocFor = Pe2;
          function R(be2) {
            if (be2.kind === D.SyntaxKind.Block)
              switch (be2.parent.kind) {
                case D.SyntaxKind.Constructor:
                case D.SyntaxKind.GetAccessor:
                case D.SyntaxKind.SetAccessor:
                case D.SyntaxKind.ArrowFunction:
                case D.SyntaxKind.FunctionExpression:
                case D.SyntaxKind.FunctionDeclaration:
                case D.SyntaxKind.MethodDeclaration:
                  return true;
                default:
                  return false;
              }
            return true;
          }
          a.canContainDirective = R;
          function pe2(be2, Ke3) {
            return [be2.getStart(Ke3), be2.getEnd()];
          }
          a.getRange = pe2;
          function ke2(be2) {
            return be2.kind >= E.FirstToken && be2.kind <= E.LastToken;
          }
          a.isToken = ke2;
          function Je2(be2) {
            return be2.kind >= E.JsxElement && be2.kind <= E.JsxAttribute;
          }
          a.isJSXToken = Je2;
          function Xe2(be2) {
            return be2.flags & D.NodeFlags.Let ? "let" : be2.flags & D.NodeFlags.Const ? "const" : "var";
          }
          a.getDeclarationKind = Xe2;
          function ee2(be2) {
            let Ke3 = (0, P.getModifiers)(be2);
            if (Ke3 == null)
              return null;
            for (let Et of Ke3)
              switch (Et.kind) {
                case E.PublicKeyword:
                  return "public";
                case E.ProtectedKeyword:
                  return "protected";
                case E.PrivateKeyword:
                  return "private";
                default:
                  break;
              }
            return null;
          }
          a.getTSNodeAccessibility = ee2;
          function je2(be2, Ke3, Et) {
            return Ft(Ke3);
            function Ft(or2) {
              return D.isToken(or2) && or2.pos === be2.end ? or2 : la(or2.getChildren(Et), (Wr2) => (Wr2.pos <= be2.pos && Wr2.end > be2.end || Wr2.pos === be2.end) && Ri(Wr2, Et) ? Ft(Wr2) : void 0);
            }
          }
          a.findNextToken = je2;
          function nt(be2, Ke3) {
            for (; be2; ) {
              if (Ke3(be2))
                return be2;
              be2 = be2.parent;
            }
          }
          a.findFirstMatchingAncestor = nt;
          function Ze2(be2) {
            return !!nt(be2, Je2);
          }
          a.hasJSXAncestor = Ze2;
          function st2(be2) {
            return be2.replace(/&(?:#\d+|#x[\da-fA-F]+|[0-9a-zA-Z]+);/g, (Ke3) => {
              let Et = Ke3.slice(1, -1);
              if (Et[0] === "#") {
                let Ft = Et[1] === "x" ? parseInt(Et.slice(2), 16) : parseInt(Et.slice(1), 10);
                return Ft > 1114111 ? Ke3 : String.fromCodePoint(Ft);
              }
              return y.xhtmlEntities[Et] || Ke3;
            });
          }
          a.unescapeStringLiteralText = st2;
          function tt(be2) {
            return be2.kind === E.ComputedPropertyName;
          }
          a.isComputedProperty = tt;
          function ct(be2) {
            return be2.questionToken ? be2.questionToken.kind === E.QuestionToken : false;
          }
          a.isOptional = ct;
          function ne2(be2) {
            return be2.type === m.AST_NODE_TYPES.ChainExpression;
          }
          a.isChainExpression = ne2;
          function ge(be2, Ke3) {
            return ne2(Ke3) && be2.expression.kind !== D.SyntaxKind.ParenthesizedExpression;
          }
          a.isChildUnwrappableOptionalChain = ge;
          function Fe2(be2) {
            let Ke3;
            if (d2 && be2.kind === E.Identifier ? Ke3 = D.identifierToKeywordKind(be2) : "originalKeywordKind" in be2 && (Ke3 = be2.originalKeywordKind), Ke3)
              return Ke3 === E.NullKeyword ? m.AST_TOKEN_TYPES.Null : Ke3 >= E.FirstFutureReservedWord && Ke3 <= E.LastKeyword ? m.AST_TOKEN_TYPES.Identifier : m.AST_TOKEN_TYPES.Keyword;
            if (be2.kind >= E.FirstKeyword && be2.kind <= E.LastFutureReservedWord)
              return be2.kind === E.FalseKeyword || be2.kind === E.TrueKeyword ? m.AST_TOKEN_TYPES.Boolean : m.AST_TOKEN_TYPES.Keyword;
            if (be2.kind >= E.FirstPunctuation && be2.kind <= E.LastPunctuation)
              return m.AST_TOKEN_TYPES.Punctuator;
            if (be2.kind >= E.NoSubstitutionTemplateLiteral && be2.kind <= E.TemplateTail)
              return m.AST_TOKEN_TYPES.Template;
            switch (be2.kind) {
              case E.NumericLiteral:
                return m.AST_TOKEN_TYPES.Numeric;
              case E.JsxText:
                return m.AST_TOKEN_TYPES.JSXText;
              case E.StringLiteral:
                return be2.parent && (be2.parent.kind === E.JsxAttribute || be2.parent.kind === E.JsxElement) ? m.AST_TOKEN_TYPES.JSXText : m.AST_TOKEN_TYPES.String;
              case E.RegularExpressionLiteral:
                return m.AST_TOKEN_TYPES.RegularExpression;
              case E.Identifier:
              case E.ConstructorKeyword:
              case E.GetKeyword:
              case E.SetKeyword:
              default:
            }
            return be2.parent && be2.kind === E.Identifier && (Je2(be2.parent) || be2.parent.kind === E.PropertyAccessExpression && Ze2(be2)) ? m.AST_TOKEN_TYPES.JSXIdentifier : m.AST_TOKEN_TYPES.Identifier;
          }
          a.getTokenType = Fe2;
          function at3(be2, Ke3) {
            let Et = be2.kind === E.JsxText ? be2.getFullStart() : be2.getStart(Ke3), Ft = be2.getEnd(), or2 = Ke3.text.slice(Et, Ft), Wr2 = Fe2(be2);
            return Wr2 === m.AST_TOKEN_TYPES.RegularExpression ? { type: Wr2, value: or2, range: [Et, Ft], loc: Pe2(Et, Ft, Ke3), regex: { pattern: or2.slice(1, or2.lastIndexOf("/")), flags: or2.slice(or2.lastIndexOf("/") + 1) } } : { type: Wr2, value: or2, range: [Et, Ft], loc: Pe2(Et, Ft, Ke3) };
          }
          a.convertToken = at3;
          function Pt(be2) {
            let Ke3 = [];
            function Et(Ft) {
              if (!(me2(Ft) || Ae2(Ft)))
                if (ke2(Ft) && Ft.kind !== E.EndOfFileToken) {
                  let or2 = at3(Ft, be2);
                  or2 && Ke3.push(or2);
                } else
                  Ft.getChildren(be2).forEach(Et);
            }
            return Et(be2), Ke3;
          }
          a.convertTokens = Pt;
          var qt = class extends Error {
            constructor(be2, Ke3, Et, Ft, or2) {
              super(be2), this.fileName = Ke3, this.index = Et, this.lineNumber = Ft, this.column = or2, Object.defineProperty(this, "name", { value: new.target.name, enumerable: false, configurable: true });
            }
          };
          a.TSError = qt;
          function Zr2(be2, Ke3, Et) {
            let Ft = be2.getLineAndCharacterOfPosition(Ke3);
            return new qt(Et, be2.fileName, Ke3, Ft.line + 1, Ft.character);
          }
          a.createError = Zr2;
          function Ri(be2, Ke3) {
            return be2.kind === E.EndOfFileToken ? !!be2.jsDoc : be2.getWidth(Ke3) !== 0;
          }
          a.nodeHasTokens = Ri;
          function la(be2, Ke3) {
            if (be2 !== void 0)
              for (let Et = 0; Et < be2.length; Et++) {
                let Ft = Ke3(be2[Et], Et);
                if (Ft !== void 0)
                  return Ft;
              }
          }
          a.firstDefined = la;
          function ua(be2) {
            return (d2 ? D.identifierToKeywordKind(be2) : be2.originalKeywordKind) === E.ThisKeyword;
          }
          a.identifierIsThisKeyword = ua;
          function Ka(be2) {
            return !!be2 && be2.kind === E.Identifier && ua(be2);
          }
          a.isThisIdentifier = Ka;
          function co(be2) {
            if (!Ka(be2))
              return false;
            for (; D.isQualifiedName(be2.parent) && be2.parent.left === be2; )
              be2 = be2.parent;
            return be2.parent.kind === E.TypeQuery;
          }
          a.isThisInTypeQuery = co;
        } }), G9 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/convert.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(c, M, q2, W) {
            W === void 0 && (W = q2);
            var K = Object.getOwnPropertyDescriptor(M, q2);
            (!K || ("get" in K ? !M.__esModule : K.writable || K.configurable)) && (K = { enumerable: true, get: function() {
              return M[q2];
            } }), Object.defineProperty(c, W, K);
          } : function(c, M, q2, W) {
            W === void 0 && (W = q2), c[W] = M[q2];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(c, M) {
            Object.defineProperty(c, "default", { enumerable: true, value: M });
          } : function(c, M) {
            c.default = M;
          }), h = a && a.__importStar || function(c) {
            if (c && c.__esModule)
              return c;
            var M = {};
            if (c != null)
              for (var q2 in c)
                q2 !== "default" && Object.prototype.hasOwnProperty.call(c, q2) && _(M, c, q2);
            return v2(M, c), M;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.Converter = a.convertError = void 0;
          var D = h(vr()), P = fT(), y = E1(), m = x1(), C2 = S1(), d2 = D.SyntaxKind;
          function E(c) {
            return (0, y.createError)(c.file, c.start, "message" in c && c.message || c.messageText);
          }
          a.convertError = E;
          var I = class {
            constructor(c, M) {
              this.esTreeNodeToTSNodeMap = /* @__PURE__ */ new WeakMap(), this.tsNodeToESTreeNodeMap = /* @__PURE__ */ new WeakMap(), this.allowPattern = false, this.inTypeMode = false, this.ast = c, this.options = Object.assign({}, M);
            }
            getASTMaps() {
              return { esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap };
            }
            convertProgram() {
              return this.converter(this.ast);
            }
            converter(c, M, q2, W) {
              if (!c)
                return null;
              let K = this.inTypeMode, ce2 = this.allowPattern;
              q2 !== void 0 && (this.inTypeMode = q2), W !== void 0 && (this.allowPattern = W);
              let Ie2 = this.convertNode(c, M != null ? M : c.parent);
              return this.registerTSNodeInNodeMap(c, Ie2), this.inTypeMode = K, this.allowPattern = ce2, Ie2;
            }
            fixExports(c, M) {
              let q2 = (0, P.getModifiers)(c);
              if ((q2 == null ? void 0 : q2[0].kind) === d2.ExportKeyword) {
                this.registerTSNodeInNodeMap(c, M);
                let W = q2[0], K = q2[1], ce2 = K && K.kind === d2.DefaultKeyword, Ie2 = ce2 ? (0, y.findNextToken)(K, this.ast, this.ast) : (0, y.findNextToken)(W, this.ast, this.ast);
                if (M.range[0] = Ie2.getStart(this.ast), M.loc = (0, y.getLocFor)(M.range[0], M.range[1], this.ast), ce2)
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ExportDefaultDeclaration, declaration: M, range: [W.getStart(this.ast), M.range[1]], exportKind: "value" });
                {
                  let me2 = M.type === m.AST_NODE_TYPES.TSInterfaceDeclaration || M.type === m.AST_NODE_TYPES.TSTypeAliasDeclaration, Ae2 = "declare" in M && M.declare === true;
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ExportNamedDeclaration, declaration: M, specifiers: [], source: null, exportKind: me2 || Ae2 ? "type" : "value", range: [W.getStart(this.ast), M.range[1]], assertions: [] });
                }
              }
              return M;
            }
            registerTSNodeInNodeMap(c, M) {
              M && this.options.shouldPreserveNodeMaps && (this.tsNodeToESTreeNodeMap.has(c) || this.tsNodeToESTreeNodeMap.set(c, M));
            }
            convertPattern(c, M) {
              return this.converter(c, M, this.inTypeMode, true);
            }
            convertChild(c, M) {
              return this.converter(c, M, this.inTypeMode, false);
            }
            convertType(c, M) {
              return this.converter(c, M, true, false);
            }
            createNode(c, M) {
              let q2 = M;
              return q2.range || (q2.range = (0, y.getRange)(c, this.ast)), q2.loc || (q2.loc = (0, y.getLocFor)(q2.range[0], q2.range[1], this.ast)), q2 && this.options.shouldPreserveNodeMaps && this.esTreeNodeToTSNodeMap.set(q2, c), q2;
            }
            convertBindingNameWithTypeAnnotation(c, M, q2) {
              let W = this.convertPattern(c);
              return M && (W.typeAnnotation = this.convertTypeAnnotation(M, q2), this.fixParentLocation(W, W.typeAnnotation.range)), W;
            }
            convertTypeAnnotation(c, M) {
              let q2 = (M == null ? void 0 : M.kind) === d2.FunctionType || (M == null ? void 0 : M.kind) === d2.ConstructorType ? 2 : 1, W = c.getFullStart() - q2, K = (0, y.getLocFor)(W, c.end, this.ast);
              return { type: m.AST_NODE_TYPES.TSTypeAnnotation, loc: K, range: [W, c.end], typeAnnotation: this.convertType(c) };
            }
            convertBodyExpressions(c, M) {
              let q2 = (0, y.canContainDirective)(M);
              return c.map((W) => {
                let K = this.convertChild(W);
                if (q2)
                  if (K != null && K.expression && D.isExpressionStatement(W) && D.isStringLiteral(W.expression)) {
                    let ce2 = K.expression.raw;
                    return K.directive = ce2.slice(1, -1), K;
                  } else
                    q2 = false;
                return K;
              }).filter((W) => W);
            }
            convertTypeArgumentsToTypeParameters(c, M) {
              let q2 = (0, y.findNextToken)(c, this.ast, this.ast);
              return this.createNode(M, { type: m.AST_NODE_TYPES.TSTypeParameterInstantiation, range: [c.pos - 1, q2.end], params: c.map((W) => this.convertType(W)) });
            }
            convertTSTypeParametersToTypeParametersDeclaration(c) {
              let M = (0, y.findNextToken)(c, this.ast, this.ast);
              return { type: m.AST_NODE_TYPES.TSTypeParameterDeclaration, range: [c.pos - 1, M.end], loc: (0, y.getLocFor)(c.pos - 1, M.end, this.ast), params: c.map((q2) => this.convertType(q2)) };
            }
            convertParameters(c) {
              return c != null && c.length ? c.map((M) => {
                let q2 = this.convertChild(M), W = (0, P.getDecorators)(M);
                return W != null && W.length && (q2.decorators = W.map((K) => this.convertChild(K))), q2;
              }) : [];
            }
            convertChainExpression(c, M) {
              let { child: q2, isOptional: W } = (() => c.type === m.AST_NODE_TYPES.MemberExpression ? { child: c.object, isOptional: c.optional } : c.type === m.AST_NODE_TYPES.CallExpression ? { child: c.callee, isOptional: c.optional } : { child: c.expression, isOptional: false })(), K = (0, y.isChildUnwrappableOptionalChain)(M, q2);
              if (!K && !W)
                return c;
              if (K && (0, y.isChainExpression)(q2)) {
                let ce2 = q2.expression;
                c.type === m.AST_NODE_TYPES.MemberExpression ? c.object = ce2 : c.type === m.AST_NODE_TYPES.CallExpression ? c.callee = ce2 : c.expression = ce2;
              }
              return this.createNode(M, { type: m.AST_NODE_TYPES.ChainExpression, expression: c });
            }
            deeplyCopy(c) {
              if (c.kind === D.SyntaxKind.JSDocFunctionType)
                throw (0, y.createError)(this.ast, c.pos, "JSDoc types can only be used inside documentation comments.");
              let M = `TS${d2[c.kind]}`;
              if (this.options.errorOnUnknownASTType && !m.AST_NODE_TYPES[M])
                throw new Error(`Unknown AST_NODE_TYPE: "${M}"`);
              let q2 = this.createNode(c, { type: M });
              "type" in c && (q2.typeAnnotation = c.type && "kind" in c.type && D.isTypeNode(c.type) ? this.convertTypeAnnotation(c.type, c) : null), "typeArguments" in c && (q2.typeParameters = c.typeArguments && "pos" in c.typeArguments ? this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) : null), "typeParameters" in c && (q2.typeParameters = c.typeParameters && "pos" in c.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters) : null);
              let W = (0, P.getDecorators)(c);
              W != null && W.length && (q2.decorators = W.map((ce2) => this.convertChild(ce2)));
              let K = /* @__PURE__ */ new Set(["_children", "decorators", "end", "flags", "illegalDecorators", "heritageClauses", "locals", "localSymbol", "jsDoc", "kind", "modifierFlagsCache", "modifiers", "nextContainer", "parent", "pos", "symbol", "transformFlags", "type", "typeArguments", "typeParameters"]);
              return Object.entries(c).filter((ce2) => {
                let [Ie2] = ce2;
                return !K.has(Ie2);
              }).forEach((ce2) => {
                let [Ie2, me2] = ce2;
                Array.isArray(me2) ? q2[Ie2] = me2.map((Ae2) => this.convertChild(Ae2)) : me2 && typeof me2 == "object" && me2.kind ? q2[Ie2] = this.convertChild(me2) : q2[Ie2] = me2;
              }), q2;
            }
            convertJSXIdentifier(c) {
              let M = this.createNode(c, { type: m.AST_NODE_TYPES.JSXIdentifier, name: c.getText() });
              return this.registerTSNodeInNodeMap(c, M), M;
            }
            convertJSXNamespaceOrIdentifier(c) {
              let M = c.getText(), q2 = M.indexOf(":");
              if (q2 > 0) {
                let W = (0, y.getRange)(c, this.ast), K = this.createNode(c, { type: m.AST_NODE_TYPES.JSXNamespacedName, namespace: this.createNode(c, { type: m.AST_NODE_TYPES.JSXIdentifier, name: M.slice(0, q2), range: [W[0], W[0] + q2] }), name: this.createNode(c, { type: m.AST_NODE_TYPES.JSXIdentifier, name: M.slice(q2 + 1), range: [W[0] + q2 + 1, W[1]] }), range: W });
                return this.registerTSNodeInNodeMap(c, K), K;
              }
              return this.convertJSXIdentifier(c);
            }
            convertJSXTagName(c, M) {
              let q2;
              switch (c.kind) {
                case d2.PropertyAccessExpression:
                  if (c.name.kind === d2.PrivateIdentifier)
                    throw new Error("Non-private identifier expected.");
                  q2 = this.createNode(c, { type: m.AST_NODE_TYPES.JSXMemberExpression, object: this.convertJSXTagName(c.expression, M), property: this.convertJSXIdentifier(c.name) });
                  break;
                case d2.ThisKeyword:
                case d2.Identifier:
                default:
                  return this.convertJSXNamespaceOrIdentifier(c);
              }
              return this.registerTSNodeInNodeMap(c, q2), q2;
            }
            convertMethodSignature(c) {
              let M = this.createNode(c, { type: m.AST_NODE_TYPES.TSMethodSignature, computed: (0, y.isComputedProperty)(c.name), key: this.convertChild(c.name), params: this.convertParameters(c.parameters), kind: (() => {
                switch (c.kind) {
                  case d2.GetAccessor:
                    return "get";
                  case d2.SetAccessor:
                    return "set";
                  case d2.MethodSignature:
                    return "method";
                }
              })() });
              (0, y.isOptional)(c) && (M.optional = true), c.type && (M.returnType = this.convertTypeAnnotation(c.type, c)), (0, y.hasModifier)(d2.ReadonlyKeyword, c) && (M.readonly = true), c.typeParameters && (M.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters));
              let q2 = (0, y.getTSNodeAccessibility)(c);
              return q2 && (M.accessibility = q2), (0, y.hasModifier)(d2.ExportKeyword, c) && (M.export = true), (0, y.hasModifier)(d2.StaticKeyword, c) && (M.static = true), M;
            }
            convertAssertClasue(c) {
              return c === void 0 ? [] : c.elements.map((M) => this.convertChild(M));
            }
            applyModifiersToResult(c, M) {
              if (!M)
                return;
              let q2 = [];
              for (let W of M)
                switch (W.kind) {
                  case d2.ExportKeyword:
                  case d2.DefaultKeyword:
                    break;
                  case d2.ConstKeyword:
                    c.const = true;
                    break;
                  case d2.DeclareKeyword:
                    c.declare = true;
                    break;
                  default:
                    q2.push(this.convertChild(W));
                    break;
                }
              q2.length > 0 && (c.modifiers = q2);
            }
            fixParentLocation(c, M) {
              M[0] < c.range[0] && (c.range[0] = M[0], c.loc.start = (0, y.getLineAndCharacterFor)(c.range[0], this.ast)), M[1] > c.range[1] && (c.range[1] = M[1], c.loc.end = (0, y.getLineAndCharacterFor)(c.range[1], this.ast));
            }
            assertModuleSpecifier(c, M) {
              var q2;
              if (!M && c.moduleSpecifier == null)
                throw (0, y.createError)(this.ast, c.pos, "Module specifier must be a string literal.");
              if (c.moduleSpecifier && ((q2 = c.moduleSpecifier) === null || q2 === void 0 ? void 0 : q2.kind) !== d2.StringLiteral)
                throw (0, y.createError)(this.ast, c.moduleSpecifier.pos, "Module specifier must be a string literal.");
            }
            convertNode(c, M) {
              var q2, W, K, ce2, Ie2, me2, Ae2, te2, he, Pe2;
              switch (c.kind) {
                case d2.SourceFile:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Program, body: this.convertBodyExpressions(c.statements, c), sourceType: c.externalModuleIndicator ? "module" : "script", range: [c.getStart(this.ast), c.endOfFileToken.end] });
                case d2.Block:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.BlockStatement, body: this.convertBodyExpressions(c.statements, c) });
                case d2.Identifier:
                  return (0, y.isThisInTypeQuery)(c) ? this.createNode(c, { type: m.AST_NODE_TYPES.ThisExpression }) : this.createNode(c, { type: m.AST_NODE_TYPES.Identifier, name: c.text });
                case d2.PrivateIdentifier:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.PrivateIdentifier, name: c.text.slice(1) });
                case d2.WithStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.WithStatement, object: this.convertChild(c.expression), body: this.convertChild(c.statement) });
                case d2.ReturnStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ReturnStatement, argument: this.convertChild(c.expression) });
                case d2.LabeledStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.LabeledStatement, label: this.convertChild(c.label), body: this.convertChild(c.statement) });
                case d2.ContinueStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ContinueStatement, label: this.convertChild(c.label) });
                case d2.BreakStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.BreakStatement, label: this.convertChild(c.label) });
                case d2.IfStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.IfStatement, test: this.convertChild(c.expression), consequent: this.convertChild(c.thenStatement), alternate: this.convertChild(c.elseStatement) });
                case d2.SwitchStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.SwitchStatement, discriminant: this.convertChild(c.expression), cases: c.caseBlock.clauses.map((R) => this.convertChild(R)) });
                case d2.CaseClause:
                case d2.DefaultClause:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.SwitchCase, test: c.kind === d2.CaseClause ? this.convertChild(c.expression) : null, consequent: c.statements.map((R) => this.convertChild(R)) });
                case d2.ThrowStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ThrowStatement, argument: this.convertChild(c.expression) });
                case d2.TryStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TryStatement, block: this.convertChild(c.tryBlock), handler: this.convertChild(c.catchClause), finalizer: this.convertChild(c.finallyBlock) });
                case d2.CatchClause:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.CatchClause, param: c.variableDeclaration ? this.convertBindingNameWithTypeAnnotation(c.variableDeclaration.name, c.variableDeclaration.type) : null, body: this.convertChild(c.block) });
                case d2.WhileStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.WhileStatement, test: this.convertChild(c.expression), body: this.convertChild(c.statement) });
                case d2.DoStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.DoWhileStatement, test: this.convertChild(c.expression), body: this.convertChild(c.statement) });
                case d2.ForStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ForStatement, init: this.convertChild(c.initializer), test: this.convertChild(c.condition), update: this.convertChild(c.incrementor), body: this.convertChild(c.statement) });
                case d2.ForInStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ForInStatement, left: this.convertPattern(c.initializer), right: this.convertChild(c.expression), body: this.convertChild(c.statement) });
                case d2.ForOfStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ForOfStatement, left: this.convertPattern(c.initializer), right: this.convertChild(c.expression), body: this.convertChild(c.statement), await: Boolean(c.awaitModifier && c.awaitModifier.kind === d2.AwaitKeyword) });
                case d2.FunctionDeclaration: {
                  let R = (0, y.hasModifier)(d2.DeclareKeyword, c), pe2 = this.createNode(c, { type: R || !c.body ? m.AST_NODE_TYPES.TSDeclareFunction : m.AST_NODE_TYPES.FunctionDeclaration, id: this.convertChild(c.name), generator: !!c.asteriskToken, expression: false, async: (0, y.hasModifier)(d2.AsyncKeyword, c), params: this.convertParameters(c.parameters), body: this.convertChild(c.body) || void 0 });
                  return c.type && (pe2.returnType = this.convertTypeAnnotation(c.type, c)), c.typeParameters && (pe2.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), R && (pe2.declare = true), this.fixExports(c, pe2);
                }
                case d2.VariableDeclaration: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.VariableDeclarator, id: this.convertBindingNameWithTypeAnnotation(c.name, c.type, c), init: this.convertChild(c.initializer) });
                  return c.exclamationToken && (R.definite = true), R;
                }
                case d2.VariableStatement: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.VariableDeclaration, declarations: c.declarationList.declarations.map((pe2) => this.convertChild(pe2)), kind: (0, y.getDeclarationKind)(c.declarationList) });
                  return (0, y.hasModifier)(d2.DeclareKeyword, c) && (R.declare = true), this.fixExports(c, R);
                }
                case d2.VariableDeclarationList:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.VariableDeclaration, declarations: c.declarations.map((R) => this.convertChild(R)), kind: (0, y.getDeclarationKind)(c) });
                case d2.ExpressionStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ExpressionStatement, expression: this.convertChild(c.expression) });
                case d2.ThisKeyword:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ThisExpression });
                case d2.ArrayLiteralExpression:
                  return this.allowPattern ? this.createNode(c, { type: m.AST_NODE_TYPES.ArrayPattern, elements: c.elements.map((R) => this.convertPattern(R)) }) : this.createNode(c, { type: m.AST_NODE_TYPES.ArrayExpression, elements: c.elements.map((R) => this.convertChild(R)) });
                case d2.ObjectLiteralExpression:
                  return this.allowPattern ? this.createNode(c, { type: m.AST_NODE_TYPES.ObjectPattern, properties: c.properties.map((R) => this.convertPattern(R)) }) : this.createNode(c, { type: m.AST_NODE_TYPES.ObjectExpression, properties: c.properties.map((R) => this.convertChild(R)) });
                case d2.PropertyAssignment:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Property, key: this.convertChild(c.name), value: this.converter(c.initializer, c, this.inTypeMode, this.allowPattern), computed: (0, y.isComputedProperty)(c.name), method: false, shorthand: false, kind: "init" });
                case d2.ShorthandPropertyAssignment:
                  return c.objectAssignmentInitializer ? this.createNode(c, { type: m.AST_NODE_TYPES.Property, key: this.convertChild(c.name), value: this.createNode(c, { type: m.AST_NODE_TYPES.AssignmentPattern, left: this.convertPattern(c.name), right: this.convertChild(c.objectAssignmentInitializer) }), computed: false, method: false, shorthand: true, kind: "init" }) : this.createNode(c, { type: m.AST_NODE_TYPES.Property, key: this.convertChild(c.name), value: this.convertChild(c.name), computed: false, method: false, shorthand: true, kind: "init" });
                case d2.ComputedPropertyName:
                  return this.convertChild(c.expression);
                case d2.PropertyDeclaration: {
                  let R = (0, y.hasModifier)(d2.AbstractKeyword, c), pe2 = (0, y.hasModifier)(d2.AccessorKeyword, c), ke2 = (() => pe2 ? R ? m.AST_NODE_TYPES.TSAbstractAccessorProperty : m.AST_NODE_TYPES.AccessorProperty : R ? m.AST_NODE_TYPES.TSAbstractPropertyDefinition : m.AST_NODE_TYPES.PropertyDefinition)(), Je2 = this.createNode(c, { type: ke2, key: this.convertChild(c.name), value: R ? null : this.convertChild(c.initializer), computed: (0, y.isComputedProperty)(c.name), static: (0, y.hasModifier)(d2.StaticKeyword, c), readonly: (0, y.hasModifier)(d2.ReadonlyKeyword, c) || void 0, declare: (0, y.hasModifier)(d2.DeclareKeyword, c), override: (0, y.hasModifier)(d2.OverrideKeyword, c) });
                  c.type && (Je2.typeAnnotation = this.convertTypeAnnotation(c.type, c));
                  let Xe2 = (0, P.getDecorators)(c);
                  Xe2 && (Je2.decorators = Xe2.map((je2) => this.convertChild(je2)));
                  let ee2 = (0, y.getTSNodeAccessibility)(c);
                  return ee2 && (Je2.accessibility = ee2), (c.name.kind === d2.Identifier || c.name.kind === d2.ComputedPropertyName || c.name.kind === d2.PrivateIdentifier) && c.questionToken && (Je2.optional = true), c.exclamationToken && (Je2.definite = true), Je2.key.type === m.AST_NODE_TYPES.Literal && c.questionToken && (Je2.optional = true), Je2;
                }
                case d2.GetAccessor:
                case d2.SetAccessor:
                  if (c.parent.kind === d2.InterfaceDeclaration || c.parent.kind === d2.TypeLiteral)
                    return this.convertMethodSignature(c);
                case d2.MethodDeclaration: {
                  let R = this.createNode(c, { type: c.body ? m.AST_NODE_TYPES.FunctionExpression : m.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, id: null, generator: !!c.asteriskToken, expression: false, async: (0, y.hasModifier)(d2.AsyncKeyword, c), body: this.convertChild(c.body), range: [c.parameters.pos - 1, c.end], params: [] });
                  c.type && (R.returnType = this.convertTypeAnnotation(c.type, c)), c.typeParameters && (R.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters), this.fixParentLocation(R, R.typeParameters.range));
                  let pe2;
                  if (M.kind === d2.ObjectLiteralExpression)
                    R.params = c.parameters.map((ke2) => this.convertChild(ke2)), pe2 = this.createNode(c, { type: m.AST_NODE_TYPES.Property, key: this.convertChild(c.name), value: R, computed: (0, y.isComputedProperty)(c.name), method: c.kind === d2.MethodDeclaration, shorthand: false, kind: "init" });
                  else {
                    R.params = this.convertParameters(c.parameters);
                    let ke2 = (0, y.hasModifier)(d2.AbstractKeyword, c) ? m.AST_NODE_TYPES.TSAbstractMethodDefinition : m.AST_NODE_TYPES.MethodDefinition;
                    pe2 = this.createNode(c, { type: ke2, key: this.convertChild(c.name), value: R, computed: (0, y.isComputedProperty)(c.name), static: (0, y.hasModifier)(d2.StaticKeyword, c), kind: "method", override: (0, y.hasModifier)(d2.OverrideKeyword, c) });
                    let Je2 = (0, P.getDecorators)(c);
                    Je2 && (pe2.decorators = Je2.map((ee2) => this.convertChild(ee2)));
                    let Xe2 = (0, y.getTSNodeAccessibility)(c);
                    Xe2 && (pe2.accessibility = Xe2);
                  }
                  return c.questionToken && (pe2.optional = true), c.kind === d2.GetAccessor ? pe2.kind = "get" : c.kind === d2.SetAccessor ? pe2.kind = "set" : !pe2.static && c.name.kind === d2.StringLiteral && c.name.text === "constructor" && pe2.type !== m.AST_NODE_TYPES.Property && (pe2.kind = "constructor"), pe2;
                }
                case d2.Constructor: {
                  let R = (0, y.getLastModifier)(c), pe2 = R && (0, y.findNextToken)(R, c, this.ast) || c.getFirstToken(), ke2 = this.createNode(c, { type: c.body ? m.AST_NODE_TYPES.FunctionExpression : m.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, id: null, params: this.convertParameters(c.parameters), generator: false, expression: false, async: false, body: this.convertChild(c.body), range: [c.parameters.pos - 1, c.end] });
                  c.typeParameters && (ke2.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters), this.fixParentLocation(ke2, ke2.typeParameters.range)), c.type && (ke2.returnType = this.convertTypeAnnotation(c.type, c));
                  let Je2 = this.createNode(c, { type: m.AST_NODE_TYPES.Identifier, name: "constructor", range: [pe2.getStart(this.ast), pe2.end] }), Xe2 = (0, y.hasModifier)(d2.StaticKeyword, c), ee2 = this.createNode(c, { type: (0, y.hasModifier)(d2.AbstractKeyword, c) ? m.AST_NODE_TYPES.TSAbstractMethodDefinition : m.AST_NODE_TYPES.MethodDefinition, key: Je2, value: ke2, computed: false, static: Xe2, kind: Xe2 ? "method" : "constructor", override: false }), je2 = (0, y.getTSNodeAccessibility)(c);
                  return je2 && (ee2.accessibility = je2), ee2;
                }
                case d2.FunctionExpression: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.FunctionExpression, id: this.convertChild(c.name), generator: !!c.asteriskToken, params: this.convertParameters(c.parameters), body: this.convertChild(c.body), async: (0, y.hasModifier)(d2.AsyncKeyword, c), expression: false });
                  return c.type && (R.returnType = this.convertTypeAnnotation(c.type, c)), c.typeParameters && (R.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), R;
                }
                case d2.SuperKeyword:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Super });
                case d2.ArrayBindingPattern:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ArrayPattern, elements: c.elements.map((R) => this.convertPattern(R)) });
                case d2.OmittedExpression:
                  return null;
                case d2.ObjectBindingPattern:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ObjectPattern, properties: c.elements.map((R) => this.convertPattern(R)) });
                case d2.BindingElement:
                  if (M.kind === d2.ArrayBindingPattern) {
                    let R = this.convertChild(c.name, M);
                    return c.initializer ? this.createNode(c, { type: m.AST_NODE_TYPES.AssignmentPattern, left: R, right: this.convertChild(c.initializer) }) : c.dotDotDotToken ? this.createNode(c, { type: m.AST_NODE_TYPES.RestElement, argument: R }) : R;
                  } else {
                    let R;
                    return c.dotDotDotToken ? R = this.createNode(c, { type: m.AST_NODE_TYPES.RestElement, argument: this.convertChild((q2 = c.propertyName) !== null && q2 !== void 0 ? q2 : c.name) }) : R = this.createNode(c, { type: m.AST_NODE_TYPES.Property, key: this.convertChild((W = c.propertyName) !== null && W !== void 0 ? W : c.name), value: this.convertChild(c.name), computed: Boolean(c.propertyName && c.propertyName.kind === d2.ComputedPropertyName), method: false, shorthand: !c.propertyName, kind: "init" }), c.initializer && (R.value = this.createNode(c, { type: m.AST_NODE_TYPES.AssignmentPattern, left: this.convertChild(c.name), right: this.convertChild(c.initializer), range: [c.name.getStart(this.ast), c.initializer.end] })), R;
                  }
                case d2.ArrowFunction: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.ArrowFunctionExpression, generator: false, id: null, params: this.convertParameters(c.parameters), body: this.convertChild(c.body), async: (0, y.hasModifier)(d2.AsyncKeyword, c), expression: c.body.kind !== d2.Block });
                  return c.type && (R.returnType = this.convertTypeAnnotation(c.type, c)), c.typeParameters && (R.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), R;
                }
                case d2.YieldExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.YieldExpression, delegate: !!c.asteriskToken, argument: this.convertChild(c.expression) });
                case d2.AwaitExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.AwaitExpression, argument: this.convertChild(c.expression) });
                case d2.NoSubstitutionTemplateLiteral:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TemplateLiteral, quasis: [this.createNode(c, { type: m.AST_NODE_TYPES.TemplateElement, value: { raw: this.ast.text.slice(c.getStart(this.ast) + 1, c.end - 1), cooked: c.text }, tail: true })], expressions: [] });
                case d2.TemplateExpression: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TemplateLiteral, quasis: [this.convertChild(c.head)], expressions: [] });
                  return c.templateSpans.forEach((pe2) => {
                    R.expressions.push(this.convertChild(pe2.expression)), R.quasis.push(this.convertChild(pe2.literal));
                  }), R;
                }
                case d2.TaggedTemplateExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TaggedTemplateExpression, typeParameters: c.typeArguments ? this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) : void 0, tag: this.convertChild(c.tag), quasi: this.convertChild(c.template) });
                case d2.TemplateHead:
                case d2.TemplateMiddle:
                case d2.TemplateTail: {
                  let R = c.kind === d2.TemplateTail;
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TemplateElement, value: { raw: this.ast.text.slice(c.getStart(this.ast) + 1, c.end - (R ? 1 : 2)), cooked: c.text }, tail: R });
                }
                case d2.SpreadAssignment:
                case d2.SpreadElement:
                  return this.allowPattern ? this.createNode(c, { type: m.AST_NODE_TYPES.RestElement, argument: this.convertPattern(c.expression) }) : this.createNode(c, { type: m.AST_NODE_TYPES.SpreadElement, argument: this.convertChild(c.expression) });
                case d2.Parameter: {
                  let R, pe2;
                  return c.dotDotDotToken ? R = pe2 = this.createNode(c, { type: m.AST_NODE_TYPES.RestElement, argument: this.convertChild(c.name) }) : c.initializer ? (R = this.convertChild(c.name), pe2 = this.createNode(c, { type: m.AST_NODE_TYPES.AssignmentPattern, left: R, right: this.convertChild(c.initializer) }), (0, P.getModifiers)(c) && (pe2.range[0] = R.range[0], pe2.loc = (0, y.getLocFor)(pe2.range[0], pe2.range[1], this.ast))) : R = pe2 = this.convertChild(c.name, M), c.type && (R.typeAnnotation = this.convertTypeAnnotation(c.type, c), this.fixParentLocation(R, R.typeAnnotation.range)), c.questionToken && (c.questionToken.end > R.range[1] && (R.range[1] = c.questionToken.end, R.loc.end = (0, y.getLineAndCharacterFor)(R.range[1], this.ast)), R.optional = true), (0, P.getModifiers)(c) ? this.createNode(c, { type: m.AST_NODE_TYPES.TSParameterProperty, accessibility: (K = (0, y.getTSNodeAccessibility)(c)) !== null && K !== void 0 ? K : void 0, readonly: (0, y.hasModifier)(d2.ReadonlyKeyword, c) || void 0, static: (0, y.hasModifier)(d2.StaticKeyword, c) || void 0, export: (0, y.hasModifier)(d2.ExportKeyword, c) || void 0, override: (0, y.hasModifier)(d2.OverrideKeyword, c) || void 0, parameter: pe2 }) : pe2;
                }
                case d2.ClassDeclaration:
                case d2.ClassExpression: {
                  let R = (ce2 = c.heritageClauses) !== null && ce2 !== void 0 ? ce2 : [], pe2 = c.kind === d2.ClassDeclaration ? m.AST_NODE_TYPES.ClassDeclaration : m.AST_NODE_TYPES.ClassExpression, ke2 = R.find((nt) => nt.token === d2.ExtendsKeyword), Je2 = R.find((nt) => nt.token === d2.ImplementsKeyword), Xe2 = this.createNode(c, { type: pe2, id: this.convertChild(c.name), body: this.createNode(c, { type: m.AST_NODE_TYPES.ClassBody, body: [], range: [c.members.pos - 1, c.end] }), superClass: ke2 != null && ke2.types[0] ? this.convertChild(ke2.types[0].expression) : null });
                  if (ke2) {
                    if (ke2.types.length > 1)
                      throw (0, y.createError)(this.ast, ke2.types[1].pos, "Classes can only extend a single class.");
                    !((Ie2 = ke2.types[0]) === null || Ie2 === void 0) && Ie2.typeArguments && (Xe2.superTypeParameters = this.convertTypeArgumentsToTypeParameters(ke2.types[0].typeArguments, ke2.types[0]));
                  }
                  c.typeParameters && (Xe2.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), Je2 && (Xe2.implements = Je2.types.map((nt) => this.convertChild(nt))), (0, y.hasModifier)(d2.AbstractKeyword, c) && (Xe2.abstract = true), (0, y.hasModifier)(d2.DeclareKeyword, c) && (Xe2.declare = true);
                  let ee2 = (0, P.getDecorators)(c);
                  ee2 && (Xe2.decorators = ee2.map((nt) => this.convertChild(nt)));
                  let je2 = c.members.filter(y.isESTreeClassMember);
                  return je2.length && (Xe2.body.body = je2.map((nt) => this.convertChild(nt))), this.fixExports(c, Xe2);
                }
                case d2.ModuleBlock:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSModuleBlock, body: this.convertBodyExpressions(c.statements, c) });
                case d2.ImportDeclaration: {
                  this.assertModuleSpecifier(c, false);
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.ImportDeclaration, source: this.convertChild(c.moduleSpecifier), specifiers: [], importKind: "value", assertions: this.convertAssertClasue(c.assertClause) });
                  if (c.importClause && (c.importClause.isTypeOnly && (R.importKind = "type"), c.importClause.name && R.specifiers.push(this.convertChild(c.importClause)), c.importClause.namedBindings))
                    switch (c.importClause.namedBindings.kind) {
                      case d2.NamespaceImport:
                        R.specifiers.push(this.convertChild(c.importClause.namedBindings));
                        break;
                      case d2.NamedImports:
                        R.specifiers = R.specifiers.concat(c.importClause.namedBindings.elements.map((pe2) => this.convertChild(pe2)));
                        break;
                    }
                  return R;
                }
                case d2.NamespaceImport:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ImportNamespaceSpecifier, local: this.convertChild(c.name) });
                case d2.ImportSpecifier:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ImportSpecifier, local: this.convertChild(c.name), imported: this.convertChild((me2 = c.propertyName) !== null && me2 !== void 0 ? me2 : c.name), importKind: c.isTypeOnly ? "type" : "value" });
                case d2.ImportClause: {
                  let R = this.convertChild(c.name);
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ImportDefaultSpecifier, local: R, range: R.range });
                }
                case d2.ExportDeclaration:
                  return ((Ae2 = c.exportClause) === null || Ae2 === void 0 ? void 0 : Ae2.kind) === d2.NamedExports ? (this.assertModuleSpecifier(c, true), this.createNode(c, { type: m.AST_NODE_TYPES.ExportNamedDeclaration, source: this.convertChild(c.moduleSpecifier), specifiers: c.exportClause.elements.map((R) => this.convertChild(R)), exportKind: c.isTypeOnly ? "type" : "value", declaration: null, assertions: this.convertAssertClasue(c.assertClause) })) : (this.assertModuleSpecifier(c, false), this.createNode(c, { type: m.AST_NODE_TYPES.ExportAllDeclaration, source: this.convertChild(c.moduleSpecifier), exportKind: c.isTypeOnly ? "type" : "value", exported: c.exportClause && c.exportClause.kind === d2.NamespaceExport ? this.convertChild(c.exportClause.name) : null, assertions: this.convertAssertClasue(c.assertClause) }));
                case d2.ExportSpecifier:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ExportSpecifier, local: this.convertChild((te2 = c.propertyName) !== null && te2 !== void 0 ? te2 : c.name), exported: this.convertChild(c.name), exportKind: c.isTypeOnly ? "type" : "value" });
                case d2.ExportAssignment:
                  return c.isExportEquals ? this.createNode(c, { type: m.AST_NODE_TYPES.TSExportAssignment, expression: this.convertChild(c.expression) }) : this.createNode(c, { type: m.AST_NODE_TYPES.ExportDefaultDeclaration, declaration: this.convertChild(c.expression), exportKind: "value" });
                case d2.PrefixUnaryExpression:
                case d2.PostfixUnaryExpression: {
                  let R = (0, y.getTextForTokenKind)(c.operator);
                  return R === "++" || R === "--" ? this.createNode(c, { type: m.AST_NODE_TYPES.UpdateExpression, operator: R, prefix: c.kind === d2.PrefixUnaryExpression, argument: this.convertChild(c.operand) }) : this.createNode(c, { type: m.AST_NODE_TYPES.UnaryExpression, operator: R, prefix: c.kind === d2.PrefixUnaryExpression, argument: this.convertChild(c.operand) });
                }
                case d2.DeleteExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.UnaryExpression, operator: "delete", prefix: true, argument: this.convertChild(c.expression) });
                case d2.VoidExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.UnaryExpression, operator: "void", prefix: true, argument: this.convertChild(c.expression) });
                case d2.TypeOfExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.UnaryExpression, operator: "typeof", prefix: true, argument: this.convertChild(c.expression) });
                case d2.TypeOperator:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeOperator, operator: (0, y.getTextForTokenKind)(c.operator), typeAnnotation: this.convertChild(c.type) });
                case d2.BinaryExpression:
                  if ((0, y.isComma)(c.operatorToken)) {
                    let R = this.createNode(c, { type: m.AST_NODE_TYPES.SequenceExpression, expressions: [] }), pe2 = this.convertChild(c.left);
                    return pe2.type === m.AST_NODE_TYPES.SequenceExpression && c.left.kind !== d2.ParenthesizedExpression ? R.expressions = R.expressions.concat(pe2.expressions) : R.expressions.push(pe2), R.expressions.push(this.convertChild(c.right)), R;
                  } else {
                    let R = (0, y.getBinaryExpressionType)(c.operatorToken);
                    return this.allowPattern && R === m.AST_NODE_TYPES.AssignmentExpression ? this.createNode(c, { type: m.AST_NODE_TYPES.AssignmentPattern, left: this.convertPattern(c.left, c), right: this.convertChild(c.right) }) : this.createNode(c, { type: R, operator: (0, y.getTextForTokenKind)(c.operatorToken.kind), left: this.converter(c.left, c, this.inTypeMode, R === m.AST_NODE_TYPES.AssignmentExpression), right: this.convertChild(c.right) });
                  }
                case d2.PropertyAccessExpression: {
                  let R = this.convertChild(c.expression), pe2 = this.convertChild(c.name), ke2 = false, Je2 = this.createNode(c, { type: m.AST_NODE_TYPES.MemberExpression, object: R, property: pe2, computed: ke2, optional: c.questionDotToken !== void 0 });
                  return this.convertChainExpression(Je2, c);
                }
                case d2.ElementAccessExpression: {
                  let R = this.convertChild(c.expression), pe2 = this.convertChild(c.argumentExpression), ke2 = true, Je2 = this.createNode(c, { type: m.AST_NODE_TYPES.MemberExpression, object: R, property: pe2, computed: ke2, optional: c.questionDotToken !== void 0 });
                  return this.convertChainExpression(Je2, c);
                }
                case d2.CallExpression: {
                  if (c.expression.kind === d2.ImportKeyword) {
                    if (c.arguments.length !== 1 && c.arguments.length !== 2)
                      throw (0, y.createError)(this.ast, c.arguments.pos, "Dynamic import requires exactly one or two arguments.");
                    return this.createNode(c, { type: m.AST_NODE_TYPES.ImportExpression, source: this.convertChild(c.arguments[0]), attributes: c.arguments[1] ? this.convertChild(c.arguments[1]) : null });
                  }
                  let R = this.convertChild(c.expression), pe2 = c.arguments.map((Je2) => this.convertChild(Je2)), ke2 = this.createNode(c, { type: m.AST_NODE_TYPES.CallExpression, callee: R, arguments: pe2, optional: c.questionDotToken !== void 0 });
                  return c.typeArguments && (ke2.typeParameters = this.convertTypeArgumentsToTypeParameters(c.typeArguments, c)), this.convertChainExpression(ke2, c);
                }
                case d2.NewExpression: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.NewExpression, callee: this.convertChild(c.expression), arguments: c.arguments ? c.arguments.map((pe2) => this.convertChild(pe2)) : [] });
                  return c.typeArguments && (R.typeParameters = this.convertTypeArgumentsToTypeParameters(c.typeArguments, c)), R;
                }
                case d2.ConditionalExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ConditionalExpression, test: this.convertChild(c.condition), consequent: this.convertChild(c.whenTrue), alternate: this.convertChild(c.whenFalse) });
                case d2.MetaProperty:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.MetaProperty, meta: this.createNode(c.getFirstToken(), { type: m.AST_NODE_TYPES.Identifier, name: (0, y.getTextForTokenKind)(c.keywordToken) }), property: this.convertChild(c.name) });
                case d2.Decorator:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Decorator, expression: this.convertChild(c.expression) });
                case d2.StringLiteral:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Literal, value: M.kind === d2.JsxAttribute ? (0, y.unescapeStringLiteralText)(c.text) : c.text, raw: c.getText() });
                case d2.NumericLiteral:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Literal, value: Number(c.text), raw: c.getText() });
                case d2.BigIntLiteral: {
                  let R = (0, y.getRange)(c, this.ast), pe2 = this.ast.text.slice(R[0], R[1]), ke2 = pe2.slice(0, -1).replace(/_/g, ""), Je2 = typeof BigInt < "u" ? BigInt(ke2) : null;
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Literal, raw: pe2, value: Je2, bigint: Je2 == null ? ke2 : String(Je2), range: R });
                }
                case d2.RegularExpressionLiteral: {
                  let R = c.text.slice(1, c.text.lastIndexOf("/")), pe2 = c.text.slice(c.text.lastIndexOf("/") + 1), ke2 = null;
                  try {
                    ke2 = new RegExp(R, pe2);
                  } catch {
                    ke2 = null;
                  }
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Literal, value: ke2, raw: c.text, regex: { pattern: R, flags: pe2 } });
                }
                case d2.TrueKeyword:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Literal, value: true, raw: "true" });
                case d2.FalseKeyword:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.Literal, value: false, raw: "false" });
                case d2.NullKeyword:
                  return !C2.typescriptVersionIsAtLeast["4.0"] && this.inTypeMode ? this.createNode(c, { type: m.AST_NODE_TYPES.TSNullKeyword }) : this.createNode(c, { type: m.AST_NODE_TYPES.Literal, value: null, raw: "null" });
                case d2.EmptyStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.EmptyStatement });
                case d2.DebuggerStatement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.DebuggerStatement });
                case d2.JsxElement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXElement, openingElement: this.convertChild(c.openingElement), closingElement: this.convertChild(c.closingElement), children: c.children.map((R) => this.convertChild(R)) });
                case d2.JsxFragment:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXFragment, openingFragment: this.convertChild(c.openingFragment), closingFragment: this.convertChild(c.closingFragment), children: c.children.map((R) => this.convertChild(R)) });
                case d2.JsxSelfClosingElement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXElement, openingElement: this.createNode(c, { type: m.AST_NODE_TYPES.JSXOpeningElement, typeParameters: c.typeArguments ? this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) : void 0, selfClosing: true, name: this.convertJSXTagName(c.tagName, c), attributes: c.attributes.properties.map((R) => this.convertChild(R)), range: (0, y.getRange)(c, this.ast) }), closingElement: null, children: [] });
                case d2.JsxOpeningElement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXOpeningElement, typeParameters: c.typeArguments ? this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) : void 0, selfClosing: false, name: this.convertJSXTagName(c.tagName, c), attributes: c.attributes.properties.map((R) => this.convertChild(R)) });
                case d2.JsxClosingElement:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXClosingElement, name: this.convertJSXTagName(c.tagName, c) });
                case d2.JsxOpeningFragment:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXOpeningFragment });
                case d2.JsxClosingFragment:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXClosingFragment });
                case d2.JsxExpression: {
                  let R = c.expression ? this.convertChild(c.expression) : this.createNode(c, { type: m.AST_NODE_TYPES.JSXEmptyExpression, range: [c.getStart(this.ast) + 1, c.getEnd() - 1] });
                  return c.dotDotDotToken ? this.createNode(c, { type: m.AST_NODE_TYPES.JSXSpreadChild, expression: R }) : this.createNode(c, { type: m.AST_NODE_TYPES.JSXExpressionContainer, expression: R });
                }
                case d2.JsxAttribute:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXAttribute, name: this.convertJSXNamespaceOrIdentifier(c.name), value: this.convertChild(c.initializer) });
                case d2.JsxText: {
                  let R = c.getFullStart(), pe2 = c.getEnd(), ke2 = this.ast.text.slice(R, pe2);
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXText, value: (0, y.unescapeStringLiteralText)(ke2), raw: ke2, range: [R, pe2] });
                }
                case d2.JsxSpreadAttribute:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.JSXSpreadAttribute, argument: this.convertChild(c.expression) });
                case d2.QualifiedName:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSQualifiedName, left: this.convertChild(c.left), right: this.convertChild(c.right) });
                case d2.TypeReference:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeReference, typeName: this.convertType(c.typeName), typeParameters: c.typeArguments ? this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) : void 0 });
                case d2.TypeParameter:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeParameter, name: this.convertType(c.name), constraint: c.constraint ? this.convertType(c.constraint) : void 0, default: c.default ? this.convertType(c.default) : void 0, in: (0, y.hasModifier)(d2.InKeyword, c), out: (0, y.hasModifier)(d2.OutKeyword, c), const: (0, y.hasModifier)(d2.ConstKeyword, c) });
                case d2.ThisType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSThisType });
                case d2.AnyKeyword:
                case d2.BigIntKeyword:
                case d2.BooleanKeyword:
                case d2.NeverKeyword:
                case d2.NumberKeyword:
                case d2.ObjectKeyword:
                case d2.StringKeyword:
                case d2.SymbolKeyword:
                case d2.UnknownKeyword:
                case d2.VoidKeyword:
                case d2.UndefinedKeyword:
                case d2.IntrinsicKeyword:
                  return this.createNode(c, { type: m.AST_NODE_TYPES[`TS${d2[c.kind]}`] });
                case d2.NonNullExpression: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSNonNullExpression, expression: this.convertChild(c.expression) });
                  return this.convertChainExpression(R, c);
                }
                case d2.TypeLiteral:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeLiteral, members: c.members.map((R) => this.convertChild(R)) });
                case d2.ArrayType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSArrayType, elementType: this.convertType(c.elementType) });
                case d2.IndexedAccessType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSIndexedAccessType, objectType: this.convertType(c.objectType), indexType: this.convertType(c.indexType) });
                case d2.ConditionalType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSConditionalType, checkType: this.convertType(c.checkType), extendsType: this.convertType(c.extendsType), trueType: this.convertType(c.trueType), falseType: this.convertType(c.falseType) });
                case d2.TypeQuery:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeQuery, exprName: this.convertType(c.exprName), typeParameters: c.typeArguments && this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) });
                case d2.MappedType: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSMappedType, typeParameter: this.convertType(c.typeParameter), nameType: (he = this.convertType(c.nameType)) !== null && he !== void 0 ? he : null });
                  return c.readonlyToken && (c.readonlyToken.kind === d2.ReadonlyKeyword ? R.readonly = true : R.readonly = (0, y.getTextForTokenKind)(c.readonlyToken.kind)), c.questionToken && (c.questionToken.kind === d2.QuestionToken ? R.optional = true : R.optional = (0, y.getTextForTokenKind)(c.questionToken.kind)), c.type && (R.typeAnnotation = this.convertType(c.type)), R;
                }
                case d2.ParenthesizedExpression:
                  return this.convertChild(c.expression, M);
                case d2.TypeAliasDeclaration: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeAliasDeclaration, id: this.convertChild(c.name), typeAnnotation: this.convertType(c.type) });
                  return (0, y.hasModifier)(d2.DeclareKeyword, c) && (R.declare = true), c.typeParameters && (R.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), this.fixExports(c, R);
                }
                case d2.MethodSignature:
                  return this.convertMethodSignature(c);
                case d2.PropertySignature: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSPropertySignature, optional: (0, y.isOptional)(c) || void 0, computed: (0, y.isComputedProperty)(c.name), key: this.convertChild(c.name), typeAnnotation: c.type ? this.convertTypeAnnotation(c.type, c) : void 0, initializer: this.convertChild(c.initializer) || void 0, readonly: (0, y.hasModifier)(d2.ReadonlyKeyword, c) || void 0, static: (0, y.hasModifier)(d2.StaticKeyword, c) || void 0, export: (0, y.hasModifier)(d2.ExportKeyword, c) || void 0 }), pe2 = (0, y.getTSNodeAccessibility)(c);
                  return pe2 && (R.accessibility = pe2), R;
                }
                case d2.IndexSignature: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSIndexSignature, parameters: c.parameters.map((ke2) => this.convertChild(ke2)) });
                  c.type && (R.typeAnnotation = this.convertTypeAnnotation(c.type, c)), (0, y.hasModifier)(d2.ReadonlyKeyword, c) && (R.readonly = true);
                  let pe2 = (0, y.getTSNodeAccessibility)(c);
                  return pe2 && (R.accessibility = pe2), (0, y.hasModifier)(d2.ExportKeyword, c) && (R.export = true), (0, y.hasModifier)(d2.StaticKeyword, c) && (R.static = true), R;
                }
                case d2.ConstructorType: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSConstructorType, params: this.convertParameters(c.parameters), abstract: (0, y.hasModifier)(d2.AbstractKeyword, c) });
                  return c.type && (R.returnType = this.convertTypeAnnotation(c.type, c)), c.typeParameters && (R.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), R;
                }
                case d2.FunctionType:
                case d2.ConstructSignature:
                case d2.CallSignature: {
                  let R = c.kind === d2.ConstructSignature ? m.AST_NODE_TYPES.TSConstructSignatureDeclaration : c.kind === d2.CallSignature ? m.AST_NODE_TYPES.TSCallSignatureDeclaration : m.AST_NODE_TYPES.TSFunctionType, pe2 = this.createNode(c, { type: R, params: this.convertParameters(c.parameters) });
                  return c.type && (pe2.returnType = this.convertTypeAnnotation(c.type, c)), c.typeParameters && (pe2.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), pe2;
                }
                case d2.ExpressionWithTypeArguments: {
                  let R = M.kind, pe2 = R === d2.InterfaceDeclaration ? m.AST_NODE_TYPES.TSInterfaceHeritage : R === d2.HeritageClause ? m.AST_NODE_TYPES.TSClassImplements : m.AST_NODE_TYPES.TSInstantiationExpression, ke2 = this.createNode(c, { type: pe2, expression: this.convertChild(c.expression) });
                  return c.typeArguments && (ke2.typeParameters = this.convertTypeArgumentsToTypeParameters(c.typeArguments, c)), ke2;
                }
                case d2.InterfaceDeclaration: {
                  let R = (Pe2 = c.heritageClauses) !== null && Pe2 !== void 0 ? Pe2 : [], pe2 = this.createNode(c, { type: m.AST_NODE_TYPES.TSInterfaceDeclaration, body: this.createNode(c, { type: m.AST_NODE_TYPES.TSInterfaceBody, body: c.members.map((ke2) => this.convertChild(ke2)), range: [c.members.pos - 1, c.end] }), id: this.convertChild(c.name) });
                  if (c.typeParameters && (pe2.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(c.typeParameters)), R.length > 0) {
                    let ke2 = [], Je2 = [];
                    for (let Xe2 of R)
                      if (Xe2.token === d2.ExtendsKeyword)
                        for (let ee2 of Xe2.types)
                          ke2.push(this.convertChild(ee2, c));
                      else
                        for (let ee2 of Xe2.types)
                          Je2.push(this.convertChild(ee2, c));
                    ke2.length && (pe2.extends = ke2), Je2.length && (pe2.implements = Je2);
                  }
                  return (0, y.hasModifier)(d2.AbstractKeyword, c) && (pe2.abstract = true), (0, y.hasModifier)(d2.DeclareKeyword, c) && (pe2.declare = true), this.fixExports(c, pe2);
                }
                case d2.TypePredicate: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSTypePredicate, asserts: c.assertsModifier !== void 0, parameterName: this.convertChild(c.parameterName), typeAnnotation: null });
                  return c.type && (R.typeAnnotation = this.convertTypeAnnotation(c.type, c), R.typeAnnotation.loc = R.typeAnnotation.typeAnnotation.loc, R.typeAnnotation.range = R.typeAnnotation.typeAnnotation.range), R;
                }
                case d2.ImportType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSImportType, isTypeOf: !!c.isTypeOf, parameter: this.convertChild(c.argument), qualifier: this.convertChild(c.qualifier), typeParameters: c.typeArguments ? this.convertTypeArgumentsToTypeParameters(c.typeArguments, c) : null });
                case d2.EnumDeclaration: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSEnumDeclaration, id: this.convertChild(c.name), members: c.members.map((pe2) => this.convertChild(pe2)) });
                  return this.applyModifiersToResult(R, (0, P.getModifiers)(c)), this.fixExports(c, R);
                }
                case d2.EnumMember: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSEnumMember, id: this.convertChild(c.name) });
                  return c.initializer && (R.initializer = this.convertChild(c.initializer)), c.name.kind === D.SyntaxKind.ComputedPropertyName && (R.computed = true), R;
                }
                case d2.ModuleDeclaration: {
                  let R = this.createNode(c, Object.assign({ type: m.AST_NODE_TYPES.TSModuleDeclaration }, (() => {
                    let pe2 = this.convertChild(c.name), ke2 = this.convertChild(c.body);
                    if (c.flags & D.NodeFlags.GlobalAugmentation) {
                      if (ke2 == null || ke2.type === m.AST_NODE_TYPES.TSModuleDeclaration)
                        throw new Error("Expected a valid module body");
                      if (pe2.type !== m.AST_NODE_TYPES.Identifier)
                        throw new Error("global module augmentation must have an Identifier id");
                      return { kind: "global", id: pe2, body: ke2, global: true };
                    } else if (c.flags & D.NodeFlags.Namespace) {
                      if (ke2 == null)
                        throw new Error("Expected a module body");
                      if (pe2.type !== m.AST_NODE_TYPES.Identifier)
                        throw new Error("`namespace`s must have an Identifier id");
                      return { kind: "namespace", id: pe2, body: ke2 };
                    } else
                      return Object.assign({ kind: "module", id: pe2 }, ke2 != null ? { body: ke2 } : {});
                  })()));
                  return this.applyModifiersToResult(R, (0, P.getModifiers)(c)), this.fixExports(c, R);
                }
                case d2.ParenthesizedType:
                  return this.convertType(c.type);
                case d2.UnionType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSUnionType, types: c.types.map((R) => this.convertType(R)) });
                case d2.IntersectionType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSIntersectionType, types: c.types.map((R) => this.convertType(R)) });
                case d2.AsExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSAsExpression, expression: this.convertChild(c.expression), typeAnnotation: this.convertType(c.type) });
                case d2.InferType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSInferType, typeParameter: this.convertType(c.typeParameter) });
                case d2.LiteralType:
                  return C2.typescriptVersionIsAtLeast["4.0"] && c.literal.kind === d2.NullKeyword ? this.createNode(c.literal, { type: m.AST_NODE_TYPES.TSNullKeyword }) : this.createNode(c, { type: m.AST_NODE_TYPES.TSLiteralType, literal: this.convertType(c.literal) });
                case d2.TypeAssertionExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTypeAssertion, typeAnnotation: this.convertType(c.type), expression: this.convertChild(c.expression) });
                case d2.ImportEqualsDeclaration:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSImportEqualsDeclaration, id: this.convertChild(c.name), moduleReference: this.convertChild(c.moduleReference), importKind: c.isTypeOnly ? "type" : "value", isExport: (0, y.hasModifier)(d2.ExportKeyword, c) });
                case d2.ExternalModuleReference:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSExternalModuleReference, expression: this.convertChild(c.expression) });
                case d2.NamespaceExportDeclaration:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSNamespaceExportDeclaration, id: this.convertChild(c.name) });
                case d2.AbstractKeyword:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSAbstractKeyword });
                case d2.TupleType: {
                  let R = "elementTypes" in c ? c.elementTypes.map((pe2) => this.convertType(pe2)) : c.elements.map((pe2) => this.convertType(pe2));
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSTupleType, elementTypes: R });
                }
                case d2.NamedTupleMember: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSNamedTupleMember, elementType: this.convertType(c.type, c), label: this.convertChild(c.name, c), optional: c.questionToken != null });
                  return c.dotDotDotToken ? (R.range[0] = R.label.range[0], R.loc.start = R.label.loc.start, this.createNode(c, { type: m.AST_NODE_TYPES.TSRestType, typeAnnotation: R })) : R;
                }
                case d2.OptionalType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSOptionalType, typeAnnotation: this.convertType(c.type) });
                case d2.RestType:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSRestType, typeAnnotation: this.convertType(c.type) });
                case d2.TemplateLiteralType: {
                  let R = this.createNode(c, { type: m.AST_NODE_TYPES.TSTemplateLiteralType, quasis: [this.convertChild(c.head)], types: [] });
                  return c.templateSpans.forEach((pe2) => {
                    R.types.push(this.convertChild(pe2.type)), R.quasis.push(this.convertChild(pe2.literal));
                  }), R;
                }
                case d2.ClassStaticBlockDeclaration:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.StaticBlock, body: this.convertBodyExpressions(c.body.statements, c) });
                case d2.AssertEntry:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.ImportAttribute, key: this.convertChild(c.name), value: this.convertChild(c.value) });
                case d2.SatisfiesExpression:
                  return this.createNode(c, { type: m.AST_NODE_TYPES.TSSatisfiesExpression, expression: this.convertChild(c.expression), typeAnnotation: this.convertChild(c.type) });
                default:
                  return this.deeplyCopy(c);
              }
            }
          };
          a.Converter = I;
        } }), $a = {};
        m1($a, { __assign: () => f1, __asyncDelegator: () => TV, __asyncGenerator: () => bV, __asyncValues: () => SV, __await: () => gp, __awaiter: () => dV, __classPrivateFieldGet: () => CV, __classPrivateFieldSet: () => AV, __createBinding: () => hV, __decorate: () => uV, __exportStar: () => gV, __extends: () => cV, __generator: () => mV, __importDefault: () => wV, __importStar: () => EV, __makeTemplateObject: () => xV, __metadata: () => fV, __param: () => pV, __read: () => $9, __rest: () => lV, __spread: () => yV, __spreadArrays: () => vV, __values: () => tT });
        function cV(a, _) {
          p1(a, _);
          function v2() {
            this.constructor = a;
          }
          a.prototype = _ === null ? Object.create(_) : (v2.prototype = _.prototype, new v2());
        }
        function lV(a, _) {
          var v2 = {};
          for (var h in a)
            Object.prototype.hasOwnProperty.call(a, h) && _.indexOf(h) < 0 && (v2[h] = a[h]);
          if (a != null && typeof Object.getOwnPropertySymbols == "function")
            for (var D = 0, h = Object.getOwnPropertySymbols(a); D < h.length; D++)
              _.indexOf(h[D]) < 0 && Object.prototype.propertyIsEnumerable.call(a, h[D]) && (v2[h[D]] = a[h[D]]);
          return v2;
        }
        function uV(a, _, v2, h) {
          var D = arguments.length, P = D < 3 ? _ : h === null ? h = Object.getOwnPropertyDescriptor(_, v2) : h, y;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            P = Reflect.decorate(a, _, v2, h);
          else
            for (var m = a.length - 1; m >= 0; m--)
              (y = a[m]) && (P = (D < 3 ? y(P) : D > 3 ? y(_, v2, P) : y(_, v2)) || P);
          return D > 3 && P && Object.defineProperty(_, v2, P), P;
        }
        function pV(a, _) {
          return function(v2, h) {
            _(v2, h, a);
          };
        }
        function fV(a, _) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(a, _);
        }
        function dV(a, _, v2, h) {
          function D(P) {
            return P instanceof v2 ? P : new v2(function(y) {
              y(P);
            });
          }
          return new (v2 || (v2 = Promise))(function(P, y) {
            function m(E) {
              try {
                d2(h.next(E));
              } catch (I) {
                y(I);
              }
            }
            function C2(E) {
              try {
                d2(h.throw(E));
              } catch (I) {
                y(I);
              }
            }
            function d2(E) {
              E.done ? P(E.value) : D(E.value).then(m, C2);
            }
            d2((h = h.apply(a, _ || [])).next());
          });
        }
        function mV(a, _) {
          var v2 = { label: 0, sent: function() {
            if (P[0] & 1)
              throw P[1];
            return P[1];
          }, trys: [], ops: [] }, h, D, P, y;
          return y = { next: m(0), throw: m(1), return: m(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
            return this;
          }), y;
          function m(d2) {
            return function(E) {
              return C2([d2, E]);
            };
          }
          function C2(d2) {
            if (h)
              throw new TypeError("Generator is already executing.");
            for (; v2; )
              try {
                if (h = 1, D && (P = d2[0] & 2 ? D.return : d2[0] ? D.throw || ((P = D.return) && P.call(D), 0) : D.next) && !(P = P.call(D, d2[1])).done)
                  return P;
                switch (D = 0, P && (d2 = [d2[0] & 2, P.value]), d2[0]) {
                  case 0:
                  case 1:
                    P = d2;
                    break;
                  case 4:
                    return v2.label++, { value: d2[1], done: false };
                  case 5:
                    v2.label++, D = d2[1], d2 = [0];
                    continue;
                  case 7:
                    d2 = v2.ops.pop(), v2.trys.pop();
                    continue;
                  default:
                    if (P = v2.trys, !(P = P.length > 0 && P[P.length - 1]) && (d2[0] === 6 || d2[0] === 2)) {
                      v2 = 0;
                      continue;
                    }
                    if (d2[0] === 3 && (!P || d2[1] > P[0] && d2[1] < P[3])) {
                      v2.label = d2[1];
                      break;
                    }
                    if (d2[0] === 6 && v2.label < P[1]) {
                      v2.label = P[1], P = d2;
                      break;
                    }
                    if (P && v2.label < P[2]) {
                      v2.label = P[2], v2.ops.push(d2);
                      break;
                    }
                    P[2] && v2.ops.pop(), v2.trys.pop();
                    continue;
                }
                d2 = _.call(a, v2);
              } catch (E) {
                d2 = [6, E], D = 0;
              } finally {
                h = P = 0;
              }
            if (d2[0] & 5)
              throw d2[1];
            return { value: d2[0] ? d2[1] : void 0, done: true };
          }
        }
        function hV(a, _, v2, h) {
          h === void 0 && (h = v2), a[h] = _[v2];
        }
        function gV(a, _) {
          for (var v2 in a)
            v2 !== "default" && !_.hasOwnProperty(v2) && (_[v2] = a[v2]);
        }
        function tT(a) {
          var _ = typeof Symbol == "function" && Symbol.iterator, v2 = _ && a[_], h = 0;
          if (v2)
            return v2.call(a);
          if (a && typeof a.length == "number")
            return { next: function() {
              return a && h >= a.length && (a = void 0), { value: a && a[h++], done: !a };
            } };
          throw new TypeError(_ ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function $9(a, _) {
          var v2 = typeof Symbol == "function" && a[Symbol.iterator];
          if (!v2)
            return a;
          var h = v2.call(a), D, P = [], y;
          try {
            for (; (_ === void 0 || _-- > 0) && !(D = h.next()).done; )
              P.push(D.value);
          } catch (m) {
            y = { error: m };
          } finally {
            try {
              D && !D.done && (v2 = h.return) && v2.call(h);
            } finally {
              if (y)
                throw y.error;
            }
          }
          return P;
        }
        function yV() {
          for (var a = [], _ = 0; _ < arguments.length; _++)
            a = a.concat($9(arguments[_]));
          return a;
        }
        function vV() {
          for (var a = 0, _ = 0, v2 = arguments.length; _ < v2; _++)
            a += arguments[_].length;
          for (var h = Array(a), D = 0, _ = 0; _ < v2; _++)
            for (var P = arguments[_], y = 0, m = P.length; y < m; y++, D++)
              h[D] = P[y];
          return h;
        }
        function gp(a) {
          return this instanceof gp ? (this.v = a, this) : new gp(a);
        }
        function bV(a, _, v2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var h = v2.apply(a, _ || []), D, P = [];
          return D = {}, y("next"), y("throw"), y("return"), D[Symbol.asyncIterator] = function() {
            return this;
          }, D;
          function y(c) {
            h[c] && (D[c] = function(M) {
              return new Promise(function(q2, W) {
                P.push([c, M, q2, W]) > 1 || m(c, M);
              });
            });
          }
          function m(c, M) {
            try {
              C2(h[c](M));
            } catch (q2) {
              I(P[0][3], q2);
            }
          }
          function C2(c) {
            c.value instanceof gp ? Promise.resolve(c.value.v).then(d2, E) : I(P[0][2], c);
          }
          function d2(c) {
            m("next", c);
          }
          function E(c) {
            m("throw", c);
          }
          function I(c, M) {
            c(M), P.shift(), P.length && m(P[0][0], P[0][1]);
          }
        }
        function TV(a) {
          var _, v2;
          return _ = {}, h("next"), h("throw", function(D) {
            throw D;
          }), h("return"), _[Symbol.iterator] = function() {
            return this;
          }, _;
          function h(D, P) {
            _[D] = a[D] ? function(y) {
              return (v2 = !v2) ? { value: gp(a[D](y)), done: D === "return" } : P ? P(y) : y;
            } : P;
          }
        }
        function SV(a) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var _ = a[Symbol.asyncIterator], v2;
          return _ ? _.call(a) : (a = typeof tT == "function" ? tT(a) : a[Symbol.iterator](), v2 = {}, h("next"), h("throw"), h("return"), v2[Symbol.asyncIterator] = function() {
            return this;
          }, v2);
          function h(P) {
            v2[P] = a[P] && function(y) {
              return new Promise(function(m, C2) {
                y = a[P](y), D(m, C2, y.done, y.value);
              });
            };
          }
          function D(P, y, m, C2) {
            Promise.resolve(C2).then(function(d2) {
              P({ value: d2, done: m });
            }, y);
          }
        }
        function xV(a, _) {
          return Object.defineProperty ? Object.defineProperty(a, "raw", { value: _ }) : a.raw = _, a;
        }
        function EV(a) {
          if (a && a.__esModule)
            return a;
          var _ = {};
          if (a != null)
            for (var v2 in a)
              Object.hasOwnProperty.call(a, v2) && (_[v2] = a[v2]);
          return _.default = a, _;
        }
        function wV(a) {
          return a && a.__esModule ? a : { default: a };
        }
        function CV(a, _) {
          if (!_.has(a))
            throw new TypeError("attempted to get private field on non-instance");
          return _.get(a);
        }
        function AV(a, _, v2) {
          if (!_.has(a))
            throw new TypeError("attempted to set private field on non-instance");
          return _.set(a, v2), v2;
        }
        var p1, f1, Ds = yp({ "node_modules/tslib/tslib.es6.js"() {
          De3(), p1 = function(a, _) {
            return p1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v2, h) {
              v2.__proto__ = h;
            } || function(v2, h) {
              for (var D in h)
                h.hasOwnProperty(D) && (v2[D] = h[D]);
            }, p1(a, _);
          }, f1 = function() {
            return f1 = Object.assign || function(_) {
              for (var v2, h = 1, D = arguments.length; h < D; h++) {
                v2 = arguments[h];
                for (var P in v2)
                  Object.prototype.hasOwnProperty.call(v2, P) && (_[P] = v2[P]);
              }
              return _;
            }, f1.apply(this, arguments);
          };
        } }), PV = Oe2({ "node_modules/tsutils/typeguard/2.8/node.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isExpressionStatement = a.isExpression = a.isExportSpecifier = a.isExportDeclaration = a.isExportAssignment = a.isEnumMember = a.isEnumDeclaration = a.isEntityNameExpression = a.isEntityName = a.isEmptyStatement = a.isElementAccessExpression = a.isDoStatement = a.isDeleteExpression = a.isDefaultClause = a.isDecorator = a.isDebuggerStatement = a.isComputedPropertyName = a.isContinueStatement = a.isConstructSignatureDeclaration = a.isConstructorTypeNode = a.isConstructorDeclaration = a.isConditionalTypeNode = a.isConditionalExpression = a.isCommaListExpression = a.isClassLikeDeclaration = a.isClassExpression = a.isClassDeclaration = a.isCatchClause = a.isCaseOrDefaultClause = a.isCaseClause = a.isCaseBlock = a.isCallSignatureDeclaration = a.isCallLikeExpression = a.isCallExpression = a.isBreakStatement = a.isBreakOrContinueStatement = a.isBooleanLiteral = a.isBlockLike = a.isBlock = a.isBindingPattern = a.isBindingElement = a.isBinaryExpression = a.isAwaitExpression = a.isAssertionExpression = a.isAsExpression = a.isArrowFunction = a.isArrayTypeNode = a.isArrayLiteralExpression = a.isArrayBindingPattern = a.isAccessorDeclaration = void 0, a.isNamespaceImport = a.isNamespaceDeclaration = a.isNamedImports = a.isNamedExports = a.isModuleDeclaration = a.isModuleBlock = a.isMethodSignature = a.isMethodDeclaration = a.isMetaProperty = a.isMappedTypeNode = a.isLiteralTypeNode = a.isLiteralExpression = a.isLabeledStatement = a.isJsxText = a.isJsxSpreadAttribute = a.isJsxSelfClosingElement = a.isJsxOpeningLikeElement = a.isJsxOpeningFragment = a.isJsxOpeningElement = a.isJsxFragment = a.isJsxExpression = a.isJsxElement = a.isJsxClosingFragment = a.isJsxClosingElement = a.isJsxAttributes = a.isJsxAttributeLike = a.isJsxAttribute = a.isJsDoc = a.isIterationStatement = a.isIntersectionTypeNode = a.isInterfaceDeclaration = a.isInferTypeNode = a.isIndexSignatureDeclaration = a.isIndexedAccessTypeNode = a.isImportSpecifier = a.isImportEqualsDeclaration = a.isImportDeclaration = a.isImportClause = a.isIfStatement = a.isIdentifier = a.isGetAccessorDeclaration = a.isFunctionTypeNode = a.isFunctionExpression = a.isFunctionDeclaration = a.isForStatement = a.isForOfStatement = a.isForInOrOfStatement = a.isForInStatement = a.isExternalModuleReference = a.isExpressionWithTypeArguments = void 0, a.isVariableStatement = a.isVariableDeclaration = a.isUnionTypeNode = a.isTypeQueryNode = a.isTypeReferenceNode = a.isTypePredicateNode = a.isTypeParameterDeclaration = a.isTypeOperatorNode = a.isTypeOfExpression = a.isTypeLiteralNode = a.isTypeAssertion = a.isTypeAliasDeclaration = a.isTupleTypeNode = a.isTryStatement = a.isThrowStatement = a.isTextualLiteral = a.isTemplateLiteral = a.isTemplateExpression = a.isTaggedTemplateExpression = a.isSyntaxList = a.isSwitchStatement = a.isStringLiteral = a.isSpreadElement = a.isSpreadAssignment = a.isSourceFile = a.isSignatureDeclaration = a.isShorthandPropertyAssignment = a.isSetAccessorDeclaration = a.isReturnStatement = a.isRegularExpressionLiteral = a.isQualifiedName = a.isPropertySignature = a.isPropertyDeclaration = a.isPropertyAssignment = a.isPropertyAccessExpression = a.isPrefixUnaryExpression = a.isPostfixUnaryExpression = a.isParenthesizedTypeNode = a.isParenthesizedExpression = a.isParameterDeclaration = a.isOmittedExpression = a.isObjectLiteralExpression = a.isObjectBindingPattern = a.isNumericOrStringLikeLiteral = a.isNumericLiteral = a.isNullLiteral = a.isNoSubstitutionTemplateLiteral = a.isNonNullExpression = a.isNewExpression = a.isNamespaceExportDeclaration = void 0, a.isWithStatement = a.isWhileStatement = a.isVoidExpression = a.isVariableDeclarationList = void 0;
          var _ = vr();
          function v2(J3) {
            return J3.kind === _.SyntaxKind.GetAccessor || J3.kind === _.SyntaxKind.SetAccessor;
          }
          a.isAccessorDeclaration = v2;
          function h(J3) {
            return J3.kind === _.SyntaxKind.ArrayBindingPattern;
          }
          a.isArrayBindingPattern = h;
          function D(J3) {
            return J3.kind === _.SyntaxKind.ArrayLiteralExpression;
          }
          a.isArrayLiteralExpression = D;
          function P(J3) {
            return J3.kind === _.SyntaxKind.ArrayType;
          }
          a.isArrayTypeNode = P;
          function y(J3) {
            return J3.kind === _.SyntaxKind.ArrowFunction;
          }
          a.isArrowFunction = y;
          function m(J3) {
            return J3.kind === _.SyntaxKind.AsExpression;
          }
          a.isAsExpression = m;
          function C2(J3) {
            return J3.kind === _.SyntaxKind.AsExpression || J3.kind === _.SyntaxKind.TypeAssertionExpression;
          }
          a.isAssertionExpression = C2;
          function d2(J3) {
            return J3.kind === _.SyntaxKind.AwaitExpression;
          }
          a.isAwaitExpression = d2;
          function E(J3) {
            return J3.kind === _.SyntaxKind.BinaryExpression;
          }
          a.isBinaryExpression = E;
          function I(J3) {
            return J3.kind === _.SyntaxKind.BindingElement;
          }
          a.isBindingElement = I;
          function c(J3) {
            return J3.kind === _.SyntaxKind.ArrayBindingPattern || J3.kind === _.SyntaxKind.ObjectBindingPattern;
          }
          a.isBindingPattern = c;
          function M(J3) {
            return J3.kind === _.SyntaxKind.Block;
          }
          a.isBlock = M;
          function q2(J3) {
            return J3.statements !== void 0;
          }
          a.isBlockLike = q2;
          function W(J3) {
            return J3.kind === _.SyntaxKind.TrueKeyword || J3.kind === _.SyntaxKind.FalseKeyword;
          }
          a.isBooleanLiteral = W;
          function K(J3) {
            return J3.kind === _.SyntaxKind.BreakStatement || J3.kind === _.SyntaxKind.ContinueStatement;
          }
          a.isBreakOrContinueStatement = K;
          function ce2(J3) {
            return J3.kind === _.SyntaxKind.BreakStatement;
          }
          a.isBreakStatement = ce2;
          function Ie2(J3) {
            return J3.kind === _.SyntaxKind.CallExpression;
          }
          a.isCallExpression = Ie2;
          function me2(J3) {
            switch (J3.kind) {
              case _.SyntaxKind.CallExpression:
              case _.SyntaxKind.Decorator:
              case _.SyntaxKind.JsxOpeningElement:
              case _.SyntaxKind.JsxSelfClosingElement:
              case _.SyntaxKind.NewExpression:
              case _.SyntaxKind.TaggedTemplateExpression:
                return true;
              default:
                return false;
            }
          }
          a.isCallLikeExpression = me2;
          function Ae2(J3) {
            return J3.kind === _.SyntaxKind.CallSignature;
          }
          a.isCallSignatureDeclaration = Ae2;
          function te2(J3) {
            return J3.kind === _.SyntaxKind.CaseBlock;
          }
          a.isCaseBlock = te2;
          function he(J3) {
            return J3.kind === _.SyntaxKind.CaseClause;
          }
          a.isCaseClause = he;
          function Pe2(J3) {
            return J3.kind === _.SyntaxKind.CaseClause || J3.kind === _.SyntaxKind.DefaultClause;
          }
          a.isCaseOrDefaultClause = Pe2;
          function R(J3) {
            return J3.kind === _.SyntaxKind.CatchClause;
          }
          a.isCatchClause = R;
          function pe2(J3) {
            return J3.kind === _.SyntaxKind.ClassDeclaration;
          }
          a.isClassDeclaration = pe2;
          function ke2(J3) {
            return J3.kind === _.SyntaxKind.ClassExpression;
          }
          a.isClassExpression = ke2;
          function Je2(J3) {
            return J3.kind === _.SyntaxKind.ClassDeclaration || J3.kind === _.SyntaxKind.ClassExpression;
          }
          a.isClassLikeDeclaration = Je2;
          function Xe2(J3) {
            return J3.kind === _.SyntaxKind.CommaListExpression;
          }
          a.isCommaListExpression = Xe2;
          function ee2(J3) {
            return J3.kind === _.SyntaxKind.ConditionalExpression;
          }
          a.isConditionalExpression = ee2;
          function je2(J3) {
            return J3.kind === _.SyntaxKind.ConditionalType;
          }
          a.isConditionalTypeNode = je2;
          function nt(J3) {
            return J3.kind === _.SyntaxKind.Constructor;
          }
          a.isConstructorDeclaration = nt;
          function Ze2(J3) {
            return J3.kind === _.SyntaxKind.ConstructorType;
          }
          a.isConstructorTypeNode = Ze2;
          function st2(J3) {
            return J3.kind === _.SyntaxKind.ConstructSignature;
          }
          a.isConstructSignatureDeclaration = st2;
          function tt(J3) {
            return J3.kind === _.SyntaxKind.ContinueStatement;
          }
          a.isContinueStatement = tt;
          function ct(J3) {
            return J3.kind === _.SyntaxKind.ComputedPropertyName;
          }
          a.isComputedPropertyName = ct;
          function ne2(J3) {
            return J3.kind === _.SyntaxKind.DebuggerStatement;
          }
          a.isDebuggerStatement = ne2;
          function ge(J3) {
            return J3.kind === _.SyntaxKind.Decorator;
          }
          a.isDecorator = ge;
          function Fe2(J3) {
            return J3.kind === _.SyntaxKind.DefaultClause;
          }
          a.isDefaultClause = Fe2;
          function at3(J3) {
            return J3.kind === _.SyntaxKind.DeleteExpression;
          }
          a.isDeleteExpression = at3;
          function Pt(J3) {
            return J3.kind === _.SyntaxKind.DoStatement;
          }
          a.isDoStatement = Pt;
          function qt(J3) {
            return J3.kind === _.SyntaxKind.ElementAccessExpression;
          }
          a.isElementAccessExpression = qt;
          function Zr2(J3) {
            return J3.kind === _.SyntaxKind.EmptyStatement;
          }
          a.isEmptyStatement = Zr2;
          function Ri(J3) {
            return J3.kind === _.SyntaxKind.Identifier || w_(J3);
          }
          a.isEntityName = Ri;
          function la(J3) {
            return J3.kind === _.SyntaxKind.Identifier || gi(J3) && la(J3.expression);
          }
          a.isEntityNameExpression = la;
          function ua(J3) {
            return J3.kind === _.SyntaxKind.EnumDeclaration;
          }
          a.isEnumDeclaration = ua;
          function Ka(J3) {
            return J3.kind === _.SyntaxKind.EnumMember;
          }
          a.isEnumMember = Ka;
          function co(J3) {
            return J3.kind === _.SyntaxKind.ExportAssignment;
          }
          a.isExportAssignment = co;
          function be2(J3) {
            return J3.kind === _.SyntaxKind.ExportDeclaration;
          }
          a.isExportDeclaration = be2;
          function Ke3(J3) {
            return J3.kind === _.SyntaxKind.ExportSpecifier;
          }
          a.isExportSpecifier = Ke3;
          function Et(J3) {
            switch (J3.kind) {
              case _.SyntaxKind.ArrayLiteralExpression:
              case _.SyntaxKind.ArrowFunction:
              case _.SyntaxKind.AsExpression:
              case _.SyntaxKind.AwaitExpression:
              case _.SyntaxKind.BinaryExpression:
              case _.SyntaxKind.CallExpression:
              case _.SyntaxKind.ClassExpression:
              case _.SyntaxKind.CommaListExpression:
              case _.SyntaxKind.ConditionalExpression:
              case _.SyntaxKind.DeleteExpression:
              case _.SyntaxKind.ElementAccessExpression:
              case _.SyntaxKind.FalseKeyword:
              case _.SyntaxKind.FunctionExpression:
              case _.SyntaxKind.Identifier:
              case _.SyntaxKind.JsxElement:
              case _.SyntaxKind.JsxFragment:
              case _.SyntaxKind.JsxExpression:
              case _.SyntaxKind.JsxOpeningElement:
              case _.SyntaxKind.JsxOpeningFragment:
              case _.SyntaxKind.JsxSelfClosingElement:
              case _.SyntaxKind.MetaProperty:
              case _.SyntaxKind.NewExpression:
              case _.SyntaxKind.NonNullExpression:
              case _.SyntaxKind.NoSubstitutionTemplateLiteral:
              case _.SyntaxKind.NullKeyword:
              case _.SyntaxKind.NumericLiteral:
              case _.SyntaxKind.ObjectLiteralExpression:
              case _.SyntaxKind.OmittedExpression:
              case _.SyntaxKind.ParenthesizedExpression:
              case _.SyntaxKind.PostfixUnaryExpression:
              case _.SyntaxKind.PrefixUnaryExpression:
              case _.SyntaxKind.PropertyAccessExpression:
              case _.SyntaxKind.RegularExpressionLiteral:
              case _.SyntaxKind.SpreadElement:
              case _.SyntaxKind.StringLiteral:
              case _.SyntaxKind.SuperKeyword:
              case _.SyntaxKind.TaggedTemplateExpression:
              case _.SyntaxKind.TemplateExpression:
              case _.SyntaxKind.ThisKeyword:
              case _.SyntaxKind.TrueKeyword:
              case _.SyntaxKind.TypeAssertionExpression:
              case _.SyntaxKind.TypeOfExpression:
              case _.SyntaxKind.VoidExpression:
              case _.SyntaxKind.YieldExpression:
                return true;
              default:
                return false;
            }
          }
          a.isExpression = Et;
          function Ft(J3) {
            return J3.kind === _.SyntaxKind.ExpressionStatement;
          }
          a.isExpressionStatement = Ft;
          function or2(J3) {
            return J3.kind === _.SyntaxKind.ExpressionWithTypeArguments;
          }
          a.isExpressionWithTypeArguments = or2;
          function Wr2(J3) {
            return J3.kind === _.SyntaxKind.ExternalModuleReference;
          }
          a.isExternalModuleReference = Wr2;
          function m_(J3) {
            return J3.kind === _.SyntaxKind.ForInStatement;
          }
          a.isForInStatement = m_;
          function Uc(J3) {
            return J3.kind === _.SyntaxKind.ForOfStatement || J3.kind === _.SyntaxKind.ForInStatement;
          }
          a.isForInOrOfStatement = Uc;
          function ji(J3) {
            return J3.kind === _.SyntaxKind.ForOfStatement;
          }
          a.isForOfStatement = ji;
          function lo(J3) {
            return J3.kind === _.SyntaxKind.ForStatement;
          }
          a.isForStatement = lo;
          function zc(J3) {
            return J3.kind === _.SyntaxKind.FunctionDeclaration;
          }
          a.isFunctionDeclaration = zc;
          function Qn(J3) {
            return J3.kind === _.SyntaxKind.FunctionExpression;
          }
          a.isFunctionExpression = Qn;
          function uo(J3) {
            return J3.kind === _.SyntaxKind.FunctionType;
          }
          a.isFunctionTypeNode = uo;
          function Wc(J3) {
            return J3.kind === _.SyntaxKind.GetAccessor;
          }
          a.isGetAccessorDeclaration = Wc;
          function Vc(J3) {
            return J3.kind === _.SyntaxKind.Identifier;
          }
          a.isIdentifier = Vc;
          function Hc(J3) {
            return J3.kind === _.SyntaxKind.IfStatement;
          }
          a.isIfStatement = Hc;
          function Gc(J3) {
            return J3.kind === _.SyntaxKind.ImportClause;
          }
          a.isImportClause = Gc;
          function h_(J3) {
            return J3.kind === _.SyntaxKind.ImportDeclaration;
          }
          a.isImportDeclaration = h_;
          function tr2(J3) {
            return J3.kind === _.SyntaxKind.ImportEqualsDeclaration;
          }
          a.isImportEqualsDeclaration = tr2;
          function $c(J3) {
            return J3.kind === _.SyntaxKind.ImportSpecifier;
          }
          a.isImportSpecifier = $c;
          function po(J3) {
            return J3.kind === _.SyntaxKind.IndexedAccessType;
          }
          a.isIndexedAccessTypeNode = po;
          function jr2(J3) {
            return J3.kind === _.SyntaxKind.IndexSignature;
          }
          a.isIndexSignatureDeclaration = jr2;
          function qn(J3) {
            return J3.kind === _.SyntaxKind.InferType;
          }
          a.isInferTypeNode = qn;
          function g_(J3) {
            return J3.kind === _.SyntaxKind.InterfaceDeclaration;
          }
          a.isInterfaceDeclaration = g_;
          function ks(J3) {
            return J3.kind === _.SyntaxKind.IntersectionType;
          }
          a.isIntersectionTypeNode = ks;
          function Is(J3) {
            switch (J3.kind) {
              case _.SyntaxKind.ForStatement:
              case _.SyntaxKind.ForOfStatement:
              case _.SyntaxKind.ForInStatement:
              case _.SyntaxKind.WhileStatement:
              case _.SyntaxKind.DoStatement:
                return true;
              default:
                return false;
            }
          }
          a.isIterationStatement = Is;
          function y_(J3) {
            return J3.kind === _.SyntaxKind.JSDocComment;
          }
          a.isJsDoc = y_;
          function Ns(J3) {
            return J3.kind === _.SyntaxKind.JsxAttribute;
          }
          a.isJsxAttribute = Ns;
          function Kc(J3) {
            return J3.kind === _.SyntaxKind.JsxAttribute || J3.kind === _.SyntaxKind.JsxSpreadAttribute;
          }
          a.isJsxAttributeLike = Kc;
          function pa(J3) {
            return J3.kind === _.SyntaxKind.JsxAttributes;
          }
          a.isJsxAttributes = pa;
          function Xc(J3) {
            return J3.kind === _.SyntaxKind.JsxClosingElement;
          }
          a.isJsxClosingElement = Xc;
          function fo2(J3) {
            return J3.kind === _.SyntaxKind.JsxClosingFragment;
          }
          a.isJsxClosingFragment = fo2;
          function v_(J3) {
            return J3.kind === _.SyntaxKind.JsxElement;
          }
          a.isJsxElement = v_;
          function Cn(J3) {
            return J3.kind === _.SyntaxKind.JsxExpression;
          }
          a.isJsxExpression = Cn;
          function Zn(J3) {
            return J3.kind === _.SyntaxKind.JsxFragment;
          }
          a.isJsxFragment = Zn;
          function Xa(J3) {
            return J3.kind === _.SyntaxKind.JsxOpeningElement;
          }
          a.isJsxOpeningElement = Xa;
          function Yc2(J3) {
            return J3.kind === _.SyntaxKind.JsxOpeningFragment;
          }
          a.isJsxOpeningFragment = Yc2;
          function mo(J3) {
            return J3.kind === _.SyntaxKind.JsxOpeningElement || J3.kind === _.SyntaxKind.JsxSelfClosingElement;
          }
          a.isJsxOpeningLikeElement = mo;
          function ei(J3) {
            return J3.kind === _.SyntaxKind.JsxSelfClosingElement;
          }
          a.isJsxSelfClosingElement = ei;
          function Ya(J3) {
            return J3.kind === _.SyntaxKind.JsxSpreadAttribute;
          }
          a.isJsxSpreadAttribute = Ya;
          function b_(J3) {
            return J3.kind === _.SyntaxKind.JsxText;
          }
          a.isJsxText = b_;
          function Qa(J3) {
            return J3.kind === _.SyntaxKind.LabeledStatement;
          }
          a.isLabeledStatement = Qa;
          function Jr(J3) {
            return J3.kind >= _.SyntaxKind.FirstLiteralToken && J3.kind <= _.SyntaxKind.LastLiteralToken;
          }
          a.isLiteralExpression = Jr;
          function Qc(J3) {
            return J3.kind === _.SyntaxKind.LiteralType;
          }
          a.isLiteralTypeNode = Qc;
          function ho(J3) {
            return J3.kind === _.SyntaxKind.MappedType;
          }
          a.isMappedTypeNode = ho;
          function T_(J3) {
            return J3.kind === _.SyntaxKind.MetaProperty;
          }
          a.isMetaProperty = T_;
          function go(J3) {
            return J3.kind === _.SyntaxKind.MethodDeclaration;
          }
          a.isMethodDeclaration = go;
          function yo(J3) {
            return J3.kind === _.SyntaxKind.MethodSignature;
          }
          a.isMethodSignature = yo;
          function Za(J3) {
            return J3.kind === _.SyntaxKind.ModuleBlock;
          }
          a.isModuleBlock = Za;
          function vo(J3) {
            return J3.kind === _.SyntaxKind.ModuleDeclaration;
          }
          a.isModuleDeclaration = vo;
          function S_(J3) {
            return J3.kind === _.SyntaxKind.NamedExports;
          }
          a.isNamedExports = S_;
          function Zc(J3) {
            return J3.kind === _.SyntaxKind.NamedImports;
          }
          a.isNamedImports = Zc;
          function Os(J3) {
            return vo(J3) && J3.name.kind === _.SyntaxKind.Identifier && J3.body !== void 0 && (J3.body.kind === _.SyntaxKind.ModuleBlock || Os(J3.body));
          }
          a.isNamespaceDeclaration = Os;
          function bo(J3) {
            return J3.kind === _.SyntaxKind.NamespaceImport;
          }
          a.isNamespaceImport = bo;
          function el(J3) {
            return J3.kind === _.SyntaxKind.NamespaceExportDeclaration;
          }
          a.isNamespaceExportDeclaration = el;
          function x_(J3) {
            return J3.kind === _.SyntaxKind.NewExpression;
          }
          a.isNewExpression = x_;
          function E_(J3) {
            return J3.kind === _.SyntaxKind.NonNullExpression;
          }
          a.isNonNullExpression = E_;
          function S(J3) {
            return J3.kind === _.SyntaxKind.NoSubstitutionTemplateLiteral;
          }
          a.isNoSubstitutionTemplateLiteral = S;
          function H(J3) {
            return J3.kind === _.SyntaxKind.NullKeyword;
          }
          a.isNullLiteral = H;
          function le(J3) {
            return J3.kind === _.SyntaxKind.NumericLiteral;
          }
          a.isNumericLiteral = le;
          function Be2(J3) {
            switch (J3.kind) {
              case _.SyntaxKind.StringLiteral:
              case _.SyntaxKind.NumericLiteral:
              case _.SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
              default:
                return false;
            }
          }
          a.isNumericOrStringLikeLiteral = Be2;
          function rt(J3) {
            return J3.kind === _.SyntaxKind.ObjectBindingPattern;
          }
          a.isObjectBindingPattern = rt;
          function ut(J3) {
            return J3.kind === _.SyntaxKind.ObjectLiteralExpression;
          }
          a.isObjectLiteralExpression = ut;
          function Ht(J3) {
            return J3.kind === _.SyntaxKind.OmittedExpression;
          }
          a.isOmittedExpression = Ht;
          function Fr2(J3) {
            return J3.kind === _.SyntaxKind.Parameter;
          }
          a.isParameterDeclaration = Fr2;
          function Cr2(J3) {
            return J3.kind === _.SyntaxKind.ParenthesizedExpression;
          }
          a.isParenthesizedExpression = Cr2;
          function ir2(J3) {
            return J3.kind === _.SyntaxKind.ParenthesizedType;
          }
          a.isParenthesizedTypeNode = ir2;
          function en(J3) {
            return J3.kind === _.SyntaxKind.PostfixUnaryExpression;
          }
          a.isPostfixUnaryExpression = en;
          function Ji(J3) {
            return J3.kind === _.SyntaxKind.PrefixUnaryExpression;
          }
          a.isPrefixUnaryExpression = Ji;
          function gi(J3) {
            return J3.kind === _.SyntaxKind.PropertyAccessExpression;
          }
          a.isPropertyAccessExpression = gi;
          function ln(J3) {
            return J3.kind === _.SyntaxKind.PropertyAssignment;
          }
          a.isPropertyAssignment = ln;
          function ti(J3) {
            return J3.kind === _.SyntaxKind.PropertyDeclaration;
          }
          a.isPropertyDeclaration = ti;
          function yn(J3) {
            return J3.kind === _.SyntaxKind.PropertySignature;
          }
          a.isPropertySignature = yn;
          function w_(J3) {
            return J3.kind === _.SyntaxKind.QualifiedName;
          }
          a.isQualifiedName = w_;
          function vp(J3) {
            return J3.kind === _.SyntaxKind.RegularExpressionLiteral;
          }
          a.isRegularExpressionLiteral = vp;
          function C1(J3) {
            return J3.kind === _.SyntaxKind.ReturnStatement;
          }
          a.isReturnStatement = C1;
          function rr2(J3) {
            return J3.kind === _.SyntaxKind.SetAccessor;
          }
          a.isSetAccessorDeclaration = rr2;
          function bp(J3) {
            return J3.kind === _.SyntaxKind.ShorthandPropertyAssignment;
          }
          a.isShorthandPropertyAssignment = bp;
          function Tp(J3) {
            return J3.parameters !== void 0;
          }
          a.isSignatureDeclaration = Tp;
          function A1(J3) {
            return J3.kind === _.SyntaxKind.SourceFile;
          }
          a.isSourceFile = A1;
          function tl(J3) {
            return J3.kind === _.SyntaxKind.SpreadAssignment;
          }
          a.isSpreadAssignment = tl;
          function An(J3) {
            return J3.kind === _.SyntaxKind.SpreadElement;
          }
          a.isSpreadElement = An;
          function P1(J3) {
            return J3.kind === _.SyntaxKind.StringLiteral;
          }
          a.isStringLiteral = P1;
          function D1(J3) {
            return J3.kind === _.SyntaxKind.SwitchStatement;
          }
          a.isSwitchStatement = D1;
          function k1(J3) {
            return J3.kind === _.SyntaxKind.SyntaxList;
          }
          a.isSyntaxList = k1;
          function fa(J3) {
            return J3.kind === _.SyntaxKind.TaggedTemplateExpression;
          }
          a.isTaggedTemplateExpression = fa;
          function Ms(J3) {
            return J3.kind === _.SyntaxKind.TemplateExpression;
          }
          a.isTemplateExpression = Ms;
          function To(J3) {
            return J3.kind === _.SyntaxKind.TemplateExpression || J3.kind === _.SyntaxKind.NoSubstitutionTemplateLiteral;
          }
          a.isTemplateLiteral = To;
          function Sp(J3) {
            return J3.kind === _.SyntaxKind.StringLiteral || J3.kind === _.SyntaxKind.NoSubstitutionTemplateLiteral;
          }
          a.isTextualLiteral = Sp;
          function Vr2(J3) {
            return J3.kind === _.SyntaxKind.ThrowStatement;
          }
          a.isThrowStatement = Vr2;
          function I1(J3) {
            return J3.kind === _.SyntaxKind.TryStatement;
          }
          a.isTryStatement = I1;
          function N1(J3) {
            return J3.kind === _.SyntaxKind.TupleType;
          }
          a.isTupleTypeNode = N1;
          function C_(J3) {
            return J3.kind === _.SyntaxKind.TypeAliasDeclaration;
          }
          a.isTypeAliasDeclaration = C_;
          function O1(J3) {
            return J3.kind === _.SyntaxKind.TypeAssertionExpression;
          }
          a.isTypeAssertion = O1;
          function ri(J3) {
            return J3.kind === _.SyntaxKind.TypeLiteral;
          }
          a.isTypeLiteralNode = ri;
          function rl(J3) {
            return J3.kind === _.SyntaxKind.TypeOfExpression;
          }
          a.isTypeOfExpression = rl;
          function M1(J3) {
            return J3.kind === _.SyntaxKind.TypeOperator;
          }
          a.isTypeOperatorNode = M1;
          function xp(J3) {
            return J3.kind === _.SyntaxKind.TypeParameter;
          }
          a.isTypeParameterDeclaration = xp;
          function L1(J3) {
            return J3.kind === _.SyntaxKind.TypePredicate;
          }
          a.isTypePredicateNode = L1;
          function R1(J3) {
            return J3.kind === _.SyntaxKind.TypeReference;
          }
          a.isTypeReferenceNode = R1;
          function j1(J3) {
            return J3.kind === _.SyntaxKind.TypeQuery;
          }
          a.isTypeQueryNode = j1;
          function Ep(J3) {
            return J3.kind === _.SyntaxKind.UnionType;
          }
          a.isUnionTypeNode = Ep;
          function J1(J3) {
            return J3.kind === _.SyntaxKind.VariableDeclaration;
          }
          a.isVariableDeclaration = J1;
          function es(J3) {
            return J3.kind === _.SyntaxKind.VariableStatement;
          }
          a.isVariableStatement = es;
          function F1(J3) {
            return J3.kind === _.SyntaxKind.VariableDeclarationList;
          }
          a.isVariableDeclarationList = F1;
          function B1(J3) {
            return J3.kind === _.SyntaxKind.VoidExpression;
          }
          a.isVoidExpression = B1;
          function Fi(J3) {
            return J3.kind === _.SyntaxKind.WhileStatement;
          }
          a.isWhileStatement = Fi;
          function q1(J3) {
            return J3.kind === _.SyntaxKind.WithStatement;
          }
          a.isWithStatement = q1;
        } }), DV = Oe2({ "node_modules/tsutils/typeguard/2.9/node.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isImportTypeNode = void 0;
          var _ = (Ds(), Li($a));
          _.__exportStar(PV(), a);
          var v2 = vr();
          function h(D) {
            return D.kind === v2.SyntaxKind.ImportType;
          }
          a.isImportTypeNode = h;
        } }), kV = Oe2({ "node_modules/tsutils/typeguard/3.0/node.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isSyntheticExpression = a.isRestTypeNode = a.isOptionalTypeNode = void 0;
          var _ = (Ds(), Li($a));
          _.__exportStar(DV(), a);
          var v2 = vr();
          function h(y) {
            return y.kind === v2.SyntaxKind.OptionalType;
          }
          a.isOptionalTypeNode = h;
          function D(y) {
            return y.kind === v2.SyntaxKind.RestType;
          }
          a.isRestTypeNode = D;
          function P(y) {
            return y.kind === v2.SyntaxKind.SyntheticExpression;
          }
          a.isSyntheticExpression = P;
        } }), K9 = Oe2({ "node_modules/tsutils/typeguard/3.2/node.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isBigIntLiteral = void 0;
          var _ = (Ds(), Li($a));
          _.__exportStar(kV(), a);
          var v2 = vr();
          function h(D) {
            return D.kind === v2.SyntaxKind.BigIntLiteral;
          }
          a.isBigIntLiteral = h;
        } }), X9 = Oe2({ "node_modules/tsutils/typeguard/node.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
          var _ = (Ds(), Li($a));
          _.__exportStar(K9(), a);
        } }), IV = Oe2({ "node_modules/tsutils/typeguard/2.8/type.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isUniqueESSymbolType = a.isUnionType = a.isUnionOrIntersectionType = a.isTypeVariable = a.isTypeReference = a.isTypeParameter = a.isSubstitutionType = a.isObjectType = a.isLiteralType = a.isIntersectionType = a.isInterfaceType = a.isInstantiableType = a.isIndexedAccessype = a.isIndexedAccessType = a.isGenericType = a.isEnumType = a.isConditionalType = void 0;
          var _ = vr();
          function v2(me2) {
            return (me2.flags & _.TypeFlags.Conditional) !== 0;
          }
          a.isConditionalType = v2;
          function h(me2) {
            return (me2.flags & _.TypeFlags.Enum) !== 0;
          }
          a.isEnumType = h;
          function D(me2) {
            return (me2.flags & _.TypeFlags.Object) !== 0 && (me2.objectFlags & _.ObjectFlags.ClassOrInterface) !== 0 && (me2.objectFlags & _.ObjectFlags.Reference) !== 0;
          }
          a.isGenericType = D;
          function P(me2) {
            return (me2.flags & _.TypeFlags.IndexedAccess) !== 0;
          }
          a.isIndexedAccessType = P;
          function y(me2) {
            return (me2.flags & _.TypeFlags.Index) !== 0;
          }
          a.isIndexedAccessype = y;
          function m(me2) {
            return (me2.flags & _.TypeFlags.Instantiable) !== 0;
          }
          a.isInstantiableType = m;
          function C2(me2) {
            return (me2.flags & _.TypeFlags.Object) !== 0 && (me2.objectFlags & _.ObjectFlags.ClassOrInterface) !== 0;
          }
          a.isInterfaceType = C2;
          function d2(me2) {
            return (me2.flags & _.TypeFlags.Intersection) !== 0;
          }
          a.isIntersectionType = d2;
          function E(me2) {
            return (me2.flags & (_.TypeFlags.StringOrNumberLiteral | _.TypeFlags.BigIntLiteral)) !== 0;
          }
          a.isLiteralType = E;
          function I(me2) {
            return (me2.flags & _.TypeFlags.Object) !== 0;
          }
          a.isObjectType = I;
          function c(me2) {
            return (me2.flags & _.TypeFlags.Substitution) !== 0;
          }
          a.isSubstitutionType = c;
          function M(me2) {
            return (me2.flags & _.TypeFlags.TypeParameter) !== 0;
          }
          a.isTypeParameter = M;
          function q2(me2) {
            return (me2.flags & _.TypeFlags.Object) !== 0 && (me2.objectFlags & _.ObjectFlags.Reference) !== 0;
          }
          a.isTypeReference = q2;
          function W(me2) {
            return (me2.flags & _.TypeFlags.TypeVariable) !== 0;
          }
          a.isTypeVariable = W;
          function K(me2) {
            return (me2.flags & _.TypeFlags.UnionOrIntersection) !== 0;
          }
          a.isUnionOrIntersectionType = K;
          function ce2(me2) {
            return (me2.flags & _.TypeFlags.Union) !== 0;
          }
          a.isUnionType = ce2;
          function Ie2(me2) {
            return (me2.flags & _.TypeFlags.UniqueESSymbol) !== 0;
          }
          a.isUniqueESSymbolType = Ie2;
        } }), S9 = Oe2({ "node_modules/tsutils/typeguard/2.9/type.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
          var _ = (Ds(), Li($a));
          _.__exportStar(IV(), a);
        } }), NV = Oe2({ "node_modules/tsutils/typeguard/3.0/type.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isTupleTypeReference = a.isTupleType = void 0;
          var _ = (Ds(), Li($a));
          _.__exportStar(S9(), a);
          var v2 = vr(), h = S9();
          function D(y) {
            return (y.flags & v2.TypeFlags.Object && y.objectFlags & v2.ObjectFlags.Tuple) !== 0;
          }
          a.isTupleType = D;
          function P(y) {
            return h.isTypeReference(y) && D(y.target);
          }
          a.isTupleTypeReference = P;
        } }), Y9 = Oe2({ "node_modules/tsutils/typeguard/3.2/type.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
          var _ = (Ds(), Li($a));
          _.__exportStar(NV(), a);
        } }), OV = Oe2({ "node_modules/tsutils/typeguard/3.2/index.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
          var _ = (Ds(), Li($a));
          _.__exportStar(K9(), a), _.__exportStar(Y9(), a);
        } }), MV = Oe2({ "node_modules/tsutils/typeguard/type.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
          var _ = (Ds(), Li($a));
          _.__exportStar(Y9(), a);
        } }), LV = Oe2({ "node_modules/tsutils/util/type.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.getBaseClassMemberOfClassElement = a.getIteratorYieldResultFromIteratorResult = a.getInstanceTypeOfClassLikeDeclaration = a.getConstructorTypeOfClassLikeDeclaration = a.getSymbolOfClassLikeDeclaration = a.getPropertyNameFromType = a.symbolHasReadonlyDeclaration = a.isPropertyReadonlyInType = a.getWellKnownSymbolPropertyOfType = a.getPropertyOfType = a.isBooleanLiteralType = a.isFalsyType = a.isThenableType = a.someTypePart = a.intersectionTypeParts = a.unionTypeParts = a.getCallSignaturesOfType = a.isTypeAssignableToString = a.isTypeAssignableToNumber = a.isOptionalChainingUndefinedMarkerType = a.removeOptionalChainingUndefinedMarkerType = a.removeOptionalityFromType = a.isEmptyObjectType = void 0;
          var _ = vr(), v2 = MV(), h = Q9(), D = X9();
          function P(ne2) {
            if (v2.isObjectType(ne2) && ne2.objectFlags & _.ObjectFlags.Anonymous && ne2.getProperties().length === 0 && ne2.getCallSignatures().length === 0 && ne2.getConstructSignatures().length === 0 && ne2.getStringIndexType() === void 0 && ne2.getNumberIndexType() === void 0) {
              let ge = ne2.getBaseTypes();
              return ge === void 0 || ge.every(P);
            }
            return false;
          }
          a.isEmptyObjectType = P;
          function y(ne2, ge) {
            if (!m(ge, _.TypeFlags.Undefined))
              return ge;
            let Fe2 = m(ge, _.TypeFlags.Null);
            return ge = ne2.getNonNullableType(ge), Fe2 ? ne2.getNullableType(ge, _.TypeFlags.Null) : ge;
          }
          a.removeOptionalityFromType = y;
          function m(ne2, ge) {
            for (let Fe2 of q2(ne2))
              if (h.isTypeFlagSet(Fe2, ge))
                return true;
            return false;
          }
          function C2(ne2, ge) {
            if (!v2.isUnionType(ge))
              return d2(ne2, ge) ? ge.getNonNullableType() : ge;
            let Fe2 = 0, at3 = false;
            for (let Pt of ge.types)
              d2(ne2, Pt) ? at3 = true : Fe2 |= Pt.flags;
            return at3 ? ne2.getNullableType(ge.getNonNullableType(), Fe2) : ge;
          }
          a.removeOptionalChainingUndefinedMarkerType = C2;
          function d2(ne2, ge) {
            return h.isTypeFlagSet(ge, _.TypeFlags.Undefined) && ne2.getNullableType(ge.getNonNullableType(), _.TypeFlags.Undefined) !== ge;
          }
          a.isOptionalChainingUndefinedMarkerType = d2;
          function E(ne2, ge) {
            return c(ne2, ge, _.TypeFlags.NumberLike);
          }
          a.isTypeAssignableToNumber = E;
          function I(ne2, ge) {
            return c(ne2, ge, _.TypeFlags.StringLike);
          }
          a.isTypeAssignableToString = I;
          function c(ne2, ge, Fe2) {
            Fe2 |= _.TypeFlags.Any;
            let at3;
            return function Pt(qt) {
              if (v2.isTypeParameter(qt) && qt.symbol !== void 0 && qt.symbol.declarations !== void 0) {
                if (at3 === void 0)
                  at3 = /* @__PURE__ */ new Set([qt]);
                else if (!at3.has(qt))
                  at3.add(qt);
                else
                  return false;
                let Zr2 = qt.symbol.declarations[0];
                return Zr2.constraint === void 0 ? true : Pt(ne2.getTypeFromTypeNode(Zr2.constraint));
              }
              return v2.isUnionType(qt) ? qt.types.every(Pt) : v2.isIntersectionType(qt) ? qt.types.some(Pt) : h.isTypeFlagSet(qt, Fe2);
            }(ge);
          }
          function M(ne2) {
            if (v2.isUnionType(ne2)) {
              let ge = [];
              for (let Fe2 of ne2.types)
                ge.push(...M(Fe2));
              return ge;
            }
            if (v2.isIntersectionType(ne2)) {
              let ge;
              for (let Fe2 of ne2.types) {
                let at3 = M(Fe2);
                if (at3.length !== 0) {
                  if (ge !== void 0)
                    return [];
                  ge = at3;
                }
              }
              return ge === void 0 ? [] : ge;
            }
            return ne2.getCallSignatures();
          }
          a.getCallSignaturesOfType = M;
          function q2(ne2) {
            return v2.isUnionType(ne2) ? ne2.types : [ne2];
          }
          a.unionTypeParts = q2;
          function W(ne2) {
            return v2.isIntersectionType(ne2) ? ne2.types : [ne2];
          }
          a.intersectionTypeParts = W;
          function K(ne2, ge, Fe2) {
            return ge(ne2) ? ne2.types.some(Fe2) : Fe2(ne2);
          }
          a.someTypePart = K;
          function ce2(ne2, ge) {
            let Fe2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ne2.getTypeAtLocation(ge);
            for (let at3 of q2(ne2.getApparentType(Fe2))) {
              let Pt = at3.getProperty("then");
              if (Pt === void 0)
                continue;
              let qt = ne2.getTypeOfSymbolAtLocation(Pt, ge);
              for (let Zr2 of q2(qt))
                for (let Ri of Zr2.getCallSignatures())
                  if (Ri.parameters.length !== 0 && Ie2(ne2, Ri.parameters[0], ge))
                    return true;
            }
            return false;
          }
          a.isThenableType = ce2;
          function Ie2(ne2, ge, Fe2) {
            let at3 = ne2.getApparentType(ne2.getTypeOfSymbolAtLocation(ge, Fe2));
            if (ge.valueDeclaration.dotDotDotToken && (at3 = at3.getNumberIndexType(), at3 === void 0))
              return false;
            for (let Pt of q2(at3))
              if (Pt.getCallSignatures().length !== 0)
                return true;
            return false;
          }
          function me2(ne2) {
            return ne2.flags & (_.TypeFlags.Undefined | _.TypeFlags.Null | _.TypeFlags.Void) ? true : v2.isLiteralType(ne2) ? !ne2.value : Ae2(ne2, false);
          }
          a.isFalsyType = me2;
          function Ae2(ne2, ge) {
            return h.isTypeFlagSet(ne2, _.TypeFlags.BooleanLiteral) && ne2.intrinsicName === (ge ? "true" : "false");
          }
          a.isBooleanLiteralType = Ae2;
          function te2(ne2, ge) {
            return ge.startsWith("__") ? ne2.getProperties().find((Fe2) => Fe2.escapedName === ge) : ne2.getProperty(ge);
          }
          a.getPropertyOfType = te2;
          function he(ne2, ge, Fe2) {
            let at3 = "__@" + ge;
            for (let Pt of ne2.getProperties()) {
              if (!Pt.name.startsWith(at3))
                continue;
              let qt = Fe2.getApparentType(Fe2.getTypeAtLocation(Pt.valueDeclaration.name.expression)).symbol;
              if (Pt.escapedName === Pe2(Fe2, qt, ge))
                return Pt;
            }
          }
          a.getWellKnownSymbolPropertyOfType = he;
          function Pe2(ne2, ge, Fe2) {
            let at3 = ge && ne2.getTypeOfSymbolAtLocation(ge, ge.valueDeclaration).getProperty(Fe2), Pt = at3 && ne2.getTypeOfSymbolAtLocation(at3, at3.valueDeclaration);
            return Pt && v2.isUniqueESSymbolType(Pt) ? Pt.escapedName : "__@" + Fe2;
          }
          function R(ne2, ge, Fe2) {
            let at3 = false, Pt = false;
            for (let qt of q2(ne2))
              if (te2(qt, ge) === void 0) {
                let Zr2 = (h.isNumericPropertyName(ge) ? Fe2.getIndexInfoOfType(qt, _.IndexKind.Number) : void 0) || Fe2.getIndexInfoOfType(qt, _.IndexKind.String);
                if (Zr2 !== void 0 && Zr2.isReadonly) {
                  if (at3)
                    return true;
                  Pt = true;
                }
              } else {
                if (Pt || pe2(qt, ge, Fe2))
                  return true;
                at3 = true;
              }
            return false;
          }
          a.isPropertyReadonlyInType = R;
          function pe2(ne2, ge, Fe2) {
            return K(ne2, v2.isIntersectionType, (at3) => {
              let Pt = te2(at3, ge);
              if (Pt === void 0)
                return false;
              if (Pt.flags & _.SymbolFlags.Transient) {
                if (/^(?:[1-9]\d*|0)$/.test(ge) && v2.isTupleTypeReference(at3))
                  return at3.target.readonly;
                switch (ke2(at3, ge, Fe2)) {
                  case true:
                    return true;
                  case false:
                    return false;
                  default:
                }
              }
              return h.isSymbolFlagSet(Pt, _.SymbolFlags.ValueModule) || Je2(Pt, Fe2);
            });
          }
          function ke2(ne2, ge, Fe2) {
            if (!v2.isObjectType(ne2) || !h.isObjectFlagSet(ne2, _.ObjectFlags.Mapped))
              return;
            let at3 = ne2.symbol.declarations[0];
            return at3.readonlyToken !== void 0 && !/^__@[^@]+$/.test(ge) ? at3.readonlyToken.kind !== _.SyntaxKind.MinusToken : R(ne2.modifiersType, ge, Fe2);
          }
          function Je2(ne2, ge) {
            return (ne2.flags & _.SymbolFlags.Accessor) === _.SymbolFlags.GetAccessor || ne2.declarations !== void 0 && ne2.declarations.some((Fe2) => h.isModifierFlagSet(Fe2, _.ModifierFlags.Readonly) || D.isVariableDeclaration(Fe2) && h.isNodeFlagSet(Fe2.parent, _.NodeFlags.Const) || D.isCallExpression(Fe2) && h.isReadonlyAssignmentDeclaration(Fe2, ge) || D.isEnumMember(Fe2) || (D.isPropertyAssignment(Fe2) || D.isShorthandPropertyAssignment(Fe2)) && h.isInConstContext(Fe2.parent));
          }
          a.symbolHasReadonlyDeclaration = Je2;
          function Xe2(ne2) {
            if (ne2.flags & (_.TypeFlags.StringLiteral | _.TypeFlags.NumberLiteral)) {
              let ge = String(ne2.value);
              return { displayName: ge, symbolName: _.escapeLeadingUnderscores(ge) };
            }
            if (v2.isUniqueESSymbolType(ne2))
              return { displayName: `[${ne2.symbol ? `${ee2(ne2.symbol) ? "Symbol." : ""}${ne2.symbol.name}` : ne2.escapedName.replace(/^__@|@\d+$/g, "")}]`, symbolName: ne2.escapedName };
          }
          a.getPropertyNameFromType = Xe2;
          function ee2(ne2) {
            return h.isSymbolFlagSet(ne2, _.SymbolFlags.Property) && ne2.valueDeclaration !== void 0 && D.isInterfaceDeclaration(ne2.valueDeclaration.parent) && ne2.valueDeclaration.parent.name.text === "SymbolConstructor" && je2(ne2.valueDeclaration.parent);
          }
          function je2(ne2) {
            return h.isNodeFlagSet(ne2.parent, _.NodeFlags.GlobalAugmentation) || D.isSourceFile(ne2.parent) && !_.isExternalModule(ne2.parent);
          }
          function nt(ne2, ge) {
            var Fe2;
            return ge.getSymbolAtLocation((Fe2 = ne2.name) !== null && Fe2 !== void 0 ? Fe2 : h.getChildOfKind(ne2, _.SyntaxKind.ClassKeyword));
          }
          a.getSymbolOfClassLikeDeclaration = nt;
          function Ze2(ne2, ge) {
            return ne2.kind === _.SyntaxKind.ClassExpression ? ge.getTypeAtLocation(ne2) : ge.getTypeOfSymbolAtLocation(nt(ne2, ge), ne2);
          }
          a.getConstructorTypeOfClassLikeDeclaration = Ze2;
          function st2(ne2, ge) {
            return ne2.kind === _.SyntaxKind.ClassDeclaration ? ge.getTypeAtLocation(ne2) : ge.getDeclaredTypeOfSymbol(nt(ne2, ge));
          }
          a.getInstanceTypeOfClassLikeDeclaration = st2;
          function tt(ne2, ge, Fe2) {
            return v2.isUnionType(ne2) && ne2.types.find((at3) => {
              let Pt = at3.getProperty("done");
              return Pt !== void 0 && Ae2(y(Fe2, Fe2.getTypeOfSymbolAtLocation(Pt, ge)), false);
            }) || ne2;
          }
          a.getIteratorYieldResultFromIteratorResult = tt;
          function ct(ne2, ge) {
            if (!D.isClassLikeDeclaration(ne2.parent))
              return;
            let Fe2 = h.getBaseOfClassLikeExpression(ne2.parent);
            if (Fe2 === void 0)
              return;
            let at3 = h.getSingleLateBoundPropertyNameOfPropertyName(ne2.name, ge);
            if (at3 === void 0)
              return;
            let Pt = ge.getTypeAtLocation(h.hasModifier(ne2.modifiers, _.SyntaxKind.StaticKeyword) ? Fe2.expression : Fe2);
            return te2(Pt, at3.symbolName);
          }
          a.getBaseClassMemberOfClassElement = ct;
        } }), Q9 = Oe2({ "node_modules/tsutils/util/util.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.isValidIdentifier = a.getLineBreakStyle = a.getLineRanges = a.forEachComment = a.forEachTokenWithTrivia = a.forEachToken = a.isFunctionWithBody = a.hasOwnThisReference = a.isBlockScopeBoundary = a.isFunctionScopeBoundary = a.isTypeScopeBoundary = a.isScopeBoundary = a.ScopeBoundarySelector = a.ScopeBoundary = a.isInSingleStatementContext = a.isBlockScopedDeclarationStatement = a.isBlockScopedVariableDeclaration = a.isBlockScopedVariableDeclarationList = a.getVariableDeclarationKind = a.VariableDeclarationKind = a.forEachDeclaredVariable = a.forEachDestructuringIdentifier = a.getPropertyName = a.getWrappedNodeAtPosition = a.getAstNodeAtPosition = a.commentText = a.isPositionInComment = a.getCommentAtPosition = a.getTokenAtPosition = a.getNextToken = a.getPreviousToken = a.getNextStatement = a.getPreviousStatement = a.isModifierFlagSet = a.isObjectFlagSet = a.isSymbolFlagSet = a.isTypeFlagSet = a.isNodeFlagSet = a.hasAccessModifier = a.isParameterProperty = a.hasModifier = a.getModifier = a.isThisParameter = a.isKeywordKind = a.isJsDocKind = a.isTypeNodeKind = a.isAssignmentKind = a.isNodeKind = a.isTokenKind = a.getChildOfKind = void 0, a.getBaseOfClassLikeExpression = a.hasExhaustiveCaseClauses = a.formatPseudoBigInt = a.unwrapParentheses = a.getSingleLateBoundPropertyNameOfPropertyName = a.getLateBoundPropertyNamesOfPropertyName = a.getLateBoundPropertyNames = a.getPropertyNameOfWellKnownSymbol = a.isWellKnownSymbolLiterally = a.isBindableObjectDefinePropertyCall = a.isReadonlyAssignmentDeclaration = a.isInConstContext = a.isConstAssertion = a.getTsCheckDirective = a.getCheckJsDirective = a.isAmbientModule = a.isCompilerOptionEnabled = a.isStrictCompilerOptionEnabled = a.getIIFE = a.isAmbientModuleBlock = a.isStatementInAmbientContext = a.findImportLikeNodes = a.findImports = a.ImportKind = a.parseJsDocOfNode = a.getJsDoc = a.canHaveJsDoc = a.isReassignmentTarget = a.getAccessKind = a.AccessKind = a.isExpressionValueUsed = a.getDeclarationOfBindingElement = a.hasSideEffects = a.SideEffectOptions = a.isSameLine = a.isNumericPropertyName = a.isValidJsxIdentifier = a.isValidNumericLiteral = a.isValidPropertyName = a.isValidPropertyAccess = void 0;
          var _ = vr(), v2 = X9(), h = OV(), D = LV();
          function P(S, H, le) {
            for (let Be2 of S.getChildren(le))
              if (Be2.kind === H)
                return Be2;
          }
          a.getChildOfKind = P;
          function y(S) {
            return S >= _.SyntaxKind.FirstToken && S <= _.SyntaxKind.LastToken;
          }
          a.isTokenKind = y;
          function m(S) {
            return S >= _.SyntaxKind.FirstNode;
          }
          a.isNodeKind = m;
          function C2(S) {
            return S >= _.SyntaxKind.FirstAssignment && S <= _.SyntaxKind.LastAssignment;
          }
          a.isAssignmentKind = C2;
          function d2(S) {
            return S >= _.SyntaxKind.FirstTypeNode && S <= _.SyntaxKind.LastTypeNode;
          }
          a.isTypeNodeKind = d2;
          function E(S) {
            return S >= _.SyntaxKind.FirstJSDocNode && S <= _.SyntaxKind.LastJSDocNode;
          }
          a.isJsDocKind = E;
          function I(S) {
            return S >= _.SyntaxKind.FirstKeyword && S <= _.SyntaxKind.LastKeyword;
          }
          a.isKeywordKind = I;
          function c(S) {
            return S.name.kind === _.SyntaxKind.Identifier && S.name.originalKeywordKind === _.SyntaxKind.ThisKeyword;
          }
          a.isThisParameter = c;
          function M(S, H) {
            if (S.modifiers !== void 0) {
              for (let le of S.modifiers)
                if (le.kind === H)
                  return le;
            }
          }
          a.getModifier = M;
          function q2(S) {
            if (S === void 0)
              return false;
            for (var H = arguments.length, le = new Array(H > 1 ? H - 1 : 0), Be2 = 1; Be2 < H; Be2++)
              le[Be2 - 1] = arguments[Be2];
            for (let rt of S)
              if (le.includes(rt.kind))
                return true;
            return false;
          }
          a.hasModifier = q2;
          function W(S) {
            return q2(S.modifiers, _.SyntaxKind.PublicKeyword, _.SyntaxKind.ProtectedKeyword, _.SyntaxKind.PrivateKeyword, _.SyntaxKind.ReadonlyKeyword);
          }
          a.isParameterProperty = W;
          function K(S) {
            return me2(S, _.ModifierFlags.AccessibilityModifier);
          }
          a.hasAccessModifier = K;
          function ce2(S, H) {
            return (S.flags & H) !== 0;
          }
          a.isNodeFlagSet = ce2, a.isTypeFlagSet = ce2, a.isSymbolFlagSet = ce2;
          function Ie2(S, H) {
            return (S.objectFlags & H) !== 0;
          }
          a.isObjectFlagSet = Ie2;
          function me2(S, H) {
            return (_.getCombinedModifierFlags(S) & H) !== 0;
          }
          a.isModifierFlagSet = me2;
          function Ae2(S) {
            let H = S.parent;
            if (v2.isBlockLike(H)) {
              let le = H.statements.indexOf(S);
              if (le > 0)
                return H.statements[le - 1];
            }
          }
          a.getPreviousStatement = Ae2;
          function te2(S) {
            let H = S.parent;
            if (v2.isBlockLike(H)) {
              let le = H.statements.indexOf(S);
              if (le < H.statements.length)
                return H.statements[le + 1];
            }
          }
          a.getNextStatement = te2;
          function he(S, H) {
            let { pos: le } = S;
            if (le !== 0) {
              do
                S = S.parent;
              while (S.pos === le);
              return pe2(S, le - 1, H != null ? H : S.getSourceFile(), false);
            }
          }
          a.getPreviousToken = he;
          function Pe2(S, H) {
            if (S.kind === _.SyntaxKind.SourceFile || S.kind === _.SyntaxKind.EndOfFileToken)
              return;
            let le = S.end;
            for (S = S.parent; S.end === le; ) {
              if (S.parent === void 0)
                return S.endOfFileToken;
              S = S.parent;
            }
            return pe2(S, le, H != null ? H : S.getSourceFile(), false);
          }
          a.getNextToken = Pe2;
          function R(S, H, le, Be2) {
            if (!(H < S.pos || H >= S.end))
              return y(S.kind) ? S : pe2(S, H, le != null ? le : S.getSourceFile(), Be2 === true);
          }
          a.getTokenAtPosition = R;
          function pe2(S, H, le, Be2) {
            if (!Be2 && (S = je2(S, H), y(S.kind)))
              return S;
            e:
              for (; ; ) {
                for (let rt of S.getChildren(le))
                  if (rt.end > H && (Be2 || rt.kind !== _.SyntaxKind.JSDocComment)) {
                    if (y(rt.kind))
                      return rt;
                    S = rt;
                    continue e;
                  }
                return;
              }
          }
          function ke2(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S, Be2 = R(le, H, S);
            if (Be2 === void 0 || Be2.kind === _.SyntaxKind.JsxText || H >= Be2.end - (_.tokenToString(Be2.kind) || "").length)
              return;
            let rt = Be2.pos === 0 ? (_.getShebang(S.text) || "").length : Be2.pos;
            return rt !== 0 && _.forEachTrailingCommentRange(S.text, rt, Je2, H) || _.forEachLeadingCommentRange(S.text, rt, Je2, H);
          }
          a.getCommentAtPosition = ke2;
          function Je2(S, H, le, Be2, rt) {
            return rt >= S && rt < H ? { pos: S, end: H, kind: le } : void 0;
          }
          function Xe2(S, H, le) {
            return ke2(S, H, le) !== void 0;
          }
          a.isPositionInComment = Xe2;
          function ee2(S, H) {
            return S.substring(H.pos + 2, H.kind === _.SyntaxKind.SingleLineCommentTrivia ? H.end : H.end - 2);
          }
          a.commentText = ee2;
          function je2(S, H) {
            if (!(S.pos > H || S.end <= H)) {
              for (; m(S.kind); ) {
                let le = _.forEachChild(S, (Be2) => Be2.pos <= H && Be2.end > H ? Be2 : void 0);
                if (le === void 0)
                  break;
                S = le;
              }
              return S;
            }
          }
          a.getAstNodeAtPosition = je2;
          function nt(S, H) {
            if (S.node.pos > H || S.node.end <= H)
              return;
            e:
              for (; ; ) {
                for (let le of S.children) {
                  if (le.node.pos > H)
                    return S;
                  if (le.node.end > H) {
                    S = le;
                    continue e;
                  }
                }
                return S;
              }
          }
          a.getWrappedNodeAtPosition = nt;
          function Ze2(S) {
            if (S.kind === _.SyntaxKind.ComputedPropertyName) {
              let H = Os(S.expression);
              if (v2.isPrefixUnaryExpression(H)) {
                let le = false;
                switch (H.operator) {
                  case _.SyntaxKind.MinusToken:
                    le = true;
                  case _.SyntaxKind.PlusToken:
                    return v2.isNumericLiteral(H.operand) ? `${le ? "-" : ""}${H.operand.text}` : h.isBigIntLiteral(H.operand) ? `${le ? "-" : ""}${H.operand.text.slice(0, -1)}` : void 0;
                  default:
                    return;
                }
              }
              return h.isBigIntLiteral(H) ? H.text.slice(0, -1) : v2.isNumericOrStringLikeLiteral(H) ? H.text : void 0;
            }
            return S.kind === _.SyntaxKind.PrivateIdentifier ? void 0 : S.text;
          }
          a.getPropertyName = Ze2;
          function st2(S, H) {
            for (let le of S.elements) {
              if (le.kind !== _.SyntaxKind.BindingElement)
                continue;
              let Be2;
              if (le.name.kind === _.SyntaxKind.Identifier ? Be2 = H(le) : Be2 = st2(le.name, H), Be2)
                return Be2;
            }
          }
          a.forEachDestructuringIdentifier = st2;
          function tt(S, H) {
            for (let le of S.declarations) {
              let Be2;
              if (le.name.kind === _.SyntaxKind.Identifier ? Be2 = H(le) : Be2 = st2(le.name, H), Be2)
                return Be2;
            }
          }
          a.forEachDeclaredVariable = tt;
          var ct;
          (function(S) {
            S[S.Var = 0] = "Var", S[S.Let = 1] = "Let", S[S.Const = 2] = "Const";
          })(ct = a.VariableDeclarationKind || (a.VariableDeclarationKind = {}));
          function ne2(S) {
            return S.flags & _.NodeFlags.Let ? 1 : S.flags & _.NodeFlags.Const ? 2 : 0;
          }
          a.getVariableDeclarationKind = ne2;
          function ge(S) {
            return (S.flags & _.NodeFlags.BlockScoped) !== 0;
          }
          a.isBlockScopedVariableDeclarationList = ge;
          function Fe2(S) {
            let H = S.parent;
            return H.kind === _.SyntaxKind.CatchClause || ge(H);
          }
          a.isBlockScopedVariableDeclaration = Fe2;
          function at3(S) {
            switch (S.kind) {
              case _.SyntaxKind.VariableStatement:
                return ge(S.declarationList);
              case _.SyntaxKind.ClassDeclaration:
              case _.SyntaxKind.EnumDeclaration:
              case _.SyntaxKind.InterfaceDeclaration:
              case _.SyntaxKind.TypeAliasDeclaration:
                return true;
              default:
                return false;
            }
          }
          a.isBlockScopedDeclarationStatement = at3;
          function Pt(S) {
            switch (S.parent.kind) {
              case _.SyntaxKind.ForStatement:
              case _.SyntaxKind.ForInStatement:
              case _.SyntaxKind.ForOfStatement:
              case _.SyntaxKind.WhileStatement:
              case _.SyntaxKind.DoStatement:
              case _.SyntaxKind.IfStatement:
              case _.SyntaxKind.WithStatement:
              case _.SyntaxKind.LabeledStatement:
                return true;
              default:
                return false;
            }
          }
          a.isInSingleStatementContext = Pt;
          var qt;
          (function(S) {
            S[S.None = 0] = "None", S[S.Function = 1] = "Function", S[S.Block = 2] = "Block", S[S.Type = 4] = "Type", S[S.ConditionalType = 8] = "ConditionalType";
          })(qt = a.ScopeBoundary || (a.ScopeBoundary = {}));
          var Zr2;
          (function(S) {
            S[S.Function = 1] = "Function", S[S.Block = 3] = "Block", S[S.Type = 7] = "Type", S[S.InferType = 8] = "InferType";
          })(Zr2 = a.ScopeBoundarySelector || (a.ScopeBoundarySelector = {}));
          function Ri(S) {
            return ua(S) || Ka(S) || la(S);
          }
          a.isScopeBoundary = Ri;
          function la(S) {
            switch (S.kind) {
              case _.SyntaxKind.InterfaceDeclaration:
              case _.SyntaxKind.TypeAliasDeclaration:
              case _.SyntaxKind.MappedType:
                return 4;
              case _.SyntaxKind.ConditionalType:
                return 8;
              default:
                return 0;
            }
          }
          a.isTypeScopeBoundary = la;
          function ua(S) {
            switch (S.kind) {
              case _.SyntaxKind.FunctionExpression:
              case _.SyntaxKind.ArrowFunction:
              case _.SyntaxKind.Constructor:
              case _.SyntaxKind.ModuleDeclaration:
              case _.SyntaxKind.ClassDeclaration:
              case _.SyntaxKind.ClassExpression:
              case _.SyntaxKind.EnumDeclaration:
              case _.SyntaxKind.MethodDeclaration:
              case _.SyntaxKind.FunctionDeclaration:
              case _.SyntaxKind.GetAccessor:
              case _.SyntaxKind.SetAccessor:
              case _.SyntaxKind.MethodSignature:
              case _.SyntaxKind.CallSignature:
              case _.SyntaxKind.ConstructSignature:
              case _.SyntaxKind.ConstructorType:
              case _.SyntaxKind.FunctionType:
                return 1;
              case _.SyntaxKind.SourceFile:
                return _.isExternalModule(S) ? 1 : 0;
              default:
                return 0;
            }
          }
          a.isFunctionScopeBoundary = ua;
          function Ka(S) {
            switch (S.kind) {
              case _.SyntaxKind.Block:
                let H = S.parent;
                return H.kind !== _.SyntaxKind.CatchClause && (H.kind === _.SyntaxKind.SourceFile || !ua(H)) ? 2 : 0;
              case _.SyntaxKind.ForStatement:
              case _.SyntaxKind.ForInStatement:
              case _.SyntaxKind.ForOfStatement:
              case _.SyntaxKind.CaseBlock:
              case _.SyntaxKind.CatchClause:
              case _.SyntaxKind.WithStatement:
                return 2;
              default:
                return 0;
            }
          }
          a.isBlockScopeBoundary = Ka;
          function co(S) {
            switch (S.kind) {
              case _.SyntaxKind.ClassDeclaration:
              case _.SyntaxKind.ClassExpression:
              case _.SyntaxKind.FunctionExpression:
                return true;
              case _.SyntaxKind.FunctionDeclaration:
                return S.body !== void 0;
              case _.SyntaxKind.MethodDeclaration:
              case _.SyntaxKind.GetAccessor:
              case _.SyntaxKind.SetAccessor:
                return S.parent.kind === _.SyntaxKind.ObjectLiteralExpression;
              default:
                return false;
            }
          }
          a.hasOwnThisReference = co;
          function be2(S) {
            switch (S.kind) {
              case _.SyntaxKind.GetAccessor:
              case _.SyntaxKind.SetAccessor:
              case _.SyntaxKind.FunctionDeclaration:
              case _.SyntaxKind.MethodDeclaration:
              case _.SyntaxKind.Constructor:
                return S.body !== void 0;
              case _.SyntaxKind.FunctionExpression:
              case _.SyntaxKind.ArrowFunction:
                return true;
              default:
                return false;
            }
          }
          a.isFunctionWithBody = be2;
          function Ke3(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S.getSourceFile(), Be2 = [];
            for (; ; ) {
              if (y(S.kind))
                H(S);
              else if (S.kind !== _.SyntaxKind.JSDocComment) {
                let rt = S.getChildren(le);
                if (rt.length === 1) {
                  S = rt[0];
                  continue;
                }
                for (let ut = rt.length - 1; ut >= 0; --ut)
                  Be2.push(rt[ut]);
              }
              if (Be2.length === 0)
                break;
              S = Be2.pop();
            }
          }
          a.forEachToken = Ke3;
          function Et(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S.getSourceFile(), Be2 = le.text, rt = _.createScanner(le.languageVersion, false, le.languageVariant, Be2);
            return Ke3(S, (ut) => {
              let Ht = ut.kind === _.SyntaxKind.JsxText || ut.pos === ut.end ? ut.pos : ut.getStart(le);
              if (Ht !== ut.pos) {
                rt.setTextPos(ut.pos);
                let Fr2 = rt.scan(), Cr2 = rt.getTokenPos();
                for (; Cr2 < Ht; ) {
                  let ir2 = rt.getTextPos();
                  if (H(Be2, Fr2, { pos: Cr2, end: ir2 }, ut.parent), ir2 === Ht)
                    break;
                  Fr2 = rt.scan(), Cr2 = rt.getTokenPos();
                }
              }
              return H(Be2, ut.kind, { end: ut.end, pos: Ht }, ut.parent);
            }, le);
          }
          a.forEachTokenWithTrivia = Et;
          function Ft(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S.getSourceFile(), Be2 = le.text, rt = le.languageVariant !== _.LanguageVariant.JSX;
            return Ke3(S, (Ht) => {
              if (Ht.pos !== Ht.end && (Ht.kind !== _.SyntaxKind.JsxText && _.forEachLeadingCommentRange(Be2, Ht.pos === 0 ? (_.getShebang(Be2) || "").length : Ht.pos, ut), rt || or2(Ht)))
                return _.forEachTrailingCommentRange(Be2, Ht.end, ut);
            }, le);
            function ut(Ht, Fr2, Cr2) {
              H(Be2, { pos: Ht, end: Fr2, kind: Cr2 });
            }
          }
          a.forEachComment = Ft;
          function or2(S) {
            switch (S.kind) {
              case _.SyntaxKind.CloseBraceToken:
                return S.parent.kind !== _.SyntaxKind.JsxExpression || !Wr2(S.parent.parent);
              case _.SyntaxKind.GreaterThanToken:
                switch (S.parent.kind) {
                  case _.SyntaxKind.JsxOpeningElement:
                    return S.end !== S.parent.end;
                  case _.SyntaxKind.JsxOpeningFragment:
                    return false;
                  case _.SyntaxKind.JsxSelfClosingElement:
                    return S.end !== S.parent.end || !Wr2(S.parent.parent);
                  case _.SyntaxKind.JsxClosingElement:
                  case _.SyntaxKind.JsxClosingFragment:
                    return !Wr2(S.parent.parent.parent);
                }
            }
            return true;
          }
          function Wr2(S) {
            return S.kind === _.SyntaxKind.JsxElement || S.kind === _.SyntaxKind.JsxFragment;
          }
          function m_(S) {
            let H = S.getLineStarts(), le = [], Be2 = H.length, rt = S.text, ut = 0;
            for (let Ht = 1; Ht < Be2; ++Ht) {
              let Fr2 = H[Ht], Cr2 = Fr2;
              for (; Cr2 > ut && _.isLineBreak(rt.charCodeAt(Cr2 - 1)); --Cr2)
                ;
              le.push({ pos: ut, end: Fr2, contentLength: Cr2 - ut }), ut = Fr2;
            }
            return le.push({ pos: ut, end: S.end, contentLength: S.end - ut }), le;
          }
          a.getLineRanges = m_;
          function Uc(S) {
            let H = S.getLineStarts();
            return H.length === 1 || H[1] < 2 || S.text[H[1] - 2] !== "\r" ? `
` : `\r
`;
          }
          a.getLineBreakStyle = Uc;
          var ji;
          function lo(S, H) {
            return ji === void 0 ? ji = _.createScanner(H, false, void 0, S) : (ji.setScriptTarget(H), ji.setText(S)), ji.scan(), ji;
          }
          function zc(S) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.ScriptTarget.Latest, le = lo(S, H);
            return le.isIdentifier() && le.getTextPos() === S.length && le.getTokenPos() === 0;
          }
          a.isValidIdentifier = zc;
          function Qn(S) {
            return S >= 65536 ? 2 : 1;
          }
          function uo(S) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.ScriptTarget.Latest;
            if (S.length === 0)
              return false;
            let le = S.codePointAt(0);
            if (!_.isIdentifierStart(le, H))
              return false;
            for (let Be2 = Qn(le); Be2 < S.length; Be2 += Qn(le))
              if (le = S.codePointAt(Be2), !_.isIdentifierPart(le, H))
                return false;
            return true;
          }
          a.isValidPropertyAccess = uo;
          function Wc(S) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.ScriptTarget.Latest;
            if (uo(S, H))
              return true;
            let le = lo(S, H);
            return le.getTextPos() === S.length && le.getToken() === _.SyntaxKind.NumericLiteral && le.getTokenValue() === S;
          }
          a.isValidPropertyName = Wc;
          function Vc(S) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.ScriptTarget.Latest, le = lo(S, H);
            return le.getToken() === _.SyntaxKind.NumericLiteral && le.getTextPos() === S.length && le.getTokenPos() === 0;
          }
          a.isValidNumericLiteral = Vc;
          function Hc(S) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.ScriptTarget.Latest;
            if (S.length === 0)
              return false;
            let le = false, Be2 = S.codePointAt(0);
            if (!_.isIdentifierStart(Be2, H))
              return false;
            for (let rt = Qn(Be2); rt < S.length; rt += Qn(Be2))
              if (Be2 = S.codePointAt(rt), !_.isIdentifierPart(Be2, H) && Be2 !== 45)
                if (!le && Be2 === 58 && rt + Qn(Be2) !== S.length)
                  le = true;
                else
                  return false;
            return true;
          }
          a.isValidJsxIdentifier = Hc;
          function Gc(S) {
            return String(+S) === S;
          }
          a.isNumericPropertyName = Gc;
          function h_(S, H, le) {
            return _.getLineAndCharacterOfPosition(S, H).line === _.getLineAndCharacterOfPosition(S, le).line;
          }
          a.isSameLine = h_;
          var tr2;
          (function(S) {
            S[S.None = 0] = "None", S[S.TaggedTemplate = 1] = "TaggedTemplate", S[S.Constructor = 2] = "Constructor", S[S.JsxElement = 4] = "JsxElement";
          })(tr2 = a.SideEffectOptions || (a.SideEffectOptions = {}));
          function $c(S, H) {
            var le, Be2;
            let rt = [];
            for (; ; ) {
              switch (S.kind) {
                case _.SyntaxKind.CallExpression:
                case _.SyntaxKind.PostfixUnaryExpression:
                case _.SyntaxKind.AwaitExpression:
                case _.SyntaxKind.YieldExpression:
                case _.SyntaxKind.DeleteExpression:
                  return true;
                case _.SyntaxKind.TypeAssertionExpression:
                case _.SyntaxKind.AsExpression:
                case _.SyntaxKind.ParenthesizedExpression:
                case _.SyntaxKind.NonNullExpression:
                case _.SyntaxKind.VoidExpression:
                case _.SyntaxKind.TypeOfExpression:
                case _.SyntaxKind.PropertyAccessExpression:
                case _.SyntaxKind.SpreadElement:
                case _.SyntaxKind.PartiallyEmittedExpression:
                  S = S.expression;
                  continue;
                case _.SyntaxKind.BinaryExpression:
                  if (C2(S.operatorToken.kind))
                    return true;
                  rt.push(S.right), S = S.left;
                  continue;
                case _.SyntaxKind.PrefixUnaryExpression:
                  switch (S.operator) {
                    case _.SyntaxKind.PlusPlusToken:
                    case _.SyntaxKind.MinusMinusToken:
                      return true;
                    default:
                      S = S.operand;
                      continue;
                  }
                case _.SyntaxKind.ElementAccessExpression:
                  S.argumentExpression !== void 0 && rt.push(S.argumentExpression), S = S.expression;
                  continue;
                case _.SyntaxKind.ConditionalExpression:
                  rt.push(S.whenTrue, S.whenFalse), S = S.condition;
                  continue;
                case _.SyntaxKind.NewExpression:
                  if (H & 2)
                    return true;
                  S.arguments !== void 0 && rt.push(...S.arguments), S = S.expression;
                  continue;
                case _.SyntaxKind.TaggedTemplateExpression:
                  if (H & 1)
                    return true;
                  if (rt.push(S.tag), S = S.template, S.kind === _.SyntaxKind.NoSubstitutionTemplateLiteral)
                    break;
                case _.SyntaxKind.TemplateExpression:
                  for (let ut of S.templateSpans)
                    rt.push(ut.expression);
                  break;
                case _.SyntaxKind.ClassExpression: {
                  if (S.decorators !== void 0)
                    return true;
                  for (let Ht of S.members) {
                    if (Ht.decorators !== void 0)
                      return true;
                    if (!q2(Ht.modifiers, _.SyntaxKind.DeclareKeyword))
                      if (((le = Ht.name) === null || le === void 0 ? void 0 : le.kind) === _.SyntaxKind.ComputedPropertyName && rt.push(Ht.name.expression), v2.isMethodDeclaration(Ht)) {
                        for (let Fr2 of Ht.parameters)
                          if (Fr2.decorators !== void 0)
                            return true;
                      } else
                        v2.isPropertyDeclaration(Ht) && Ht.initializer !== void 0 && q2(Ht.modifiers, _.SyntaxKind.StaticKeyword) && rt.push(Ht.initializer);
                  }
                  let ut = E_(S);
                  if (ut === void 0)
                    break;
                  S = ut.expression;
                  continue;
                }
                case _.SyntaxKind.ArrayLiteralExpression:
                  rt.push(...S.elements);
                  break;
                case _.SyntaxKind.ObjectLiteralExpression:
                  for (let ut of S.properties)
                    switch (((Be2 = ut.name) === null || Be2 === void 0 ? void 0 : Be2.kind) === _.SyntaxKind.ComputedPropertyName && rt.push(ut.name.expression), ut.kind) {
                      case _.SyntaxKind.PropertyAssignment:
                        rt.push(ut.initializer);
                        break;
                      case _.SyntaxKind.SpreadAssignment:
                        rt.push(ut.expression);
                    }
                  break;
                case _.SyntaxKind.JsxExpression:
                  if (S.expression === void 0)
                    break;
                  S = S.expression;
                  continue;
                case _.SyntaxKind.JsxElement:
                case _.SyntaxKind.JsxFragment:
                  for (let ut of S.children)
                    ut.kind !== _.SyntaxKind.JsxText && rt.push(ut);
                  if (S.kind === _.SyntaxKind.JsxFragment)
                    break;
                  S = S.openingElement;
                case _.SyntaxKind.JsxSelfClosingElement:
                case _.SyntaxKind.JsxOpeningElement:
                  if (H & 4)
                    return true;
                  for (let ut of S.attributes.properties)
                    ut.kind === _.SyntaxKind.JsxSpreadAttribute ? rt.push(ut.expression) : ut.initializer !== void 0 && rt.push(ut.initializer);
                  break;
                case _.SyntaxKind.CommaListExpression:
                  rt.push(...S.elements);
              }
              if (rt.length === 0)
                return false;
              S = rt.pop();
            }
          }
          a.hasSideEffects = $c;
          function po(S) {
            let H = S.parent.parent;
            for (; H.kind === _.SyntaxKind.BindingElement; )
              H = H.parent.parent;
            return H;
          }
          a.getDeclarationOfBindingElement = po;
          function jr2(S) {
            for (; ; ) {
              let H = S.parent;
              switch (H.kind) {
                case _.SyntaxKind.CallExpression:
                case _.SyntaxKind.NewExpression:
                case _.SyntaxKind.ElementAccessExpression:
                case _.SyntaxKind.WhileStatement:
                case _.SyntaxKind.DoStatement:
                case _.SyntaxKind.WithStatement:
                case _.SyntaxKind.ThrowStatement:
                case _.SyntaxKind.ReturnStatement:
                case _.SyntaxKind.JsxExpression:
                case _.SyntaxKind.JsxSpreadAttribute:
                case _.SyntaxKind.JsxElement:
                case _.SyntaxKind.JsxFragment:
                case _.SyntaxKind.JsxSelfClosingElement:
                case _.SyntaxKind.ComputedPropertyName:
                case _.SyntaxKind.ArrowFunction:
                case _.SyntaxKind.ExportSpecifier:
                case _.SyntaxKind.ExportAssignment:
                case _.SyntaxKind.ImportDeclaration:
                case _.SyntaxKind.ExternalModuleReference:
                case _.SyntaxKind.Decorator:
                case _.SyntaxKind.TaggedTemplateExpression:
                case _.SyntaxKind.TemplateSpan:
                case _.SyntaxKind.ExpressionWithTypeArguments:
                case _.SyntaxKind.TypeOfExpression:
                case _.SyntaxKind.AwaitExpression:
                case _.SyntaxKind.YieldExpression:
                case _.SyntaxKind.LiteralType:
                case _.SyntaxKind.JsxAttributes:
                case _.SyntaxKind.JsxOpeningElement:
                case _.SyntaxKind.JsxClosingElement:
                case _.SyntaxKind.IfStatement:
                case _.SyntaxKind.CaseClause:
                case _.SyntaxKind.SwitchStatement:
                  return true;
                case _.SyntaxKind.PropertyAccessExpression:
                  return H.expression === S;
                case _.SyntaxKind.QualifiedName:
                  return H.left === S;
                case _.SyntaxKind.ShorthandPropertyAssignment:
                  return H.objectAssignmentInitializer === S || !qn(H);
                case _.SyntaxKind.PropertyAssignment:
                  return H.initializer === S && !qn(H);
                case _.SyntaxKind.SpreadAssignment:
                case _.SyntaxKind.SpreadElement:
                case _.SyntaxKind.ArrayLiteralExpression:
                  return !qn(H);
                case _.SyntaxKind.ParenthesizedExpression:
                case _.SyntaxKind.AsExpression:
                case _.SyntaxKind.TypeAssertionExpression:
                case _.SyntaxKind.PostfixUnaryExpression:
                case _.SyntaxKind.PrefixUnaryExpression:
                case _.SyntaxKind.NonNullExpression:
                  S = H;
                  continue;
                case _.SyntaxKind.ForStatement:
                  return H.condition === S;
                case _.SyntaxKind.ForInStatement:
                case _.SyntaxKind.ForOfStatement:
                  return H.expression === S;
                case _.SyntaxKind.ConditionalExpression:
                  if (H.condition === S)
                    return true;
                  S = H;
                  break;
                case _.SyntaxKind.PropertyDeclaration:
                case _.SyntaxKind.BindingElement:
                case _.SyntaxKind.VariableDeclaration:
                case _.SyntaxKind.Parameter:
                case _.SyntaxKind.EnumMember:
                  return H.initializer === S;
                case _.SyntaxKind.ImportEqualsDeclaration:
                  return H.moduleReference === S;
                case _.SyntaxKind.CommaListExpression:
                  if (H.elements[H.elements.length - 1] !== S)
                    return false;
                  S = H;
                  break;
                case _.SyntaxKind.BinaryExpression:
                  if (H.right === S) {
                    if (H.operatorToken.kind === _.SyntaxKind.CommaToken) {
                      S = H;
                      break;
                    }
                    return true;
                  }
                  switch (H.operatorToken.kind) {
                    case _.SyntaxKind.CommaToken:
                    case _.SyntaxKind.EqualsToken:
                      return false;
                    case _.SyntaxKind.EqualsEqualsEqualsToken:
                    case _.SyntaxKind.EqualsEqualsToken:
                    case _.SyntaxKind.ExclamationEqualsEqualsToken:
                    case _.SyntaxKind.ExclamationEqualsToken:
                    case _.SyntaxKind.InstanceOfKeyword:
                    case _.SyntaxKind.PlusToken:
                    case _.SyntaxKind.MinusToken:
                    case _.SyntaxKind.AsteriskToken:
                    case _.SyntaxKind.SlashToken:
                    case _.SyntaxKind.PercentToken:
                    case _.SyntaxKind.AsteriskAsteriskToken:
                    case _.SyntaxKind.GreaterThanToken:
                    case _.SyntaxKind.GreaterThanGreaterThanToken:
                    case _.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    case _.SyntaxKind.GreaterThanEqualsToken:
                    case _.SyntaxKind.LessThanToken:
                    case _.SyntaxKind.LessThanLessThanToken:
                    case _.SyntaxKind.LessThanEqualsToken:
                    case _.SyntaxKind.AmpersandToken:
                    case _.SyntaxKind.BarToken:
                    case _.SyntaxKind.CaretToken:
                    case _.SyntaxKind.BarBarToken:
                    case _.SyntaxKind.AmpersandAmpersandToken:
                    case _.SyntaxKind.QuestionQuestionToken:
                    case _.SyntaxKind.InKeyword:
                    case _.SyntaxKind.QuestionQuestionEqualsToken:
                    case _.SyntaxKind.AmpersandAmpersandEqualsToken:
                    case _.SyntaxKind.BarBarEqualsToken:
                      return true;
                    default:
                      S = H;
                  }
                  break;
                default:
                  return false;
              }
            }
          }
          a.isExpressionValueUsed = jr2;
          function qn(S) {
            switch (S.kind) {
              case _.SyntaxKind.ShorthandPropertyAssignment:
                if (S.objectAssignmentInitializer !== void 0)
                  return true;
              case _.SyntaxKind.PropertyAssignment:
              case _.SyntaxKind.SpreadAssignment:
                S = S.parent;
                break;
              case _.SyntaxKind.SpreadElement:
                if (S.parent.kind !== _.SyntaxKind.ArrayLiteralExpression)
                  return false;
                S = S.parent;
            }
            for (; ; )
              switch (S.parent.kind) {
                case _.SyntaxKind.BinaryExpression:
                  return S.parent.left === S && S.parent.operatorToken.kind === _.SyntaxKind.EqualsToken;
                case _.SyntaxKind.ForOfStatement:
                  return S.parent.initializer === S;
                case _.SyntaxKind.ArrayLiteralExpression:
                case _.SyntaxKind.ObjectLiteralExpression:
                  S = S.parent;
                  break;
                case _.SyntaxKind.SpreadAssignment:
                case _.SyntaxKind.PropertyAssignment:
                  S = S.parent.parent;
                  break;
                case _.SyntaxKind.SpreadElement:
                  if (S.parent.parent.kind !== _.SyntaxKind.ArrayLiteralExpression)
                    return false;
                  S = S.parent.parent;
                  break;
                default:
                  return false;
              }
          }
          var g_;
          (function(S) {
            S[S.None = 0] = "None", S[S.Read = 1] = "Read", S[S.Write = 2] = "Write", S[S.Delete = 4] = "Delete", S[S.ReadWrite = 3] = "ReadWrite", S[S.Modification = 6] = "Modification";
          })(g_ = a.AccessKind || (a.AccessKind = {}));
          function ks(S) {
            let H = S.parent;
            switch (H.kind) {
              case _.SyntaxKind.DeleteExpression:
                return 4;
              case _.SyntaxKind.PostfixUnaryExpression:
                return 3;
              case _.SyntaxKind.PrefixUnaryExpression:
                return H.operator === _.SyntaxKind.PlusPlusToken || H.operator === _.SyntaxKind.MinusMinusToken ? 3 : 1;
              case _.SyntaxKind.BinaryExpression:
                return H.right === S ? 1 : C2(H.operatorToken.kind) ? H.operatorToken.kind === _.SyntaxKind.EqualsToken ? 2 : 3 : 1;
              case _.SyntaxKind.ShorthandPropertyAssignment:
                return H.objectAssignmentInitializer === S ? 1 : qn(H) ? 2 : 1;
              case _.SyntaxKind.PropertyAssignment:
                return H.name === S ? 0 : qn(H) ? 2 : 1;
              case _.SyntaxKind.ArrayLiteralExpression:
              case _.SyntaxKind.SpreadElement:
              case _.SyntaxKind.SpreadAssignment:
                return qn(H) ? 2 : 1;
              case _.SyntaxKind.ParenthesizedExpression:
              case _.SyntaxKind.NonNullExpression:
              case _.SyntaxKind.TypeAssertionExpression:
              case _.SyntaxKind.AsExpression:
                return ks(H);
              case _.SyntaxKind.ForOfStatement:
              case _.SyntaxKind.ForInStatement:
                return H.initializer === S ? 2 : 1;
              case _.SyntaxKind.ExpressionWithTypeArguments:
                return H.parent.token === _.SyntaxKind.ExtendsKeyword && H.parent.parent.kind !== _.SyntaxKind.InterfaceDeclaration ? 1 : 0;
              case _.SyntaxKind.ComputedPropertyName:
              case _.SyntaxKind.ExpressionStatement:
              case _.SyntaxKind.TypeOfExpression:
              case _.SyntaxKind.ElementAccessExpression:
              case _.SyntaxKind.ForStatement:
              case _.SyntaxKind.IfStatement:
              case _.SyntaxKind.DoStatement:
              case _.SyntaxKind.WhileStatement:
              case _.SyntaxKind.SwitchStatement:
              case _.SyntaxKind.WithStatement:
              case _.SyntaxKind.ThrowStatement:
              case _.SyntaxKind.CallExpression:
              case _.SyntaxKind.NewExpression:
              case _.SyntaxKind.TaggedTemplateExpression:
              case _.SyntaxKind.JsxExpression:
              case _.SyntaxKind.Decorator:
              case _.SyntaxKind.TemplateSpan:
              case _.SyntaxKind.JsxOpeningElement:
              case _.SyntaxKind.JsxSelfClosingElement:
              case _.SyntaxKind.JsxSpreadAttribute:
              case _.SyntaxKind.VoidExpression:
              case _.SyntaxKind.ReturnStatement:
              case _.SyntaxKind.AwaitExpression:
              case _.SyntaxKind.YieldExpression:
              case _.SyntaxKind.ConditionalExpression:
              case _.SyntaxKind.CaseClause:
              case _.SyntaxKind.JsxElement:
                return 1;
              case _.SyntaxKind.ArrowFunction:
                return H.body === S ? 1 : 2;
              case _.SyntaxKind.PropertyDeclaration:
              case _.SyntaxKind.VariableDeclaration:
              case _.SyntaxKind.Parameter:
              case _.SyntaxKind.EnumMember:
              case _.SyntaxKind.BindingElement:
              case _.SyntaxKind.JsxAttribute:
                return H.initializer === S ? 1 : 0;
              case _.SyntaxKind.PropertyAccessExpression:
                return H.expression === S ? 1 : 0;
              case _.SyntaxKind.ExportAssignment:
                return H.isExportEquals ? 1 : 0;
            }
            return 0;
          }
          a.getAccessKind = ks;
          function Is(S) {
            return (ks(S) & 2) !== 0;
          }
          a.isReassignmentTarget = Is;
          function y_(S) {
            switch (S.kind) {
              case _.SyntaxKind.Parameter:
              case _.SyntaxKind.CallSignature:
              case _.SyntaxKind.ConstructSignature:
              case _.SyntaxKind.MethodSignature:
              case _.SyntaxKind.PropertySignature:
              case _.SyntaxKind.ArrowFunction:
              case _.SyntaxKind.ParenthesizedExpression:
              case _.SyntaxKind.SpreadAssignment:
              case _.SyntaxKind.ShorthandPropertyAssignment:
              case _.SyntaxKind.PropertyAssignment:
              case _.SyntaxKind.FunctionExpression:
              case _.SyntaxKind.LabeledStatement:
              case _.SyntaxKind.ExpressionStatement:
              case _.SyntaxKind.VariableStatement:
              case _.SyntaxKind.FunctionDeclaration:
              case _.SyntaxKind.Constructor:
              case _.SyntaxKind.MethodDeclaration:
              case _.SyntaxKind.PropertyDeclaration:
              case _.SyntaxKind.GetAccessor:
              case _.SyntaxKind.SetAccessor:
              case _.SyntaxKind.ClassDeclaration:
              case _.SyntaxKind.ClassExpression:
              case _.SyntaxKind.InterfaceDeclaration:
              case _.SyntaxKind.TypeAliasDeclaration:
              case _.SyntaxKind.EnumMember:
              case _.SyntaxKind.EnumDeclaration:
              case _.SyntaxKind.ModuleDeclaration:
              case _.SyntaxKind.ImportEqualsDeclaration:
              case _.SyntaxKind.ImportDeclaration:
              case _.SyntaxKind.NamespaceExportDeclaration:
              case _.SyntaxKind.ExportAssignment:
              case _.SyntaxKind.IndexSignature:
              case _.SyntaxKind.FunctionType:
              case _.SyntaxKind.ConstructorType:
              case _.SyntaxKind.JSDocFunctionType:
              case _.SyntaxKind.ExportDeclaration:
              case _.SyntaxKind.NamedTupleMember:
              case _.SyntaxKind.EndOfFileToken:
                return true;
              default:
                return false;
            }
          }
          a.canHaveJsDoc = y_;
          function Ns(S, H) {
            let le = [];
            for (let Be2 of S.getChildren(H)) {
              if (!v2.isJsDoc(Be2))
                break;
              le.push(Be2);
            }
            return le;
          }
          a.getJsDoc = Ns;
          function Kc(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S.getSourceFile();
            if (y_(S) && S.kind !== _.SyntaxKind.EndOfFileToken) {
              let Be2 = Ns(S, le);
              if (Be2.length !== 0 || !H)
                return Be2;
            }
            return pa(S, S.getStart(le), le, H);
          }
          a.parseJsDocOfNode = Kc;
          function pa(S, H, le, Be2) {
            let rt = _[Be2 && h_(le, S.pos, H) ? "forEachTrailingCommentRange" : "forEachLeadingCommentRange"](le.text, S.pos, (en, Ji, gi) => gi === _.SyntaxKind.MultiLineCommentTrivia && le.text[en + 2] === "*" ? { pos: en } : void 0);
            if (rt === void 0)
              return [];
            let ut = rt.pos, Ht = le.text.slice(ut, H), Fr2 = _.createSourceFile("jsdoc.ts", `${Ht}var a;`, le.languageVersion), Cr2 = Ns(Fr2.statements[0], Fr2);
            for (let en of Cr2)
              ir2(en, S);
            return Cr2;
            function ir2(en, Ji) {
              return en.pos += ut, en.end += ut, en.parent = Ji, _.forEachChild(en, (gi) => ir2(gi, en), (gi) => {
                gi.pos += ut, gi.end += ut;
                for (let ln of gi)
                  ir2(ln, en);
              });
            }
          }
          var Xc;
          (function(S) {
            S[S.ImportDeclaration = 1] = "ImportDeclaration", S[S.ImportEquals = 2] = "ImportEquals", S[S.ExportFrom = 4] = "ExportFrom", S[S.DynamicImport = 8] = "DynamicImport", S[S.Require = 16] = "Require", S[S.ImportType = 32] = "ImportType", S[S.All = 63] = "All", S[S.AllImports = 59] = "AllImports", S[S.AllStaticImports = 3] = "AllStaticImports", S[S.AllImportExpressions = 24] = "AllImportExpressions", S[S.AllRequireLike = 18] = "AllRequireLike", S[S.AllNestedImports = 56] = "AllNestedImports", S[S.AllTopLevelImports = 7] = "AllTopLevelImports";
          })(Xc = a.ImportKind || (a.ImportKind = {}));
          function fo2(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, Be2 = [];
            for (let ut of v_(S, H, le))
              switch (ut.kind) {
                case _.SyntaxKind.ImportDeclaration:
                  rt(ut.moduleSpecifier);
                  break;
                case _.SyntaxKind.ImportEqualsDeclaration:
                  rt(ut.moduleReference.expression);
                  break;
                case _.SyntaxKind.ExportDeclaration:
                  rt(ut.moduleSpecifier);
                  break;
                case _.SyntaxKind.CallExpression:
                  rt(ut.arguments[0]);
                  break;
                case _.SyntaxKind.ImportType:
                  v2.isLiteralTypeNode(ut.argument) && rt(ut.argument.literal);
                  break;
                default:
                  throw new Error("unexpected node");
              }
            return Be2;
            function rt(ut) {
              v2.isTextualLiteral(ut) && Be2.push(ut);
            }
          }
          a.findImports = fo2;
          function v_(S, H) {
            let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            return new Cn(S, H, le).find();
          }
          a.findImportLikeNodes = v_;
          var Cn = class {
            constructor(S, H, le) {
              this._sourceFile = S, this._options = H, this._ignoreFileName = le, this._result = [];
            }
            find() {
              return this._sourceFile.isDeclarationFile && (this._options &= -25), this._options & 7 && this._findImports(this._sourceFile.statements), this._options & 56 && this._findNestedImports(), this._result;
            }
            _findImports(S) {
              for (let H of S)
                v2.isImportDeclaration(H) ? this._options & 1 && this._result.push(H) : v2.isImportEqualsDeclaration(H) ? this._options & 2 && H.moduleReference.kind === _.SyntaxKind.ExternalModuleReference && this._result.push(H) : v2.isExportDeclaration(H) ? H.moduleSpecifier !== void 0 && this._options & 4 && this._result.push(H) : v2.isModuleDeclaration(H) && this._findImportsInModule(H);
            }
            _findImportsInModule(S) {
              if (S.body !== void 0) {
                if (S.body.kind === _.SyntaxKind.ModuleDeclaration)
                  return this._findImportsInModule(S.body);
                this._findImports(S.body.statements);
              }
            }
            _findNestedImports() {
              let S = this._ignoreFileName || (this._sourceFile.flags & _.NodeFlags.JavaScriptFile) !== 0, H, le;
              if ((this._options & 56) === 16) {
                if (!S)
                  return;
                H = /\brequire\s*[</(]/g, le = false;
              } else
                this._options & 16 && S ? (H = /\b(?:import|require)\s*[</(]/g, le = (this._options & 32) !== 0) : (H = /\bimport\s*[</(]/g, le = S && (this._options & 32) !== 0);
              for (let Be2 = H.exec(this._sourceFile.text); Be2 !== null; Be2 = H.exec(this._sourceFile.text)) {
                let rt = pe2(this._sourceFile, Be2.index, this._sourceFile, Be2[0][0] === "i" && le);
                if (rt.kind === _.SyntaxKind.ImportKeyword) {
                  if (rt.end - 6 !== Be2.index)
                    continue;
                  switch (rt.parent.kind) {
                    case _.SyntaxKind.ImportType:
                      this._result.push(rt.parent);
                      break;
                    case _.SyntaxKind.CallExpression:
                      rt.parent.arguments.length > 1 && this._result.push(rt.parent);
                  }
                } else
                  rt.kind === _.SyntaxKind.Identifier && rt.end - 7 === Be2.index && rt.parent.kind === _.SyntaxKind.CallExpression && rt.parent.expression === rt && rt.parent.arguments.length === 1 && this._result.push(rt.parent);
              }
            }
          };
          function Zn(S) {
            for (; S.flags & _.NodeFlags.NestedNamespace; )
              S = S.parent;
            return q2(S.modifiers, _.SyntaxKind.DeclareKeyword) || Xa(S.parent);
          }
          a.isStatementInAmbientContext = Zn;
          function Xa(S) {
            for (; S.kind === _.SyntaxKind.ModuleBlock; ) {
              do
                S = S.parent;
              while (S.flags & _.NodeFlags.NestedNamespace);
              if (q2(S.modifiers, _.SyntaxKind.DeclareKeyword))
                return true;
              S = S.parent;
            }
            return false;
          }
          a.isAmbientModuleBlock = Xa;
          function Yc2(S) {
            let H = S.parent;
            for (; H.kind === _.SyntaxKind.ParenthesizedExpression; )
              H = H.parent;
            return v2.isCallExpression(H) && S.end <= H.expression.end ? H : void 0;
          }
          a.getIIFE = Yc2;
          function mo(S, H) {
            return (S.strict ? S[H] !== false : S[H] === true) && (H !== "strictPropertyInitialization" || mo(S, "strictNullChecks"));
          }
          a.isStrictCompilerOptionEnabled = mo;
          function ei(S, H) {
            switch (H) {
              case "stripInternal":
              case "declarationMap":
              case "emitDeclarationOnly":
                return S[H] === true && ei(S, "declaration");
              case "declaration":
                return S.declaration || ei(S, "composite");
              case "incremental":
                return S.incremental === void 0 ? ei(S, "composite") : S.incremental;
              case "skipDefaultLibCheck":
                return S.skipDefaultLibCheck || ei(S, "skipLibCheck");
              case "suppressImplicitAnyIndexErrors":
                return S.suppressImplicitAnyIndexErrors === true && ei(S, "noImplicitAny");
              case "allowSyntheticDefaultImports":
                return S.allowSyntheticDefaultImports !== void 0 ? S.allowSyntheticDefaultImports : ei(S, "esModuleInterop") || S.module === _.ModuleKind.System;
              case "noUncheckedIndexedAccess":
                return S.noUncheckedIndexedAccess === true && ei(S, "strictNullChecks");
              case "allowJs":
                return S.allowJs === void 0 ? ei(S, "checkJs") : S.allowJs;
              case "noImplicitAny":
              case "noImplicitThis":
              case "strictNullChecks":
              case "strictFunctionTypes":
              case "strictPropertyInitialization":
              case "alwaysStrict":
              case "strictBindCallApply":
                return mo(S, H);
            }
            return S[H] === true;
          }
          a.isCompilerOptionEnabled = ei;
          function Ya(S) {
            return S.name.kind === _.SyntaxKind.StringLiteral || (S.flags & _.NodeFlags.GlobalAugmentation) !== 0;
          }
          a.isAmbientModule = Ya;
          function b_(S) {
            return Qa(S);
          }
          a.getCheckJsDirective = b_;
          function Qa(S) {
            let H;
            return _.forEachLeadingCommentRange(S, (_.getShebang(S) || "").length, (le, Be2, rt) => {
              if (rt === _.SyntaxKind.SingleLineCommentTrivia) {
                let ut = S.slice(le, Be2), Ht = /^\/{2,3}\s*@ts-(no)?check(?:\s|$)/i.exec(ut);
                Ht !== null && (H = { pos: le, end: Be2, enabled: Ht[1] === void 0 });
              }
            }), H;
          }
          a.getTsCheckDirective = Qa;
          function Jr(S) {
            return v2.isTypeReferenceNode(S.type) && S.type.typeName.kind === _.SyntaxKind.Identifier && S.type.typeName.escapedText === "const";
          }
          a.isConstAssertion = Jr;
          function Qc(S) {
            let H = S;
            for (; ; ) {
              let le = H.parent;
              e:
                switch (le.kind) {
                  case _.SyntaxKind.TypeAssertionExpression:
                  case _.SyntaxKind.AsExpression:
                    return Jr(le);
                  case _.SyntaxKind.PrefixUnaryExpression:
                    if (H.kind !== _.SyntaxKind.NumericLiteral)
                      return false;
                    switch (le.operator) {
                      case _.SyntaxKind.PlusToken:
                      case _.SyntaxKind.MinusToken:
                        H = le;
                        break e;
                      default:
                        return false;
                    }
                  case _.SyntaxKind.PropertyAssignment:
                    if (le.initializer !== H)
                      return false;
                    H = le.parent;
                    break;
                  case _.SyntaxKind.ShorthandPropertyAssignment:
                    H = le.parent;
                    break;
                  case _.SyntaxKind.ParenthesizedExpression:
                  case _.SyntaxKind.ArrayLiteralExpression:
                  case _.SyntaxKind.ObjectLiteralExpression:
                  case _.SyntaxKind.TemplateExpression:
                    H = le;
                    break;
                  default:
                    return false;
                }
            }
          }
          a.isInConstContext = Qc;
          function ho(S, H) {
            if (!T_(S))
              return false;
            let le = H.getTypeAtLocation(S.arguments[2]);
            if (le.getProperty("value") === void 0)
              return le.getProperty("set") === void 0;
            let Be2 = le.getProperty("writable");
            if (Be2 === void 0)
              return false;
            let rt = Be2.valueDeclaration !== void 0 && v2.isPropertyAssignment(Be2.valueDeclaration) ? H.getTypeAtLocation(Be2.valueDeclaration.initializer) : H.getTypeOfSymbolAtLocation(Be2, S.arguments[2]);
            return D.isBooleanLiteralType(rt, false);
          }
          a.isReadonlyAssignmentDeclaration = ho;
          function T_(S) {
            return S.arguments.length === 3 && v2.isEntityNameExpression(S.arguments[0]) && v2.isNumericOrStringLikeLiteral(S.arguments[1]) && v2.isPropertyAccessExpression(S.expression) && S.expression.name.escapedText === "defineProperty" && v2.isIdentifier(S.expression.expression) && S.expression.expression.escapedText === "Object";
          }
          a.isBindableObjectDefinePropertyCall = T_;
          function go(S) {
            return _.isPropertyAccessExpression(S) && _.isIdentifier(S.expression) && S.expression.escapedText === "Symbol";
          }
          a.isWellKnownSymbolLiterally = go;
          function yo(S) {
            return { displayName: `[Symbol.${S.name.text}]`, symbolName: "__@" + S.name.text };
          }
          a.getPropertyNameOfWellKnownSymbol = yo;
          var Za = ((S) => {
            let [H, le] = S;
            return H < "4" || H === "4" && le < "3";
          })(_.versionMajorMinor.split("."));
          function vo(S, H) {
            let le = { known: true, names: [] };
            if (S = Os(S), Za && go(S))
              le.names.push(yo(S));
            else {
              let Be2 = H.getTypeAtLocation(S);
              for (let rt of D.unionTypeParts(H.getBaseConstraintOfType(Be2) || Be2)) {
                let ut = D.getPropertyNameFromType(rt);
                ut ? le.names.push(ut) : le.known = false;
              }
            }
            return le;
          }
          a.getLateBoundPropertyNames = vo;
          function S_(S, H) {
            let le = Ze2(S);
            return le !== void 0 ? { known: true, names: [{ displayName: le, symbolName: _.escapeLeadingUnderscores(le) }] } : S.kind === _.SyntaxKind.PrivateIdentifier ? { known: true, names: [{ displayName: S.text, symbolName: H.getSymbolAtLocation(S).escapedName }] } : vo(S.expression, H);
          }
          a.getLateBoundPropertyNamesOfPropertyName = S_;
          function Zc(S, H) {
            let le = Ze2(S);
            if (le !== void 0)
              return { displayName: le, symbolName: _.escapeLeadingUnderscores(le) };
            if (S.kind === _.SyntaxKind.PrivateIdentifier)
              return { displayName: S.text, symbolName: H.getSymbolAtLocation(S).escapedName };
            let { expression: Be2 } = S;
            return Za && go(Be2) ? yo(Be2) : D.getPropertyNameFromType(H.getTypeAtLocation(Be2));
          }
          a.getSingleLateBoundPropertyNameOfPropertyName = Zc;
          function Os(S) {
            for (; S.kind === _.SyntaxKind.ParenthesizedExpression; )
              S = S.expression;
            return S;
          }
          a.unwrapParentheses = Os;
          function bo(S) {
            return `${S.negative ? "-" : ""}${S.base10Value}n`;
          }
          a.formatPseudoBigInt = bo;
          function el(S, H) {
            let le = S.caseBlock.clauses.filter(v2.isCaseClause);
            if (le.length === 0)
              return false;
            let Be2 = D.unionTypeParts(H.getTypeAtLocation(S.expression));
            if (Be2.length > le.length)
              return false;
            let rt = new Set(Be2.map(x_));
            if (rt.has(void 0))
              return false;
            let ut = /* @__PURE__ */ new Set();
            for (let Ht of le) {
              let Fr2 = H.getTypeAtLocation(Ht.expression);
              if (a.isTypeFlagSet(Fr2, _.TypeFlags.Never))
                continue;
              let Cr2 = x_(Fr2);
              if (rt.has(Cr2))
                ut.add(Cr2);
              else if (Cr2 !== "null" && Cr2 !== "undefined")
                return false;
            }
            return rt.size === ut.size;
          }
          a.hasExhaustiveCaseClauses = el;
          function x_(S) {
            if (a.isTypeFlagSet(S, _.TypeFlags.Null))
              return "null";
            if (a.isTypeFlagSet(S, _.TypeFlags.Undefined))
              return "undefined";
            if (a.isTypeFlagSet(S, _.TypeFlags.NumberLiteral))
              return `${a.isTypeFlagSet(S, _.TypeFlags.EnumLiteral) ? "enum:" : ""}${S.value}`;
            if (a.isTypeFlagSet(S, _.TypeFlags.StringLiteral))
              return `${a.isTypeFlagSet(S, _.TypeFlags.EnumLiteral) ? "enum:" : ""}string:${S.value}`;
            if (a.isTypeFlagSet(S, _.TypeFlags.BigIntLiteral))
              return bo(S.value);
            if (h.isUniqueESSymbolType(S))
              return S.escapedName;
            if (D.isBooleanLiteralType(S, true))
              return "true";
            if (D.isBooleanLiteralType(S, false))
              return "false";
          }
          function E_(S) {
            var H;
            if (((H = S.heritageClauses) === null || H === void 0 ? void 0 : H[0].token) === _.SyntaxKind.ExtendsKeyword)
              return S.heritageClauses[0].types[0];
          }
          a.getBaseOfClassLikeExpression = E_;
        } }), RV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/convert-comments.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(d2, E, I, c) {
            c === void 0 && (c = I);
            var M = Object.getOwnPropertyDescriptor(E, I);
            (!M || ("get" in M ? !E.__esModule : M.writable || M.configurable)) && (M = { enumerable: true, get: function() {
              return E[I];
            } }), Object.defineProperty(d2, c, M);
          } : function(d2, E, I, c) {
            c === void 0 && (c = I), d2[c] = E[I];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(d2, E) {
            Object.defineProperty(d2, "default", { enumerable: true, value: E });
          } : function(d2, E) {
            d2.default = E;
          }), h = a && a.__importStar || function(d2) {
            if (d2 && d2.__esModule)
              return d2;
            var E = {};
            if (d2 != null)
              for (var I in d2)
                I !== "default" && Object.prototype.hasOwnProperty.call(d2, I) && _(E, d2, I);
            return v2(E, d2), E;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.convertComments = void 0;
          var D = Q9(), P = h(vr()), y = E1(), m = x1();
          function C2(d2, E) {
            let I = [];
            return (0, D.forEachComment)(d2, (c, M) => {
              let q2 = M.kind === P.SyntaxKind.SingleLineCommentTrivia ? m.AST_TOKEN_TYPES.Line : m.AST_TOKEN_TYPES.Block, W = [M.pos, M.end], K = (0, y.getLocFor)(W[0], W[1], d2), ce2 = W[0] + 2, Ie2 = M.kind === P.SyntaxKind.SingleLineCommentTrivia ? W[1] - ce2 : W[1] - ce2 - 2;
              I.push({ type: q2, value: E.slice(ce2, ce2 + Ie2), range: W, loc: K });
            }, d2), I;
          }
          a.convertComments = C2;
        } }), Z9 = Oe2({ "node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true });
          var _ = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["exported", "source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportExpression: ["source"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXClosingFragment: [], JSXOpeningFragment: [], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], PrivateIdentifier: [], Program: ["body"], Property: ["key", "value"], PropertyDefinition: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], StaticBlock: ["body"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] }, v2 = Object.keys(_);
          for (let m of v2)
            Object.freeze(_[m]);
          Object.freeze(_);
          var h = /* @__PURE__ */ new Set(["parent", "leadingComments", "trailingComments"]);
          function D(m) {
            return !h.has(m) && m[0] !== "_";
          }
          function P(m) {
            return Object.keys(m).filter(D);
          }
          function y(m) {
            let C2 = Object.assign({}, _);
            for (let d2 of Object.keys(m))
              if (Object.prototype.hasOwnProperty.call(C2, d2)) {
                let E = new Set(m[d2]);
                for (let I of C2[d2])
                  E.add(I);
                C2[d2] = Object.freeze(Array.from(E));
              } else
                C2[d2] = Object.freeze(Array.from(m[d2]));
            return Object.freeze(C2);
          }
          a.KEYS = _, a.getKeys = P, a.unionWith = y;
        } }), jV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/visitor-keys/dist/get-keys.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.getKeys = void 0;
          var _ = Z9(), v2 = _.getKeys;
          a.getKeys = v2;
        } }), JV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/visitor-keys/dist/visitor-keys.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(C2, d2, E, I) {
            I === void 0 && (I = E);
            var c = Object.getOwnPropertyDescriptor(d2, E);
            (!c || ("get" in c ? !d2.__esModule : c.writable || c.configurable)) && (c = { enumerable: true, get: function() {
              return d2[E];
            } }), Object.defineProperty(C2, I, c);
          } : function(C2, d2, E, I) {
            I === void 0 && (I = E), C2[I] = d2[E];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(C2, d2) {
            Object.defineProperty(C2, "default", { enumerable: true, value: d2 });
          } : function(C2, d2) {
            C2.default = d2;
          }), h = a && a.__importStar || function(C2) {
            if (C2 && C2.__esModule)
              return C2;
            var d2 = {};
            if (C2 != null)
              for (var E in C2)
                E !== "default" && Object.prototype.hasOwnProperty.call(C2, E) && _(d2, C2, E);
            return v2(d2, C2), d2;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.visitorKeys = void 0;
          var D = h(Z9()), P = (() => {
            let C2 = ["typeParameters", "params", "returnType"], d2 = [...C2, "body"], E = ["decorators", "key", "typeAnnotation"];
            return { AnonymousFunction: d2, Function: ["id", ...d2], FunctionType: C2, ClassDeclaration: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "implements", "body"], AbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], PropertyDefinition: [...E, "value"], TypeAssertion: ["expression", "typeAnnotation"] };
          })(), y = { AccessorProperty: P.PropertyDefinition, ArrayPattern: ["decorators", "elements", "typeAnnotation"], ArrowFunctionExpression: P.AnonymousFunction, AssignmentPattern: ["decorators", "left", "right", "typeAnnotation"], CallExpression: ["callee", "typeParameters", "arguments"], ClassDeclaration: P.ClassDeclaration, ClassExpression: P.ClassDeclaration, Decorator: ["expression"], ExportAllDeclaration: ["exported", "source", "assertions"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "assertions"], FunctionDeclaration: P.Function, FunctionExpression: P.Function, Identifier: ["decorators", "typeAnnotation"], ImportAttribute: ["key", "value"], ImportDeclaration: ["specifiers", "source", "assertions"], ImportExpression: ["source", "attributes"], JSXClosingFragment: [], JSXOpeningElement: ["name", "typeParameters", "attributes"], JSXOpeningFragment: [], JSXSpreadChild: ["expression"], MethodDefinition: ["decorators", "key", "value", "typeParameters"], NewExpression: ["callee", "typeParameters", "arguments"], ObjectPattern: ["decorators", "properties", "typeAnnotation"], PropertyDefinition: P.PropertyDefinition, RestElement: ["decorators", "argument", "typeAnnotation"], StaticBlock: ["body"], TaggedTemplateExpression: ["tag", "typeParameters", "quasi"], TSAbstractAccessorProperty: P.AbstractPropertyDefinition, TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: P.AbstractPropertyDefinition, TSAnyKeyword: [], TSArrayType: ["elementType"], TSAsExpression: P.TypeAssertion, TSAsyncKeyword: [], TSBigIntKeyword: [], TSBooleanKeyword: [], TSCallSignatureDeclaration: P.FunctionType, TSClassImplements: ["expression", "typeParameters"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSConstructorType: P.FunctionType, TSConstructSignatureDeclaration: P.FunctionType, TSDeclareFunction: P.Function, TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", ...P.FunctionType], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSExportAssignment: ["expression"], TSExportKeyword: [], TSExternalModuleReference: ["expression"], TSFunctionType: P.FunctionType, TSImportEqualsDeclaration: ["id", "moduleReference"], TSImportType: ["parameter", "qualifier", "typeParameters"], TSIndexedAccessType: ["indexType", "objectType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSInferType: ["typeParameter"], TSInstantiationExpression: ["expression", "typeParameters"], TSInterfaceBody: ["body"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceHeritage: ["expression", "typeParameters"], TSIntersectionType: ["types"], TSIntrinsicKeyword: [], TSLiteralType: ["literal"], TSMappedType: ["nameType", "typeParameter", "typeAnnotation"], TSMethodSignature: ["typeParameters", "key", "params", "returnType"], TSModuleBlock: ["body"], TSModuleDeclaration: ["id", "body"], TSNamedTupleMember: ["label", "elementType"], TSNamespaceExportDeclaration: ["id"], TSNeverKeyword: [], TSNonNullExpression: ["expression"], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSOptionalType: ["typeAnnotation"], TSParameterProperty: ["decorators", "parameter"], TSPrivateKeyword: [], TSPropertySignature: ["typeAnnotation", "key", "initializer"], TSProtectedKeyword: [], TSPublicKeyword: [], TSQualifiedName: ["left", "right"], TSReadonlyKeyword: [], TSRestType: ["typeAnnotation"], TSSatisfiesExpression: ["typeAnnotation", "expression"], TSStaticKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSTemplateLiteralType: ["quasis", "types"], TSThisType: [], TSTupleType: ["elementTypes"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSTypeAnnotation: ["typeAnnotation"], TSTypeAssertion: P.TypeAssertion, TSTypeLiteral: ["members"], TSTypeOperator: ["typeAnnotation"], TSTypeParameter: ["name", "constraint", "default"], TSTypeParameterDeclaration: ["params"], TSTypeParameterInstantiation: ["params"], TSTypePredicate: ["typeAnnotation", "parameterName"], TSTypeQuery: ["exprName", "typeParameters"], TSTypeReference: ["typeName", "typeParameters"], TSUndefinedKeyword: [], TSUnionType: ["types"], TSUnknownKeyword: [], TSVoidKeyword: [] }, m = D.unionWith(y);
          a.visitorKeys = m;
        } }), e5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/visitor-keys/dist/index.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.visitorKeys = a.getKeys = void 0;
          var _ = jV();
          Object.defineProperty(a, "getKeys", { enumerable: true, get: function() {
            return _.getKeys;
          } });
          var v2 = JV();
          Object.defineProperty(a, "visitorKeys", { enumerable: true, get: function() {
            return v2.visitorKeys;
          } });
        } }), t5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/simple-traverse.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.simpleTraverse = void 0;
          var _ = e5();
          function v2(y) {
            return y != null && typeof y == "object" && typeof y.type == "string";
          }
          function h(y, m) {
            let C2 = y[m.type];
            return C2 != null ? C2 : [];
          }
          var D = class {
            constructor(y) {
              let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              this.allVisitorKeys = _.visitorKeys, this.selectors = y, this.setParentPointers = m;
            }
            traverse(y, m) {
              if (!v2(y))
                return;
              this.setParentPointers && (y.parent = m), "enter" in this.selectors ? this.selectors.enter(y, m) : y.type in this.selectors && this.selectors[y.type](y, m);
              let C2 = h(this.allVisitorKeys, y);
              if (!(C2.length < 1))
                for (let d2 of C2) {
                  let E = y[d2];
                  if (Array.isArray(E))
                    for (let I of E)
                      this.traverse(I, y);
                  else
                    this.traverse(E, y);
                }
            }
          };
          function P(y, m) {
            let C2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            new D(m, C2).traverse(y, void 0);
          }
          a.simpleTraverse = P;
        } }), FV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/ast-converter.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.astConverter = void 0;
          var _ = G9(), v2 = RV(), h = E1(), D = t5();
          function P(y, m, C2) {
            let { parseDiagnostics: d2 } = y;
            if (d2.length)
              throw (0, _.convertError)(d2[0]);
            let E = new _.Converter(y, { errorOnUnknownASTType: m.errorOnUnknownASTType || false, shouldPreserveNodeMaps: C2 }), I = E.convertProgram();
            (!m.range || !m.loc) && (0, D.simpleTraverse)(I, { enter: (M) => {
              m.range || delete M.range, m.loc || delete M.loc;
            } }), m.tokens && (I.tokens = (0, h.convertTokens)(y)), m.comment && (I.comments = (0, v2.convertComments)(y, m.code));
            let c = E.getASTMaps();
            return { estree: I, astMaps: c };
          }
          a.astConverter = P;
        } }), r5 = {};
        m1(r5, { basename: () => o5, default: () => c5, delimiter: () => nT, dirname: () => s5, extname: () => _5, isAbsolute: () => mT, join: () => i5, normalize: () => dT, relative: () => a5, resolve: () => d1, sep: () => rT });
        function n5(a, _) {
          for (var v2 = 0, h = a.length - 1; h >= 0; h--) {
            var D = a[h];
            D === "." ? a.splice(h, 1) : D === ".." ? (a.splice(h, 1), v2++) : v2 && (a.splice(h, 1), v2--);
          }
          if (_)
            for (; v2--; v2)
              a.unshift("..");
          return a;
        }
        function d1() {
          for (var a = "", _ = false, v2 = arguments.length - 1; v2 >= -1 && !_; v2--) {
            var h = v2 >= 0 ? arguments[v2] : "/";
            if (typeof h != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!h)
              continue;
            a = h + "/" + a, _ = h.charAt(0) === "/";
          }
          return a = n5(hT(a.split("/"), function(D) {
            return !!D;
          }), !_).join("/"), (_ ? "/" : "") + a || ".";
        }
        function dT(a) {
          var _ = mT(a), v2 = l5(a, -1) === "/";
          return a = n5(hT(a.split("/"), function(h) {
            return !!h;
          }), !_).join("/"), !a && !_ && (a = "."), a && v2 && (a += "/"), (_ ? "/" : "") + a;
        }
        function mT(a) {
          return a.charAt(0) === "/";
        }
        function i5() {
          var a = Array.prototype.slice.call(arguments, 0);
          return dT(hT(a, function(_, v2) {
            if (typeof _ != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return _;
          }).join("/"));
        }
        function a5(a, _) {
          a = d1(a).substr(1), _ = d1(_).substr(1);
          function v2(d2) {
            for (var E = 0; E < d2.length && d2[E] === ""; E++)
              ;
            for (var I = d2.length - 1; I >= 0 && d2[I] === ""; I--)
              ;
            return E > I ? [] : d2.slice(E, I - E + 1);
          }
          for (var h = v2(a.split("/")), D = v2(_.split("/")), P = Math.min(h.length, D.length), y = P, m = 0; m < P; m++)
            if (h[m] !== D[m]) {
              y = m;
              break;
            }
          for (var C2 = [], m = y; m < h.length; m++)
            C2.push("..");
          return C2 = C2.concat(D.slice(y)), C2.join("/");
        }
        function s5(a) {
          var _ = w1(a), v2 = _[0], h = _[1];
          return !v2 && !h ? "." : (h && (h = h.substr(0, h.length - 1)), v2 + h);
        }
        function o5(a, _) {
          var v2 = w1(a)[2];
          return _ && v2.substr(-1 * _.length) === _ && (v2 = v2.substr(0, v2.length - _.length)), v2;
        }
        function _5(a) {
          return w1(a)[3];
        }
        function hT(a, _) {
          if (a.filter)
            return a.filter(_);
          for (var v2 = [], h = 0; h < a.length; h++)
            _(a[h], h, a) && v2.push(a[h]);
          return v2;
        }
        var x9, w1, rT, nT, c5, l5, BV = yp({ "node-modules-polyfills:path"() {
          De3(), x9 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, w1 = function(a) {
            return x9.exec(a).slice(1);
          }, rT = "/", nT = ":", c5 = { extname: _5, basename: o5, dirname: s5, sep: rT, delimiter: nT, relative: a5, join: i5, isAbsolute: mT, normalize: dT, resolve: d1 }, l5 = "ab".substr(-1) === "b" ? function(a, _, v2) {
            return a.substr(_, v2);
          } : function(a, _, v2) {
            return _ < 0 && (_ = a.length + _), a.substr(_, v2);
          };
        } }), _o = Oe2({ "node-modules-polyfills-commonjs:path"(a, _) {
          De3();
          var v2 = (BV(), Li(r5));
          if (v2 && v2.default) {
            _.exports = v2.default;
            for (let h in v2)
              _.exports[h] = v2[h];
          } else
            v2 && (_.exports = v2);
        } }), d_ = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/shared.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(Ae2, te2, he, Pe2) {
            Pe2 === void 0 && (Pe2 = he);
            var R = Object.getOwnPropertyDescriptor(te2, he);
            (!R || ("get" in R ? !te2.__esModule : R.writable || R.configurable)) && (R = { enumerable: true, get: function() {
              return te2[he];
            } }), Object.defineProperty(Ae2, Pe2, R);
          } : function(Ae2, te2, he, Pe2) {
            Pe2 === void 0 && (Pe2 = he), Ae2[Pe2] = te2[he];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(Ae2, te2) {
            Object.defineProperty(Ae2, "default", { enumerable: true, value: te2 });
          } : function(Ae2, te2) {
            Ae2.default = te2;
          }), h = a && a.__importStar || function(Ae2) {
            if (Ae2 && Ae2.__esModule)
              return Ae2;
            var te2 = {};
            if (Ae2 != null)
              for (var he in Ae2)
                he !== "default" && Object.prototype.hasOwnProperty.call(Ae2, he) && _(te2, Ae2, he);
            return v2(te2, Ae2), te2;
          }, D = a && a.__importDefault || function(Ae2) {
            return Ae2 && Ae2.__esModule ? Ae2 : { default: Ae2 };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getModuleResolver = a.getAstFromProgram = a.getCanonicalFileName = a.ensureAbsolutePath = a.createHash = a.createDefaultCompilerOptionsFromExtra = a.canonicalDirname = a.CORE_COMPILER_OPTIONS = void 0;
          var P = D(_o()), y = h(vr()), m = { noEmit: true, noUnusedLocals: true, noUnusedParameters: true };
          a.CORE_COMPILER_OPTIONS = m;
          var C2 = Object.assign(Object.assign({}, m), { allowNonTsExtensions: true, allowJs: true, checkJs: true });
          function d2(Ae2) {
            return Ae2.debugLevel.has("typescript") ? Object.assign(Object.assign({}, C2), { extendedDiagnostics: true }) : C2;
          }
          a.createDefaultCompilerOptionsFromExtra = d2;
          var E = y.sys !== void 0 ? y.sys.useCaseSensitiveFileNames : true, I = E ? (Ae2) => Ae2 : (Ae2) => Ae2.toLowerCase();
          function c(Ae2) {
            let te2 = P.default.normalize(Ae2);
            return te2.endsWith(P.default.sep) && (te2 = te2.slice(0, -1)), I(te2);
          }
          a.getCanonicalFileName = c;
          function M(Ae2, te2) {
            return P.default.isAbsolute(Ae2) ? Ae2 : P.default.join(te2 || "/prettier-security-dirname-placeholder", Ae2);
          }
          a.ensureAbsolutePath = M;
          function q2(Ae2) {
            return P.default.dirname(Ae2);
          }
          a.canonicalDirname = q2;
          var W = [y.Extension.Dts, y.Extension.Dcts, y.Extension.Dmts];
          function K(Ae2) {
            var te2;
            return Ae2 ? (te2 = W.find((he) => Ae2.endsWith(he))) !== null && te2 !== void 0 ? te2 : P.default.extname(Ae2) : null;
          }
          function ce2(Ae2, te2) {
            let he = Ae2.getSourceFile(te2.filePath), Pe2 = K(te2.filePath), R = K(he == null ? void 0 : he.fileName);
            if (Pe2 === R)
              return he && { ast: he, program: Ae2 };
          }
          a.getAstFromProgram = ce2;
          function Ie2(Ae2) {
            let te2;
            try {
              throw new Error("Dynamic require is not supported");
            } catch {
              let Pe2 = ["Could not find the provided parserOptions.moduleResolver.", "Hint: use an absolute path if you are not in control over where the ESLint instance runs."];
              throw new Error(Pe2.join(`
`));
            }
            return te2;
          }
          a.getModuleResolver = Ie2;
          function me2(Ae2) {
            var te2;
            return !((te2 = y.sys) === null || te2 === void 0) && te2.createHash ? y.sys.createHash(Ae2) : Ae2;
          }
          a.createHash = me2;
        } }), qV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createDefaultProgram.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(I, c, M, q2) {
            q2 === void 0 && (q2 = M);
            var W = Object.getOwnPropertyDescriptor(c, M);
            (!W || ("get" in W ? !c.__esModule : W.writable || W.configurable)) && (W = { enumerable: true, get: function() {
              return c[M];
            } }), Object.defineProperty(I, q2, W);
          } : function(I, c, M, q2) {
            q2 === void 0 && (q2 = M), I[q2] = c[M];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(I, c) {
            Object.defineProperty(I, "default", { enumerable: true, value: c });
          } : function(I, c) {
            I.default = c;
          }), h = a && a.__importStar || function(I) {
            if (I && I.__esModule)
              return I;
            var c = {};
            if (I != null)
              for (var M in I)
                M !== "default" && Object.prototype.hasOwnProperty.call(I, M) && _(c, I, M);
            return v2(c, I), c;
          }, D = a && a.__importDefault || function(I) {
            return I && I.__esModule ? I : { default: I };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createDefaultProgram = void 0;
          var P = D(Ga()), y = D(_o()), m = h(vr()), C2 = d_(), d2 = (0, P.default)("typescript-eslint:typescript-estree:createDefaultProgram");
          function E(I) {
            var c;
            if (d2("Getting default program for: %s", I.filePath || "unnamed file"), ((c = I.projects) === null || c === void 0 ? void 0 : c.length) !== 1)
              return;
            let M = I.projects[0], q2 = m.getParsedCommandLineOfConfigFile(M, (0, C2.createDefaultCompilerOptionsFromExtra)(I), Object.assign(Object.assign({}, m.sys), { onUnRecoverableConfigFileDiagnostic: () => {
            } }));
            if (!q2)
              return;
            let W = m.createCompilerHost(q2.options, true);
            I.moduleResolver && (W.resolveModuleNames = (0, C2.getModuleResolver)(I.moduleResolver).resolveModuleNames);
            let K = W.readFile;
            W.readFile = (me2) => y.default.normalize(me2) === y.default.normalize(I.filePath) ? I.code : K(me2);
            let ce2 = m.createProgram([I.filePath], q2.options, W), Ie2 = ce2.getSourceFile(I.filePath);
            return Ie2 && { ast: Ie2, program: ce2 };
          }
          a.createDefaultProgram = E;
        } }), gT = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/getScriptKind.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(d2, E, I, c) {
            c === void 0 && (c = I);
            var M = Object.getOwnPropertyDescriptor(E, I);
            (!M || ("get" in M ? !E.__esModule : M.writable || M.configurable)) && (M = { enumerable: true, get: function() {
              return E[I];
            } }), Object.defineProperty(d2, c, M);
          } : function(d2, E, I, c) {
            c === void 0 && (c = I), d2[c] = E[I];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(d2, E) {
            Object.defineProperty(d2, "default", { enumerable: true, value: E });
          } : function(d2, E) {
            d2.default = E;
          }), h = a && a.__importStar || function(d2) {
            if (d2 && d2.__esModule)
              return d2;
            var E = {};
            if (d2 != null)
              for (var I in d2)
                I !== "default" && Object.prototype.hasOwnProperty.call(d2, I) && _(E, d2, I);
            return v2(E, d2), E;
          }, D = a && a.__importDefault || function(d2) {
            return d2 && d2.__esModule ? d2 : { default: d2 };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getLanguageVariant = a.getScriptKind = void 0;
          var P = D(_o()), y = h(vr());
          function m(d2, E) {
            switch (P.default.extname(d2).toLowerCase()) {
              case y.Extension.Js:
              case y.Extension.Cjs:
              case y.Extension.Mjs:
                return y.ScriptKind.JS;
              case y.Extension.Jsx:
                return y.ScriptKind.JSX;
              case y.Extension.Ts:
              case y.Extension.Cts:
              case y.Extension.Mts:
                return y.ScriptKind.TS;
              case y.Extension.Tsx:
                return y.ScriptKind.TSX;
              case y.Extension.Json:
                return y.ScriptKind.JSON;
              default:
                return E ? y.ScriptKind.TSX : y.ScriptKind.TS;
            }
          }
          a.getScriptKind = m;
          function C2(d2) {
            switch (d2) {
              case y.ScriptKind.TSX:
              case y.ScriptKind.JSX:
              case y.ScriptKind.JS:
              case y.ScriptKind.JSON:
                return y.LanguageVariant.JSX;
              default:
                return y.LanguageVariant.Standard;
            }
          }
          a.getLanguageVariant = C2;
        } }), UV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createIsolatedProgram.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(I, c, M, q2) {
            q2 === void 0 && (q2 = M);
            var W = Object.getOwnPropertyDescriptor(c, M);
            (!W || ("get" in W ? !c.__esModule : W.writable || W.configurable)) && (W = { enumerable: true, get: function() {
              return c[M];
            } }), Object.defineProperty(I, q2, W);
          } : function(I, c, M, q2) {
            q2 === void 0 && (q2 = M), I[q2] = c[M];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(I, c) {
            Object.defineProperty(I, "default", { enumerable: true, value: c });
          } : function(I, c) {
            I.default = c;
          }), h = a && a.__importStar || function(I) {
            if (I && I.__esModule)
              return I;
            var c = {};
            if (I != null)
              for (var M in I)
                M !== "default" && Object.prototype.hasOwnProperty.call(I, M) && _(c, I, M);
            return v2(c, I), c;
          }, D = a && a.__importDefault || function(I) {
            return I && I.__esModule ? I : { default: I };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createIsolatedProgram = void 0;
          var P = D(Ga()), y = h(vr()), m = gT(), C2 = d_(), d2 = (0, P.default)("typescript-eslint:typescript-estree:createIsolatedProgram");
          function E(I) {
            d2("Getting isolated program in %s mode for: %s", I.jsx ? "TSX" : "TS", I.filePath);
            let c = { fileExists() {
              return true;
            }, getCanonicalFileName() {
              return I.filePath;
            }, getCurrentDirectory() {
              return "";
            }, getDirectories() {
              return [];
            }, getDefaultLibFileName() {
              return "lib.d.ts";
            }, getNewLine() {
              return `
`;
            }, getSourceFile(W) {
              return y.createSourceFile(W, I.code, y.ScriptTarget.Latest, true, (0, m.getScriptKind)(I.filePath, I.jsx));
            }, readFile() {
            }, useCaseSensitiveFileNames() {
              return true;
            }, writeFile() {
              return null;
            } }, M = y.createProgram([I.filePath], Object.assign({ noResolve: true, target: y.ScriptTarget.Latest, jsx: I.jsx ? y.JsxEmit.Preserve : void 0 }, (0, C2.createDefaultCompilerOptionsFromExtra)(I)), c), q2 = M.getSourceFile(I.filePath);
            if (!q2)
              throw new Error("Expected an ast to be returned for the single-file isolated program.");
            return { ast: q2, program: M };
          }
          a.createIsolatedProgram = E;
        } }), zV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/describeFilePath.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__importDefault || function(D) {
            return D && D.__esModule ? D : { default: D };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.describeFilePath = void 0;
          var v2 = _(_o());
          function h(D, P) {
            let y = v2.default.relative(P, D);
            return y && !y.startsWith("..") && !v2.default.isAbsolute(y) ? `<tsconfigRootDir>/${y}` : /^[(\w+:)\\/~]/.test(D) || /\.\.[/\\]\.\./.test(y) ? D : `<tsconfigRootDir>/${y}`;
          }
          a.describeFilePath = h;
        } }), u5 = {};
        m1(u5, { default: () => p5 });
        var p5, WV = yp({ "node-modules-polyfills:fs"() {
          De3(), p5 = {};
        } }), yT = Oe2({ "node-modules-polyfills-commonjs:fs"(a, _) {
          De3();
          var v2 = (WV(), Li(u5));
          if (v2 && v2.default) {
            _.exports = v2.default;
            for (let h in v2)
              _.exports[h] = v2[h];
          } else
            v2 && (_.exports = v2);
        } }), f5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/getWatchProgramsForProjects.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(Je2, Xe2, ee2, je2) {
            je2 === void 0 && (je2 = ee2);
            var nt = Object.getOwnPropertyDescriptor(Xe2, ee2);
            (!nt || ("get" in nt ? !Xe2.__esModule : nt.writable || nt.configurable)) && (nt = { enumerable: true, get: function() {
              return Xe2[ee2];
            } }), Object.defineProperty(Je2, je2, nt);
          } : function(Je2, Xe2, ee2, je2) {
            je2 === void 0 && (je2 = ee2), Je2[je2] = Xe2[ee2];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(Je2, Xe2) {
            Object.defineProperty(Je2, "default", { enumerable: true, value: Xe2 });
          } : function(Je2, Xe2) {
            Je2.default = Xe2;
          }), h = a && a.__importStar || function(Je2) {
            if (Je2 && Je2.__esModule)
              return Je2;
            var Xe2 = {};
            if (Je2 != null)
              for (var ee2 in Je2)
                ee2 !== "default" && Object.prototype.hasOwnProperty.call(Je2, ee2) && _(Xe2, Je2, ee2);
            return v2(Xe2, Je2), Xe2;
          }, D = a && a.__importDefault || function(Je2) {
            return Je2 && Je2.__esModule ? Je2 : { default: Je2 };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getWatchProgramsForProjects = a.clearWatchCaches = void 0;
          var P = D(Ga()), y = D(yT()), m = D(pT()), C2 = h(vr()), d2 = d_(), E = (0, P.default)("typescript-eslint:typescript-estree:createWatchProgram"), I = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), M = /* @__PURE__ */ new Map(), q2 = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), K = /* @__PURE__ */ new Map();
          function ce2() {
            I.clear(), c.clear(), M.clear(), K.clear(), q2.clear(), W.clear();
          }
          a.clearWatchCaches = ce2;
          function Ie2(Je2) {
            return (Xe2, ee2) => {
              let je2 = (0, d2.getCanonicalFileName)(Xe2), nt = (() => {
                let Ze2 = Je2.get(je2);
                return Ze2 || (Ze2 = /* @__PURE__ */ new Set(), Je2.set(je2, Ze2)), Ze2;
              })();
              return nt.add(ee2), { close: () => {
                nt.delete(ee2);
              } };
            };
          }
          var me2 = { code: "", filePath: "" };
          function Ae2(Je2) {
            throw new Error(C2.flattenDiagnosticMessageText(Je2.messageText, C2.sys.newLine));
          }
          function te2(Je2, Xe2, ee2) {
            let je2 = ee2.EXPERIMENTAL_useSourceOfProjectReferenceRedirect ? new Set(Xe2.getSourceFiles().map((nt) => (0, d2.getCanonicalFileName)(nt.fileName))) : new Set(Xe2.getRootFileNames().map((nt) => (0, d2.getCanonicalFileName)(nt)));
            return q2.set(Je2, je2), je2;
          }
          function he(Je2) {
            let Xe2 = (0, d2.getCanonicalFileName)(Je2.filePath), ee2 = [];
            me2.code = Je2.code, me2.filePath = Xe2;
            let je2 = c.get(Xe2), nt = (0, d2.createHash)(Je2.code);
            K.get(Xe2) !== nt && je2 && je2.size > 0 && je2.forEach((st2) => st2(Xe2, C2.FileWatcherEventKind.Changed));
            let Ze2 = new Set(Je2.projects);
            for (let [st2, tt] of I.entries()) {
              if (!Ze2.has(st2))
                continue;
              let ct = q2.get(st2), ne2 = null;
              if (ct || (ne2 = tt.getProgram().getProgram(), ct = te2(st2, ne2, Je2)), ct.has(Xe2))
                return E("Found existing program for file. %s", Xe2), ne2 = ne2 != null ? ne2 : tt.getProgram().getProgram(), ne2.getTypeChecker(), [ne2];
            }
            E("File did not belong to any existing programs, moving to create/update. %s", Xe2);
            for (let st2 of Je2.projects) {
              let tt = I.get(st2);
              if (tt) {
                let Fe2 = ke2(tt, Xe2, st2);
                if (!Fe2)
                  continue;
                if (Fe2.getTypeChecker(), te2(st2, Fe2, Je2).has(Xe2))
                  return E("Found updated program for file. %s", Xe2), [Fe2];
                ee2.push(Fe2);
                continue;
              }
              let ct = R(st2, Je2);
              I.set(st2, ct);
              let ne2 = ct.getProgram().getProgram();
              if (ne2.getTypeChecker(), te2(st2, ne2, Je2).has(Xe2))
                return E("Found program for file. %s", Xe2), [ne2];
              ee2.push(ne2);
            }
            return ee2;
          }
          a.getWatchProgramsForProjects = he;
          var Pe2 = m.default.satisfies(C2.version, ">=3.9.0-beta", { includePrerelease: true });
          function R(Je2, Xe2) {
            E("Creating watch program for %s.", Je2);
            let ee2 = C2.createWatchCompilerHost(Je2, (0, d2.createDefaultCompilerOptionsFromExtra)(Xe2), C2.sys, C2.createAbstractBuilder, Ae2, () => {
            });
            Xe2.moduleResolver && (ee2.resolveModuleNames = (0, d2.getModuleResolver)(Xe2.moduleResolver).resolveModuleNames);
            let je2 = ee2.readFile;
            ee2.readFile = (tt, ct) => {
              let ne2 = (0, d2.getCanonicalFileName)(tt), ge = ne2 === me2.filePath ? me2.code : je2(ne2, ct);
              return ge !== void 0 && K.set(ne2, (0, d2.createHash)(ge)), ge;
            }, ee2.onUnRecoverableConfigFileDiagnostic = Ae2, ee2.afterProgramCreate = (tt) => {
              let ct = tt.getConfigFileParsingDiagnostics().filter((ne2) => ne2.category === C2.DiagnosticCategory.Error && ne2.code !== 18003);
              ct.length > 0 && Ae2(ct[0]);
            }, ee2.watchFile = Ie2(c), ee2.watchDirectory = Ie2(M);
            let nt = ee2.onCachedDirectoryStructureHostCreate;
            ee2.onCachedDirectoryStructureHostCreate = (tt) => {
              let ct = tt.readDirectory;
              tt.readDirectory = (ne2, ge, Fe2, at3, Pt) => ct(ne2, ge ? ge.concat(Xe2.extraFileExtensions) : void 0, Fe2, at3, Pt), nt(tt);
            }, ee2.extraFileExtensions = Xe2.extraFileExtensions.map((tt) => ({ extension: tt, isMixedContent: true, scriptKind: C2.ScriptKind.Deferred })), ee2.trace = E, ee2.useSourceOfProjectReferenceRedirect = () => Xe2.EXPERIMENTAL_useSourceOfProjectReferenceRedirect;
            let Ze2;
            Pe2 ? (ee2.setTimeout = void 0, ee2.clearTimeout = void 0) : (E("Running without timeout fix"), ee2.setTimeout = function(tt, ct) {
              for (var ne2 = arguments.length, ge = new Array(ne2 > 2 ? ne2 - 2 : 0), Fe2 = 2; Fe2 < ne2; Fe2++)
                ge[Fe2 - 2] = arguments[Fe2];
              return Ze2 = tt.bind(void 0, ...ge), Ze2;
            }, ee2.clearTimeout = () => {
              Ze2 = void 0;
            });
            let st2 = C2.createWatchProgram(ee2);
            if (!Pe2) {
              let tt = st2.getProgram;
              st2.getProgram = () => (Ze2 && Ze2(), Ze2 = void 0, tt.call(st2));
            }
            return st2;
          }
          function pe2(Je2) {
            let ee2 = y.default.statSync(Je2).mtimeMs, je2 = W.get(Je2);
            return W.set(Je2, ee2), je2 === void 0 ? false : Math.abs(je2 - ee2) > Number.EPSILON;
          }
          function ke2(Je2, Xe2, ee2) {
            let je2 = Je2.getProgram().getProgram();
            if (cn.env.TSESTREE_NO_INVALIDATION === "true")
              return je2;
            pe2(ee2) && (E("tsconfig has changed - triggering program update. %s", ee2), c.get(ee2).forEach((at3) => at3(ee2, C2.FileWatcherEventKind.Changed)), q2.delete(ee2));
            let nt = je2.getSourceFile(Xe2);
            if (nt)
              return je2;
            E("File was not found in program - triggering folder update. %s", Xe2);
            let Ze2 = (0, d2.canonicalDirname)(Xe2), st2 = null, tt = Ze2, ct = false;
            for (; st2 !== tt; ) {
              st2 = tt;
              let at3 = M.get(st2);
              at3 && (at3.forEach((Pt) => {
                Ze2 !== st2 && Pt(Ze2, C2.FileWatcherEventKind.Changed), Pt(st2, C2.FileWatcherEventKind.Changed);
              }), ct = true), tt = (0, d2.canonicalDirname)(st2);
            }
            if (!ct)
              return E("No callback found for file, not part of this program. %s", Xe2), null;
            if (q2.delete(ee2), je2 = Je2.getProgram().getProgram(), nt = je2.getSourceFile(Xe2), nt)
              return je2;
            E("File was still not found in program after directory update - checking file deletions. %s", Xe2);
            let ge = je2.getRootFileNames().find((at3) => !y.default.existsSync(at3));
            if (!ge)
              return null;
            let Fe2 = c.get((0, d2.getCanonicalFileName)(ge));
            return Fe2 ? (E("Marking file as deleted. %s", ge), Fe2.forEach((at3) => at3(ge, C2.FileWatcherEventKind.Deleted)), q2.delete(ee2), je2 = Je2.getProgram().getProgram(), nt = je2.getSourceFile(Xe2), nt ? je2 : (E("File was still not found in program after deletion check, assuming it is not part of this program. %s", Xe2), null)) : (E("Could not find watch callbacks for root file. %s", ge), je2);
          }
        } }), VV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createProjectProgram.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(W, K, ce2, Ie2) {
            Ie2 === void 0 && (Ie2 = ce2);
            var me2 = Object.getOwnPropertyDescriptor(K, ce2);
            (!me2 || ("get" in me2 ? !K.__esModule : me2.writable || me2.configurable)) && (me2 = { enumerable: true, get: function() {
              return K[ce2];
            } }), Object.defineProperty(W, Ie2, me2);
          } : function(W, K, ce2, Ie2) {
            Ie2 === void 0 && (Ie2 = ce2), W[Ie2] = K[ce2];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(W, K) {
            Object.defineProperty(W, "default", { enumerable: true, value: K });
          } : function(W, K) {
            W.default = K;
          }), h = a && a.__importStar || function(W) {
            if (W && W.__esModule)
              return W;
            var K = {};
            if (W != null)
              for (var ce2 in W)
                ce2 !== "default" && Object.prototype.hasOwnProperty.call(W, ce2) && _(K, W, ce2);
            return v2(K, W), K;
          }, D = a && a.__importDefault || function(W) {
            return W && W.__esModule ? W : { default: W };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createProjectProgram = void 0;
          var P = D(Ga()), y = D(_o()), m = h(vr()), C2 = E1(), d2 = zV(), E = f5(), I = d_(), c = (0, P.default)("typescript-eslint:typescript-estree:createProjectProgram"), M = [m.Extension.Ts, m.Extension.Tsx, m.Extension.Js, m.Extension.Jsx, m.Extension.Mjs, m.Extension.Mts, m.Extension.Cjs, m.Extension.Cts];
          function q2(W) {
            c("Creating project program for: %s", W.filePath);
            let K = (0, E.getWatchProgramsForProjects)(W), ce2 = (0, C2.firstDefined)(K, (ke2) => (0, I.getAstFromProgram)(ke2, W));
            if (ce2 || W.createDefaultProgram)
              return ce2;
            let Ie2 = (ke2) => (0, d2.describeFilePath)(ke2, W.tsconfigRootDir), me2 = (0, d2.describeFilePath)(W.filePath, W.tsconfigRootDir), Ae2 = W.projects.map(Ie2), te2 = Ae2.length === 1 ? Ae2[0] : `
${Ae2.map((ke2) => `- ${ke2}`).join(`
`)}`, he = [`ESLint was configured to run on \`${me2}\` using \`parserOptions.project\`: ${te2}`], Pe2 = false, R = W.extraFileExtensions || [];
            R.forEach((ke2) => {
              ke2.startsWith(".") || he.push(`Found unexpected extension \`${ke2}\` specified with the \`parserOptions.extraFileExtensions\` option. Did you mean \`.${ke2}\`?`), M.includes(ke2) && he.push(`You unnecessarily included the extension \`${ke2}\` with the \`parserOptions.extraFileExtensions\` option. This extension is already handled by the parser by default.`);
            });
            let pe2 = y.default.extname(W.filePath);
            if (!M.includes(pe2)) {
              let ke2 = `The extension for the file (\`${pe2}\`) is non-standard`;
              R.length > 0 ? R.includes(pe2) || (he.push(`${ke2}. It should be added to your existing \`parserOptions.extraFileExtensions\`.`), Pe2 = true) : (he.push(`${ke2}. You should add \`parserOptions.extraFileExtensions\` to your config.`), Pe2 = true);
            }
            if (!Pe2) {
              let [ke2, Je2] = W.projects.length === 1 ? ["that TSConfig does not", "that TSConfig"] : ["none of those TSConfigs", "one of those TSConfigs"];
              he.push(`However, ${ke2} include this file. Either:`, "- Change ESLint's list of included files to not include this file", `- Change ${Je2} to include this file`, "- Create a new TSConfig that includes this file and include it in your parserOptions.project", "See the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file");
            }
            throw new Error(he.join(`
`));
          }
          a.createProjectProgram = q2;
        } }), HV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createSourceFile.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(E, I, c, M) {
            M === void 0 && (M = c);
            var q2 = Object.getOwnPropertyDescriptor(I, c);
            (!q2 || ("get" in q2 ? !I.__esModule : q2.writable || q2.configurable)) && (q2 = { enumerable: true, get: function() {
              return I[c];
            } }), Object.defineProperty(E, M, q2);
          } : function(E, I, c, M) {
            M === void 0 && (M = c), E[M] = I[c];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(E, I) {
            Object.defineProperty(E, "default", { enumerable: true, value: I });
          } : function(E, I) {
            E.default = I;
          }), h = a && a.__importStar || function(E) {
            if (E && E.__esModule)
              return E;
            var I = {};
            if (E != null)
              for (var c in E)
                c !== "default" && Object.prototype.hasOwnProperty.call(E, c) && _(I, E, c);
            return v2(I, E), I;
          }, D = a && a.__importDefault || function(E) {
            return E && E.__esModule ? E : { default: E };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createSourceFile = void 0;
          var P = D(Ga()), y = h(vr()), m = gT(), C2 = (0, P.default)("typescript-eslint:typescript-estree:createSourceFile");
          function d2(E) {
            return C2("Getting AST without type information in %s mode for: %s", E.jsx ? "TSX" : "TS", E.filePath), y.createSourceFile(E.filePath, E.code, y.ScriptTarget.Latest, true, (0, m.getScriptKind)(E.filePath, E.jsx));
          }
          a.createSourceFile = d2;
        } }), d5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/useProvidedPrograms.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(q2, W, K, ce2) {
            ce2 === void 0 && (ce2 = K);
            var Ie2 = Object.getOwnPropertyDescriptor(W, K);
            (!Ie2 || ("get" in Ie2 ? !W.__esModule : Ie2.writable || Ie2.configurable)) && (Ie2 = { enumerable: true, get: function() {
              return W[K];
            } }), Object.defineProperty(q2, ce2, Ie2);
          } : function(q2, W, K, ce2) {
            ce2 === void 0 && (ce2 = K), q2[ce2] = W[K];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(q2, W) {
            Object.defineProperty(q2, "default", { enumerable: true, value: W });
          } : function(q2, W) {
            q2.default = W;
          }), h = a && a.__importStar || function(q2) {
            if (q2 && q2.__esModule)
              return q2;
            var W = {};
            if (q2 != null)
              for (var K in q2)
                K !== "default" && Object.prototype.hasOwnProperty.call(q2, K) && _(W, q2, K);
            return v2(W, q2), W;
          }, D = a && a.__importDefault || function(q2) {
            return q2 && q2.__esModule ? q2 : { default: q2 };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createProgramFromConfigFile = a.useProvidedPrograms = void 0;
          var P = D(Ga()), y = h(yT()), m = h(_o()), C2 = h(vr()), d2 = d_(), E = (0, P.default)("typescript-eslint:typescript-estree:useProvidedProgram");
          function I(q2, W) {
            E("Retrieving ast for %s from provided program instance(s)", W.filePath);
            let K;
            for (let ce2 of q2)
              if (K = (0, d2.getAstFromProgram)(ce2, W), K)
                break;
            if (!K) {
              let Ie2 = ['"parserOptions.programs" has been provided for @typescript-eslint/parser.', `The file was not found in any of the provided program instance(s): ${m.relative(W.tsconfigRootDir || "/prettier-security-dirname-placeholder", W.filePath)}`];
              throw new Error(Ie2.join(`
`));
            }
            return K.program.getTypeChecker(), K;
          }
          a.useProvidedPrograms = I;
          function c(q2, W) {
            if (C2.sys === void 0)
              throw new Error("`createProgramFromConfigFile` is only supported in a Node-like environment.");
            let ce2 = C2.getParsedCommandLineOfConfigFile(q2, d2.CORE_COMPILER_OPTIONS, { onUnRecoverableConfigFileDiagnostic: (me2) => {
              throw new Error(M([me2]));
            }, fileExists: y.existsSync, getCurrentDirectory: () => W && m.resolve(W) || "/prettier-security-dirname-placeholder", readDirectory: C2.sys.readDirectory, readFile: (me2) => y.readFileSync(me2, "utf-8"), useCaseSensitiveFileNames: C2.sys.useCaseSensitiveFileNames });
            if (ce2.errors.length)
              throw new Error(M(ce2.errors));
            let Ie2 = C2.createCompilerHost(ce2.options, true);
            return C2.createProgram(ce2.fileNames, ce2.options, Ie2);
          }
          a.createProgramFromConfigFile = c;
          function M(q2) {
            return C2.formatDiagnostics(q2, { getCanonicalFileName: (W) => W, getCurrentDirectory: cn.cwd, getNewLine: () => `
` });
          }
        } }), m5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/ExpiringCache.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__classPrivateFieldSet || function(m, C2, d2, E, I) {
            if (E === "m")
              throw new TypeError("Private method is not writable");
            if (E === "a" && !I)
              throw new TypeError("Private accessor was defined without a setter");
            if (typeof C2 == "function" ? m !== C2 || !I : !C2.has(m))
              throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return E === "a" ? I.call(m, d2) : I ? I.value = d2 : C2.set(m, d2), d2;
          }, v2 = a && a.__classPrivateFieldGet || function(m, C2, d2, E) {
            if (d2 === "a" && !E)
              throw new TypeError("Private accessor was defined without a getter");
            if (typeof C2 == "function" ? m !== C2 || !E : !C2.has(m))
              throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return d2 === "m" ? E : d2 === "a" ? E.call(m) : E ? E.value : C2.get(m);
          }, h, D;
          Object.defineProperty(a, "__esModule", { value: true }), a.ExpiringCache = a.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS = void 0, a.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS = 30;
          var P = [0, 0], y = class {
            constructor(m) {
              h.set(this, void 0), D.set(this, /* @__PURE__ */ new Map()), _(this, h, m, "f");
            }
            set(m, C2) {
              return v2(this, D, "f").set(m, { value: C2, lastSeen: v2(this, h, "f") === "Infinity" ? P : cn.hrtime() }), this;
            }
            get(m) {
              let C2 = v2(this, D, "f").get(m);
              if ((C2 == null ? void 0 : C2.value) != null) {
                if (v2(this, h, "f") === "Infinity" || cn.hrtime(C2.lastSeen)[0] < v2(this, h, "f"))
                  return C2.value;
                v2(this, D, "f").delete(m);
              }
            }
            clear() {
              v2(this, D, "f").clear();
            }
          };
          a.ExpiringCache = y, h = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
        } }), GV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/getProjectConfigFiles.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(E, I, c, M) {
            M === void 0 && (M = c);
            var q2 = Object.getOwnPropertyDescriptor(I, c);
            (!q2 || ("get" in q2 ? !I.__esModule : q2.writable || q2.configurable)) && (q2 = { enumerable: true, get: function() {
              return I[c];
            } }), Object.defineProperty(E, M, q2);
          } : function(E, I, c, M) {
            M === void 0 && (M = c), E[M] = I[c];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(E, I) {
            Object.defineProperty(E, "default", { enumerable: true, value: I });
          } : function(E, I) {
            E.default = I;
          }), h = a && a.__importStar || function(E) {
            if (E && E.__esModule)
              return E;
            var I = {};
            if (E != null)
              for (var c in E)
                c !== "default" && Object.prototype.hasOwnProperty.call(E, c) && _(I, E, c);
            return v2(I, E), I;
          }, D = a && a.__importDefault || function(E) {
            return E && E.__esModule ? E : { default: E };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getProjectConfigFiles = void 0;
          var P = D(Ga()), y = h(yT()), m = h(_o()), C2 = (0, P.default)("typescript-eslint:typescript-estree:getProjectConfigFiles");
          function d2(E, I) {
            var c;
            if (I !== true)
              return I === void 0 || Array.isArray(I) ? I : [I];
            C2("Looking for tsconfig.json at or above file: %s", E.filePath);
            let M = m.dirname(E.filePath), q2 = [M];
            do {
              C2("Checking tsconfig.json path: %s", M);
              let W = m.join(M, "tsconfig.json"), K = (c = E.tsconfigMatchCache.get(M)) !== null && c !== void 0 ? c : y.existsSync(W) && W;
              if (K) {
                for (let ce2 of q2)
                  E.tsconfigMatchCache.set(ce2, K);
                return [K];
              }
              M = m.dirname(M), q2.push(M);
            } while (M.length > 1 && M.length >= E.tsconfigRootDir.length);
            throw new Error(`project was set to \`true\` but couldn't find any tsconfig.json relative to '${E.filePath}' within '${E.tsconfigRootDir}'.`);
          }
          a.getProjectConfigFiles = d2;
        } }), $V = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/inferSingleRun.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.inferSingleRun = void 0;
          var _ = _o();
          function v2(h) {
            return (h == null ? void 0 : h.project) == null || (h == null ? void 0 : h.programs) != null || cn.env.TSESTREE_SINGLE_RUN === "false" ? false : !!(cn.env.TSESTREE_SINGLE_RUN === "true" || h != null && h.allowAutomaticSingleRunInference && (cn.env.CI === "true" || cn.argv[1].endsWith((0, _.normalize)("node_modules/.bin/eslint"))));
          }
          a.inferSingleRun = v2;
        } }), KV = Oe2({ "node_modules/is-extglob/index.js"(a, _) {
          De3(), _.exports = function(h) {
            if (typeof h != "string" || h === "")
              return false;
            for (var D; D = /(\\).|([@?!+*]\(.*\))/g.exec(h); ) {
              if (D[2])
                return true;
              h = h.slice(D.index + D[0].length);
            }
            return false;
          };
        } }), XV = Oe2({ "node_modules/is-glob/index.js"(a, _) {
          De3();
          var v2 = KV(), h = { "{": "}", "(": ")", "[": "]" }, D = function(y) {
            if (y[0] === "!")
              return true;
            for (var m = 0, C2 = -2, d2 = -2, E = -2, I = -2, c = -2; m < y.length; ) {
              if (y[m] === "*" || y[m + 1] === "?" && /[\].+)]/.test(y[m]) || d2 !== -1 && y[m] === "[" && y[m + 1] !== "]" && (d2 < m && (d2 = y.indexOf("]", m)), d2 > m && (c === -1 || c > d2 || (c = y.indexOf("\\", m), c === -1 || c > d2))) || E !== -1 && y[m] === "{" && y[m + 1] !== "}" && (E = y.indexOf("}", m), E > m && (c = y.indexOf("\\", m), c === -1 || c > E)) || I !== -1 && y[m] === "(" && y[m + 1] === "?" && /[:!=]/.test(y[m + 2]) && y[m + 3] !== ")" && (I = y.indexOf(")", m), I > m && (c = y.indexOf("\\", m), c === -1 || c > I)) || C2 !== -1 && y[m] === "(" && y[m + 1] !== "|" && (C2 < m && (C2 = y.indexOf("|", m)), C2 !== -1 && y[C2 + 1] !== ")" && (I = y.indexOf(")", C2), I > C2 && (c = y.indexOf("\\", C2), c === -1 || c > I))))
                return true;
              if (y[m] === "\\") {
                var M = y[m + 1];
                m += 2;
                var q2 = h[M];
                if (q2) {
                  var W = y.indexOf(q2, m);
                  W !== -1 && (m = W + 1);
                }
                if (y[m] === "!")
                  return true;
              } else
                m++;
            }
            return false;
          }, P = function(y) {
            if (y[0] === "!")
              return true;
            for (var m = 0; m < y.length; ) {
              if (/[*?{}()[\]]/.test(y[m]))
                return true;
              if (y[m] === "\\") {
                var C2 = y[m + 1];
                m += 2;
                var d2 = h[C2];
                if (d2) {
                  var E = y.indexOf(d2, m);
                  E !== -1 && (m = E + 1);
                }
                if (y[m] === "!")
                  return true;
              } else
                m++;
            }
            return false;
          };
          _.exports = function(m, C2) {
            if (typeof m != "string" || m === "")
              return false;
            if (v2(m))
              return true;
            var d2 = D;
            return C2 && C2.strict === false && (d2 = P), d2(m);
          };
        } }), h5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/resolveProjectList.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__importDefault || function(M) {
            return M && M.__esModule ? M : { default: M };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.clearGlobResolutionCache = a.resolveProjectList = a.clearGlobCache = void 0;
          var v2 = _(Ga()), h = {}, D = _(XV()), P = d_(), y = m5(), m = (0, v2.default)("typescript-eslint:typescript-estree:parser:parseSettings:resolveProjectList"), C2 = null;
          function d2() {
            C2 == null || C2.clear();
          }
          a.clearGlobCache = d2;
          function E(M) {
            var q2, W, K;
            let ce2 = [];
            if (typeof M.project == "string")
              ce2.push(M.project);
            else if (Array.isArray(M.project))
              for (let R of M.project)
                typeof R == "string" && ce2.push(R);
            if (ce2.length === 0)
              return [];
            let Ie2 = ((q2 = M.projectFolderIgnoreList) !== null && q2 !== void 0 ? q2 : ["**/node_modules/**"]).reduce((R, pe2) => (typeof pe2 == "string" && R.push(pe2), R), []).map((R) => R.startsWith("!") ? R : `!${R}`), me2 = I({ project: ce2, projectFolderIgnoreList: Ie2, tsconfigRootDir: M.tsconfigRootDir });
            if (C2 == null)
              C2 = new y.ExpiringCache(M.singleRun ? "Infinity" : (K = (W = M.cacheLifetime) === null || W === void 0 ? void 0 : W.glob) !== null && K !== void 0 ? K : y.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS);
            else {
              let R = C2.get(me2);
              if (R)
                return R;
            }
            let Ae2 = ce2.filter((R) => !(0, D.default)(R)), te2 = ce2.filter((R) => (0, D.default)(R)), he = new Set(Ae2.concat(te2.length === 0 ? [] : (0, h.sync)([...te2, ...Ie2], { cwd: M.tsconfigRootDir })).map((R) => (0, P.getCanonicalFileName)((0, P.ensureAbsolutePath)(R, M.tsconfigRootDir))));
            m("parserOptions.project (excluding ignored) matched projects: %s", he);
            let Pe2 = Array.from(he);
            return C2.set(me2, Pe2), Pe2;
          }
          a.resolveProjectList = E;
          function I(M) {
            let { project: q2, projectFolderIgnoreList: W, tsconfigRootDir: K } = M, ce2 = { tsconfigRootDir: K, project: q2, projectFolderIgnoreList: [...W].sort() };
            return (0, P.createHash)(JSON.stringify(ce2));
          }
          function c() {
            C2 == null || C2.clear(), C2 = null;
          }
          a.clearGlobResolutionCache = c;
        } }), YV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/warnAboutTSVersion.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(M, q2, W, K) {
            K === void 0 && (K = W);
            var ce2 = Object.getOwnPropertyDescriptor(q2, W);
            (!ce2 || ("get" in ce2 ? !q2.__esModule : ce2.writable || ce2.configurable)) && (ce2 = { enumerable: true, get: function() {
              return q2[W];
            } }), Object.defineProperty(M, K, ce2);
          } : function(M, q2, W, K) {
            K === void 0 && (K = W), M[K] = q2[W];
          }), v2 = a && a.__setModuleDefault || (Object.create ? function(M, q2) {
            Object.defineProperty(M, "default", { enumerable: true, value: q2 });
          } : function(M, q2) {
            M.default = q2;
          }), h = a && a.__importStar || function(M) {
            if (M && M.__esModule)
              return M;
            var q2 = {};
            if (M != null)
              for (var W in M)
                W !== "default" && Object.prototype.hasOwnProperty.call(M, W) && _(q2, M, W);
            return v2(q2, M), q2;
          }, D = a && a.__importDefault || function(M) {
            return M && M.__esModule ? M : { default: M };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.warnAboutTSVersion = void 0;
          var P = D(pT()), y = h(vr()), m = ">=3.3.1 <5.1.0", C2 = ["5.0.1-rc"], d2 = y.version, E = P.default.satisfies(d2, [m].concat(C2).join(" || ")), I = false;
          function c(M) {
            var q2;
            if (!E && !I) {
              if (typeof cn > "u" ? false : (q2 = cn.stdout) === null || q2 === void 0 ? void 0 : q2.isTTY) {
                let K = "=============", ce2 = [K, "WARNING: You are currently running a version of TypeScript which is not officially supported by @typescript-eslint/typescript-estree.", "You may find that it works just fine, or you may not.", `SUPPORTED TYPESCRIPT VERSIONS: ${m}`, `YOUR TYPESCRIPT VERSION: ${d2}`, "Please only submit bug reports when using the officially supported version.", K];
                M.log(ce2.join(`

`));
              }
              I = true;
            }
          }
          a.warnAboutTSVersion = c;
        } }), g5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/createParseSettings.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__importDefault || function(W) {
            return W && W.__esModule ? W : { default: W };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.clearTSConfigMatchCache = a.createParseSettings = void 0;
          var v2 = _(Ga()), h = d_(), D = m5(), P = GV(), y = $V(), m = h5(), C2 = YV(), d2 = (0, v2.default)("typescript-eslint:typescript-estree:parser:parseSettings:createParseSettings"), E;
          function I(W) {
            let K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var ce2, Ie2, me2;
            let Ae2 = (0, y.inferSingleRun)(K), te2 = typeof K.tsconfigRootDir == "string" ? K.tsconfigRootDir : "/prettier-security-dirname-placeholder", he = { code: M(W), comment: K.comment === true, comments: [], createDefaultProgram: K.createDefaultProgram === true, debugLevel: K.debugLevel === true ? /* @__PURE__ */ new Set(["typescript-eslint"]) : Array.isArray(K.debugLevel) ? new Set(K.debugLevel) : /* @__PURE__ */ new Set(), errorOnTypeScriptSyntacticAndSemanticIssues: false, errorOnUnknownASTType: K.errorOnUnknownASTType === true, EXPERIMENTAL_useSourceOfProjectReferenceRedirect: K.EXPERIMENTAL_useSourceOfProjectReferenceRedirect === true, extraFileExtensions: Array.isArray(K.extraFileExtensions) && K.extraFileExtensions.every((Pe2) => typeof Pe2 == "string") ? K.extraFileExtensions : [], filePath: (0, h.ensureAbsolutePath)(typeof K.filePath == "string" && K.filePath !== "<input>" ? K.filePath : q2(K.jsx), te2), jsx: K.jsx === true, loc: K.loc === true, log: typeof K.loggerFn == "function" ? K.loggerFn : K.loggerFn === false ? () => {
            } : console.log, moduleResolver: (ce2 = K.moduleResolver) !== null && ce2 !== void 0 ? ce2 : "", preserveNodeMaps: K.preserveNodeMaps !== false, programs: Array.isArray(K.programs) ? K.programs : null, projects: [], range: K.range === true, singleRun: Ae2, tokens: K.tokens === true ? [] : null, tsconfigMatchCache: E != null ? E : E = new D.ExpiringCache(Ae2 ? "Infinity" : (me2 = (Ie2 = K.cacheLifetime) === null || Ie2 === void 0 ? void 0 : Ie2.glob) !== null && me2 !== void 0 ? me2 : D.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS), tsconfigRootDir: te2 };
            if (he.debugLevel.size > 0) {
              let Pe2 = [];
              he.debugLevel.has("typescript-eslint") && Pe2.push("typescript-eslint:*"), (he.debugLevel.has("eslint") || v2.default.enabled("eslint:*,-eslint:code-path")) && Pe2.push("eslint:*,-eslint:code-path"), v2.default.enable(Pe2.join(","));
            }
            if (Array.isArray(K.programs)) {
              if (!K.programs.length)
                throw new Error("You have set parserOptions.programs to an empty array. This will cause all files to not be found in existing programs. Either provide one or more existing TypeScript Program instances in the array, or remove the parserOptions.programs setting.");
              d2("parserOptions.programs was provided, so parserOptions.project will be ignored.");
            }
            return he.programs || (he.projects = (0, m.resolveProjectList)({ cacheLifetime: K.cacheLifetime, project: (0, P.getProjectConfigFiles)(he, K.project), projectFolderIgnoreList: K.projectFolderIgnoreList, singleRun: he.singleRun, tsconfigRootDir: te2 })), (0, C2.warnAboutTSVersion)(he), he;
          }
          a.createParseSettings = I;
          function c() {
            E == null || E.clear();
          }
          a.clearTSConfigMatchCache = c;
          function M(W) {
            return typeof W != "string" ? String(W) : W;
          }
          function q2(W) {
            return W ? "estree.tsx" : "estree.ts";
          }
        } }), QV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/semantic-or-syntactic-errors.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.getFirstSemanticOrSyntacticError = void 0;
          var _ = vr();
          function v2(P, y) {
            try {
              let m = h(P.getSyntacticDiagnostics(y));
              if (m.length)
                return D(m[0]);
              let C2 = h(P.getSemanticDiagnostics(y));
              return C2.length ? D(C2[0]) : void 0;
            } catch (m) {
              console.warn(`Warning From TSC: "${m.message}`);
              return;
            }
          }
          a.getFirstSemanticOrSyntacticError = v2;
          function h(P) {
            return P.filter((y) => {
              switch (y.code) {
                case 1013:
                case 1014:
                case 1044:
                case 1045:
                case 1048:
                case 1049:
                case 1070:
                case 1071:
                case 1085:
                case 1090:
                case 1096:
                case 1097:
                case 1098:
                case 1099:
                case 1117:
                case 1121:
                case 1123:
                case 1141:
                case 1162:
                case 1164:
                case 1172:
                case 1173:
                case 1175:
                case 1176:
                case 1190:
                case 1196:
                case 1200:
                case 1206:
                case 1211:
                case 1242:
                case 1246:
                case 1255:
                case 1308:
                case 2364:
                case 2369:
                case 2452:
                case 2462:
                case 8017:
                case 17012:
                case 17013:
                  return true;
              }
              return false;
            });
          }
          function D(P) {
            return Object.assign(Object.assign({}, P), { message: (0, _.flattenDiagnosticMessageText)(P.messageText, _.sys.newLine) });
          }
        } }), y5 = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/parser.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__importDefault || function(he) {
            return he && he.__esModule ? he : { default: he };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.clearParseAndGenerateServicesCalls = a.clearProgramCache = a.parseWithNodeMaps = a.parseAndGenerateServices = a.parse = void 0;
          var v2 = _(Ga()), h = FV(), D = G9(), P = qV(), y = UV(), m = VV(), C2 = HV(), d2 = d5(), E = g5(), I = QV(), c = (0, v2.default)("typescript-eslint:typescript-estree:parser"), M = /* @__PURE__ */ new Map();
          function q2() {
            M.clear();
          }
          a.clearProgramCache = q2;
          function W(he, Pe2) {
            return he.programs && (0, d2.useProvidedPrograms)(he.programs, he) || Pe2 && (0, m.createProjectProgram)(he) || Pe2 && he.createDefaultProgram && (0, P.createDefaultProgram)(he) || (0, y.createIsolatedProgram)(he);
          }
          function K(he, Pe2) {
            let { ast: R } = ce2(he, Pe2, false);
            return R;
          }
          a.parse = K;
          function ce2(he, Pe2, R) {
            let pe2 = (0, E.createParseSettings)(he, Pe2);
            if (Pe2 != null && Pe2.errorOnTypeScriptSyntacticAndSemanticIssues)
              throw new Error('"errorOnTypeScriptSyntacticAndSemanticIssues" is only supported for parseAndGenerateServices()');
            let ke2 = (0, C2.createSourceFile)(pe2), { estree: Je2, astMaps: Xe2 } = (0, h.astConverter)(ke2, pe2, R);
            return { ast: Je2, esTreeNodeToTSNodeMap: Xe2.esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap: Xe2.tsNodeToESTreeNodeMap };
          }
          function Ie2(he, Pe2) {
            return ce2(he, Pe2, true);
          }
          a.parseWithNodeMaps = Ie2;
          var me2 = {};
          function Ae2() {
            me2 = {};
          }
          a.clearParseAndGenerateServicesCalls = Ae2;
          function te2(he, Pe2) {
            var R, pe2;
            let ke2 = (0, E.createParseSettings)(he, Pe2);
            Pe2 !== void 0 && typeof Pe2.errorOnTypeScriptSyntacticAndSemanticIssues == "boolean" && Pe2.errorOnTypeScriptSyntacticAndSemanticIssues && (ke2.errorOnTypeScriptSyntacticAndSemanticIssues = true), ke2.singleRun && !ke2.programs && ((R = ke2.projects) === null || R === void 0 ? void 0 : R.length) > 0 && (ke2.programs = { *[Symbol.iterator]() {
              for (let st2 of ke2.projects) {
                let tt = M.get(st2);
                if (tt)
                  yield tt;
                else {
                  c("Detected single-run/CLI usage, creating Program once ahead of time for project: %s", st2);
                  let ct = (0, d2.createProgramFromConfigFile)(st2);
                  M.set(st2, ct), yield ct;
                }
              }
            } });
            let Je2 = ke2.programs != null || ((pe2 = ke2.projects) === null || pe2 === void 0 ? void 0 : pe2.length) > 0;
            ke2.singleRun && Pe2.filePath && (me2[Pe2.filePath] = (me2[Pe2.filePath] || 0) + 1);
            let { ast: Xe2, program: ee2 } = ke2.singleRun && Pe2.filePath && me2[Pe2.filePath] > 1 ? (0, y.createIsolatedProgram)(ke2) : W(ke2, Je2), je2 = typeof ke2.preserveNodeMaps == "boolean" ? ke2.preserveNodeMaps : true, { estree: nt, astMaps: Ze2 } = (0, h.astConverter)(Xe2, ke2, je2);
            if (ee2 && ke2.errorOnTypeScriptSyntacticAndSemanticIssues) {
              let st2 = (0, I.getFirstSemanticOrSyntacticError)(ee2, Xe2);
              if (st2)
                throw (0, D.convertError)(st2);
            }
            return { ast: nt, services: { hasFullTypeInformation: Je2, program: ee2, esTreeNodeToTSNodeMap: Ze2.esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap: Ze2.tsNodeToESTreeNodeMap } };
          }
          a.parseAndGenerateServices = te2;
        } }), ZV = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/clear-caches.js"(a) {
          "use strict";
          De3(), Object.defineProperty(a, "__esModule", { value: true }), a.clearProgramCache = a.clearCaches = void 0;
          var _ = f5(), v2 = y5(), h = g5(), D = h5();
          function P() {
            (0, v2.clearProgramCache)(), (0, _.clearWatchCaches)(), (0, h.clearTSConfigMatchCache)(), (0, D.clearGlobCache)();
          }
          a.clearCaches = P, a.clearProgramCache = P;
        } }), eH = Oe2({ "node_modules/@typescript-eslint/typescript-estree/package.json"(a, _) {
          _.exports = { name: "@typescript-eslint/typescript-estree", version: "5.55.0", description: "A parser that converts TypeScript source code into an ESTree compatible form", main: "dist/index.js", types: "dist/index.d.ts", files: ["dist", "_ts3.4", "README.md", "LICENSE"], engines: { node: "^12.22.0 || ^14.17.0 || >=16.0.0" }, repository: { type: "git", url: "https://github.com/typescript-eslint/typescript-eslint.git", directory: "packages/typescript-estree" }, bugs: { url: "https://github.com/typescript-eslint/typescript-eslint/issues" }, license: "BSD-2-Clause", keywords: ["ast", "estree", "ecmascript", "javascript", "typescript", "parser", "syntax"], scripts: { build: "tsc -b tsconfig.build.json", postbuild: "downlevel-dts dist _ts3.4/dist", clean: "tsc -b tsconfig.build.json --clean", postclean: "rimraf dist && rimraf _ts3.4 && rimraf coverage", format: 'prettier --write "./**/*.{ts,mts,cts,tsx,js,mjs,cjs,jsx,json,md,css}" --ignore-path ../../.prettierignore', lint: "nx lint", test: "jest --coverage", typecheck: "tsc -p tsconfig.json --noEmit" }, dependencies: { "@typescript-eslint/types": "5.55.0", "@typescript-eslint/visitor-keys": "5.55.0", debug: "^4.3.4", globby: "^11.1.0", "is-glob": "^4.0.3", semver: "^7.3.7", tsutils: "^3.21.0" }, devDependencies: { "@babel/code-frame": "*", "@babel/parser": "*", "@types/babel__code-frame": "*", "@types/debug": "*", "@types/glob": "*", "@types/is-glob": "*", "@types/semver": "*", "@types/tmp": "*", glob: "*", "jest-specific-snapshot": "*", "make-dir": "*", tmp: "*", typescript: "*" }, peerDependenciesMeta: { typescript: { optional: true } }, funding: { type: "opencollective", url: "https://opencollective.com/typescript-eslint" }, typesVersions: { "<3.8": { "*": ["_ts3.4/*"] } }, gitHead: "877d73327fca3bdbe7e170e8b3a906d090a6de37" };
        } }), tH = Oe2({ "node_modules/@typescript-eslint/typescript-estree/dist/index.js"(a) {
          "use strict";
          De3();
          var _ = a && a.__createBinding || (Object.create ? function(C2, d2, E, I) {
            I === void 0 && (I = E);
            var c = Object.getOwnPropertyDescriptor(d2, E);
            (!c || ("get" in c ? !d2.__esModule : c.writable || c.configurable)) && (c = { enumerable: true, get: function() {
              return d2[E];
            } }), Object.defineProperty(C2, I, c);
          } : function(C2, d2, E, I) {
            I === void 0 && (I = E), C2[I] = d2[E];
          }), v2 = a && a.__exportStar || function(C2, d2) {
            for (var E in C2)
              E !== "default" && !Object.prototype.hasOwnProperty.call(d2, E) && _(d2, C2, E);
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.version = a.visitorKeys = a.typescriptVersionIsAtLeast = a.createProgram = a.simpleTraverse = a.parseWithNodeMaps = a.parseAndGenerateServices = a.parse = void 0;
          var h = y5();
          Object.defineProperty(a, "parse", { enumerable: true, get: function() {
            return h.parse;
          } }), Object.defineProperty(a, "parseAndGenerateServices", { enumerable: true, get: function() {
            return h.parseAndGenerateServices;
          } }), Object.defineProperty(a, "parseWithNodeMaps", { enumerable: true, get: function() {
            return h.parseWithNodeMaps;
          } });
          var D = t5();
          Object.defineProperty(a, "simpleTraverse", { enumerable: true, get: function() {
            return D.simpleTraverse;
          } }), v2(x1(), a);
          var P = d5();
          Object.defineProperty(a, "createProgram", { enumerable: true, get: function() {
            return P.createProgramFromConfigFile;
          } }), v2(gT(), a);
          var y = S1();
          Object.defineProperty(a, "typescriptVersionIsAtLeast", { enumerable: true, get: function() {
            return y.typescriptVersionIsAtLeast;
          } }), v2(fT(), a), v2(ZV(), a);
          var m = e5();
          Object.defineProperty(a, "visitorKeys", { enumerable: true, get: function() {
            return m.visitorKeys;
          } }), a.version = eH().version;
        } });
        De3();
        var rH = w9(), nH = pW(), iH = SW(), aH = xW(), sH = PW(), { throwErrorForInvalidNodes: oH } = DW(), E9 = { loc: true, range: true, comment: true, jsx: true, tokens: true, loggerFn: false, project: [] };
        function _H(a) {
          let { message: _, lineNumber: v2, column: h } = a;
          return typeof v2 != "number" ? a : rH(_, { start: { line: v2, column: h + 1 } });
        }
        function cH(a, _) {
          let v2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = aH(a), D = lH(a), { parseWithNodeMaps: P } = tH(), { result: y, error: m } = nH(() => P(h, Object.assign(Object.assign({}, E9), {}, { jsx: D })), () => P(h, Object.assign(Object.assign({}, E9), {}, { jsx: !D })));
          if (!y)
            throw _H(m);
          return v2.originalText = a, oH(y, v2), sH(y.ast, v2);
        }
        function lH(a) {
          return new RegExp(["(?:^[^\"'`]*</)", "|", "(?:^[^/]{2}.*/>)"].join(""), "m").test(a);
        }
        v5.exports = { parsers: { typescript: iH(cH) } };
      });
      return uH();
    });
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
    })(exports2, function(exports3) {
      "use strict";
      exports3.get = void 0;
      exports3.put = void 0;
      exports3.pop = void 0;
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      (() => {
        exports3.get = (strarr, key) => strarr._indexes[key];
        exports3.put = (strarr, key) => {
          const index = exports3.get(strarr, key);
          if (index !== void 0)
            return index;
          const { array: array2, _indexes: indexes } = strarr;
          return indexes[key] = array2.push(key) - 1;
        };
        exports3.pop = (strarr) => {
          const { array: array2, _indexes: indexes } = strarr;
          if (array2.length === 0)
            return;
          const last = array2.pop();
          indexes[last] = void 0;
        };
      })();
      exports3.SetArray = SetArray;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports2, function(exports3) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon2 = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i2 = 0; i2 < chars.length; i2++) {
        const c = chars.charCodeAt(i2);
        intToChar[i2] = c;
        charToInt[c] = i2;
      }
      const td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i2 = 0; i2 < buf.length; i2++) {
            out += String.fromCharCode(buf[i2]);
          }
          return out;
        }
      };
      function decode(mappings) {
        const state2 = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf2(mappings, index);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state2[0] = 0;
          for (let i2 = index; i2 < semi; i2++) {
            let seg;
            i2 = decodeInteger(mappings, i2, state2, 0);
            const col = state2[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i2, semi)) {
              i2 = decodeInteger(mappings, i2, state2, 1);
              i2 = decodeInteger(mappings, i2, state2, 2);
              i2 = decodeInteger(mappings, i2, state2, 3);
              if (hasMoreVlq(mappings, i2, semi)) {
                i2 = decodeInteger(mappings, i2, state2, 4);
                seg = [col, state2[1], state2[2], state2[3], state2[4]];
              } else {
                seg = [col, state2[1], state2[2], state2[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf2(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state2, j2) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = mappings.charCodeAt(pos++);
          integer = charToInt[c];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        state2[j2] += value;
        return pos;
      }
      function hasMoreVlq(mappings, i2, length) {
        if (i2 >= length)
          return false;
        return mappings.charCodeAt(i2) !== comma;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const state2 = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i2 = 0; i2 < decoded.length; i2++) {
          const line = decoded[i2];
          if (i2 > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon2;
          }
          if (line.length === 0)
            continue;
          state2[0] = 0;
          for (let j2 = 0; j2 < line.length; j2++) {
            const segment = line[j2];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j2 > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state2, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state2, segment, 1);
            pos = encodeInteger(buf, pos, state2, segment, 2);
            pos = encodeInteger(buf, pos, state2, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state2, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state2, segment, j2) {
        const next2 = segment[j2];
        let num = next2 - state2[j2];
        state2[j2] = next2;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports3.decode = decode;
      exports3.encode = encode;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input2) {
        return schemeRegex.test(input2);
      }
      function isSchemeRelativeUrl(input2) {
        return input2.startsWith("//");
      }
      function isAbsolutePath(input2) {
        return input2.startsWith("/");
      }
      function isFileUrl(input2) {
        return input2.startsWith("file:");
      }
      function isRelative(input2) {
        return /^[.?#]/.test(input2);
      }
      function parseAbsoluteUrl(input2) {
        const match2 = urlRegex.exec(input2);
        return makeUrl(match2[1], match2[2] || "", match2[3], match2[4] || "", match2[5] || "/", match2[6] || "", match2[7] || "");
      }
      function parseFileUrl(input2) {
        const match2 = fileRegex.exec(input2);
        const path = match2[2];
        return makeUrl("file:", "", match2[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match2[3] || "", match2[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input2) {
        if (isSchemeRelativeUrl(input2)) {
          const url2 = parseAbsoluteUrl("http:" + input2);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input2)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input2);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input2))
          return parseFileUrl(input2);
        if (isAbsoluteUrl(input2))
          return parseAbsoluteUrl(input2);
        const url = parseAbsoluteUrl("http://foo.com/" + input2);
        url.scheme = "";
        url.host = "";
        url.type = input2 ? input2.startsWith("?") ? UrlType.Query : input2.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i2 = 1; i2 < pieces.length; i2++) {
          const piece = pieces[i2];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i2 = 1; i2 < pointer; i2++) {
          path += "/" + pieces[i2];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input2, base) {
        if (!input2 && !base)
          return "";
        const url = parseUrl(input2);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            case UrlType.Hash:
              url.query = baseUrl.query;
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input2) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports2, function(exports3, sourcemapCodec, resolveUri) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var resolveUri__default = _interopDefaultLegacy(resolveUri);
      function resolve(input2, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri__default["default"](input2, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine(mappings, i2 + 1)) {
          mappings[i2] = sortSegments(mappings[i2], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i2 = start; i2 < mappings.length; i2++) {
          if (!isSorted(mappings[i2]))
            return i2;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j2 = 1; j2 < line.length; j2++) {
          if (line[j2][COLUMN] < line[j2 - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i2 = index + 1; i2 < haystack.length; index = i2++) {
          if (haystack[i2][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i2 = index - 1; i2 >= 0; index = i2--) {
          if (haystack[i2][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state2, key) {
        const { lastKey, lastNeedle, lastIndex } = state2;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state2.lastKey = key;
        state2.lastNeedle = needle;
        return state2.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i2 = 0; i2 < decoded.length; i2++) {
          const line = decoded[i2];
          for (let j2 = 0; j2 < line.length; j2++) {
            const seg = line[j2];
            if (seg.length === 1)
              continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo2 = memos[sourceIndex];
            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo2, sourceLine));
            insert(originalLine, memo2.lastIndex = index + 1, [sourceColumn, i2, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array2, index, value) {
        for (let i2 = array2.length; i2 > index; i2--) {
          array2[i2] = array2[i2 - 1];
        }
        array2[index] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map2, mapUrl) {
        const parsed = typeof map2 === "string" ? JSON.parse(map2) : map2;
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings
        };
        return exports3.presortedDecodedMap(joined);
      };
      function recurse(input2, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input2;
        for (let i2 = 0; i2 < sections.length; i2++) {
          const { map: map2, offset } = sections[i2];
          let sl = stopLine;
          let sc = stopColumn;
          if (i2 + 1 < sections.length) {
            const nextOffset = sections[i2 + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map2, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input2, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        if ("sections" in input2)
          return recurse(...arguments);
        const map2 = new TraceMap(input2, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = exports3.decodedMappings(map2);
        const { resolvedSources, sourcesContent: contents } = map2;
        append(sources, resolvedSources);
        append(names, map2.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i2 = 0; i2 < resolvedSources.length; i2++)
            sourcesContent.push(null);
        for (let i2 = 0; i2 < decoded.length; i2++) {
          const lineI = lineOffset + i2;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i2 === 0 ? columnOffset : 0;
          const line = decoded[i2];
          for (let j2 = 0; j2 < line.length; j2++) {
            const seg = line[j2];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i2 = 0; i2 < other.length; i2++)
          arr.push(other[i2]);
      }
      function getLine(arr, index) {
        for (let i2 = arr.length; i2 <= index; i2++)
          arr[i2] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      exports3.encodedMappings = void 0;
      exports3.decodedMappings = void 0;
      exports3.traceSegment = void 0;
      exports3.originalPositionFor = void 0;
      exports3.generatedPositionFor = void 0;
      exports3.allGeneratedPositionsFor = void 0;
      exports3.eachMapping = void 0;
      exports3.sourceContentFor = void 0;
      exports3.presortedDecodedMap = void 0;
      exports3.decodedMap = void 0;
      exports3.encodedMap = void 0;
      class TraceMap {
        constructor(map2, mapUrl) {
          const isString2 = typeof map2 === "string";
          if (!isString2 && map2._decodedMemo)
            return map2;
          const parsed = isString2 ? JSON.parse(map2) : map2;
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString2);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      (() => {
        exports3.encodedMappings = (map2) => {
          var _a;
          return (_a = map2._encoded) !== null && _a !== void 0 ? _a : map2._encoded = sourcemapCodec.encode(map2._decoded);
        };
        exports3.decodedMappings = (map2) => {
          return map2._decoded || (map2._decoded = sourcemapCodec.decode(map2._encoded));
        };
        exports3.traceSegment = (map2, line, column) => {
          const decoded = exports3.decodedMappings(map2);
          if (line >= decoded.length)
            return null;
          const segments = decoded[line];
          const index = traceSegmentInternal(segments, map2._decodedMemo, line, column, GREATEST_LOWER_BOUND);
          return index === -1 ? null : segments[index];
        };
        exports3.originalPositionFor = (map2, { line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const decoded = exports3.decodedMappings(map2);
          if (line >= decoded.length)
            return OMapping(null, null, null, null);
          const segments = decoded[line];
          const index = traceSegmentInternal(segments, map2._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
          if (index === -1)
            return OMapping(null, null, null, null);
          const segment = segments[index];
          if (segment.length === 1)
            return OMapping(null, null, null, null);
          const { names, resolvedSources } = map2;
          return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
        };
        exports3.allGeneratedPositionsFor = (map2, { source, line, column, bias }) => {
          return generatedPosition(map2, source, line, column, bias || LEAST_UPPER_BOUND, true);
        };
        exports3.generatedPositionFor = (map2, { source, line, column, bias }) => {
          return generatedPosition(map2, source, line, column, bias || GREATEST_LOWER_BOUND, false);
        };
        exports3.eachMapping = (map2, cb) => {
          const decoded = exports3.decodedMappings(map2);
          const { names, resolvedSources } = map2;
          for (let i2 = 0; i2 < decoded.length; i2++) {
            const line = decoded[i2];
            for (let j2 = 0; j2 < line.length; j2++) {
              const seg = line[j2];
              const generatedLine = i2 + 1;
              const generatedColumn = seg[0];
              let source = null;
              let originalLine = null;
              let originalColumn = null;
              let name = null;
              if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
              }
              if (seg.length === 5)
                name = names[seg[4]];
              cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
              });
            }
          }
        };
        exports3.sourceContentFor = (map2, source) => {
          const { sources, resolvedSources, sourcesContent } = map2;
          if (sourcesContent == null)
            return null;
          let index = sources.indexOf(source);
          if (index === -1)
            index = resolvedSources.indexOf(source);
          return index === -1 ? null : sourcesContent[index];
        };
        exports3.presortedDecodedMap = (map2, mapUrl) => {
          const tracer = new TraceMap(clone2(map2, []), mapUrl);
          tracer._decoded = map2.mappings;
          return tracer;
        };
        exports3.decodedMap = (map2) => {
          return clone2(map2, exports3.decodedMappings(map2));
        };
        exports3.encodedMap = (map2) => {
          return clone2(map2, exports3.encodedMappings(map2));
        };
        function generatedPosition(map2, source, line, column, bias, all) {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const { sources, resolvedSources } = map2;
          let sourceIndex = sources.indexOf(source);
          if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
          if (sourceIndex === -1)
            return all ? [] : GMapping(null, null);
          const generated = map2._bySources || (map2._bySources = buildBySources(exports3.decodedMappings(map2), map2._bySourceMemos = sources.map(memoizedState)));
          const segments = generated[sourceIndex][line];
          if (segments == null)
            return all ? [] : GMapping(null, null);
          const memo2 = map2._bySourceMemos[sourceIndex];
          if (all)
            return sliceGeneratedPositions(segments, memo2, line, column, bias);
          const index = traceSegmentInternal(segments, memo2, line, column, bias);
          if (index === -1)
            return GMapping(null, null);
          const segment = segments[index];
          return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
        }
      })();
      function clone2(map2, mappings) {
        return {
          version: map2.version,
          file: map2.file,
          names: map2.names,
          sourceRoot: map2.sourceRoot,
          sources: map2.sources,
          sourcesContent: map2.sourcesContent,
          mappings
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo2, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo2, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo2, line, column, bias) {
        let min3 = traceSegmentInternal(segments, memo2, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min3++;
        if (min3 === -1 || min3 === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min3][COLUMN];
        if (!found)
          min3 = lowerBound(segments, matchedColumn, min3);
        const max3 = upperBound(segments, matchedColumn, min3);
        const result2 = [];
        for (; min3 <= max3; min3++) {
          const segment = segments[min3];
          result2.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result2;
      }
      exports3.AnyMap = AnyMap;
      exports3.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports3.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports3.TraceMap = TraceMap;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
    })(exports2, function(exports3, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      exports3.addSegment = void 0;
      exports3.addMapping = void 0;
      exports3.maybeAddSegment = void 0;
      exports3.maybeAddMapping = void 0;
      exports3.setSourceContent = void 0;
      exports3.toDecodedMap = void 0;
      exports3.toEncodedMap = void 0;
      exports3.fromMap = void 0;
      exports3.allMappings = void 0;
      let addSegmentInternal;
      class GenMapping2 {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
        }
      }
      (() => {
        exports3.addSegment = (map2, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
          return addSegmentInternal(false, map2, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
        };
        exports3.maybeAddSegment = (map2, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
          return addSegmentInternal(true, map2, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
        };
        exports3.addMapping = (map2, mapping) => {
          return addMappingInternal(false, map2, mapping);
        };
        exports3.maybeAddMapping = (map2, mapping) => {
          return addMappingInternal(true, map2, mapping);
        };
        exports3.setSourceContent = (map2, source, content) => {
          const { _sources: sources, _sourcesContent: sourcesContent } = map2;
          sourcesContent[setArray.put(sources, source)] = content;
        };
        exports3.toDecodedMap = (map2) => {
          const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map2;
          removeEmptyFinalLines(mappings);
          return {
            version: 3,
            file: file || void 0,
            names: names.array,
            sourceRoot: sourceRoot || void 0,
            sources: sources.array,
            sourcesContent,
            mappings
          };
        };
        exports3.toEncodedMap = (map2) => {
          const decoded = exports3.toDecodedMap(map2);
          return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
        };
        exports3.allMappings = (map2) => {
          const out = [];
          const { _mappings: mappings, _sources: sources, _names: names } = map2;
          for (let i2 = 0; i2 < mappings.length; i2++) {
            const line = mappings[i2];
            for (let j2 = 0; j2 < line.length; j2++) {
              const seg = line[j2];
              const generated = { line: i2 + 1, column: seg[COLUMN] };
              let source = void 0;
              let original = void 0;
              let name = void 0;
              if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                if (seg.length === 5)
                  name = names.array[seg[NAMES_INDEX]];
              }
              out.push({ generated, source, original, name });
            }
          }
          return out;
        };
        exports3.fromMap = (input2) => {
          const map2 = new traceMapping.TraceMap(input2);
          const gen = new GenMapping2({ file: map2.file, sourceRoot: map2.sourceRoot });
          putAll(gen._names, map2.names);
          putAll(gen._sources, map2.sources);
          gen._sourcesContent = map2.sourcesContent || map2.sources.map(() => null);
          gen._mappings = traceMapping.decodedMappings(map2);
          return gen;
        };
        addSegmentInternal = (skipable, map2, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
          const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map2;
          const line = getLine(mappings, genLine);
          const index = getColumnIndex(line, genColumn);
          if (!source) {
            if (skipable && skipSourceless(line, index))
              return;
            return insert(line, index, [genColumn]);
          }
          const sourcesIndex = setArray.put(sources, source);
          const namesIndex = name ? setArray.put(names, name) : NO_NAME;
          if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
          if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
          }
          return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
        };
      })();
      function getLine(mappings, index) {
        for (let i2 = mappings.length; i2 <= index; i2++) {
          mappings[i2] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i2 = index - 1; i2 >= 0; index = i2--) {
          const current = line[i2];
          if (genColumn >= current[COLUMN])
            break;
        }
        return index;
      }
      function insert(array2, index, value) {
        for (let i2 = array2.length; i2 > index; i2--) {
          array2[i2] = array2[i2 - 1];
        }
        array2[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i2 = len - 1; i2 >= 0; len = i2, i2--) {
          if (mappings[i2].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(strarr, array2) {
        for (let i2 = 0; i2 < array2.length; i2++)
          setArray.put(strarr, array2[i2]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map2, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map2, generated.line - 1, generated.column, null, null, null, null, null);
        }
        const s = source;
        return addSegmentInternal(skipable, map2, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
      }
      exports3.GenMapping = GenMapping2;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/ts-interface-checker/dist/util.js
var require_util = __commonJS({
  "node_modules/ts-interface-checker/dist/util.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d2, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
          d3.__proto__ = b2;
        } || function(d3, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d3[p] = b2[p];
        };
        return extendStatics(d2, b);
      };
      return function(d2, b) {
        extendStatics(d2, b);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DetailContext = exports2.NoopContext = exports2.VError = void 0;
    var VError = (
      /** @class */
      function(_super) {
        __extends(VError2, _super);
        function VError2(path, message) {
          var _this = _super.call(this, message) || this;
          _this.path = path;
          Object.setPrototypeOf(_this, VError2.prototype);
          return _this;
        }
        return VError2;
      }(Error)
    );
    exports2.VError = VError;
    var NoopContext = (
      /** @class */
      function() {
        function NoopContext2() {
        }
        NoopContext2.prototype.fail = function(relPath, message, score) {
          return false;
        };
        NoopContext2.prototype.unionResolver = function() {
          return this;
        };
        NoopContext2.prototype.createContext = function() {
          return this;
        };
        NoopContext2.prototype.resolveUnion = function(ur2) {
        };
        return NoopContext2;
      }()
    );
    exports2.NoopContext = NoopContext;
    var DetailContext = (
      /** @class */
      function() {
        function DetailContext2() {
          this._propNames = [""];
          this._messages = [null];
          this._score = 0;
        }
        DetailContext2.prototype.fail = function(relPath, message, score) {
          this._propNames.push(relPath);
          this._messages.push(message);
          this._score += score;
          return false;
        };
        DetailContext2.prototype.unionResolver = function() {
          return new DetailUnionResolver();
        };
        DetailContext2.prototype.resolveUnion = function(unionResolver) {
          var _a, _b;
          var u = unionResolver;
          var best = null;
          for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {
            var ctx = _c[_i];
            if (!best || ctx._score >= best._score) {
              best = ctx;
            }
          }
          if (best && best._score > 0) {
            (_a = this._propNames).push.apply(_a, best._propNames);
            (_b = this._messages).push.apply(_b, best._messages);
          }
        };
        DetailContext2.prototype.getError = function(path) {
          var msgParts = [];
          for (var i2 = this._propNames.length - 1; i2 >= 0; i2--) {
            var p = this._propNames[i2];
            path += typeof p === "number" ? "[" + p + "]" : p ? "." + p : "";
            var m = this._messages[i2];
            if (m) {
              msgParts.push(path + " " + m);
            }
          }
          return new VError(path, msgParts.join("; "));
        };
        DetailContext2.prototype.getErrorDetail = function(path) {
          var details = [];
          for (var i2 = this._propNames.length - 1; i2 >= 0; i2--) {
            var p = this._propNames[i2];
            path += typeof p === "number" ? "[" + p + "]" : p ? "." + p : "";
            var message = this._messages[i2];
            if (message) {
              details.push({ path, message });
            }
          }
          var detail = null;
          for (var i2 = details.length - 1; i2 >= 0; i2--) {
            if (detail) {
              details[i2].nested = [detail];
            }
            detail = details[i2];
          }
          return detail;
        };
        return DetailContext2;
      }()
    );
    exports2.DetailContext = DetailContext;
    var DetailUnionResolver = (
      /** @class */
      function() {
        function DetailUnionResolver2() {
          this.contexts = [];
        }
        DetailUnionResolver2.prototype.createContext = function() {
          var ctx = new DetailContext();
          this.contexts.push(ctx);
          return ctx;
        };
        return DetailUnionResolver2;
      }()
    );
  }
});

// node_modules/ts-interface-checker/dist/types.js
var require_types = __commonJS({
  "node_modules/ts-interface-checker/dist/types.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d2, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
          d3.__proto__ = b2;
        } || function(d3, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d3[p] = b2[p];
        };
        return extendStatics(d2, b);
      };
      return function(d2, b) {
        extendStatics(d2, b);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.basicTypes = exports2.BasicType = exports2.TParamList = exports2.TParam = exports2.param = exports2.TFunc = exports2.func = exports2.TProp = exports2.TOptional = exports2.opt = exports2.TIface = exports2.iface = exports2.TEnumLiteral = exports2.enumlit = exports2.TEnumType = exports2.enumtype = exports2.TIntersection = exports2.intersection = exports2.TUnion = exports2.union = exports2.TTuple = exports2.tuple = exports2.TArray = exports2.array = exports2.TLiteral = exports2.lit = exports2.TName = exports2.name = exports2.TType = void 0;
    var util_1 = require_util();
    var TType = (
      /** @class */
      function() {
        function TType2() {
        }
        return TType2;
      }()
    );
    exports2.TType = TType;
    function parseSpec(typeSpec) {
      return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
    }
    function getNamedType(suite, name2) {
      var ttype = suite[name2];
      if (!ttype) {
        throw new Error("Unknown type " + name2);
      }
      return ttype;
    }
    function name(value) {
      return new TName(value);
    }
    exports2.name = name;
    var TName = (
      /** @class */
      function(_super) {
        __extends(TName2, _super);
        function TName2(name2) {
          var _this = _super.call(this) || this;
          _this.name = name2;
          _this._failMsg = "is not a " + name2;
          return _this;
        }
        TName2.prototype.getChecker = function(suite, strict, allowedProps) {
          var _this = this;
          var ttype = getNamedType(suite, this.name);
          var checker = ttype.getChecker(suite, strict, allowedProps);
          if (ttype instanceof BasicType || ttype instanceof TName2) {
            return checker;
          }
          return function(value, ctx) {
            return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0);
          };
        };
        return TName2;
      }(TType)
    );
    exports2.TName = TName;
    function lit2(value) {
      return new TLiteral(value);
    }
    exports2.lit = lit2;
    var TLiteral = (
      /** @class */
      function(_super) {
        __extends(TLiteral2, _super);
        function TLiteral2(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          _this.name = JSON.stringify(value);
          _this._failMsg = "is not " + _this.name;
          return _this;
        }
        TLiteral2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          return function(value, ctx) {
            return value === _this.value ? true : ctx.fail(null, _this._failMsg, -1);
          };
        };
        return TLiteral2;
      }(TType)
    );
    exports2.TLiteral = TLiteral;
    function array2(typeSpec) {
      return new TArray(parseSpec(typeSpec));
    }
    exports2.array = array2;
    var TArray = (
      /** @class */
      function(_super) {
        __extends(TArray2, _super);
        function TArray2(ttype) {
          var _this = _super.call(this) || this;
          _this.ttype = ttype;
          return _this;
        }
        TArray2.prototype.getChecker = function(suite, strict) {
          var itemChecker = this.ttype.getChecker(suite, strict);
          return function(value, ctx) {
            if (!Array.isArray(value)) {
              return ctx.fail(null, "is not an array", 0);
            }
            for (var i2 = 0; i2 < value.length; i2++) {
              var ok = itemChecker(value[i2], ctx);
              if (!ok) {
                return ctx.fail(i2, null, 1);
              }
            }
            return true;
          };
        };
        return TArray2;
      }(TType)
    );
    exports2.TArray = TArray;
    function tuple() {
      var typeSpec = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        typeSpec[_i2] = arguments[_i2];
      }
      return new TTuple(typeSpec.map(function(t2) {
        return parseSpec(t2);
      }));
    }
    exports2.tuple = tuple;
    var TTuple = (
      /** @class */
      function(_super) {
        __extends(TTuple2, _super);
        function TTuple2(ttypes) {
          var _this = _super.call(this) || this;
          _this.ttypes = ttypes;
          return _this;
        }
        TTuple2.prototype.getChecker = function(suite, strict) {
          var itemCheckers = this.ttypes.map(function(t2) {
            return t2.getChecker(suite, strict);
          });
          var checker = function(value, ctx) {
            if (!Array.isArray(value)) {
              return ctx.fail(null, "is not an array", 0);
            }
            for (var i2 = 0; i2 < itemCheckers.length; i2++) {
              var ok = itemCheckers[i2](value[i2], ctx);
              if (!ok) {
                return ctx.fail(i2, null, 1);
              }
            }
            return true;
          };
          if (!strict) {
            return checker;
          }
          return function(value, ctx) {
            if (!checker(value, ctx)) {
              return false;
            }
            return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
          };
        };
        return TTuple2;
      }(TType)
    );
    exports2.TTuple = TTuple;
    function union3() {
      var typeSpec = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        typeSpec[_i2] = arguments[_i2];
      }
      return new TUnion(typeSpec.map(function(t2) {
        return parseSpec(t2);
      }));
    }
    exports2.union = union3;
    var TUnion = (
      /** @class */
      function(_super) {
        __extends(TUnion2, _super);
        function TUnion2(ttypes) {
          var _this = _super.call(this) || this;
          _this.ttypes = ttypes;
          var names = ttypes.map(function(t2) {
            return t2 instanceof TName || t2 instanceof TLiteral ? t2.name : null;
          }).filter(function(n2) {
            return n2;
          });
          var otherTypes = ttypes.length - names.length;
          if (names.length) {
            if (otherTypes > 0) {
              names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
          } else {
            _this._failMsg = "is none of " + otherTypes + " types";
          }
          return _this;
        }
        TUnion2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          var itemCheckers = this.ttypes.map(function(t2) {
            return t2.getChecker(suite, strict);
          });
          return function(value, ctx) {
            var ur2 = ctx.unionResolver();
            for (var i2 = 0; i2 < itemCheckers.length; i2++) {
              var ok = itemCheckers[i2](value, ur2.createContext());
              if (ok) {
                return true;
              }
            }
            ctx.resolveUnion(ur2);
            return ctx.fail(null, _this._failMsg, 0);
          };
        };
        return TUnion2;
      }(TType)
    );
    exports2.TUnion = TUnion;
    function intersection2() {
      var typeSpec = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        typeSpec[_i2] = arguments[_i2];
      }
      return new TIntersection(typeSpec.map(function(t2) {
        return parseSpec(t2);
      }));
    }
    exports2.intersection = intersection2;
    var TIntersection = (
      /** @class */
      function(_super) {
        __extends(TIntersection2, _super);
        function TIntersection2(ttypes) {
          var _this = _super.call(this) || this;
          _this.ttypes = ttypes;
          return _this;
        }
        TIntersection2.prototype.getChecker = function(suite, strict) {
          var allowedProps = /* @__PURE__ */ new Set();
          var itemCheckers = this.ttypes.map(function(t2) {
            return t2.getChecker(suite, strict, allowedProps);
          });
          return function(value, ctx) {
            var ok = itemCheckers.every(function(checker) {
              return checker(value, ctx);
            });
            if (ok) {
              return true;
            }
            return ctx.fail(null, null, 0);
          };
        };
        return TIntersection2;
      }(TType)
    );
    exports2.TIntersection = TIntersection;
    function enumtype(values2) {
      return new TEnumType(values2);
    }
    exports2.enumtype = enumtype;
    var TEnumType = (
      /** @class */
      function(_super) {
        __extends(TEnumType2, _super);
        function TEnumType2(members) {
          var _this = _super.call(this) || this;
          _this.members = members;
          _this.validValues = /* @__PURE__ */ new Set();
          _this._failMsg = "is not a valid enum value";
          _this.validValues = new Set(Object.keys(members).map(function(name2) {
            return members[name2];
          }));
          return _this;
        }
        TEnumType2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          return function(value, ctx) {
            return _this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0);
          };
        };
        return TEnumType2;
      }(TType)
    );
    exports2.TEnumType = TEnumType;
    function enumlit(name2, prop) {
      return new TEnumLiteral(name2, prop);
    }
    exports2.enumlit = enumlit;
    var TEnumLiteral = (
      /** @class */
      function(_super) {
        __extends(TEnumLiteral2, _super);
        function TEnumLiteral2(enumName, prop) {
          var _this = _super.call(this) || this;
          _this.enumName = enumName;
          _this.prop = prop;
          _this._failMsg = "is not " + enumName + "." + prop;
          return _this;
        }
        TEnumLiteral2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          var ttype = getNamedType(suite, this.enumName);
          if (!(ttype instanceof TEnumType)) {
            throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
          }
          var val = ttype.members[this.prop];
          if (!ttype.members.hasOwnProperty(this.prop)) {
            throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
          }
          return function(value, ctx) {
            return value === val ? true : ctx.fail(null, _this._failMsg, -1);
          };
        };
        return TEnumLiteral2;
      }(TType)
    );
    exports2.TEnumLiteral = TEnumLiteral;
    function makeIfaceProps(props) {
      return Object.keys(props).map(function(name2) {
        return makeIfaceProp(name2, props[name2]);
      });
    }
    function makeIfaceProp(name2, prop) {
      return prop instanceof TOptional ? new TProp(name2, prop.ttype, true) : new TProp(name2, parseSpec(prop), false);
    }
    function iface2(bases, props) {
      return new TIface(bases, makeIfaceProps(props));
    }
    exports2.iface = iface2;
    var TIface = (
      /** @class */
      function(_super) {
        __extends(TIface2, _super);
        function TIface2(bases, props) {
          var _this = _super.call(this) || this;
          _this.bases = bases;
          _this.props = props;
          _this.propSet = new Set(props.map(function(p) {
            return p.name;
          }));
          return _this;
        }
        TIface2.prototype.getChecker = function(suite, strict, allowedProps) {
          var _this = this;
          var baseCheckers = this.bases.map(function(b) {
            return getNamedType(suite, b).getChecker(suite, strict);
          });
          var propCheckers = this.props.map(function(prop) {
            return prop.ttype.getChecker(suite, strict);
          });
          var testCtx = new util_1.NoopContext();
          var isPropRequired = this.props.map(function(prop, i2) {
            return !prop.isOpt && !propCheckers[i2](void 0, testCtx);
          });
          var checker = function(value, ctx) {
            if (typeof value !== "object" || value === null) {
              return ctx.fail(null, "is not an object", 0);
            }
            for (var i2 = 0; i2 < baseCheckers.length; i2++) {
              if (!baseCheckers[i2](value, ctx)) {
                return false;
              }
            }
            for (var i2 = 0; i2 < propCheckers.length; i2++) {
              var name_1 = _this.props[i2].name;
              var v2 = value[name_1];
              if (v2 === void 0) {
                if (isPropRequired[i2]) {
                  return ctx.fail(name_1, "is missing", 1);
                }
              } else {
                var ok = propCheckers[i2](v2, ctx);
                if (!ok) {
                  return ctx.fail(name_1, null, 1);
                }
              }
            }
            return true;
          };
          if (!strict) {
            return checker;
          }
          var propSet = this.propSet;
          if (allowedProps) {
            this.propSet.forEach(function(prop) {
              return allowedProps.add(prop);
            });
            propSet = allowedProps;
          }
          return function(value, ctx) {
            if (!checker(value, ctx)) {
              return false;
            }
            for (var prop in value) {
              if (!propSet.has(prop)) {
                return ctx.fail(prop, "is extraneous", 2);
              }
            }
            return true;
          };
        };
        return TIface2;
      }(TType)
    );
    exports2.TIface = TIface;
    function opt2(typeSpec) {
      return new TOptional(parseSpec(typeSpec));
    }
    exports2.opt = opt2;
    var TOptional = (
      /** @class */
      function(_super) {
        __extends(TOptional2, _super);
        function TOptional2(ttype) {
          var _this = _super.call(this) || this;
          _this.ttype = ttype;
          return _this;
        }
        TOptional2.prototype.getChecker = function(suite, strict) {
          var itemChecker = this.ttype.getChecker(suite, strict);
          return function(value, ctx) {
            return value === void 0 || itemChecker(value, ctx);
          };
        };
        return TOptional2;
      }(TType)
    );
    exports2.TOptional = TOptional;
    var TProp = (
      /** @class */
      function() {
        function TProp2(name2, ttype, isOpt) {
          this.name = name2;
          this.ttype = ttype;
          this.isOpt = isOpt;
        }
        return TProp2;
      }()
    );
    exports2.TProp = TProp;
    function func(resultSpec) {
      var params = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        params[_i2 - 1] = arguments[_i2];
      }
      return new TFunc(new TParamList(params), parseSpec(resultSpec));
    }
    exports2.func = func;
    var TFunc = (
      /** @class */
      function(_super) {
        __extends(TFunc2, _super);
        function TFunc2(paramList, result2) {
          var _this = _super.call(this) || this;
          _this.paramList = paramList;
          _this.result = result2;
          return _this;
        }
        TFunc2.prototype.getChecker = function(suite, strict) {
          return function(value, ctx) {
            return typeof value === "function" ? true : ctx.fail(null, "is not a function", 0);
          };
        };
        return TFunc2;
      }(TType)
    );
    exports2.TFunc = TFunc;
    function param(name2, typeSpec, isOpt) {
      return new TParam(name2, parseSpec(typeSpec), Boolean(isOpt));
    }
    exports2.param = param;
    var TParam = (
      /** @class */
      function() {
        function TParam2(name2, ttype, isOpt) {
          this.name = name2;
          this.ttype = ttype;
          this.isOpt = isOpt;
        }
        return TParam2;
      }()
    );
    exports2.TParam = TParam;
    var TParamList = (
      /** @class */
      function(_super) {
        __extends(TParamList2, _super);
        function TParamList2(params) {
          var _this = _super.call(this) || this;
          _this.params = params;
          return _this;
        }
        TParamList2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          var itemCheckers = this.params.map(function(t2) {
            return t2.ttype.getChecker(suite, strict);
          });
          var testCtx = new util_1.NoopContext();
          var isParamRequired = this.params.map(function(param2, i2) {
            return !param2.isOpt && !itemCheckers[i2](void 0, testCtx);
          });
          var checker = function(value, ctx) {
            if (!Array.isArray(value)) {
              return ctx.fail(null, "is not an array", 0);
            }
            for (var i2 = 0; i2 < itemCheckers.length; i2++) {
              var p = _this.params[i2];
              if (value[i2] === void 0) {
                if (isParamRequired[i2]) {
                  return ctx.fail(p.name, "is missing", 1);
                }
              } else {
                var ok = itemCheckers[i2](value[i2], ctx);
                if (!ok) {
                  return ctx.fail(p.name, null, 1);
                }
              }
            }
            return true;
          };
          if (!strict) {
            return checker;
          }
          return function(value, ctx) {
            if (!checker(value, ctx)) {
              return false;
            }
            return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
          };
        };
        return TParamList2;
      }(TType)
    );
    exports2.TParamList = TParamList;
    var BasicType = (
      /** @class */
      function(_super) {
        __extends(BasicType2, _super);
        function BasicType2(validator, message) {
          var _this = _super.call(this) || this;
          _this.validator = validator;
          _this.message = message;
          return _this;
        }
        BasicType2.prototype.getChecker = function(suite, strict) {
          var _this = this;
          return function(value, ctx) {
            return _this.validator(value) ? true : ctx.fail(null, _this.message, 0);
          };
        };
        return BasicType2;
      }(TType)
    );
    exports2.BasicType = BasicType;
    exports2.basicTypes = {
      any: new BasicType(function(v2) {
        return true;
      }, "is invalid"),
      number: new BasicType(function(v2) {
        return typeof v2 === "number";
      }, "is not a number"),
      object: new BasicType(function(v2) {
        return typeof v2 === "object" && v2;
      }, "is not an object"),
      boolean: new BasicType(function(v2) {
        return typeof v2 === "boolean";
      }, "is not a boolean"),
      string: new BasicType(function(v2) {
        return typeof v2 === "string";
      }, "is not a string"),
      symbol: new BasicType(function(v2) {
        return typeof v2 === "symbol";
      }, "is not a symbol"),
      void: new BasicType(function(v2) {
        return v2 == null;
      }, "is not void"),
      undefined: new BasicType(function(v2) {
        return v2 === void 0;
      }, "is not undefined"),
      null: new BasicType(function(v2) {
        return v2 === null;
      }, "is not null"),
      never: new BasicType(function(v2) {
        return false;
      }, "is unexpected"),
      Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
      RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp")
    };
    var nativeToString = Object.prototype.toString;
    function getIsNativeChecker(tag) {
      return function(v2) {
        return typeof v2 === "object" && v2 && nativeToString.call(v2) === tag;
      };
    }
    if (typeof Buffer !== "undefined") {
      exports2.basicTypes.Buffer = new BasicType(function(v2) {
        return Buffer.isBuffer(v2);
      }, "is not a Buffer");
    }
    var _loop_1 = function(array_12) {
      exports2.basicTypes[array_12.name] = new BasicType(function(v2) {
        return v2 instanceof array_12;
      }, "is not a " + array_12.name);
    };
    for (_i = 0, _a = [
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      ArrayBuffer
    ]; _i < _a.length; _i++) {
      array_1 = _a[_i];
      _loop_1(array_1);
    }
    var array_1;
    var _i;
    var _a;
  }
});

// node_modules/ts-interface-checker/dist/index.js
var require_dist = __commonJS({
  "node_modules/ts-interface-checker/dist/index.js"(exports2) {
    "use strict";
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j2 = 0, jl = a.length; j2 < jl; j2++, k++)
          r[k] = a[j2];
      return r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Checker = exports2.createCheckers = void 0;
    var types_1 = require_types();
    var util_1 = require_util();
    var types_2 = require_types();
    Object.defineProperty(exports2, "TArray", { enumerable: true, get: function() {
      return types_2.TArray;
    } });
    Object.defineProperty(exports2, "TEnumType", { enumerable: true, get: function() {
      return types_2.TEnumType;
    } });
    Object.defineProperty(exports2, "TEnumLiteral", { enumerable: true, get: function() {
      return types_2.TEnumLiteral;
    } });
    Object.defineProperty(exports2, "TFunc", { enumerable: true, get: function() {
      return types_2.TFunc;
    } });
    Object.defineProperty(exports2, "TIface", { enumerable: true, get: function() {
      return types_2.TIface;
    } });
    Object.defineProperty(exports2, "TLiteral", { enumerable: true, get: function() {
      return types_2.TLiteral;
    } });
    Object.defineProperty(exports2, "TName", { enumerable: true, get: function() {
      return types_2.TName;
    } });
    Object.defineProperty(exports2, "TOptional", { enumerable: true, get: function() {
      return types_2.TOptional;
    } });
    Object.defineProperty(exports2, "TParam", { enumerable: true, get: function() {
      return types_2.TParam;
    } });
    Object.defineProperty(exports2, "TParamList", { enumerable: true, get: function() {
      return types_2.TParamList;
    } });
    Object.defineProperty(exports2, "TProp", { enumerable: true, get: function() {
      return types_2.TProp;
    } });
    Object.defineProperty(exports2, "TTuple", { enumerable: true, get: function() {
      return types_2.TTuple;
    } });
    Object.defineProperty(exports2, "TType", { enumerable: true, get: function() {
      return types_2.TType;
    } });
    Object.defineProperty(exports2, "TUnion", { enumerable: true, get: function() {
      return types_2.TUnion;
    } });
    Object.defineProperty(exports2, "TIntersection", { enumerable: true, get: function() {
      return types_2.TIntersection;
    } });
    Object.defineProperty(exports2, "array", { enumerable: true, get: function() {
      return types_2.array;
    } });
    Object.defineProperty(exports2, "enumlit", { enumerable: true, get: function() {
      return types_2.enumlit;
    } });
    Object.defineProperty(exports2, "enumtype", { enumerable: true, get: function() {
      return types_2.enumtype;
    } });
    Object.defineProperty(exports2, "func", { enumerable: true, get: function() {
      return types_2.func;
    } });
    Object.defineProperty(exports2, "iface", { enumerable: true, get: function() {
      return types_2.iface;
    } });
    Object.defineProperty(exports2, "lit", { enumerable: true, get: function() {
      return types_2.lit;
    } });
    Object.defineProperty(exports2, "name", { enumerable: true, get: function() {
      return types_2.name;
    } });
    Object.defineProperty(exports2, "opt", { enumerable: true, get: function() {
      return types_2.opt;
    } });
    Object.defineProperty(exports2, "param", { enumerable: true, get: function() {
      return types_2.param;
    } });
    Object.defineProperty(exports2, "tuple", { enumerable: true, get: function() {
      return types_2.tuple;
    } });
    Object.defineProperty(exports2, "union", { enumerable: true, get: function() {
      return types_2.union;
    } });
    Object.defineProperty(exports2, "intersection", { enumerable: true, get: function() {
      return types_2.intersection;
    } });
    Object.defineProperty(exports2, "BasicType", { enumerable: true, get: function() {
      return types_2.BasicType;
    } });
    var util_2 = require_util();
    Object.defineProperty(exports2, "VError", { enumerable: true, get: function() {
      return util_2.VError;
    } });
    function createCheckers2() {
      var typeSuite = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        typeSuite[_i] = arguments[_i];
      }
      var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));
      var checkers = {};
      for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {
        var suite_1 = typeSuite_1[_a];
        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {
          var name = _c[_b];
          checkers[name] = new Checker(fullSuite, suite_1[name]);
        }
      }
      return checkers;
    }
    exports2.createCheckers = createCheckers2;
    var Checker = (
      /** @class */
      function() {
        function Checker2(suite, ttype, _path) {
          if (_path === void 0) {
            _path = "value";
          }
          this.suite = suite;
          this.ttype = ttype;
          this._path = _path;
          this.props = /* @__PURE__ */ new Map();
          if (ttype instanceof types_1.TIface) {
            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {
              var p = _a[_i];
              this.props.set(p.name, p.ttype);
            }
          }
          this.checkerPlain = this.ttype.getChecker(suite, false);
          this.checkerStrict = this.ttype.getChecker(suite, true);
        }
        Checker2.prototype.setReportedPath = function(path) {
          this._path = path;
        };
        Checker2.prototype.check = function(value) {
          return this._doCheck(this.checkerPlain, value);
        };
        Checker2.prototype.test = function(value) {
          return this.checkerPlain(value, new util_1.NoopContext());
        };
        Checker2.prototype.validate = function(value) {
          return this._doValidate(this.checkerPlain, value);
        };
        Checker2.prototype.strictCheck = function(value) {
          return this._doCheck(this.checkerStrict, value);
        };
        Checker2.prototype.strictTest = function(value) {
          return this.checkerStrict(value, new util_1.NoopContext());
        };
        Checker2.prototype.strictValidate = function(value) {
          return this._doValidate(this.checkerStrict, value);
        };
        Checker2.prototype.getProp = function(prop) {
          var ttype = this.props.get(prop);
          if (!ttype) {
            throw new Error("Type has no property " + prop);
          }
          return new Checker2(this.suite, ttype, this._path + "." + prop);
        };
        Checker2.prototype.methodArgs = function(methodName) {
          var tfunc = this._getMethod(methodName);
          return new Checker2(this.suite, tfunc.paramList);
        };
        Checker2.prototype.methodResult = function(methodName) {
          var tfunc = this._getMethod(methodName);
          return new Checker2(this.suite, tfunc.result);
        };
        Checker2.prototype.getArgs = function() {
          if (!(this.ttype instanceof types_1.TFunc)) {
            throw new Error("getArgs() applied to non-function");
          }
          return new Checker2(this.suite, this.ttype.paramList);
        };
        Checker2.prototype.getResult = function() {
          if (!(this.ttype instanceof types_1.TFunc)) {
            throw new Error("getResult() applied to non-function");
          }
          return new Checker2(this.suite, this.ttype.result);
        };
        Checker2.prototype.getType = function() {
          return this.ttype;
        };
        Checker2.prototype._doCheck = function(checkerFunc, value) {
          var noopCtx = new util_1.NoopContext();
          if (!checkerFunc(value, noopCtx)) {
            var detailCtx = new util_1.DetailContext();
            checkerFunc(value, detailCtx);
            throw detailCtx.getError(this._path);
          }
        };
        Checker2.prototype._doValidate = function(checkerFunc, value) {
          var noopCtx = new util_1.NoopContext();
          if (checkerFunc(value, noopCtx)) {
            return null;
          }
          var detailCtx = new util_1.DetailContext();
          checkerFunc(value, detailCtx);
          return detailCtx.getErrorDetail(this._path);
        };
        Checker2.prototype._getMethod = function(methodName) {
          var ttype = this.props.get(methodName);
          if (!ttype) {
            throw new Error("Type has no property " + methodName);
          }
          if (!(ttype instanceof types_1.TFunc)) {
            throw new Error("Property " + methodName + " is not a method");
          }
          return ttype;
        };
        return Checker2;
      }()
    );
    exports2.Checker = Checker;
  }
});

// node_modules/lines-and-columns/build/index.js
var require_build = __commonJS({
  "node_modules/lines-and-columns/build/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.LinesAndColumns = void 0;
    var LF = "\n";
    var CR = "\r";
    var LinesAndColumns2 = (
      /** @class */
      function() {
        function LinesAndColumns3(string) {
          this.string = string;
          var offsets = [0];
          for (var offset = 0; offset < string.length; ) {
            switch (string[offset]) {
              case LF:
                offset += LF.length;
                offsets.push(offset);
                break;
              case CR:
                offset += CR.length;
                if (string[offset] === LF) {
                  offset += LF.length;
                }
                offsets.push(offset);
                break;
              default:
                offset++;
                break;
            }
          }
          this.offsets = offsets;
        }
        LinesAndColumns3.prototype.locationForIndex = function(index) {
          if (index < 0 || index > this.string.length) {
            return null;
          }
          var line = 0;
          var offsets = this.offsets;
          while (offsets[line + 1] <= index) {
            line++;
          }
          var column = index - offsets[line];
          return { line, column };
        };
        LinesAndColumns3.prototype.indexForLocation = function(location) {
          var line = location.line, column = location.column;
          if (line < 0 || line >= this.offsets.length) {
            return null;
          }
          if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
          }
          return this.offsets[line] + column;
        };
        LinesAndColumns3.prototype.lengthOfLine = function(line) {
          var offset = this.offsets[line];
          var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
          return nextOffset - offset;
        };
        return LinesAndColumns3;
      }()
    );
    exports2.LinesAndColumns = LinesAndColumns2;
    exports2["default"] = LinesAndColumns2;
  }
});

// node_modules/@refinedev/inferencer/dist/esm/chakra-ui.js
var import_react5 = __toESM(require_react());
var import_react7 = __toESM(require_react());
var import_standalone = __toESM(require_standalone());
var import_parser_typescript = __toESM(require_parser_typescript());
var import_pluralize = __toESM(require_pluralize());
var import_pluralize2 = __toESM(require_pluralize());
var import_pluralize3 = __toESM(require_pluralize());
var import_pluralize4 = __toESM(require_pluralize());
var import_dayjs = __toESM(require_dayjs_min());
var import_react8 = __toESM(require_react());

// node_modules/@aliemir/react-live/dist/react-live.es.js
var import_react2 = __toESM(require_react());

// node_modules/prism-react-renderer/prism/index.js
var Prism = function() {
  var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
  var uniqueId2 = 0;
  var plainTextGrammar = {};
  var _ = {
    /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */
    util: {
      encode: function encode(tokens) {
        if (tokens instanceof Token2) {
          return new Token2(tokens.type, encode(tokens.content), tokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(encode);
        } else {
          return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }
      },
      /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */
      type: function(o) {
        return Object.prototype.toString.call(o).slice(8, -1);
      },
      /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */
      objId: function(obj) {
        if (!obj["__id"]) {
          Object.defineProperty(obj, "__id", { value: ++uniqueId2 });
        }
        return obj["__id"];
      },
      /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */
      clone: function deepClone(o, visited) {
        visited = visited || {};
        var clone2;
        var id;
        switch (_.util.type(o)) {
          case "Object":
            id = _.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone2 = /** @type {Record<string, any>} */
            {};
            visited[id] = clone2;
            for (var key in o) {
              if (o.hasOwnProperty(key)) {
                clone2[key] = deepClone(o[key], visited);
              }
            }
            return (
              /** @type {any} */
              clone2
            );
          case "Array":
            id = _.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone2 = [];
            visited[id] = clone2;
            /** @type {Array} */
            /** @type {any} */
            o.forEach(function(v2, i2) {
              clone2[i2] = deepClone(v2, visited);
            });
            return (
              /** @type {any} */
              clone2
            );
          default:
            return o;
        }
      },
      /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */
      getLanguage: function(element) {
        while (element) {
          var m = lang.exec(element.className);
          if (m) {
            return m[1].toLowerCase();
          }
          element = element.parentElement;
        }
        return "none";
      },
      /**
       * Sets the Prism `language-xxxx` class of the given element.
       *
       * @param {Element} element
       * @param {string} language
       * @returns {void}
       */
      setLanguage: function(element, language) {
        element.className = element.className.replace(RegExp(lang, "gi"), "");
        element.classList.add("language-" + language);
      },
      /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */
      isActive: function(element, className, defaultActivation) {
        var no = "no-" + className;
        while (element) {
          var classList = element.classList;
          if (classList.contains(className)) {
            return true;
          }
          if (classList.contains(no)) {
            return false;
          }
          element = element.parentElement;
        }
        return !!defaultActivation;
      }
    },
    /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */
    languages: {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,
      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: function(id, redef) {
        var lang2 = _.util.clone(_.languages[id]);
        for (var key in redef) {
          lang2[key] = redef[key];
        }
        return lang2;
      },
      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: function(inside, before2, insert, root) {
        root = root || /** @type {any} */
        _.languages;
        var grammar = root[inside];
        var ret = {};
        for (var token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before2) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }
        var old = root[inside];
        root[inside] = ret;
        _.languages.DFS(_.languages, function(key, value) {
          if (value === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o, callback, type, visited) {
        visited = visited || {};
        var objId = _.util.objId;
        for (var i2 in o) {
          if (o.hasOwnProperty(i2)) {
            callback.call(o, i2, o[i2], type || i2);
            var property = o[i2];
            var propertyType = _.util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i2, visited);
            }
          }
        }
      }
    },
    plugins: {},
    /**
     * Low-level function, only use if you know what youâre doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */
    highlight: function(text2, grammar, language) {
      var env = {
        code: text2,
        grammar,
        language
      };
      _.hooks.run("before-tokenize", env);
      env.tokens = _.tokenize(env.code, env.grammar);
      _.hooks.run("after-tokenize", env);
      return Token2.stringify(_.util.encode(env.tokens), env.language);
    },
    /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */
    tokenize: function(text2, grammar) {
      var rest2 = grammar.rest;
      if (rest2) {
        for (var token in rest2) {
          grammar[token] = rest2[token];
        }
        delete grammar.rest;
      }
      var tokenList = new LinkedList();
      addAfter(tokenList, tokenList.head, text2);
      matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
      return toArray2(tokenList);
    },
    /**
     * @namespace
     * @memberof Prism
     * @public
     */
    hooks: {
      all: {},
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function(name, callback) {
        var hooks = _.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function(name, env) {
        var callbacks = _.hooks.all[name];
        if (!callbacks || !callbacks.length) {
          return;
        }
        for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
          callback(env);
        }
      }
    },
    Token: Token2
  };
  function Token2(type, content, alias, matchedStr) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
  }
  Token2.stringify = function stringify(o, language) {
    if (typeof o == "string") {
      return o;
    }
    if (Array.isArray(o)) {
      var s = "";
      o.forEach(function(e) {
        s += stringify(e, language);
      });
      return s;
    }
    var env = {
      type: o.type,
      content: stringify(o.content, language),
      tag: "span",
      classes: ["token", o.type],
      attributes: {},
      language
    };
    var aliases = o.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    _.hooks.run("wrap", env);
    var attributes = "";
    for (var name in env.attributes) {
      attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
    }
    return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
  };
  function matchPattern(pattern, pos, text2, lookbehind) {
    pattern.lastIndex = pos;
    var match2 = pattern.exec(text2);
    if (match2 && lookbehind && match2[1]) {
      var lookbehindLength = match2[1].length;
      match2.index += lookbehindLength;
      match2[0] = match2[0].slice(lookbehindLength);
    }
    return match2;
  }
  function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
    for (var token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }
      var patterns = grammar[token];
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      for (var j2 = 0; j2 < patterns.length; ++j2) {
        if (rematch && rematch.cause == token + "," + j2) {
          return;
        }
        var patternObj = patterns[j2];
        var inside = patternObj.inside;
        var lookbehind = !!patternObj.lookbehind;
        var greedy = !!patternObj.greedy;
        var alias = patternObj.alias;
        if (greedy && !patternObj.pattern.global) {
          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
          patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
        }
        var pattern = patternObj.pattern || patternObj;
        for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
          if (rematch && pos >= rematch.reach) {
            break;
          }
          var str = currentNode.value;
          if (tokenList.length > text2.length) {
            return;
          }
          if (str instanceof Token2) {
            continue;
          }
          var removeCount = 1;
          var match2;
          if (greedy) {
            match2 = matchPattern(pattern, pos, text2, lookbehind);
            if (!match2 || match2.index >= text2.length) {
              break;
            }
            var from = match2.index;
            var to = match2.index + match2[0].length;
            var p = pos;
            p += currentNode.value.length;
            while (from >= p) {
              currentNode = currentNode.next;
              p += currentNode.value.length;
            }
            p -= currentNode.value.length;
            pos = p;
            if (currentNode.value instanceof Token2) {
              continue;
            }
            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
              removeCount++;
              p += k.value.length;
            }
            removeCount--;
            str = text2.slice(pos, p);
            match2.index -= pos;
          } else {
            match2 = matchPattern(pattern, 0, str, lookbehind);
            if (!match2) {
              continue;
            }
          }
          var from = match2.index;
          var matchStr = match2[0];
          var before2 = str.slice(0, from);
          var after2 = str.slice(from + matchStr.length);
          var reach = pos + str.length;
          if (rematch && reach > rematch.reach) {
            rematch.reach = reach;
          }
          var removeFrom = currentNode.prev;
          if (before2) {
            removeFrom = addAfter(tokenList, removeFrom, before2);
            pos += before2.length;
          }
          removeRange(tokenList, removeFrom, removeCount);
          var wrapped = new Token2(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
          currentNode = addAfter(tokenList, removeFrom, wrapped);
          if (after2) {
            addAfter(tokenList, currentNode, after2);
          }
          if (removeCount > 1) {
            var nestedRematch = {
              cause: token + "," + j2,
              reach
            };
            matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
            if (rematch && nestedRematch.reach > rematch.reach) {
              rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
  }
  function LinkedList() {
    var head2 = { value: null, prev: null, next: null };
    var tail2 = { value: null, prev: head2, next: null };
    head2.next = tail2;
    this.head = head2;
    this.tail = tail2;
    this.length = 0;
  }
  function addAfter(list, node, value) {
    var next2 = node.next;
    var newNode = { value, prev: node, next: next2 };
    node.next = newNode;
    next2.prev = newNode;
    list.length++;
    return newNode;
  }
  function removeRange(list, node, count2) {
    var next2 = node.next;
    for (var i2 = 0; i2 < count2 && next2 !== list.tail; i2++) {
      next2 = next2.next;
    }
    node.next = next2;
    next2.prev = node;
    list.length -= i2;
  }
  function toArray2(list) {
    var array2 = [];
    var node = list.head.next;
    while (node !== list.tail) {
      array2.push(node.value);
      node = node.next;
    }
    return array2;
  }
  return _;
}();
var prism = Prism;
Prism.default = Prism;
prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, /"|'/]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = prism.languages.markup["entity"];
prism.languages.markup["doctype"].inside["internal-subset"].inside = prism.languages.markup;
prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
prism.languages.html = prism.languages.markup;
prism.languages.mathml = prism.languages.markup;
prism.languages.svg = prism.languages.markup;
prism.languages.xml = prism.languages.extend("markup", {});
prism.languages.ssml = prism.languages.xml;
prism.languages.atom = prism.languages.xml;
prism.languages.rss = prism.languages.xml;
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: true
          }, /^\$\(\(/],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not âfoo {â
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (â=â and â+=â).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // â No expansion (so no âinsideâ).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // âNormalâ string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
  var inside = insideString.variable[1].inside;
  for (var i2 = 0; i2 < toBeCopied.length; i2++) {
    inside[toBeCopied[i2]] = Prism2.languages.bash[toBeCopied[i2]];
  }
  Prism2.languages.shell = Prism2.languages.bash;
})(prism);
prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
prism.languages.c = prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, prism.languages.c["string"]],
      "char": prism.languages.c["char"],
      "comment": prism.languages.c["comment"],
      "macro-name": [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: "function"
      }],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: prism.languages.c
      }
    }
  }
});
prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
        return modName;
      }) + ")"),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(prism);
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(prism);
(function(Prism2) {
  var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
  var selectorInside;
  Prism2.languages.css.selector = {
    pattern: Prism2.languages.css.selector.pattern,
    lookbehind: true,
    inside: selectorInside = {
      "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
      "pseudo-class": /:[-\w]+/,
      "class": /\.[-\w]+/,
      "id": /#[-\w]+/,
      "attribute": {
        pattern: RegExp(`\\[(?:[^[\\]"']|` + string.source + ")*\\]"),
        greedy: true,
        inside: {
          "punctuation": /^\[|\]$/,
          "case-sensitivity": {
            pattern: /(\s)[si]$/i,
            lookbehind: true,
            alias: "keyword"
          },
          "namespace": {
            pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
            lookbehind: true,
            inside: {
              "punctuation": /\|$/
            }
          },
          "attr-name": {
            pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
            lookbehind: true
          },
          "attr-value": [string, {
            pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
            lookbehind: true
          }],
          "operator": /[|~*^$]?=/
        }
      },
      "n-th": [{
        pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
        lookbehind: true,
        inside: {
          "number": /[\dn]+/,
          "operator": /[+-]/
        }
      }, {
        pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
        lookbehind: true
      }],
      "combinator": />|\+|~|\|\|/,
      // the `tag` token has been existed and removed.
      // because we can't find a perfect tokenize to match it.
      // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
      "punctuation": /[(),]/
    }
  };
  Prism2.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
  Prism2.languages.insertBefore("css", "property", {
    "variable": {
      pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
      lookbehind: true
    }
  });
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
    lookbehind: true
  };
  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  Prism2.languages.insertBefore("css", "function", {
    "operator": {
      pattern: /(\s)[+\-*\/](?=\s)/,
      lookbehind: true
    },
    // CAREFUL!
    // Previewers and Inline color use hexcode and color.
    "hexcode": {
      pattern: /\B#[\da-f]{3,8}\b/i,
      alias: "color"
    },
    "color": [{
      pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
      lookbehind: true
    }, {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        "unit": unit,
        "number": number,
        "function": /[\w-]+(?=\()/,
        "punctuation": /[(),]/
      }
    }],
    // it's important that there is no boundary assertion after the hex digits
    "entity": /\\[\da-f]{1,8}/i,
    "unit": unit,
    "number": number
  });
})(prism);
prism.languages.javascript = prism.languages.extend("clike", {
  "class-name": [prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    // eslint-disable-next-line regexp/no-dupe-characters-character-class
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (prism.languages.markup) {
  prism.languages.markup.tag.addInlined("script", "javascript");
  prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
prism.languages.js = prism.languages.javascript;
(function(Prism2) {
  var comment = /#(?!\{).+/;
  var interpolation = {
    pattern: /#\{[^}]+\}/,
    alias: "variable"
  };
  Prism2.languages.coffeescript = Prism2.languages.extend("javascript", {
    "comment": comment,
    "string": [
      // Strings are multiline
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        greedy: true
      },
      {
        // Strings are multiline
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        greedy: true,
        inside: {
          "interpolation": interpolation
        }
      }
    ],
    "keyword": /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
    "class-member": {
      pattern: /@(?!\d)\w+/,
      alias: "variable"
    }
  });
  Prism2.languages.insertBefore("coffeescript", "comment", {
    "multiline-comment": {
      pattern: /###[\s\S]+?###/,
      alias: "comment"
    },
    // Block regexp can contain comments and interpolation
    "block-regex": {
      pattern: /\/{3}[\s\S]*?\/{3}/,
      alias: "regex",
      inside: {
        "comment": comment,
        "interpolation": interpolation
      }
    }
  });
  Prism2.languages.insertBefore("coffeescript", "string", {
    "inline-javascript": {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      inside: {
        "delimiter": {
          pattern: /^`|`$/,
          alias: "punctuation"
        },
        "script": {
          pattern: /[\s\S]+/,
          alias: "language-javascript",
          inside: Prism2.languages.javascript
        }
      }
    },
    // Block strings
    "multiline-string": [{
      pattern: /'''[\s\S]*?'''/,
      greedy: true,
      alias: "string"
    }, {
      pattern: /"""[\s\S]*?"""/,
      greedy: true,
      alias: "string",
      inside: {
        interpolation
      }
    }]
  });
  Prism2.languages.insertBefore("coffeescript", "keyword", {
    // Object property
    "property": /(?!\d)\w+(?=\s*:(?!:))/
  });
  delete Prism2.languages.coffeescript["template-string"];
  Prism2.languages.coffee = Prism2.languages.coffeescript;
})(prism);
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(prism);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: "keyword"
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        "code-block": {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        "code-language": {
          pattern: /^(```).+/,
          lookbehind: true
        },
        "punctuation": /```/
      }
    }],
    "title": [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: "important",
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: "important",
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token !== inside) {
        Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i2 = 0, l = tokens.length; i2 < l; i2++) {
        var token = tokens[i2];
        if (token.type !== "code") {
          walkTokens(token.content);
          continue;
        }
        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i2 = 0, l = env.classes.length; i2 < l; i2++) {
      var cls = env.classes[i2];
      var match2 = /language-(.+)/.exec(cls);
      if (match2) {
        codeLang = match2[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html) {
    var text2 = html.replace(tagPattern, "");
    text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
      code = code.toLowerCase();
      if (code[0] === "#") {
        var value;
        if (code[1] === "x") {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        }
        return m;
      }
    });
    return text2;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(prism);
prism.languages.graphql = {
  "comment": /#.*/,
  "description": {
    pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
    greedy: true,
    alias: "string",
    inside: {
      "language-markdown": {
        pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
        lookbehind: true,
        inside: prism.languages.markdown
      }
    }
  },
  "string": {
    pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
    greedy: true
  },
  "number": /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "boolean": /\b(?:false|true)\b/,
  "variable": /\$[a-z_]\w*/i,
  "directive": {
    pattern: /@[a-z_]\w*/i,
    alias: "function"
  },
  "attr-name": {
    pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
    greedy: true
  },
  "atom-input": {
    pattern: /\b[A-Z]\w*Input\b/,
    alias: "class-name"
  },
  "scalar": /\b(?:Boolean|Float|ID|Int|String)\b/,
  "constant": /\b[A-Z][A-Z_\d]*\b/,
  "class-name": {
    pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
    lookbehind: true
  },
  "fragment": {
    pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "definition-mutation": {
    pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "definition-query": {
    pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "keyword": /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
  "operator": /[!=|&]|\.{3}/,
  "property-query": /\w+(?=\s*\()/,
  "object": /\w+(?=\s*\{)/,
  "punctuation": /[!(){}\[\]:=,]/,
  "property": /\w+/
};
prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env) {
  if (env.language !== "graphql") {
    return;
  }
  var validTokens = env.tokens.filter(function(token) {
    return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
  });
  var currentIndex = 0;
  function getToken(offset) {
    return validTokens[currentIndex + offset];
  }
  function isTokenType(types, offset) {
    offset = offset || 0;
    for (var i3 = 0; i3 < types.length; i3++) {
      var token = getToken(i3 + offset);
      if (!token || token.type !== types[i3]) {
        return false;
      }
    }
    return true;
  }
  function findClosingBracket(open, close) {
    var stackHeight = 1;
    for (var i3 = currentIndex; i3 < validTokens.length; i3++) {
      var token = validTokens[i3];
      var content = token.content;
      if (token.type === "punctuation" && typeof content === "string") {
        if (open.test(content)) {
          stackHeight++;
        } else if (close.test(content)) {
          stackHeight--;
          if (stackHeight === 0) {
            return i3;
          }
        }
      }
    }
    return -1;
  }
  function addAlias(token, alias) {
    var aliases = token.alias;
    if (!aliases) {
      token.alias = aliases = [];
    } else if (!Array.isArray(aliases)) {
      token.alias = aliases = [aliases];
    }
    aliases.push(alias);
  }
  for (; currentIndex < validTokens.length; ) {
    var startToken = validTokens[currentIndex++];
    if (startToken.type === "keyword" && startToken.content === "mutation") {
      var inputVariables = [];
      if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
        currentIndex += 2;
        var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
        if (definitionEnd === -1) {
          continue;
        }
        for (; currentIndex < definitionEnd; currentIndex++) {
          var t2 = getToken(0);
          if (t2.type === "variable") {
            addAlias(t2, "variable-input");
            inputVariables.push(t2.content);
          }
        }
        currentIndex = definitionEnd + 1;
      }
      if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
        currentIndex++;
        addAlias(getToken(0), "property-mutation");
        if (inputVariables.length > 0) {
          var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
          if (mutationEnd === -1) {
            continue;
          }
          for (var i2 = currentIndex; i2 < mutationEnd; i2++) {
            var varToken = validTokens[i2];
            if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
              addAlias(varToken, "variable-input");
            }
          }
        }
      }
    }
  }
});
prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
(function(Prism2) {
  var templateString = Prism2.languages.javascript["template-string"];
  var templateLiteralPattern = templateString.pattern.source;
  var interpolationObject = templateString.inside["interpolation"];
  var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
  var interpolationPattern = interpolationObject.pattern.source;
  function createTemplate(language, tag) {
    if (!Prism2.languages[language]) {
      return void 0;
    }
    return {
      pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
      lookbehind: true,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "embedded-code": {
          pattern: /[\s\S]+/,
          alias: language
        }
      }
    };
  }
  Prism2.languages.javascript["template-string"] = [
    // styled-jsx:
    //   css`a { color: #25F; }`
    // styled-components:
    //   styled.h1`color: red;`
    createTemplate("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
    // html`<p></p>`
    // div.innerHTML = `<p></p>`
    createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
    // svg`<path fill="#fff" d="M55.37 ..."/>`
    createTemplate("svg", /\bsvg/.source),
    // md`# h1`, markdown`## h2`
    createTemplate("markdown", /\b(?:markdown|md)/.source),
    // gql`...`, graphql`...`, graphql.experimental`...`
    createTemplate("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
    // sql`...`
    createTemplate("sql", /\bsql/.source),
    // vanilla template string
    templateString
  ].filter(Boolean);
  function getPlaceholder(counter, language) {
    return "___" + language.toUpperCase() + "_" + counter + "___";
  }
  function tokenizeWithHooks(code, grammar, language) {
    var env = {
      code,
      grammar,
      language
    };
    Prism2.hooks.run("before-tokenize", env);
    env.tokens = Prism2.tokenize(env.code, env.grammar);
    Prism2.hooks.run("after-tokenize", env);
    return env.tokens;
  }
  function tokenizeInterpolationExpression(expression) {
    var tempGrammar = {};
    tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
    var tokens = Prism2.tokenize(expression, tempGrammar);
    if (tokens.length === 3) {
      var args = [1, 1];
      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism2.languages.javascript, "javascript"));
      tokens.splice.apply(tokens, args);
    }
    return new Prism2.Token("interpolation", tokens, interpolationObject.alias, expression);
  }
  function tokenizeEmbedded(code, grammar, language) {
    var _tokens = Prism2.tokenize(code, {
      "interpolation": {
        pattern: RegExp(interpolationPattern),
        lookbehind: true
      }
    });
    var placeholderCounter = 0;
    var placeholderMap = {};
    var embeddedCode = _tokens.map(function(token) {
      if (typeof token === "string") {
        return token;
      } else {
        var interpolationExpression = token.content;
        var placeholder;
        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {
        }
        placeholderMap[placeholder] = interpolationExpression;
        return placeholder;
      }
    }).join("");
    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);
    var placeholders = Object.keys(placeholderMap);
    placeholderCounter = 0;
    function walkTokens(tokens) {
      for (var i2 = 0; i2 < tokens.length; i2++) {
        if (placeholderCounter >= placeholders.length) {
          return;
        }
        var token = tokens[i2];
        if (typeof token === "string" || typeof token.content === "string") {
          var placeholder = placeholders[placeholderCounter];
          var s = typeof token === "string" ? token : (
            /** @type {string} */
            token.content
          );
          var index = s.indexOf(placeholder);
          if (index !== -1) {
            ++placeholderCounter;
            var before2 = s.substring(0, index);
            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
            var after2 = s.substring(index + placeholder.length);
            var replacement = [];
            if (before2) {
              replacement.push(before2);
            }
            replacement.push(middle);
            if (after2) {
              var afterTokens = [after2];
              walkTokens(afterTokens);
              replacement.push.apply(replacement, afterTokens);
            }
            if (typeof token === "string") {
              tokens.splice.apply(tokens, [i2, 1].concat(replacement));
              i2 += replacement.length - 1;
            } else {
              token.content = replacement;
            }
          }
        } else {
          var content = token.content;
          if (Array.isArray(content)) {
            walkTokens(content);
          } else {
            walkTokens([content]);
          }
        }
      }
    }
    walkTokens(embeddedTokens);
    return new Prism2.Token(language, embeddedTokens, "language-" + language, code);
  }
  var supportedLanguages = {
    "javascript": true,
    "js": true,
    "typescript": true,
    "ts": true,
    "jsx": true,
    "tsx": true
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (!(env.language in supportedLanguages)) {
      return;
    }
    function findTemplateStrings(tokens) {
      for (var i2 = 0, l = tokens.length; i2 < l; i2++) {
        var token = tokens[i2];
        if (typeof token === "string") {
          continue;
        }
        var content = token.content;
        if (!Array.isArray(content)) {
          if (typeof content !== "string") {
            findTemplateStrings([content]);
          }
          continue;
        }
        if (token.type === "template-string") {
          var embedded = content[1];
          if (content.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
            var code = stringContent(embedded);
            var alias = embedded.alias;
            var language = Array.isArray(alias) ? alias[0] : alias;
            var grammar = Prism2.languages[language];
            if (!grammar) {
              continue;
            }
            content[1] = tokenizeEmbedded(code, grammar, language);
          }
        } else {
          findTemplateStrings(content);
        }
      }
    }
    findTemplateStrings(env.tokens);
  });
  function stringContent(value) {
    if (typeof value === "string") {
      return value;
    } else if (Array.isArray(value)) {
      return value.map(stringContent).join("");
    } else {
      return stringContent(value.content);
    }
  }
})(prism);
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(prism);
(function(Prism2) {
  Prism2.languages.insertBefore("javascript", "function-variable", {
    "method-variable": {
      pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source),
      lookbehind: true,
      alias: ["function-variable", "method", "function", "property-access"]
    }
  });
  Prism2.languages.insertBefore("javascript", "function", {
    "method": {
      pattern: RegExp("(\\.\\s*)" + Prism2.languages.javascript["function"].source),
      lookbehind: true,
      alias: ["function", "property-access"]
    }
  });
  Prism2.languages.insertBefore("javascript", "constant", {
    "known-class-name": [{
      // standard built-ins
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
      pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
      alias: "class-name"
    }, {
      // errors
      pattern: /\b(?:[A-Z]\w*)Error\b/,
      alias: "class-name"
    }]
  });
  function withId(source, flags) {
    return RegExp(source.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), flags);
  }
  Prism2.languages.insertBefore("javascript", "keyword", {
    "imports": {
      // https://tc39.es/ecma262/#sec-imports
      pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
      lookbehind: true,
      inside: Prism2.languages.javascript
    },
    "exports": {
      // https://tc39.es/ecma262/#sec-exports
      pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
      lookbehind: true,
      inside: Prism2.languages.javascript
    }
  });
  Prism2.languages.javascript["keyword"].unshift({
    pattern: /\b(?:as|default|export|from|import)\b/,
    alias: "module"
  }, {
    pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
    alias: "control-flow"
  }, {
    pattern: /\bnull\b/,
    alias: ["null", "nil"]
  }, {
    pattern: /\bundefined\b/,
    alias: "nil"
  });
  Prism2.languages.insertBefore("javascript", "operator", {
    "spread": {
      pattern: /\.{3}/,
      alias: "operator"
    },
    "arrow": {
      pattern: /=>/,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("javascript", "punctuation", {
    "property-access": {
      pattern: withId(/(\.\s*)#?<ID>/.source),
      lookbehind: true
    },
    "maybe-class-name": {
      pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
      lookbehind: true
    },
    "dom": {
      // this contains only a few commonly used DOM variables
      pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
      alias: "variable"
    },
    "console": {
      pattern: /\bconsole(?=\s*\.)/,
      alias: "class-name"
    }
  });
  var maybeClassNameTokens = ["function", "function-variable", "method", "method-variable", "property-access"];
  for (var i2 = 0; i2 < maybeClassNameTokens.length; i2++) {
    var token = maybeClassNameTokens[i2];
    var value = Prism2.languages.javascript[token];
    if (Prism2.util.type(value) === "RegExp") {
      value = Prism2.languages.javascript[token] = {
        pattern: value
      };
    }
    var inside = value.inside || {};
    value.inside = inside;
    inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
})(prism);
(function(Prism2) {
  var javascript = Prism2.util.clone(Prism2.languages.javascript);
  var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function re2(source, flags) {
    source = source.replace(/<S>/g, function() {
      return space;
    }).replace(/<BRACES>/g, function() {
      return braces;
    }).replace(/<SPREAD>/g, function() {
      return spread2;
    });
    return RegExp(source, flags);
  }
  spread2 = re2(spread2).source;
  Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
  Prism2.languages.jsx.tag.pattern = re2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
  Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
  Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
  Prism2.languages.insertBefore("inside", "attr-name", {
    "spread": {
      pattern: re2(/<SPREAD>/.source),
      inside: Prism2.languages.jsx
    }
  }, Prism2.languages.jsx.tag);
  Prism2.languages.insertBefore("inside", "special-attr", {
    "script": {
      // Allow for two levels of nesting
      pattern: re2(/=<BRACES>/.source),
      alias: "language-javascript",
      inside: {
        "script-punctuation": {
          pattern: /^=(?=\{)/,
          alias: "punctuation"
        },
        rest: Prism2.languages.jsx
      }
    }
  }, Prism2.languages.jsx.tag);
  var stringifyToken = function(token) {
    if (!token) {
      return "";
    }
    if (typeof token === "string") {
      return token;
    }
    if (typeof token.content === "string") {
      return token.content;
    }
    return token.content.map(stringifyToken).join("");
  };
  var walkTokens = function(tokens) {
    var openedTags = [];
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      var notTagNorBrace = false;
      if (typeof token !== "string") {
        if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
          if (token.content[0].content[0].content === "</") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
              openedTags.pop();
            }
          } else {
            if (token.content[token.content.length - 1].content === "/>")
              ;
            else {
              openedTags.push({
                tagName: stringifyToken(token.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token === "string") {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          var plainText = stringifyToken(token);
          if (i2 < tokens.length - 1 && (typeof tokens[i2 + 1] === "string" || tokens[i2 + 1].type === "plain-text")) {
            plainText += stringifyToken(tokens[i2 + 1]);
            tokens.splice(i2 + 1, 1);
          }
          if (i2 > 0 && (typeof tokens[i2 - 1] === "string" || tokens[i2 - 1].type === "plain-text")) {
            plainText = stringifyToken(tokens[i2 - 1]) + plainText;
            tokens.splice(i2 - 1, 1);
            i2--;
          }
          tokens[i2] = new Prism2.Token("plain-text", plainText, null, plainText);
        }
      }
      if (token.content && typeof token.content !== "string") {
        walkTokens(token.content);
      }
    }
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "jsx" && env.language !== "tsx") {
      return;
    }
    walkTokens(env.tokens);
  });
})(prism);
(function(Prism2) {
  Prism2.languages.diff = {
    "coord": [
      // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
      /^(?:\*{3}|-{3}|\+{3}).*$/m,
      // Match "@@ ... @@" coord lines in unified diff.
      /^@@.*@@$/m,
      // Match coord lines in normal diff (starts with a number).
      /^\d.*$/m
    ]
    // deleted, inserted, unchanged, diff
  };
  var PREFIXES = {
    "deleted-sign": "-",
    "deleted-arrow": "<",
    "inserted-sign": "+",
    "inserted-arrow": ">",
    "unchanged": " ",
    "diff": "!"
  };
  Object.keys(PREFIXES).forEach(function(name) {
    var prefix = PREFIXES[name];
    var alias = [];
    if (!/^\w+$/.test(name)) {
      alias.push(/\w+/.exec(name)[0]);
    }
    if (name === "diff") {
      alias.push("bold");
    }
    Prism2.languages.diff[name] = {
      pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
      alias,
      inside: {
        "line": {
          pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
          lookbehind: true
        },
        "prefix": {
          pattern: /[\s\S]/,
          alias: /\w+/.exec(name)[0]
        }
      }
    };
  });
  Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
    value: PREFIXES
  });
})(prism);
prism.languages.git = {
  /*
   * A simple one line comment like in a git status command
   * For instance:
   * $ git status
   * # On branch infinite-scroll
   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
   * # and have 1 and 2 different commits each, respectively.
   * nothing to commit (working directory clean)
   */
  "comment": /^#.*/m,
  /*
   * Regexp to match the changed lines in a git diff output. Check the example below.
   */
  "deleted": /^[-â].*/m,
  "inserted": /^\+.*/m,
  /*
   * a string (double and simple quote)
   */
  "string": /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
  /*
   * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
   * For instance:
   * $ git add file.txt
   */
  "command": {
    pattern: /^.*\$ git .*$/m,
    inside: {
      /*
       * A git command can contain a parameter starting by a single or a double dash followed by a string
       * For instance:
       * $ git diff --cached
       * $ git log -p
       */
      "parameter": /\s--?\w+/
    }
  },
  /*
   * Coordinates displayed in a git diff command
   * For instance:
   * $ git diff
   * diff --git file.txt file.txt
   * index 6214953..1d54a52 100644
   * --- file.txt
   * +++ file.txt
   * @@ -1 +1,2 @@
   * -Here's my tetx file
   * +Here's my text file
   * +And this is the second line
   */
  "coord": /^@@.*@@$/m,
  /*
   * Match a "commit [SHA1]" line in a git log output.
   * For instance:
   * $ git log
   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
   * Author: lgiraudel
   * Date:   Mon Feb 17 11:18:34 2014 +0100
   *
   *     Add of a new line
   */
  "commit-sha1": /^commit \w{40}$/m
};
prism.languages.go = prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete prism.languages.go["class-name"];
(function(Prism2) {
  function getPlaceholder(language, index) {
    return "___" + language.toUpperCase() + index + "___";
  }
  Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
    buildPlaceholders: {
      /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */
      value: function(env, language, placeholderPattern, replaceFilter) {
        if (env.language !== language) {
          return;
        }
        var tokenStack = env.tokenStack = [];
        env.code = env.code.replace(placeholderPattern, function(match2) {
          if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
            return match2;
          }
          var i2 = tokenStack.length;
          var placeholder;
          while (env.code.indexOf(placeholder = getPlaceholder(language, i2)) !== -1) {
            ++i2;
          }
          tokenStack[i2] = match2;
          return placeholder;
        });
        env.grammar = Prism2.languages.markup;
      }
    },
    tokenizePlaceholders: {
      /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */
      value: function(env, language) {
        if (env.language !== language || !env.tokenStack) {
          return;
        }
        env.grammar = Prism2.languages[language];
        var j2 = 0;
        var keys = Object.keys(env.tokenStack);
        function walkTokens(tokens) {
          for (var i2 = 0; i2 < tokens.length; i2++) {
            if (j2 >= keys.length) {
              break;
            }
            var token = tokens[i2];
            if (typeof token === "string" || token.content && typeof token.content === "string") {
              var k = keys[j2];
              var t2 = env.tokenStack[k];
              var s = typeof token === "string" ? token : token.content;
              var placeholder = getPlaceholder(language, k);
              var index = s.indexOf(placeholder);
              if (index > -1) {
                ++j2;
                var before2 = s.substring(0, index);
                var middle = new Prism2.Token(language, Prism2.tokenize(t2, env.grammar), "language-" + language, t2);
                var after2 = s.substring(index + placeholder.length);
                var replacement = [];
                if (before2) {
                  replacement.push.apply(replacement, walkTokens([before2]));
                }
                replacement.push(middle);
                if (after2) {
                  replacement.push.apply(replacement, walkTokens([after2]));
                }
                if (typeof token === "string") {
                  tokens.splice.apply(tokens, [i2, 1].concat(replacement));
                } else {
                  token.content = replacement;
                }
              }
            } else if (token.content) {
              walkTokens(token.content);
            }
          }
          return tokens;
        }
        walkTokens(env.tokens);
      }
    }
  });
})(prism);
(function(Prism2) {
  Prism2.languages.handlebars = {
    "comment": /\{\{![\s\S]*?\}\}/,
    "delimiter": {
      pattern: /^\{\{\{?|\}\}\}?$/,
      alias: "punctuation"
    },
    "string": /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    "boolean": /\b(?:false|true)\b/,
    "block": {
      pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
      lookbehind: true,
      alias: "keyword"
    },
    "brackets": {
      pattern: /\[[^\]]+\]/,
      inside: {
        punctuation: /\[|\]/,
        variable: /[\s\S]+/
      }
    },
    "punctuation": /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
    "variable": /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
  };
  Prism2.hooks.add("before-tokenize", function(env) {
    var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
    Prism2.languages["markup-templating"].buildPlaceholders(env, "handlebars", handlebarsPattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    Prism2.languages["markup-templating"].tokenizePlaceholders(env, "handlebars");
  });
  Prism2.languages.hbs = Prism2.languages.handlebars;
})(prism);
prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
prism.languages.webmanifest = prism.languages.json;
prism.languages.less = prism.languages.extend("css", {
  "comment": [/\/\*[\s\S]*?\*\//, {
    pattern: /(^|[^\\])\/\/.*/,
    lookbehind: true
  }],
  "atrule": {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "punctuation": /[:()]/
    }
  },
  // selectors and mixins are considered the same
  "selector": {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      // mixin parameters
      "variable": /@+[\w-]+/
    }
  },
  "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  "operator": /[+\-*\/]/
});
prism.languages.insertBefore("less", "property", {
  "variable": [
    // Variable declaration (the colon must be consumed!)
    {
      pattern: /@[\w-]+\s*:/,
      inside: {
        "punctuation": /:/
      }
    },
    // Variable usage
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
});
prism.languages.makefile = {
  "comment": {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  "target": {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: {
      "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  "function": {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  "operator": /(?:::|[?:+!])?=|[|@]/,
  "punctuation": /[:;(){}]/
};
prism.languages.objectivec = prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete prism.languages.objectivec["class-name"];
prism.languages.objc = prism.languages.objectivec;
prism.languages.ocaml = {
  "comment": {
    pattern: /\(\*[\s\S]*?\*\)/,
    greedy: true
  },
  "char": {
    pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
    greedy: true
  },
  "string": [{
    pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
    greedy: true
  }, {
    pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
    greedy: true
  }],
  "number": [
    // binary and octal
    /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
    // hexadecimal
    /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
    // decimal
    /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
  ],
  "directive": {
    pattern: /\B#\w+/,
    alias: "property"
  },
  "label": {
    pattern: /\B~\w+/,
    alias: "property"
  },
  "type-variable": {
    pattern: /\B'\w+/,
    alias: "function"
  },
  "variant": {
    pattern: /`\w+/,
    alias: "symbol"
  },
  // For the list of keywords and operators,
  // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
  "keyword": /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
  "boolean": /\b(?:false|true)\b/,
  "operator-like-punctuation": {
    pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
    alias: "punctuation"
  },
  // Custom operators are allowed
  "operator": /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
  "punctuation": /;;|::|[(){}\[\].,:;#]|\b_\b/
};
prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = prism.languages.python;
prism.languages.py = prism.languages.python;
prism.languages.reason = prism.languages.extend("clike", {
  "string": {
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
    greedy: true
  },
  // 'class-name' must be matched *after* 'constructor' defined below
  "class-name": /\b[A-Z]\w*/,
  "keyword": /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
  "operator": /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
});
prism.languages.insertBefore("reason", "class-name", {
  "char": {
    pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
    greedy: true
  },
  // Negative look-ahead prevents from matching things like String.capitalize
  "constructor": /\b[A-Z]\w*\b(?!\s*\.)/,
  "label": {
    pattern: /\b[a-z]\w*(?=::)/,
    alias: "symbol"
  }
});
delete prism.languages.reason.function;
(function(Prism2) {
  Prism2.languages.sass = Prism2.languages.extend("css", {
    // Sass comments don't need to be closed, only indented
    "comment": {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("sass", "atrule", {
    // We want to consume the whole line
    "atrule-line": {
      // Includes support for = and + shortcuts
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: {
        "atrule": /(?:@[\w-]+|[+=])/
      }
    }
  });
  delete Prism2.languages.sass.atrule;
  var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
  var operator = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
    pattern: /(\s)-(?=\s)/,
    lookbehind: true
  }];
  Prism2.languages.insertBefore("sass", "property", {
    // We want to consume the whole line
    "variable-line": {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: {
        "punctuation": /:/,
        "variable": variable,
        "operator": operator
      }
    },
    // We want to consume the whole line
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        "property": [/[^:\s]+(?=\s*:)/, {
          pattern: /(:)[^:\s]+/,
          lookbehind: true
        }],
        "punctuation": /:/,
        "variable": variable,
        "operator": operator,
        "important": Prism2.languages.sass.important
      }
    }
  });
  delete Prism2.languages.sass.property;
  delete Prism2.languages.sass.important;
  Prism2.languages.insertBefore("sass", "punctuation", {
    "selector": {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
})(prism);
prism.languages.scss = prism.languages.extend("css", {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  "atrule": {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      "rule": /@[\w-]+/
      // See rest below
    }
  },
  // url, compassified
  "url": /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  "selector": {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      "parent": {
        pattern: /&/,
        alias: "important"
      },
      "placeholder": /%[-\w]+/,
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  "property": {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
prism.languages.insertBefore("scss", "atrule", {
  "keyword": [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
    pattern: /( )(?:from|through)(?= )/,
    lookbehind: true
  }]
});
prism.languages.insertBefore("scss", "important", {
  // var and interpolated vars
  "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  "placeholder": {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  "statement": {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  "operator": {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
prism.languages.scss["atrule"].inside.rest = prism.languages.scss;
(function(Prism2) {
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+)/,
    lookbehind: true
  };
  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  var inside = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    "url": {
      pattern: /\burl\((["']?).*?\1\)/i,
      greedy: true
    },
    "string": {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    "interpolation": null,
    // See below
    "func": null,
    // See below
    "important": /\B!(?:important|optional)\b/i,
    "keyword": {
      pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
      lookbehind: true
    },
    "hexcode": /#[\da-f]{3,6}/i,
    "color": [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        "unit": unit,
        "number": number,
        "function": /[\w-]+(?=\()/,
        "punctuation": /[(),]/
      }
    }],
    "entity": /\\[\da-f]{1,8}/i,
    "unit": unit,
    "boolean": /\b(?:false|true)\b/,
    "operator": [
      // We want non-word chars around "-" because it is
      // accepted in property names.
      /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
    ],
    "number": number,
    "punctuation": /[{}()\[\];:,]/
  };
  inside["interpolation"] = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: "variable",
    inside: {
      "delimiter": {
        pattern: /^\{|\}$/,
        alias: "punctuation"
      },
      rest: inside
    }
  };
  inside["func"] = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: {
      "function": /^[^(]+/,
      rest: inside
    }
  };
  Prism2.languages.stylus = {
    "atrule-declaration": {
      pattern: /(^[ \t]*)@.+/m,
      lookbehind: true,
      inside: {
        "atrule": /^@[\w-]+/,
        rest: inside
      }
    },
    "variable-declaration": {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
      lookbehind: true,
      inside: {
        "variable": /^\S+/,
        rest: inside
      }
    },
    "statement": {
      pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
      lookbehind: true,
      inside: {
        "keyword": /^\S+/,
        rest: inside
      }
    },
    // A property/value pair cannot end with a comma or a brace
    // It cannot have indented content unless it ended with a semicolon
    "property-declaration": {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
      lookbehind: true,
      inside: {
        "property": {
          pattern: /^[^\s:]+/,
          inside: {
            "interpolation": inside.interpolation
          }
        },
        rest: inside
      }
    },
    // A selector can contain parentheses only as part of a pseudo-element
    // It can span multiple lines.
    // It must end with a comma or an accolade or have indented content.
    "selector": {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
      lookbehind: true,
      inside: {
        "interpolation": inside.interpolation,
        "comment": inside.comment,
        "punctuation": /[{},]/
      }
    },
    "func": inside.func,
    "string": inside.string,
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true,
      greedy: true
    },
    "interpolation": inside.interpolation,
    "punctuation": /[{}()\[\];:.]/
  };
})(prism);
(function(Prism2) {
  var typescript = Prism2.util.clone(Prism2.languages.typescript);
  Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
  delete Prism2.languages.tsx["parameter"];
  delete Prism2.languages.tsx["literal-property"];
  var tag = Prism2.languages.tsx.tag;
  tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
  tag.lookbehind = true;
})(prism);
prism.languages.wasm = {
  "comment": [/\(;[\s\S]*?;\)/, {
    pattern: /;;.*/,
    greedy: true
  }],
  "string": {
    pattern: /"(?:\\[\s\S]|[^"\\])*"/,
    greedy: true
  },
  "keyword": [{
    pattern: /\b(?:align|offset)=/,
    inside: {
      "operator": /=/
    }
  }, {
    pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
    inside: {
      "punctuation": /\./
    }
  }, /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/],
  "variable": /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
  "number": /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
  "punctuation": /[()]/
};
var prism_default = prism;

// node_modules/prism-react-renderer/themes/duotoneDark/index.js
var theme = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
    style: {
      color: "#6c6783"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["tag", "operator", "number"],
    style: {
      color: "#e09142"
    }
  }, {
    types: ["property", "function"],
    style: {
      color: "#9a86fd"
    }
  }, {
    types: ["tag-id", "selector", "atrule-id"],
    style: {
      color: "#eeebff"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "#c4b9fe"
    }
  }, {
    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule", "placeholder", "variable"],
    style: {
      color: "#ffcc99"
    }
  }, {
    types: ["deleted"],
    style: {
      textDecorationLine: "line-through"
    }
  }, {
    types: ["inserted"],
    style: {
      textDecorationLine: "underline"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["important", "bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["important"],
    style: {
      color: "#c4b9fe"
    }
  }]
};
var duotoneDark_default = theme;

// node_modules/prism-react-renderer/dist/index.js
var import_react = __toESM(require_react());
var defaultProps = {
  // $FlowFixMe
  Prism: prism_default,
  theme: duotoneDark_default
};
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var newlineRe = /\r\n|\r|\n/;
var normalizeEmptyLines = function(line) {
  if (line.length === 0) {
    line.push({
      types: ["plain"],
      content: "\n",
      empty: true
    });
  } else if (line.length === 1 && line[0].content === "") {
    line[0].content = "\n";
    line[0].empty = true;
  }
};
var appendTypes = function(types, add2) {
  var typesSize = types.length;
  if (typesSize > 0 && types[typesSize - 1] === add2) {
    return types;
  }
  return types.concat(add2);
};
var normalizeTokens = function(tokens) {
  var typeArrStack = [[]];
  var tokenArrStack = [tokens];
  var tokenArrIndexStack = [0];
  var tokenArrSizeStack = [tokens.length];
  var i2 = 0;
  var stackIndex = 0;
  var currentLine = [];
  var acc = [currentLine];
  while (stackIndex > -1) {
    while ((i2 = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
      var content = void 0;
      var types = typeArrStack[stackIndex];
      var tokenArr = tokenArrStack[stackIndex];
      var token = tokenArr[i2];
      if (typeof token === "string") {
        types = stackIndex > 0 ? types : ["plain"];
        content = token;
      } else {
        types = appendTypes(types, token.type);
        if (token.alias) {
          types = appendTypes(types, token.alias);
        }
        content = token.content;
      }
      if (typeof content !== "string") {
        stackIndex++;
        typeArrStack.push(types);
        tokenArrStack.push(content);
        tokenArrIndexStack.push(0);
        tokenArrSizeStack.push(content.length);
        continue;
      }
      var splitByNewlines = content.split(newlineRe);
      var newlineCount = splitByNewlines.length;
      currentLine.push({
        types,
        content: splitByNewlines[0]
      });
      for (var i$1 = 1; i$1 < newlineCount; i$1++) {
        normalizeEmptyLines(currentLine);
        acc.push(currentLine = []);
        currentLine.push({
          types,
          content: splitByNewlines[i$1]
        });
      }
    }
    stackIndex--;
    typeArrStack.pop();
    tokenArrStack.pop();
    tokenArrIndexStack.pop();
    tokenArrSizeStack.pop();
  }
  normalizeEmptyLines(currentLine);
  return acc;
};
var themeToDict = function(theme3, language) {
  var plain = theme3.plain;
  var base = /* @__PURE__ */ Object.create(null);
  var themeDict = theme3.styles.reduce(function(acc, themeEntry) {
    var languages = themeEntry.languages;
    var style = themeEntry.style;
    if (languages && !languages.includes(language)) {
      return acc;
    }
    themeEntry.types.forEach(function(type) {
      var accStyle = _extends({}, acc[type], style);
      acc[type] = accStyle;
    });
    return acc;
  }, base);
  themeDict.root = plain;
  themeDict.plain = _extends({}, plain, {
    backgroundColor: null
  });
  return themeDict;
};
function objectWithoutProperties(obj, exclude) {
  var target = {};
  for (var k in obj)
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1)
      target[k] = obj[k];
  return target;
}
var Highlight = function(Component3) {
  function Highlight2() {
    var this$1 = this;
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    Component3.apply(this, args);
    _defineProperty(this, "getThemeDict", function(props) {
      if (this$1.themeDict !== void 0 && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {
        return this$1.themeDict;
      }
      this$1.prevTheme = props.theme;
      this$1.prevLanguage = props.language;
      var themeDict = props.theme ? themeToDict(props.theme, props.language) : void 0;
      return this$1.themeDict = themeDict;
    });
    _defineProperty(this, "getLineProps", function(ref) {
      var key = ref.key;
      var className = ref.className;
      var style = ref.style;
      var rest$1 = objectWithoutProperties(ref, ["key", "className", "style", "line"]);
      var rest2 = rest$1;
      var output = _extends({}, rest2, {
        className: "token-line",
        style: void 0,
        key: void 0
      });
      var themeDict = this$1.getThemeDict(this$1.props);
      if (themeDict !== void 0) {
        output.style = themeDict.plain;
      }
      if (style !== void 0) {
        output.style = output.style !== void 0 ? _extends({}, output.style, style) : style;
      }
      if (key !== void 0) {
        output.key = key;
      }
      if (className) {
        output.className += " " + className;
      }
      return output;
    });
    _defineProperty(this, "getStyleForToken", function(ref) {
      var types = ref.types;
      var empty = ref.empty;
      var typesSize = types.length;
      var themeDict = this$1.getThemeDict(this$1.props);
      if (themeDict === void 0) {
        return void 0;
      } else if (typesSize === 1 && types[0] === "plain") {
        return empty ? {
          display: "inline-block"
        } : void 0;
      } else if (typesSize === 1 && !empty) {
        return themeDict[types[0]];
      }
      var baseStyle = empty ? {
        display: "inline-block"
      } : {};
      var typeStyles = types.map(function(type) {
        return themeDict[type];
      });
      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));
    });
    _defineProperty(this, "getTokenProps", function(ref) {
      var key = ref.key;
      var className = ref.className;
      var style = ref.style;
      var token = ref.token;
      var rest$1 = objectWithoutProperties(ref, ["key", "className", "style", "token"]);
      var rest2 = rest$1;
      var output = _extends({}, rest2, {
        className: "token " + token.types.join(" "),
        children: token.content,
        style: this$1.getStyleForToken(token),
        key: void 0
      });
      if (style !== void 0) {
        output.style = output.style !== void 0 ? _extends({}, output.style, style) : style;
      }
      if (key !== void 0) {
        output.key = key;
      }
      if (className) {
        output.className += " " + className;
      }
      return output;
    });
    _defineProperty(this, "tokenize", function(Prism2, code, grammar, language) {
      var env = {
        code,
        grammar,
        language,
        tokens: []
      };
      Prism2.hooks.run("before-tokenize", env);
      var tokens = env.tokens = Prism2.tokenize(env.code, env.grammar, env.language);
      Prism2.hooks.run("after-tokenize", env);
      return tokens;
    });
  }
  if (Component3)
    Highlight2.__proto__ = Component3;
  Highlight2.prototype = Object.create(Component3 && Component3.prototype);
  Highlight2.prototype.constructor = Highlight2;
  Highlight2.prototype.render = function render() {
    var ref = this.props;
    var Prism2 = ref.Prism;
    var language = ref.language;
    var code = ref.code;
    var children = ref.children;
    var themeDict = this.getThemeDict(this.props);
    var grammar = Prism2.languages[language];
    var mixedTokens = grammar !== void 0 ? this.tokenize(Prism2, code, grammar, language) : [code];
    var tokens = normalizeTokens(mixedTokens);
    return children({
      tokens,
      className: "prism-code language-" + language,
      style: themeDict !== void 0 ? themeDict.root : {},
      getLineProps: this.getLineProps,
      getTokenProps: this.getTokenProps
    });
  };
  return Highlight2;
}(import_react.Component);
var dist_default = Highlight;

// node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js
var ContextualKeyword;
(function(ContextualKeyword2) {
  const NONE = 0;
  ContextualKeyword2[ContextualKeyword2["NONE"] = NONE] = "NONE";
  const _abstract = NONE + 1;
  ContextualKeyword2[ContextualKeyword2["_abstract"] = _abstract] = "_abstract";
  const _accessor = _abstract + 1;
  ContextualKeyword2[ContextualKeyword2["_accessor"] = _accessor] = "_accessor";
  const _as = _accessor + 1;
  ContextualKeyword2[ContextualKeyword2["_as"] = _as] = "_as";
  const _assert = _as + 1;
  ContextualKeyword2[ContextualKeyword2["_assert"] = _assert] = "_assert";
  const _asserts = _assert + 1;
  ContextualKeyword2[ContextualKeyword2["_asserts"] = _asserts] = "_asserts";
  const _async = _asserts + 1;
  ContextualKeyword2[ContextualKeyword2["_async"] = _async] = "_async";
  const _await = _async + 1;
  ContextualKeyword2[ContextualKeyword2["_await"] = _await] = "_await";
  const _checks = _await + 1;
  ContextualKeyword2[ContextualKeyword2["_checks"] = _checks] = "_checks";
  const _constructor = _checks + 1;
  ContextualKeyword2[ContextualKeyword2["_constructor"] = _constructor] = "_constructor";
  const _declare = _constructor + 1;
  ContextualKeyword2[ContextualKeyword2["_declare"] = _declare] = "_declare";
  const _enum = _declare + 1;
  ContextualKeyword2[ContextualKeyword2["_enum"] = _enum] = "_enum";
  const _exports = _enum + 1;
  ContextualKeyword2[ContextualKeyword2["_exports"] = _exports] = "_exports";
  const _from = _exports + 1;
  ContextualKeyword2[ContextualKeyword2["_from"] = _from] = "_from";
  const _get = _from + 1;
  ContextualKeyword2[ContextualKeyword2["_get"] = _get] = "_get";
  const _global = _get + 1;
  ContextualKeyword2[ContextualKeyword2["_global"] = _global] = "_global";
  const _implements = _global + 1;
  ContextualKeyword2[ContextualKeyword2["_implements"] = _implements] = "_implements";
  const _infer = _implements + 1;
  ContextualKeyword2[ContextualKeyword2["_infer"] = _infer] = "_infer";
  const _interface = _infer + 1;
  ContextualKeyword2[ContextualKeyword2["_interface"] = _interface] = "_interface";
  const _is = _interface + 1;
  ContextualKeyword2[ContextualKeyword2["_is"] = _is] = "_is";
  const _keyof = _is + 1;
  ContextualKeyword2[ContextualKeyword2["_keyof"] = _keyof] = "_keyof";
  const _mixins = _keyof + 1;
  ContextualKeyword2[ContextualKeyword2["_mixins"] = _mixins] = "_mixins";
  const _module = _mixins + 1;
  ContextualKeyword2[ContextualKeyword2["_module"] = _module] = "_module";
  const _namespace = _module + 1;
  ContextualKeyword2[ContextualKeyword2["_namespace"] = _namespace] = "_namespace";
  const _of = _namespace + 1;
  ContextualKeyword2[ContextualKeyword2["_of"] = _of] = "_of";
  const _opaque = _of + 1;
  ContextualKeyword2[ContextualKeyword2["_opaque"] = _opaque] = "_opaque";
  const _out = _opaque + 1;
  ContextualKeyword2[ContextualKeyword2["_out"] = _out] = "_out";
  const _override = _out + 1;
  ContextualKeyword2[ContextualKeyword2["_override"] = _override] = "_override";
  const _private = _override + 1;
  ContextualKeyword2[ContextualKeyword2["_private"] = _private] = "_private";
  const _protected = _private + 1;
  ContextualKeyword2[ContextualKeyword2["_protected"] = _protected] = "_protected";
  const _proto = _protected + 1;
  ContextualKeyword2[ContextualKeyword2["_proto"] = _proto] = "_proto";
  const _public = _proto + 1;
  ContextualKeyword2[ContextualKeyword2["_public"] = _public] = "_public";
  const _readonly = _public + 1;
  ContextualKeyword2[ContextualKeyword2["_readonly"] = _readonly] = "_readonly";
  const _require = _readonly + 1;
  ContextualKeyword2[ContextualKeyword2["_require"] = _require] = "_require";
  const _satisfies = _require + 1;
  ContextualKeyword2[ContextualKeyword2["_satisfies"] = _satisfies] = "_satisfies";
  const _set = _satisfies + 1;
  ContextualKeyword2[ContextualKeyword2["_set"] = _set] = "_set";
  const _static = _set + 1;
  ContextualKeyword2[ContextualKeyword2["_static"] = _static] = "_static";
  const _symbol = _static + 1;
  ContextualKeyword2[ContextualKeyword2["_symbol"] = _symbol] = "_symbol";
  const _type = _symbol + 1;
  ContextualKeyword2[ContextualKeyword2["_type"] = _type] = "_type";
  const _unique = _type + 1;
  ContextualKeyword2[ContextualKeyword2["_unique"] = _unique] = "_unique";
  const _using = _unique + 1;
  ContextualKeyword2[ContextualKeyword2["_using"] = _using] = "_using";
})(ContextualKeyword || (ContextualKeyword = {}));

// node_modules/sucrase/dist/esm/parser/tokenizer/types.js
var TokenType;
(function(TokenType2) {
  const PRECEDENCE_MASK = 15;
  TokenType2[TokenType2["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
  const IS_KEYWORD = 1 << 4;
  TokenType2[TokenType2["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
  const IS_ASSIGN = 1 << 5;
  TokenType2[TokenType2["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
  const IS_RIGHT_ASSOCIATIVE = 1 << 6;
  TokenType2[TokenType2["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
  const IS_PREFIX = 1 << 7;
  TokenType2[TokenType2["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
  const IS_POSTFIX = 1 << 8;
  TokenType2[TokenType2["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
  const IS_EXPRESSION_START = 1 << 9;
  TokenType2[TokenType2["IS_EXPRESSION_START"] = IS_EXPRESSION_START] = "IS_EXPRESSION_START";
  const num = 512;
  TokenType2[TokenType2["num"] = num] = "num";
  const bigint = 1536;
  TokenType2[TokenType2["bigint"] = bigint] = "bigint";
  const decimal = 2560;
  TokenType2[TokenType2["decimal"] = decimal] = "decimal";
  const regexp = 3584;
  TokenType2[TokenType2["regexp"] = regexp] = "regexp";
  const string = 4608;
  TokenType2[TokenType2["string"] = string] = "string";
  const name = 5632;
  TokenType2[TokenType2["name"] = name] = "name";
  const eof = 6144;
  TokenType2[TokenType2["eof"] = eof] = "eof";
  const bracketL = 7680;
  TokenType2[TokenType2["bracketL"] = bracketL] = "bracketL";
  const bracketR = 8192;
  TokenType2[TokenType2["bracketR"] = bracketR] = "bracketR";
  const braceL = 9728;
  TokenType2[TokenType2["braceL"] = braceL] = "braceL";
  const braceBarL = 10752;
  TokenType2[TokenType2["braceBarL"] = braceBarL] = "braceBarL";
  const braceR = 11264;
  TokenType2[TokenType2["braceR"] = braceR] = "braceR";
  const braceBarR = 12288;
  TokenType2[TokenType2["braceBarR"] = braceBarR] = "braceBarR";
  const parenL = 13824;
  TokenType2[TokenType2["parenL"] = parenL] = "parenL";
  const parenR = 14336;
  TokenType2[TokenType2["parenR"] = parenR] = "parenR";
  const comma = 15360;
  TokenType2[TokenType2["comma"] = comma] = "comma";
  const semi = 16384;
  TokenType2[TokenType2["semi"] = semi] = "semi";
  const colon = 17408;
  TokenType2[TokenType2["colon"] = colon] = "colon";
  const doubleColon = 18432;
  TokenType2[TokenType2["doubleColon"] = doubleColon] = "doubleColon";
  const dot = 19456;
  TokenType2[TokenType2["dot"] = dot] = "dot";
  const question = 20480;
  TokenType2[TokenType2["question"] = question] = "question";
  const questionDot = 21504;
  TokenType2[TokenType2["questionDot"] = questionDot] = "questionDot";
  const arrow = 22528;
  TokenType2[TokenType2["arrow"] = arrow] = "arrow";
  const template2 = 23552;
  TokenType2[TokenType2["template"] = template2] = "template";
  const ellipsis = 24576;
  TokenType2[TokenType2["ellipsis"] = ellipsis] = "ellipsis";
  const backQuote = 25600;
  TokenType2[TokenType2["backQuote"] = backQuote] = "backQuote";
  const dollarBraceL = 27136;
  TokenType2[TokenType2["dollarBraceL"] = dollarBraceL] = "dollarBraceL";
  const at3 = 27648;
  TokenType2[TokenType2["at"] = at3] = "at";
  const hash = 29184;
  TokenType2[TokenType2["hash"] = hash] = "hash";
  const eq = 29728;
  TokenType2[TokenType2["eq"] = eq] = "eq";
  const assign2 = 30752;
  TokenType2[TokenType2["assign"] = assign2] = "assign";
  const preIncDec = 32640;
  TokenType2[TokenType2["preIncDec"] = preIncDec] = "preIncDec";
  const postIncDec = 33664;
  TokenType2[TokenType2["postIncDec"] = postIncDec] = "postIncDec";
  const bang = 34432;
  TokenType2[TokenType2["bang"] = bang] = "bang";
  const tilde = 35456;
  TokenType2[TokenType2["tilde"] = tilde] = "tilde";
  const pipeline = 35841;
  TokenType2[TokenType2["pipeline"] = pipeline] = "pipeline";
  const nullishCoalescing = 36866;
  TokenType2[TokenType2["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing";
  const logicalOR = 37890;
  TokenType2[TokenType2["logicalOR"] = logicalOR] = "logicalOR";
  const logicalAND = 38915;
  TokenType2[TokenType2["logicalAND"] = logicalAND] = "logicalAND";
  const bitwiseOR = 39940;
  TokenType2[TokenType2["bitwiseOR"] = bitwiseOR] = "bitwiseOR";
  const bitwiseXOR = 40965;
  TokenType2[TokenType2["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR";
  const bitwiseAND = 41990;
  TokenType2[TokenType2["bitwiseAND"] = bitwiseAND] = "bitwiseAND";
  const equality = 43015;
  TokenType2[TokenType2["equality"] = equality] = "equality";
  const lessThan = 44040;
  TokenType2[TokenType2["lessThan"] = lessThan] = "lessThan";
  const greaterThan = 45064;
  TokenType2[TokenType2["greaterThan"] = greaterThan] = "greaterThan";
  const relationalOrEqual = 46088;
  TokenType2[TokenType2["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual";
  const bitShiftL = 47113;
  TokenType2[TokenType2["bitShiftL"] = bitShiftL] = "bitShiftL";
  const bitShiftR = 48137;
  TokenType2[TokenType2["bitShiftR"] = bitShiftR] = "bitShiftR";
  const plus = 49802;
  TokenType2[TokenType2["plus"] = plus] = "plus";
  const minus = 50826;
  TokenType2[TokenType2["minus"] = minus] = "minus";
  const modulo = 51723;
  TokenType2[TokenType2["modulo"] = modulo] = "modulo";
  const star = 52235;
  TokenType2[TokenType2["star"] = star] = "star";
  const slash = 53259;
  TokenType2[TokenType2["slash"] = slash] = "slash";
  const exponent = 54348;
  TokenType2[TokenType2["exponent"] = exponent] = "exponent";
  const jsxName = 55296;
  TokenType2[TokenType2["jsxName"] = jsxName] = "jsxName";
  const jsxText = 56320;
  TokenType2[TokenType2["jsxText"] = jsxText] = "jsxText";
  const jsxEmptyText = 57344;
  TokenType2[TokenType2["jsxEmptyText"] = jsxEmptyText] = "jsxEmptyText";
  const jsxTagStart = 58880;
  TokenType2[TokenType2["jsxTagStart"] = jsxTagStart] = "jsxTagStart";
  const jsxTagEnd = 59392;
  TokenType2[TokenType2["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd";
  const typeParameterStart = 60928;
  TokenType2[TokenType2["typeParameterStart"] = typeParameterStart] = "typeParameterStart";
  const nonNullAssertion = 61440;
  TokenType2[TokenType2["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion";
  const _break = 62480;
  TokenType2[TokenType2["_break"] = _break] = "_break";
  const _case = 63504;
  TokenType2[TokenType2["_case"] = _case] = "_case";
  const _catch = 64528;
  TokenType2[TokenType2["_catch"] = _catch] = "_catch";
  const _continue = 65552;
  TokenType2[TokenType2["_continue"] = _continue] = "_continue";
  const _debugger = 66576;
  TokenType2[TokenType2["_debugger"] = _debugger] = "_debugger";
  const _default = 67600;
  TokenType2[TokenType2["_default"] = _default] = "_default";
  const _do = 68624;
  TokenType2[TokenType2["_do"] = _do] = "_do";
  const _else = 69648;
  TokenType2[TokenType2["_else"] = _else] = "_else";
  const _finally = 70672;
  TokenType2[TokenType2["_finally"] = _finally] = "_finally";
  const _for = 71696;
  TokenType2[TokenType2["_for"] = _for] = "_for";
  const _function = 73232;
  TokenType2[TokenType2["_function"] = _function] = "_function";
  const _if = 73744;
  TokenType2[TokenType2["_if"] = _if] = "_if";
  const _return = 74768;
  TokenType2[TokenType2["_return"] = _return] = "_return";
  const _switch = 75792;
  TokenType2[TokenType2["_switch"] = _switch] = "_switch";
  const _throw = 77456;
  TokenType2[TokenType2["_throw"] = _throw] = "_throw";
  const _try = 77840;
  TokenType2[TokenType2["_try"] = _try] = "_try";
  const _var = 78864;
  TokenType2[TokenType2["_var"] = _var] = "_var";
  const _let = 79888;
  TokenType2[TokenType2["_let"] = _let] = "_let";
  const _const = 80912;
  TokenType2[TokenType2["_const"] = _const] = "_const";
  const _while = 81936;
  TokenType2[TokenType2["_while"] = _while] = "_while";
  const _with = 82960;
  TokenType2[TokenType2["_with"] = _with] = "_with";
  const _new = 84496;
  TokenType2[TokenType2["_new"] = _new] = "_new";
  const _this = 85520;
  TokenType2[TokenType2["_this"] = _this] = "_this";
  const _super = 86544;
  TokenType2[TokenType2["_super"] = _super] = "_super";
  const _class = 87568;
  TokenType2[TokenType2["_class"] = _class] = "_class";
  const _extends2 = 88080;
  TokenType2[TokenType2["_extends"] = _extends2] = "_extends";
  const _export = 89104;
  TokenType2[TokenType2["_export"] = _export] = "_export";
  const _import = 90640;
  TokenType2[TokenType2["_import"] = _import] = "_import";
  const _yield = 91664;
  TokenType2[TokenType2["_yield"] = _yield] = "_yield";
  const _null = 92688;
  TokenType2[TokenType2["_null"] = _null] = "_null";
  const _true = 93712;
  TokenType2[TokenType2["_true"] = _true] = "_true";
  const _false = 94736;
  TokenType2[TokenType2["_false"] = _false] = "_false";
  const _in = 95256;
  TokenType2[TokenType2["_in"] = _in] = "_in";
  const _instanceof = 96280;
  TokenType2[TokenType2["_instanceof"] = _instanceof] = "_instanceof";
  const _typeof = 97936;
  TokenType2[TokenType2["_typeof"] = _typeof] = "_typeof";
  const _void = 98960;
  TokenType2[TokenType2["_void"] = _void] = "_void";
  const _delete = 99984;
  TokenType2[TokenType2["_delete"] = _delete] = "_delete";
  const _async = 100880;
  TokenType2[TokenType2["_async"] = _async] = "_async";
  const _get = 101904;
  TokenType2[TokenType2["_get"] = _get] = "_get";
  const _set = 102928;
  TokenType2[TokenType2["_set"] = _set] = "_set";
  const _declare = 103952;
  TokenType2[TokenType2["_declare"] = _declare] = "_declare";
  const _readonly = 104976;
  TokenType2[TokenType2["_readonly"] = _readonly] = "_readonly";
  const _abstract = 106e3;
  TokenType2[TokenType2["_abstract"] = _abstract] = "_abstract";
  const _static = 107024;
  TokenType2[TokenType2["_static"] = _static] = "_static";
  const _public = 107536;
  TokenType2[TokenType2["_public"] = _public] = "_public";
  const _private = 108560;
  TokenType2[TokenType2["_private"] = _private] = "_private";
  const _protected = 109584;
  TokenType2[TokenType2["_protected"] = _protected] = "_protected";
  const _override = 110608;
  TokenType2[TokenType2["_override"] = _override] = "_override";
  const _as = 112144;
  TokenType2[TokenType2["_as"] = _as] = "_as";
  const _enum = 113168;
  TokenType2[TokenType2["_enum"] = _enum] = "_enum";
  const _type = 114192;
  TokenType2[TokenType2["_type"] = _type] = "_type";
  const _implements = 115216;
  TokenType2[TokenType2["_implements"] = _implements] = "_implements";
})(TokenType || (TokenType = {}));
function formatTokenType(tokenType) {
  switch (tokenType) {
    case TokenType.num:
      return "num";
    case TokenType.bigint:
      return "bigint";
    case TokenType.decimal:
      return "decimal";
    case TokenType.regexp:
      return "regexp";
    case TokenType.string:
      return "string";
    case TokenType.name:
      return "name";
    case TokenType.eof:
      return "eof";
    case TokenType.bracketL:
      return "[";
    case TokenType.bracketR:
      return "]";
    case TokenType.braceL:
      return "{";
    case TokenType.braceBarL:
      return "{|";
    case TokenType.braceR:
      return "}";
    case TokenType.braceBarR:
      return "|}";
    case TokenType.parenL:
      return "(";
    case TokenType.parenR:
      return ")";
    case TokenType.comma:
      return ",";
    case TokenType.semi:
      return ";";
    case TokenType.colon:
      return ":";
    case TokenType.doubleColon:
      return "::";
    case TokenType.dot:
      return ".";
    case TokenType.question:
      return "?";
    case TokenType.questionDot:
      return "?.";
    case TokenType.arrow:
      return "=>";
    case TokenType.template:
      return "template";
    case TokenType.ellipsis:
      return "...";
    case TokenType.backQuote:
      return "`";
    case TokenType.dollarBraceL:
      return "${";
    case TokenType.at:
      return "@";
    case TokenType.hash:
      return "#";
    case TokenType.eq:
      return "=";
    case TokenType.assign:
      return "_=";
    case TokenType.preIncDec:
      return "++/--";
    case TokenType.postIncDec:
      return "++/--";
    case TokenType.bang:
      return "!";
    case TokenType.tilde:
      return "~";
    case TokenType.pipeline:
      return "|>";
    case TokenType.nullishCoalescing:
      return "??";
    case TokenType.logicalOR:
      return "||";
    case TokenType.logicalAND:
      return "&&";
    case TokenType.bitwiseOR:
      return "|";
    case TokenType.bitwiseXOR:
      return "^";
    case TokenType.bitwiseAND:
      return "&";
    case TokenType.equality:
      return "==/!=";
    case TokenType.lessThan:
      return "<";
    case TokenType.greaterThan:
      return ">";
    case TokenType.relationalOrEqual:
      return "<=/>=";
    case TokenType.bitShiftL:
      return "<<";
    case TokenType.bitShiftR:
      return ">>/>>>";
    case TokenType.plus:
      return "+";
    case TokenType.minus:
      return "-";
    case TokenType.modulo:
      return "%";
    case TokenType.star:
      return "*";
    case TokenType.slash:
      return "/";
    case TokenType.exponent:
      return "**";
    case TokenType.jsxName:
      return "jsxName";
    case TokenType.jsxText:
      return "jsxText";
    case TokenType.jsxEmptyText:
      return "jsxEmptyText";
    case TokenType.jsxTagStart:
      return "jsxTagStart";
    case TokenType.jsxTagEnd:
      return "jsxTagEnd";
    case TokenType.typeParameterStart:
      return "typeParameterStart";
    case TokenType.nonNullAssertion:
      return "nonNullAssertion";
    case TokenType._break:
      return "break";
    case TokenType._case:
      return "case";
    case TokenType._catch:
      return "catch";
    case TokenType._continue:
      return "continue";
    case TokenType._debugger:
      return "debugger";
    case TokenType._default:
      return "default";
    case TokenType._do:
      return "do";
    case TokenType._else:
      return "else";
    case TokenType._finally:
      return "finally";
    case TokenType._for:
      return "for";
    case TokenType._function:
      return "function";
    case TokenType._if:
      return "if";
    case TokenType._return:
      return "return";
    case TokenType._switch:
      return "switch";
    case TokenType._throw:
      return "throw";
    case TokenType._try:
      return "try";
    case TokenType._var:
      return "var";
    case TokenType._let:
      return "let";
    case TokenType._const:
      return "const";
    case TokenType._while:
      return "while";
    case TokenType._with:
      return "with";
    case TokenType._new:
      return "new";
    case TokenType._this:
      return "this";
    case TokenType._super:
      return "super";
    case TokenType._class:
      return "class";
    case TokenType._extends:
      return "extends";
    case TokenType._export:
      return "export";
    case TokenType._import:
      return "import";
    case TokenType._yield:
      return "yield";
    case TokenType._null:
      return "null";
    case TokenType._true:
      return "true";
    case TokenType._false:
      return "false";
    case TokenType._in:
      return "in";
    case TokenType._instanceof:
      return "instanceof";
    case TokenType._typeof:
      return "typeof";
    case TokenType._void:
      return "void";
    case TokenType._delete:
      return "delete";
    case TokenType._async:
      return "async";
    case TokenType._get:
      return "get";
    case TokenType._set:
      return "set";
    case TokenType._declare:
      return "declare";
    case TokenType._readonly:
      return "readonly";
    case TokenType._abstract:
      return "abstract";
    case TokenType._static:
      return "static";
    case TokenType._public:
      return "public";
    case TokenType._private:
      return "private";
    case TokenType._protected:
      return "protected";
    case TokenType._override:
      return "override";
    case TokenType._as:
      return "as";
    case TokenType._enum:
      return "enum";
    case TokenType._type:
      return "type";
    case TokenType._implements:
      return "implements";
    default:
      return "";
  }
}

// node_modules/sucrase/dist/esm/parser/tokenizer/state.js
var Scope = class {
  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
    this.startTokenIndex = startTokenIndex;
    this.endTokenIndex = endTokenIndex;
    this.isFunctionScope = isFunctionScope;
  }
};
var StateSnapshot = class {
  constructor(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error) {
    ;
    this.potentialArrowAt = potentialArrowAt;
    this.noAnonFunctionType = noAnonFunctionType;
    this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;
    this.tokensLength = tokensLength;
    this.scopesLength = scopesLength;
    this.pos = pos;
    this.type = type;
    this.contextualKeyword = contextualKeyword;
    this.start = start;
    this.end = end;
    this.isType = isType;
    this.scopeDepth = scopeDepth;
    this.error = error;
  }
};
var State = class _State {
  constructor() {
    _State.prototype.__init.call(this);
    _State.prototype.__init2.call(this);
    _State.prototype.__init3.call(this);
    _State.prototype.__init4.call(this);
    _State.prototype.__init5.call(this);
    _State.prototype.__init6.call(this);
    _State.prototype.__init7.call(this);
    _State.prototype.__init8.call(this);
    _State.prototype.__init9.call(this);
    _State.prototype.__init10.call(this);
    _State.prototype.__init11.call(this);
    _State.prototype.__init12.call(this);
    _State.prototype.__init13.call(this);
  }
  // Used to signify the start of a potential arrow function
  __init() {
    this.potentialArrowAt = -1;
  }
  // Used by Flow to handle an edge case involving function type parsing.
  __init2() {
    this.noAnonFunctionType = false;
  }
  // Used by TypeScript to handle ambiguities when parsing conditional types.
  __init3() {
    this.inDisallowConditionalTypesContext = false;
  }
  // Token store.
  __init4() {
    this.tokens = [];
  }
  // Array of all observed scopes, ordered by their ending position.
  __init5() {
    this.scopes = [];
  }
  // The current position of the tokenizer in the input.
  __init6() {
    this.pos = 0;
  }
  // Information about the current token.
  __init7() {
    this.type = TokenType.eof;
  }
  __init8() {
    this.contextualKeyword = ContextualKeyword.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = false;
  }
  __init12() {
    this.scopeDepth = 0;
  }
  /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new StateSnapshot(
      this.potentialArrowAt,
      this.noAnonFunctionType,
      this.inDisallowConditionalTypesContext,
      this.tokens.length,
      this.scopes.length,
      this.pos,
      this.type,
      this.contextualKeyword,
      this.start,
      this.end,
      this.isType,
      this.scopeDepth,
      this.error
    );
  }
  restoreFromSnapshot(snapshot) {
    this.potentialArrowAt = snapshot.potentialArrowAt;
    this.noAnonFunctionType = snapshot.noAnonFunctionType;
    this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;
    this.tokens.length = snapshot.tokensLength;
    this.scopes.length = snapshot.scopesLength;
    this.pos = snapshot.pos;
    this.type = snapshot.type;
    this.contextualKeyword = snapshot.contextualKeyword;
    this.start = snapshot.start;
    this.end = snapshot.end;
    this.isType = snapshot.isType;
    this.scopeDepth = snapshot.scopeDepth;
    this.error = snapshot.error;
  }
};

// node_modules/sucrase/dist/esm/parser/util/charcodes.js
var charCodes;
(function(charCodes2) {
  const backSpace = 8;
  charCodes2[charCodes2["backSpace"] = backSpace] = "backSpace";
  const lineFeed = 10;
  charCodes2[charCodes2["lineFeed"] = lineFeed] = "lineFeed";
  const tab = 9;
  charCodes2[charCodes2["tab"] = tab] = "tab";
  const carriageReturn = 13;
  charCodes2[charCodes2["carriageReturn"] = carriageReturn] = "carriageReturn";
  const shiftOut = 14;
  charCodes2[charCodes2["shiftOut"] = shiftOut] = "shiftOut";
  const space = 32;
  charCodes2[charCodes2["space"] = space] = "space";
  const exclamationMark = 33;
  charCodes2[charCodes2["exclamationMark"] = exclamationMark] = "exclamationMark";
  const quotationMark = 34;
  charCodes2[charCodes2["quotationMark"] = quotationMark] = "quotationMark";
  const numberSign = 35;
  charCodes2[charCodes2["numberSign"] = numberSign] = "numberSign";
  const dollarSign = 36;
  charCodes2[charCodes2["dollarSign"] = dollarSign] = "dollarSign";
  const percentSign = 37;
  charCodes2[charCodes2["percentSign"] = percentSign] = "percentSign";
  const ampersand = 38;
  charCodes2[charCodes2["ampersand"] = ampersand] = "ampersand";
  const apostrophe = 39;
  charCodes2[charCodes2["apostrophe"] = apostrophe] = "apostrophe";
  const leftParenthesis = 40;
  charCodes2[charCodes2["leftParenthesis"] = leftParenthesis] = "leftParenthesis";
  const rightParenthesis = 41;
  charCodes2[charCodes2["rightParenthesis"] = rightParenthesis] = "rightParenthesis";
  const asterisk = 42;
  charCodes2[charCodes2["asterisk"] = asterisk] = "asterisk";
  const plusSign = 43;
  charCodes2[charCodes2["plusSign"] = plusSign] = "plusSign";
  const comma = 44;
  charCodes2[charCodes2["comma"] = comma] = "comma";
  const dash = 45;
  charCodes2[charCodes2["dash"] = dash] = "dash";
  const dot = 46;
  charCodes2[charCodes2["dot"] = dot] = "dot";
  const slash = 47;
  charCodes2[charCodes2["slash"] = slash] = "slash";
  const digit0 = 48;
  charCodes2[charCodes2["digit0"] = digit0] = "digit0";
  const digit1 = 49;
  charCodes2[charCodes2["digit1"] = digit1] = "digit1";
  const digit2 = 50;
  charCodes2[charCodes2["digit2"] = digit2] = "digit2";
  const digit3 = 51;
  charCodes2[charCodes2["digit3"] = digit3] = "digit3";
  const digit4 = 52;
  charCodes2[charCodes2["digit4"] = digit4] = "digit4";
  const digit5 = 53;
  charCodes2[charCodes2["digit5"] = digit5] = "digit5";
  const digit6 = 54;
  charCodes2[charCodes2["digit6"] = digit6] = "digit6";
  const digit7 = 55;
  charCodes2[charCodes2["digit7"] = digit7] = "digit7";
  const digit8 = 56;
  charCodes2[charCodes2["digit8"] = digit8] = "digit8";
  const digit9 = 57;
  charCodes2[charCodes2["digit9"] = digit9] = "digit9";
  const colon = 58;
  charCodes2[charCodes2["colon"] = colon] = "colon";
  const semicolon2 = 59;
  charCodes2[charCodes2["semicolon"] = semicolon2] = "semicolon";
  const lessThan = 60;
  charCodes2[charCodes2["lessThan"] = lessThan] = "lessThan";
  const equalsTo = 61;
  charCodes2[charCodes2["equalsTo"] = equalsTo] = "equalsTo";
  const greaterThan = 62;
  charCodes2[charCodes2["greaterThan"] = greaterThan] = "greaterThan";
  const questionMark = 63;
  charCodes2[charCodes2["questionMark"] = questionMark] = "questionMark";
  const atSign = 64;
  charCodes2[charCodes2["atSign"] = atSign] = "atSign";
  const uppercaseA = 65;
  charCodes2[charCodes2["uppercaseA"] = uppercaseA] = "uppercaseA";
  const uppercaseB = 66;
  charCodes2[charCodes2["uppercaseB"] = uppercaseB] = "uppercaseB";
  const uppercaseC = 67;
  charCodes2[charCodes2["uppercaseC"] = uppercaseC] = "uppercaseC";
  const uppercaseD = 68;
  charCodes2[charCodes2["uppercaseD"] = uppercaseD] = "uppercaseD";
  const uppercaseE = 69;
  charCodes2[charCodes2["uppercaseE"] = uppercaseE] = "uppercaseE";
  const uppercaseF = 70;
  charCodes2[charCodes2["uppercaseF"] = uppercaseF] = "uppercaseF";
  const uppercaseG = 71;
  charCodes2[charCodes2["uppercaseG"] = uppercaseG] = "uppercaseG";
  const uppercaseH = 72;
  charCodes2[charCodes2["uppercaseH"] = uppercaseH] = "uppercaseH";
  const uppercaseI = 73;
  charCodes2[charCodes2["uppercaseI"] = uppercaseI] = "uppercaseI";
  const uppercaseJ = 74;
  charCodes2[charCodes2["uppercaseJ"] = uppercaseJ] = "uppercaseJ";
  const uppercaseK = 75;
  charCodes2[charCodes2["uppercaseK"] = uppercaseK] = "uppercaseK";
  const uppercaseL = 76;
  charCodes2[charCodes2["uppercaseL"] = uppercaseL] = "uppercaseL";
  const uppercaseM = 77;
  charCodes2[charCodes2["uppercaseM"] = uppercaseM] = "uppercaseM";
  const uppercaseN = 78;
  charCodes2[charCodes2["uppercaseN"] = uppercaseN] = "uppercaseN";
  const uppercaseO = 79;
  charCodes2[charCodes2["uppercaseO"] = uppercaseO] = "uppercaseO";
  const uppercaseP = 80;
  charCodes2[charCodes2["uppercaseP"] = uppercaseP] = "uppercaseP";
  const uppercaseQ = 81;
  charCodes2[charCodes2["uppercaseQ"] = uppercaseQ] = "uppercaseQ";
  const uppercaseR = 82;
  charCodes2[charCodes2["uppercaseR"] = uppercaseR] = "uppercaseR";
  const uppercaseS = 83;
  charCodes2[charCodes2["uppercaseS"] = uppercaseS] = "uppercaseS";
  const uppercaseT = 84;
  charCodes2[charCodes2["uppercaseT"] = uppercaseT] = "uppercaseT";
  const uppercaseU = 85;
  charCodes2[charCodes2["uppercaseU"] = uppercaseU] = "uppercaseU";
  const uppercaseV = 86;
  charCodes2[charCodes2["uppercaseV"] = uppercaseV] = "uppercaseV";
  const uppercaseW = 87;
  charCodes2[charCodes2["uppercaseW"] = uppercaseW] = "uppercaseW";
  const uppercaseX = 88;
  charCodes2[charCodes2["uppercaseX"] = uppercaseX] = "uppercaseX";
  const uppercaseY = 89;
  charCodes2[charCodes2["uppercaseY"] = uppercaseY] = "uppercaseY";
  const uppercaseZ = 90;
  charCodes2[charCodes2["uppercaseZ"] = uppercaseZ] = "uppercaseZ";
  const leftSquareBracket = 91;
  charCodes2[charCodes2["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket";
  const backslash = 92;
  charCodes2[charCodes2["backslash"] = backslash] = "backslash";
  const rightSquareBracket = 93;
  charCodes2[charCodes2["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket";
  const caret = 94;
  charCodes2[charCodes2["caret"] = caret] = "caret";
  const underscore = 95;
  charCodes2[charCodes2["underscore"] = underscore] = "underscore";
  const graveAccent = 96;
  charCodes2[charCodes2["graveAccent"] = graveAccent] = "graveAccent";
  const lowercaseA = 97;
  charCodes2[charCodes2["lowercaseA"] = lowercaseA] = "lowercaseA";
  const lowercaseB = 98;
  charCodes2[charCodes2["lowercaseB"] = lowercaseB] = "lowercaseB";
  const lowercaseC = 99;
  charCodes2[charCodes2["lowercaseC"] = lowercaseC] = "lowercaseC";
  const lowercaseD = 100;
  charCodes2[charCodes2["lowercaseD"] = lowercaseD] = "lowercaseD";
  const lowercaseE = 101;
  charCodes2[charCodes2["lowercaseE"] = lowercaseE] = "lowercaseE";
  const lowercaseF = 102;
  charCodes2[charCodes2["lowercaseF"] = lowercaseF] = "lowercaseF";
  const lowercaseG = 103;
  charCodes2[charCodes2["lowercaseG"] = lowercaseG] = "lowercaseG";
  const lowercaseH = 104;
  charCodes2[charCodes2["lowercaseH"] = lowercaseH] = "lowercaseH";
  const lowercaseI = 105;
  charCodes2[charCodes2["lowercaseI"] = lowercaseI] = "lowercaseI";
  const lowercaseJ = 106;
  charCodes2[charCodes2["lowercaseJ"] = lowercaseJ] = "lowercaseJ";
  const lowercaseK = 107;
  charCodes2[charCodes2["lowercaseK"] = lowercaseK] = "lowercaseK";
  const lowercaseL = 108;
  charCodes2[charCodes2["lowercaseL"] = lowercaseL] = "lowercaseL";
  const lowercaseM = 109;
  charCodes2[charCodes2["lowercaseM"] = lowercaseM] = "lowercaseM";
  const lowercaseN = 110;
  charCodes2[charCodes2["lowercaseN"] = lowercaseN] = "lowercaseN";
  const lowercaseO = 111;
  charCodes2[charCodes2["lowercaseO"] = lowercaseO] = "lowercaseO";
  const lowercaseP = 112;
  charCodes2[charCodes2["lowercaseP"] = lowercaseP] = "lowercaseP";
  const lowercaseQ = 113;
  charCodes2[charCodes2["lowercaseQ"] = lowercaseQ] = "lowercaseQ";
  const lowercaseR = 114;
  charCodes2[charCodes2["lowercaseR"] = lowercaseR] = "lowercaseR";
  const lowercaseS = 115;
  charCodes2[charCodes2["lowercaseS"] = lowercaseS] = "lowercaseS";
  const lowercaseT = 116;
  charCodes2[charCodes2["lowercaseT"] = lowercaseT] = "lowercaseT";
  const lowercaseU = 117;
  charCodes2[charCodes2["lowercaseU"] = lowercaseU] = "lowercaseU";
  const lowercaseV = 118;
  charCodes2[charCodes2["lowercaseV"] = lowercaseV] = "lowercaseV";
  const lowercaseW = 119;
  charCodes2[charCodes2["lowercaseW"] = lowercaseW] = "lowercaseW";
  const lowercaseX = 120;
  charCodes2[charCodes2["lowercaseX"] = lowercaseX] = "lowercaseX";
  const lowercaseY = 121;
  charCodes2[charCodes2["lowercaseY"] = lowercaseY] = "lowercaseY";
  const lowercaseZ = 122;
  charCodes2[charCodes2["lowercaseZ"] = lowercaseZ] = "lowercaseZ";
  const leftCurlyBrace = 123;
  charCodes2[charCodes2["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace";
  const verticalBar = 124;
  charCodes2[charCodes2["verticalBar"] = verticalBar] = "verticalBar";
  const rightCurlyBrace = 125;
  charCodes2[charCodes2["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace";
  const tilde = 126;
  charCodes2[charCodes2["tilde"] = tilde] = "tilde";
  const nonBreakingSpace = 160;
  charCodes2[charCodes2["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
  const oghamSpaceMark = 5760;
  charCodes2[charCodes2["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark";
  const lineSeparator = 8232;
  charCodes2[charCodes2["lineSeparator"] = lineSeparator] = "lineSeparator";
  const paragraphSeparator = 8233;
  charCodes2[charCodes2["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
})(charCodes || (charCodes = {}));

// node_modules/sucrase/dist/esm/parser/traverser/base.js
var isJSXEnabled;
var isTypeScriptEnabled;
var isFlowEnabled;
var state;
var input;
var nextContextId;
function getNextContextId() {
  return nextContextId++;
}
function augmentError(error) {
  if ("pos" in error) {
    const loc = locationForIndex(error.pos);
    error.message += ` (${loc.line}:${loc.column})`;
    error.loc = loc;
  }
  return error;
}
var Loc = class {
  constructor(line, column) {
    this.line = line;
    this.column = column;
  }
};
function locationForIndex(pos) {
  let line = 1;
  let column = 1;
  for (let i2 = 0; i2 < pos; i2++) {
    if (input.charCodeAt(i2) === charCodes.lineFeed) {
      line++;
      column = 1;
    } else {
      column++;
    }
  }
  return new Loc(line, column);
}
function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEnabledArg) {
  input = inputCode;
  state = new State();
  nextContextId = 1;
  isJSXEnabled = isJSXEnabledArg;
  isTypeScriptEnabled = isTypeScriptEnabledArg;
  isFlowEnabled = isFlowEnabledArg;
}

// node_modules/sucrase/dist/esm/parser/traverser/util.js
function isContextual(contextualKeyword) {
  return state.contextualKeyword === contextualKeyword;
}
function isLookaheadContextual(contextualKeyword) {
  const l = lookaheadTypeAndKeyword();
  return l.type === TokenType.name && l.contextualKeyword === contextualKeyword;
}
function eatContextual(contextualKeyword) {
  return state.contextualKeyword === contextualKeyword && eat(TokenType.name);
}
function expectContextual(contextualKeyword) {
  if (!eatContextual(contextualKeyword)) {
    unexpected();
  }
}
function canInsertSemicolon() {
  return match(TokenType.eof) || match(TokenType.braceR) || hasPrecedingLineBreak();
}
function hasPrecedingLineBreak() {
  const prevToken = state.tokens[state.tokens.length - 1];
  const lastTokEnd = prevToken ? prevToken.end : 0;
  for (let i2 = lastTokEnd; i2 < state.start; i2++) {
    const code = input.charCodeAt(i2);
    if (code === charCodes.lineFeed || code === charCodes.carriageReturn || code === 8232 || code === 8233) {
      return true;
    }
  }
  return false;
}
function hasFollowingLineBreak() {
  const nextStart = nextTokenStart();
  for (let i2 = state.end; i2 < nextStart; i2++) {
    const code = input.charCodeAt(i2);
    if (code === charCodes.lineFeed || code === charCodes.carriageReturn || code === 8232 || code === 8233) {
      return true;
    }
  }
  return false;
}
function isLineTerminator() {
  return eat(TokenType.semi) || canInsertSemicolon();
}
function semicolon() {
  if (!isLineTerminator()) {
    unexpected('Unexpected token, expected ";"');
  }
}
function expect(type) {
  const matched = eat(type);
  if (!matched) {
    unexpected(`Unexpected token, expected "${formatTokenType(type)}"`);
  }
}
function unexpected(message = "Unexpected token", pos = state.start) {
  if (state.error) {
    return;
  }
  const err = new SyntaxError(message);
  err.pos = pos;
  state.error = err;
  state.pos = input.length;
  finishToken(TokenType.eof);
}

// node_modules/sucrase/dist/esm/parser/util/whitespace.js
var WHITESPACE_CHARS = [
  9,
  11,
  12,
  charCodes.space,
  charCodes.nonBreakingSpace,
  charCodes.oghamSpaceMark,
  8192,
  // EN QUAD
  8193,
  // EM QUAD
  8194,
  // EN SPACE
  8195,
  // EM SPACE
  8196,
  // THREE-PER-EM SPACE
  8197,
  // FOUR-PER-EM SPACE
  8198,
  // SIX-PER-EM SPACE
  8199,
  // FIGURE SPACE
  8200,
  // PUNCTUATION SPACE
  8201,
  // THIN SPACE
  8202,
  // HAIR SPACE
  8239,
  // NARROW NO-BREAK SPACE
  8287,
  // MEDIUM MATHEMATICAL SPACE
  12288,
  // IDEOGRAPHIC SPACE
  65279
  // ZERO WIDTH NO-BREAK SPACE
];
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var IS_WHITESPACE = new Uint8Array(65536);
for (const char of WHITESPACE_CHARS) {
  IS_WHITESPACE[char] = 1;
}

// node_modules/sucrase/dist/esm/parser/util/identifier.js
function computeIsIdentifierChar(code) {
  if (code < 48)
    return code === 36;
  if (code < 58)
    return true;
  if (code < 65)
    return false;
  if (code < 91)
    return true;
  if (code < 97)
    return code === 95;
  if (code < 123)
    return true;
  if (code < 128)
    return false;
  throw new Error("Should not be called with non-ASCII char code.");
}
var IS_IDENTIFIER_CHAR = new Uint8Array(65536);
for (let i2 = 0; i2 < 128; i2++) {
  IS_IDENTIFIER_CHAR[i2] = computeIsIdentifierChar(i2) ? 1 : 0;
}
for (let i2 = 128; i2 < 65536; i2++) {
  IS_IDENTIFIER_CHAR[i2] = 1;
}
for (const whitespaceChar of WHITESPACE_CHARS) {
  IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
}
IS_IDENTIFIER_CHAR[8232] = 0;
IS_IDENTIFIER_CHAR[8233] = 0;
var IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();
for (let numChar = charCodes.digit0; numChar <= charCodes.digit9; numChar++) {
  IS_IDENTIFIER_START[numChar] = 0;
}

// node_modules/sucrase/dist/esm/parser/tokenizer/readWordTree.js
var READ_WORD_TREE = new Int32Array([
  // ""
  -1,
  27,
  783,
  918,
  1755,
  2376,
  2862,
  3483,
  -1,
  3699,
  -1,
  4617,
  4752,
  4833,
  5130,
  5508,
  5940,
  -1,
  6480,
  6939,
  7749,
  8181,
  8451,
  8613,
  -1,
  8829,
  -1,
  // "a"
  -1,
  -1,
  54,
  243,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  432,
  -1,
  -1,
  -1,
  675,
  -1,
  -1,
  -1,
  // "ab"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  81,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abs"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  108,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abst"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstr"
  -1,
  162,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstra"
  -1,
  -1,
  -1,
  189,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstrac"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  216,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstract"
  ContextualKeyword._abstract << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ac"
  -1,
  -1,
  -1,
  270,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acc"
  -1,
  -1,
  -1,
  -1,
  -1,
  297,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acce"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  324,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acces"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  351,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "access"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  378,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accesso"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  405,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accessor"
  ContextualKeyword._accessor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "as"
  ContextualKeyword._as << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  459,
  -1,
  -1,
  -1,
  -1,
  -1,
  594,
  -1,
  // "ass"
  -1,
  -1,
  -1,
  -1,
  -1,
  486,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asse"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  513,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asser"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  540,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "assert"
  ContextualKeyword._assert << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  567,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asserts"
  ContextualKeyword._asserts << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  621,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asyn"
  -1,
  -1,
  -1,
  648,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "async"
  ContextualKeyword._async << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "aw"
  -1,
  702,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  729,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awai"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  756,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "await"
  ContextualKeyword._await << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "b"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  810,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "br"
  -1,
  -1,
  -1,
  -1,
  -1,
  837,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "bre"
  -1,
  864,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "brea"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  891,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "break"
  (TokenType._break << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "c"
  -1,
  945,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1107,
  -1,
  -1,
  -1,
  1242,
  -1,
  -1,
  1350,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ca"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  972,
  1026,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cas"
  -1,
  -1,
  -1,
  -1,
  -1,
  999,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "case"
  (TokenType._case << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cat"
  -1,
  -1,
  -1,
  1053,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1080,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catch"
  (TokenType._catch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ch"
  -1,
  -1,
  -1,
  -1,
  -1,
  1134,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "che"
  -1,
  -1,
  -1,
  1161,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "chec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1188,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "check"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1215,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "checks"
  ContextualKeyword._checks << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cl"
  -1,
  1269,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1296,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "clas"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1323,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "class"
  (TokenType._class << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "co"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1377,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "con"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1404,
  1620,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cons"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1431,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "const"
  (TokenType._const << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1458,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1485,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constru"
  -1,
  -1,
  -1,
  1512,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1539,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1566,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1593,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructor"
  ContextualKeyword._constructor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cont"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1647,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "conti"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1674,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "contin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1701,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continu"
  -1,
  -1,
  -1,
  -1,
  -1,
  1728,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continue"
  (TokenType._continue << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "d"
  -1,
  -1,
  -1,
  -1,
  -1,
  1782,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2349,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "de"
  -1,
  -1,
  1809,
  1971,
  -1,
  -1,
  2106,
  -1,
  -1,
  -1,
  -1,
  -1,
  2241,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "deb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1836,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1863,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debug"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1890,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugg"
  -1,
  -1,
  -1,
  -1,
  -1,
  1917,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1944,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugger"
  (TokenType._debugger << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1998,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decl"
  -1,
  2025,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2052,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declar"
  -1,
  -1,
  -1,
  -1,
  -1,
  2079,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declare"
  ContextualKeyword._declare << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "def"
  -1,
  2133,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2160,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defau"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2187,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defaul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2214,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "default"
  (TokenType._default << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "del"
  -1,
  -1,
  -1,
  -1,
  -1,
  2268,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dele"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2295,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delet"
  -1,
  -1,
  -1,
  -1,
  -1,
  2322,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delete"
  (TokenType._delete << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "do"
  (TokenType._do << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "e"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2403,
  -1,
  2484,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2565,
  -1,
  -1,
  // "el"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2430,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "els"
  -1,
  -1,
  -1,
  -1,
  -1,
  2457,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "else"
  (TokenType._else << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "en"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2511,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2538,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enum"
  ContextualKeyword._enum << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ex"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2592,
  -1,
  -1,
  -1,
  2727,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2619,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2646,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2673,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "export"
  (TokenType._export << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2700,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exports"
  ContextualKeyword._exports << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ext"
  -1,
  -1,
  -1,
  -1,
  -1,
  2754,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2781,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exten"
  -1,
  -1,
  -1,
  -1,
  2808,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extend"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2835,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extends"
  (TokenType._extends << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "f"
  -1,
  2889,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2997,
  -1,
  -1,
  -1,
  -1,
  -1,
  3159,
  -1,
  -1,
  3213,
  -1,
  -1,
  3294,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2916,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fal"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2943,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fals"
  -1,
  -1,
  -1,
  -1,
  -1,
  2970,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "false"
  (TokenType._false << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3024,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fin"
  -1,
  3051,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fina"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3078,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "final"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3105,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "finall"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3132,
  -1,
  // "finally"
  (TokenType._finally << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3186,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "for"
  (TokenType._for << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3240,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3267,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "from"
  ContextualKeyword._from << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3321,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fun"
  -1,
  -1,
  -1,
  3348,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "func"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3375,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "funct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3402,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3429,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functio"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3456,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "function"
  (TokenType._function << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "g"
  -1,
  -1,
  -1,
  -1,
  -1,
  3510,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3564,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3537,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "get"
  ContextualKeyword._get << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "gl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3591,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glo"
  -1,
  -1,
  3618,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glob"
  -1,
  3645,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "globa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3672,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "global"
  ContextualKeyword._global << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "i"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3726,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3753,
  4077,
  -1,
  -1,
  -1,
  -1,
  4590,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "if"
  (TokenType._if << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "im"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3780,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3807,
  -1,
  -1,
  3996,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impl"
  -1,
  -1,
  -1,
  -1,
  -1,
  3834,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imple"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3861,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implem"
  -1,
  -1,
  -1,
  -1,
  -1,
  3888,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impleme"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3915,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implemen"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3942,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implement"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3969,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implements"
  ContextualKeyword._implements << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4023,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4050,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "import"
  (TokenType._import << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "in"
  (TokenType._in << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4104,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4185,
  4401,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inf"
  -1,
  -1,
  -1,
  -1,
  -1,
  4131,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4158,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infer"
  ContextualKeyword._infer << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ins"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4212,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inst"
  -1,
  4239,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "insta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4266,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instan"
  -1,
  -1,
  -1,
  4293,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanc"
  -1,
  -1,
  -1,
  -1,
  -1,
  4320,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instance"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4347,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4374,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceof"
  (TokenType._instanceof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "int"
  -1,
  -1,
  -1,
  -1,
  -1,
  4428,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4455,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inter"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4482,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interf"
  -1,
  4509,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfa"
  -1,
  -1,
  -1,
  4536,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfac"
  -1,
  -1,
  -1,
  -1,
  -1,
  4563,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interface"
  ContextualKeyword._interface << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "is"
  ContextualKeyword._is << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "k"
  -1,
  -1,
  -1,
  -1,
  -1,
  4644,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ke"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4671,
  -1,
  // "key"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4698,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4725,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyof"
  ContextualKeyword._keyof << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "l"
  -1,
  -1,
  -1,
  -1,
  -1,
  4779,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "le"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4806,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "let"
  (TokenType._let << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "m"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4860,
  -1,
  -1,
  -1,
  -1,
  -1,
  4995,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4887,
  -1,
  -1,
  // "mix"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4914,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4941,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4968,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixins"
  ContextualKeyword._mixins << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mo"
  -1,
  -1,
  -1,
  -1,
  5022,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mod"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5049,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5076,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modul"
  -1,
  -1,
  -1,
  -1,
  -1,
  5103,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "module"
  ContextualKeyword._module << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "n"
  -1,
  5157,
  -1,
  -1,
  -1,
  5373,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5427,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "na"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5184,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nam"
  -1,
  -1,
  -1,
  -1,
  -1,
  5211,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "name"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5238,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "names"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5265,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namesp"
  -1,
  5292,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespa"
  -1,
  -1,
  -1,
  5319,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespac"
  -1,
  -1,
  -1,
  -1,
  -1,
  5346,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespace"
  ContextualKeyword._namespace << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ne"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5400,
  -1,
  -1,
  -1,
  // "new"
  (TokenType._new << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5454,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5481,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "null"
  (TokenType._null << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "o"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5535,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5562,
  -1,
  -1,
  -1,
  -1,
  5697,
  5751,
  -1,
  -1,
  -1,
  -1,
  // "of"
  ContextualKeyword._of << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "op"
  -1,
  5589,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5616,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5643,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  5670,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaque"
  ContextualKeyword._opaque << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ou"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5724,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "out"
  ContextualKeyword._out << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ov"
  -1,
  -1,
  -1,
  -1,
  -1,
  5778,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ove"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5805,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "over"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5832,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5859,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overri"
  -1,
  -1,
  -1,
  -1,
  5886,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overrid"
  -1,
  -1,
  -1,
  -1,
  -1,
  5913,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "override"
  ContextualKeyword._override << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "p"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5967,
  -1,
  -1,
  6345,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5994,
  -1,
  -1,
  -1,
  -1,
  -1,
  6129,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pri"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6021,
  -1,
  -1,
  -1,
  -1,
  // "priv"
  -1,
  6048,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "priva"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6075,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "privat"
  -1,
  -1,
  -1,
  -1,
  -1,
  6102,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "private"
  ContextualKeyword._private << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6156,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prot"
  -1,
  -1,
  -1,
  -1,
  -1,
  6183,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6318,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prote"
  -1,
  -1,
  -1,
  6210,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6237,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protect"
  -1,
  -1,
  -1,
  -1,
  -1,
  6264,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protecte"
  -1,
  -1,
  -1,
  -1,
  6291,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protected"
  ContextualKeyword._protected << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "proto"
  ContextualKeyword._proto << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pu"
  -1,
  -1,
  6372,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pub"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6399,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6426,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publi"
  -1,
  -1,
  -1,
  6453,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "public"
  ContextualKeyword._public << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "r"
  -1,
  -1,
  -1,
  -1,
  -1,
  6507,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "re"
  -1,
  6534,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6696,
  -1,
  -1,
  6831,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "rea"
  -1,
  -1,
  -1,
  -1,
  6561,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "read"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6588,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "reado"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6615,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readon"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6642,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readonl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6669,
  -1,
  // "readonly"
  ContextualKeyword._readonly << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "req"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6723,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6750,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6777,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requir"
  -1,
  -1,
  -1,
  -1,
  -1,
  6804,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "require"
  ContextualKeyword._require << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ret"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6858,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6885,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retur"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6912,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "return"
  (TokenType._return << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "s"
  -1,
  6966,
  -1,
  -1,
  -1,
  7182,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7236,
  7371,
  -1,
  7479,
  -1,
  7614,
  -1,
  // "sa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6993,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7020,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sati"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7047,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satis"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7074,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisf"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7101,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfi"
  -1,
  -1,
  -1,
  -1,
  -1,
  7128,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7155,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfies"
  ContextualKeyword._satisfies << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "se"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7209,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "set"
  ContextualKeyword._set << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "st"
  -1,
  7263,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7290,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7317,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stati"
  -1,
  -1,
  -1,
  7344,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "static"
  ContextualKeyword._static << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "su"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7398,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sup"
  -1,
  -1,
  -1,
  -1,
  -1,
  7425,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "supe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7452,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "super"
  (TokenType._super << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sw"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7506,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7533,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swit"
  -1,
  -1,
  -1,
  7560,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7587,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switch"
  (TokenType._switch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7641,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sym"
  -1,
  -1,
  7668,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7695,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7722,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbol"
  ContextualKeyword._symbol << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "t"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7776,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7938,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8046,
  -1,
  // "th"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7803,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7857,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7830,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "this"
  (TokenType._this << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7884,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7911,
  -1,
  -1,
  -1,
  // "throw"
  (TokenType._throw << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "tr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7965,
  -1,
  -1,
  -1,
  8019,
  -1,
  // "tru"
  -1,
  -1,
  -1,
  -1,
  -1,
  7992,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "true"
  (TokenType._true << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "try"
  (TokenType._try << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ty"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8073,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typ"
  -1,
  -1,
  -1,
  -1,
  -1,
  8100,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "type"
  ContextualKeyword._type << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8127,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8154,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeof"
  (TokenType._typeof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "u"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8208,
  -1,
  -1,
  -1,
  -1,
  8343,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "un"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8235,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uni"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8262,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8289,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  8316,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "unique"
  ContextualKeyword._unique << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "us"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8370,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8397,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8424,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "using"
  ContextualKeyword._using << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "v"
  -1,
  8478,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8532,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "va"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8505,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "var"
  (TokenType._var << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "vo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8559,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "voi"
  -1,
  -1,
  -1,
  -1,
  8586,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "void"
  (TokenType._void << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "w"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8640,
  8748,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wh"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8667,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8694,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whil"
  -1,
  -1,
  -1,
  -1,
  -1,
  8721,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "while"
  (TokenType._while << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8775,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wit"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8802,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "with"
  (TokenType._with << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "y"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8856,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yi"
  -1,
  -1,
  -1,
  -1,
  -1,
  8883,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8910,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yiel"
  -1,
  -1,
  -1,
  -1,
  8937,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yield"
  (TokenType._yield << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);

// node_modules/sucrase/dist/esm/parser/tokenizer/readWord.js
function readWord() {
  let treePos = 0;
  let code = 0;
  let pos = state.pos;
  while (pos < input.length) {
    code = input.charCodeAt(pos);
    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {
      break;
    }
    const next2 = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];
    if (next2 === -1) {
      break;
    } else {
      treePos = next2;
      pos++;
    }
  }
  const keywordValue = READ_WORD_TREE[treePos];
  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {
    state.pos = pos;
    if (keywordValue & 1) {
      finishToken(keywordValue >>> 1);
    } else {
      finishToken(TokenType.name, keywordValue >>> 1);
    }
    return;
  }
  while (pos < input.length) {
    const ch = input.charCodeAt(pos);
    if (IS_IDENTIFIER_CHAR[ch]) {
      pos++;
    } else if (ch === charCodes.backslash) {
      pos += 2;
      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {
        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {
          pos++;
        }
        pos++;
      }
    } else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {
      pos += 2;
    } else {
      break;
    }
  }
  state.pos = pos;
  finishToken(TokenType.name);
}

// node_modules/sucrase/dist/esm/parser/tokenizer/index.js
var IdentifierRole;
(function(IdentifierRole2) {
  const Access = 0;
  IdentifierRole2[IdentifierRole2["Access"] = Access] = "Access";
  const ExportAccess = Access + 1;
  IdentifierRole2[IdentifierRole2["ExportAccess"] = ExportAccess] = "ExportAccess";
  const TopLevelDeclaration = ExportAccess + 1;
  IdentifierRole2[IdentifierRole2["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
  const FunctionScopedDeclaration = TopLevelDeclaration + 1;
  IdentifierRole2[IdentifierRole2["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
  const BlockScopedDeclaration = FunctionScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
  const ImportDeclaration = ObjectShorthand + 1;
  IdentifierRole2[IdentifierRole2["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
  const ObjectKey = ImportDeclaration + 1;
  IdentifierRole2[IdentifierRole2["ObjectKey"] = ObjectKey] = "ObjectKey";
  const ImportAccess = ObjectKey + 1;
  IdentifierRole2[IdentifierRole2["ImportAccess"] = ImportAccess] = "ImportAccess";
})(IdentifierRole || (IdentifierRole = {}));
var JSXRole;
(function(JSXRole2) {
  const NoChildren = 0;
  JSXRole2[JSXRole2["NoChildren"] = NoChildren] = "NoChildren";
  const OneChild = NoChildren + 1;
  JSXRole2[JSXRole2["OneChild"] = OneChild] = "OneChild";
  const StaticChildren = OneChild + 1;
  JSXRole2[JSXRole2["StaticChildren"] = StaticChildren] = "StaticChildren";
  const KeyAfterPropSpread = StaticChildren + 1;
  JSXRole2[JSXRole2["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
})(JSXRole || (JSXRole = {}));
function isDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isNonTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;
}
function isBlockScopedDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isFunctionScopedDeclaration(token) {
  const role = token.identifierRole;
  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
function isObjectShorthandDeclaration(token) {
  return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
var Token = class {
  constructor() {
    this.type = state.type;
    this.contextualKeyword = state.contextualKeyword;
    this.start = state.start;
    this.end = state.end;
    this.scopeDepth = state.scopeDepth;
    this.isType = state.isType;
    this.identifierRole = null;
    this.jsxRole = null;
    this.shadowsGlobal = false;
    this.isAsyncOperation = false;
    this.contextId = null;
    this.rhsEndIndex = null;
    this.isExpression = false;
    this.numNullishCoalesceStarts = 0;
    this.numNullishCoalesceEnds = 0;
    this.isOptionalChainStart = false;
    this.isOptionalChainEnd = false;
    this.subscriptStartIndex = null;
    this.nullishStartIndex = null;
  }
  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.
  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.
  // For assignments, the index of the RHS. For export tokens, the end of the export.
  // For class tokens, records if the class is a class expression or a class statement.
  // Number of times to insert a `nullishCoalesce(` snippet before this token.
  // Number of times to insert a `)` snippet after this token.
  // If true, insert an `optionalChain([` snippet before this token.
  // If true, insert a `])` snippet after this token.
  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.
  // Tag for `??` operators to denote the root token for this nullish coalescing call.
};
function next() {
  state.tokens.push(new Token());
  nextToken();
}
function nextTemplateToken() {
  state.tokens.push(new Token());
  state.start = state.pos;
  readTmplToken();
}
function retokenizeSlashAsRegex() {
  if (state.type === TokenType.assign) {
    --state.pos;
  }
  readRegexp();
}
function pushTypeContext(existingTokensInType) {
  for (let i2 = state.tokens.length - existingTokensInType; i2 < state.tokens.length; i2++) {
    state.tokens[i2].isType = true;
  }
  const oldIsType = state.isType;
  state.isType = true;
  return oldIsType;
}
function popTypeContext(oldIsType) {
  state.isType = oldIsType;
}
function eat(type) {
  if (match(type)) {
    next();
    return true;
  } else {
    return false;
  }
}
function eatTypeToken(tokenType) {
  const oldIsType = state.isType;
  state.isType = true;
  eat(tokenType);
  state.isType = oldIsType;
}
function match(type) {
  return state.type === type;
}
function lookaheadType() {
  const snapshot = state.snapshot();
  next();
  const type = state.type;
  state.restoreFromSnapshot(snapshot);
  return type;
}
var TypeAndKeyword = class {
  constructor(type, contextualKeyword) {
    this.type = type;
    this.contextualKeyword = contextualKeyword;
  }
};
function lookaheadTypeAndKeyword() {
  const snapshot = state.snapshot();
  next();
  const type = state.type;
  const contextualKeyword = state.contextualKeyword;
  state.restoreFromSnapshot(snapshot);
  return new TypeAndKeyword(type, contextualKeyword);
}
function nextTokenStart() {
  return nextTokenStartSince(state.pos);
}
function nextTokenStartSince(pos) {
  skipWhiteSpace.lastIndex = pos;
  const skip = skipWhiteSpace.exec(input);
  return pos + skip[0].length;
}
function lookaheadCharCode() {
  return input.charCodeAt(nextTokenStart());
}
function nextToken() {
  skipSpace();
  state.start = state.pos;
  if (state.pos >= input.length) {
    const tokens = state.tokens;
    if (tokens.length >= 2 && tokens[tokens.length - 1].start >= input.length && tokens[tokens.length - 2].start >= input.length) {
      unexpected("Unexpectedly reached the end of input.");
    }
    finishToken(TokenType.eof);
    return;
  }
  readToken(input.charCodeAt(state.pos));
}
function readToken(code) {
  if (IS_IDENTIFIER_START[code] || code === charCodes.backslash || code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign) {
    readWord();
  } else {
    getTokenFromCode(code);
  }
}
function skipBlockComment() {
  while (input.charCodeAt(state.pos) !== charCodes.asterisk || input.charCodeAt(state.pos + 1) !== charCodes.slash) {
    state.pos++;
    if (state.pos > input.length) {
      unexpected("Unterminated comment", state.pos - 2);
      return;
    }
  }
  state.pos += 2;
}
function skipLineComment(startSkip) {
  let ch = input.charCodeAt(state.pos += startSkip);
  if (state.pos < input.length) {
    while (ch !== charCodes.lineFeed && ch !== charCodes.carriageReturn && ch !== charCodes.lineSeparator && ch !== charCodes.paragraphSeparator && ++state.pos < input.length) {
      ch = input.charCodeAt(state.pos);
    }
  }
}
function skipSpace() {
  while (state.pos < input.length) {
    const ch = input.charCodeAt(state.pos);
    switch (ch) {
      case charCodes.carriageReturn:
        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {
          ++state.pos;
        }
      case charCodes.lineFeed:
      case charCodes.lineSeparator:
      case charCodes.paragraphSeparator:
        ++state.pos;
        break;
      case charCodes.slash:
        switch (input.charCodeAt(state.pos + 1)) {
          case charCodes.asterisk:
            state.pos += 2;
            skipBlockComment();
            break;
          case charCodes.slash:
            skipLineComment(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (IS_WHITESPACE[ch]) {
          ++state.pos;
        } else {
          return;
        }
    }
  }
}
function finishToken(type, contextualKeyword = ContextualKeyword.NONE) {
  state.end = state.pos;
  state.type = type;
  state.contextualKeyword = contextualKeyword;
}
function readToken_dot() {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {
    readNumber(true);
    return;
  }
  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {
    state.pos += 3;
    finishToken(TokenType.ellipsis);
  } else {
    ++state.pos;
    finishToken(TokenType.dot);
  }
}
function readToken_slash() {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
  } else {
    finishOp(TokenType.slash, 1);
  }
}
function readToken_mult_modulo(code) {
  let tokenType = code === charCodes.asterisk ? TokenType.star : TokenType.modulo;
  let width = 1;
  let nextChar = input.charCodeAt(state.pos + 1);
  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {
    width++;
    nextChar = input.charCodeAt(state.pos + 2);
    tokenType = TokenType.exponent;
  }
  if (nextChar === charCodes.equalsTo && input.charCodeAt(state.pos + 2) !== charCodes.greaterThan) {
    width++;
    tokenType = TokenType.assign;
  }
  finishOp(tokenType, width);
}
function readToken_pipe_amp(code) {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === code) {
    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
      finishOp(TokenType.assign, 3);
    } else {
      finishOp(code === charCodes.verticalBar ? TokenType.logicalOR : TokenType.logicalAND, 2);
    }
    return;
  }
  if (code === charCodes.verticalBar) {
    if (nextChar === charCodes.greaterThan) {
      finishOp(TokenType.pipeline, 2);
      return;
    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {
      finishOp(TokenType.braceBarR, 2);
      return;
    }
  }
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
    return;
  }
  finishOp(code === charCodes.verticalBar ? TokenType.bitwiseOR : TokenType.bitwiseAND, 1);
}
function readToken_caret() {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
  } else {
    finishOp(TokenType.bitwiseXOR, 1);
  }
}
function readToken_plus_min(code) {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === code) {
    finishOp(TokenType.preIncDec, 2);
    return;
  }
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.assign, 2);
  } else if (code === charCodes.plusSign) {
    finishOp(TokenType.plus, 1);
  } else {
    finishOp(TokenType.minus, 1);
  }
}
function readToken_lt() {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.lessThan) {
    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {
      finishOp(TokenType.assign, 3);
      return;
    }
    if (state.isType) {
      finishOp(TokenType.lessThan, 1);
    } else {
      finishOp(TokenType.bitShiftL, 2);
    }
    return;
  }
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.relationalOrEqual, 2);
  } else {
    finishOp(TokenType.lessThan, 1);
  }
}
function readToken_gt() {
  if (state.isType) {
    finishOp(TokenType.greaterThan, 1);
    return;
  }
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.greaterThan) {
    const size2 = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;
    if (input.charCodeAt(state.pos + size2) === charCodes.equalsTo) {
      finishOp(TokenType.assign, size2 + 1);
      return;
    }
    finishOp(TokenType.bitShiftR, size2);
    return;
  }
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.relationalOrEqual, 2);
  } else {
    finishOp(TokenType.greaterThan, 1);
  }
}
function rescan_gt() {
  if (state.type === TokenType.greaterThan) {
    state.pos -= 1;
    readToken_gt();
  }
}
function readToken_eq_excl(code) {
  const nextChar = input.charCodeAt(state.pos + 1);
  if (nextChar === charCodes.equalsTo) {
    finishOp(TokenType.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);
    return;
  }
  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {
    state.pos += 2;
    finishToken(TokenType.arrow);
    return;
  }
  finishOp(code === charCodes.equalsTo ? TokenType.eq : TokenType.bang, 1);
}
function readToken_question() {
  const nextChar = input.charCodeAt(state.pos + 1);
  const nextChar2 = input.charCodeAt(state.pos + 2);
  if (nextChar === charCodes.questionMark && // In Flow (but not TypeScript), ??string is a valid type that should be
  // tokenized as two individual ? tokens.
  !(isFlowEnabled && state.isType)) {
    if (nextChar2 === charCodes.equalsTo) {
      finishOp(TokenType.assign, 3);
    } else {
      finishOp(TokenType.nullishCoalescing, 2);
    }
  } else if (nextChar === charCodes.dot && !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)) {
    state.pos += 2;
    finishToken(TokenType.questionDot);
  } else {
    ++state.pos;
    finishToken(TokenType.question);
  }
}
function getTokenFromCode(code) {
  switch (code) {
    case charCodes.numberSign:
      ++state.pos;
      finishToken(TokenType.hash);
      return;
    case charCodes.dot:
      readToken_dot();
      return;
    case charCodes.leftParenthesis:
      ++state.pos;
      finishToken(TokenType.parenL);
      return;
    case charCodes.rightParenthesis:
      ++state.pos;
      finishToken(TokenType.parenR);
      return;
    case charCodes.semicolon:
      ++state.pos;
      finishToken(TokenType.semi);
      return;
    case charCodes.comma:
      ++state.pos;
      finishToken(TokenType.comma);
      return;
    case charCodes.leftSquareBracket:
      ++state.pos;
      finishToken(TokenType.bracketL);
      return;
    case charCodes.rightSquareBracket:
      ++state.pos;
      finishToken(TokenType.bracketR);
      return;
    case charCodes.leftCurlyBrace:
      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {
        finishOp(TokenType.braceBarL, 2);
      } else {
        ++state.pos;
        finishToken(TokenType.braceL);
      }
      return;
    case charCodes.rightCurlyBrace:
      ++state.pos;
      finishToken(TokenType.braceR);
      return;
    case charCodes.colon:
      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {
        finishOp(TokenType.doubleColon, 2);
      } else {
        ++state.pos;
        finishToken(TokenType.colon);
      }
      return;
    case charCodes.questionMark:
      readToken_question();
      return;
    case charCodes.atSign:
      ++state.pos;
      finishToken(TokenType.at);
      return;
    case charCodes.graveAccent:
      ++state.pos;
      finishToken(TokenType.backQuote);
      return;
    case charCodes.digit0: {
      const nextChar = input.charCodeAt(state.pos + 1);
      if (nextChar === charCodes.lowercaseX || nextChar === charCodes.uppercaseX || nextChar === charCodes.lowercaseO || nextChar === charCodes.uppercaseO || nextChar === charCodes.lowercaseB || nextChar === charCodes.uppercaseB) {
        readRadixNumber();
        return;
      }
    }
    case charCodes.digit1:
    case charCodes.digit2:
    case charCodes.digit3:
    case charCodes.digit4:
    case charCodes.digit5:
    case charCodes.digit6:
    case charCodes.digit7:
    case charCodes.digit8:
    case charCodes.digit9:
      readNumber(false);
      return;
    case charCodes.quotationMark:
    case charCodes.apostrophe:
      readString(code);
      return;
    case charCodes.slash:
      readToken_slash();
      return;
    case charCodes.percentSign:
    case charCodes.asterisk:
      readToken_mult_modulo(code);
      return;
    case charCodes.verticalBar:
    case charCodes.ampersand:
      readToken_pipe_amp(code);
      return;
    case charCodes.caret:
      readToken_caret();
      return;
    case charCodes.plusSign:
    case charCodes.dash:
      readToken_plus_min(code);
      return;
    case charCodes.lessThan:
      readToken_lt();
      return;
    case charCodes.greaterThan:
      readToken_gt();
      return;
    case charCodes.equalsTo:
    case charCodes.exclamationMark:
      readToken_eq_excl(code);
      return;
    case charCodes.tilde:
      finishOp(TokenType.tilde, 1);
      return;
    default:
      break;
  }
  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);
}
function finishOp(type, size2) {
  state.pos += size2;
  finishToken(type);
}
function readRegexp() {
  const start = state.pos;
  let escaped = false;
  let inClass = false;
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated regular expression", start);
      return;
    }
    const code = input.charCodeAt(state.pos);
    if (escaped) {
      escaped = false;
    } else {
      if (code === charCodes.leftSquareBracket) {
        inClass = true;
      } else if (code === charCodes.rightSquareBracket && inClass) {
        inClass = false;
      } else if (code === charCodes.slash && !inClass) {
        break;
      }
      escaped = code === charCodes.backslash;
    }
    ++state.pos;
  }
  ++state.pos;
  skipWord();
  finishToken(TokenType.regexp);
}
function readInt() {
  while (true) {
    const code = input.charCodeAt(state.pos);
    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code === charCodes.underscore) {
      state.pos++;
    } else {
      break;
    }
  }
}
function readRadixNumber() {
  state.pos += 2;
  while (true) {
    const code = input.charCodeAt(state.pos);
    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF || code === charCodes.underscore) {
      state.pos++;
    } else {
      break;
    }
  }
  const nextChar = input.charCodeAt(state.pos);
  if (nextChar === charCodes.lowercaseN) {
    ++state.pos;
    finishToken(TokenType.bigint);
  } else {
    finishToken(TokenType.num);
  }
}
function readNumber(startsWithDot) {
  let isBigInt = false;
  let isDecimal = false;
  if (!startsWithDot) {
    readInt();
  }
  let nextChar = input.charCodeAt(state.pos);
  if (nextChar === charCodes.dot) {
    ++state.pos;
    readInt();
    nextChar = input.charCodeAt(state.pos);
  }
  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {
    nextChar = input.charCodeAt(++state.pos);
    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {
      ++state.pos;
    }
    readInt();
    nextChar = input.charCodeAt(state.pos);
  }
  if (nextChar === charCodes.lowercaseN) {
    ++state.pos;
    isBigInt = true;
  } else if (nextChar === charCodes.lowercaseM) {
    ++state.pos;
    isDecimal = true;
  }
  if (isBigInt) {
    finishToken(TokenType.bigint);
    return;
  }
  if (isDecimal) {
    finishToken(TokenType.decimal);
    return;
  }
  finishToken(TokenType.num);
}
function readString(quote2) {
  state.pos++;
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated string constant");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.backslash) {
      state.pos++;
    } else if (ch === quote2) {
      break;
    }
    state.pos++;
  }
  state.pos++;
  finishToken(TokenType.string);
}
function readTmplToken() {
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated template");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.graveAccent || ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace) {
      if (state.pos === state.start && match(TokenType.template)) {
        if (ch === charCodes.dollarSign) {
          state.pos += 2;
          finishToken(TokenType.dollarBraceL);
          return;
        } else {
          ++state.pos;
          finishToken(TokenType.backQuote);
          return;
        }
      }
      finishToken(TokenType.template);
      return;
    }
    if (ch === charCodes.backslash) {
      state.pos++;
    }
    state.pos++;
  }
}
function skipWord() {
  while (state.pos < input.length) {
    const ch = input.charCodeAt(state.pos);
    if (IS_IDENTIFIER_CHAR[ch]) {
      state.pos++;
    } else if (ch === charCodes.backslash) {
      state.pos += 2;
      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {
        while (state.pos < input.length && input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace) {
          state.pos++;
        }
        state.pos++;
      }
    } else {
      break;
    }
  }
}

// node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js
function getImportExportSpecifierInfo(tokens, index = tokens.currentIndex()) {
  let endIndex = index + 1;
  if (isSpecifierEnd(tokens, endIndex)) {
    const name = tokens.identifierNameAtIndex(index);
    return {
      isType: false,
      leftName: name,
      rightName: name,
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    return {
      isType: true,
      leftName: null,
      rightName: null,
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    return {
      isType: false,
      leftName: tokens.identifierNameAtIndex(index),
      rightName: tokens.identifierNameAtIndex(index + 2),
      endIndex
    };
  }
  endIndex++;
  if (isSpecifierEnd(tokens, endIndex)) {
    return {
      isType: true,
      leftName: null,
      rightName: null,
      endIndex
    };
  }
  throw new Error(`Unexpected import/export specifier at ${index}`);
}
function isSpecifierEnd(tokens, index) {
  const token = tokens.tokens[index];
  return token.type === TokenType.braceR || token.type === TokenType.comma;
}

// node_modules/sucrase/dist/esm/parser/plugins/jsx/xhtml.js
var xhtml_default = /* @__PURE__ */ new Map([
  ["quot", '"'],
  ["amp", "&"],
  ["apos", "'"],
  ["lt", "<"],
  ["gt", ">"],
  ["nbsp", "Â "],
  ["iexcl", "Â¡"],
  ["cent", "Â¢"],
  ["pound", "Â£"],
  ["curren", "Â¤"],
  ["yen", "Â¥"],
  ["brvbar", "Â¦"],
  ["sect", "Â§"],
  ["uml", "Â¨"],
  ["copy", "Â©"],
  ["ordf", "Âª"],
  ["laquo", "Â«"],
  ["not", "Â¬"],
  ["shy", "Â­"],
  ["reg", "Â®"],
  ["macr", "Â¯"],
  ["deg", "Â°"],
  ["plusmn", "Â±"],
  ["sup2", "Â²"],
  ["sup3", "Â³"],
  ["acute", "Â´"],
  ["micro", "Âµ"],
  ["para", "Â¶"],
  ["middot", "Â·"],
  ["cedil", "Â¸"],
  ["sup1", "Â¹"],
  ["ordm", "Âº"],
  ["raquo", "Â»"],
  ["frac14", "Â¼"],
  ["frac12", "Â½"],
  ["frac34", "Â¾"],
  ["iquest", "Â¿"],
  ["Agrave", "Ã"],
  ["Aacute", "Ã"],
  ["Acirc", "Ã"],
  ["Atilde", "Ã"],
  ["Auml", "Ã"],
  ["Aring", "Ã"],
  ["AElig", "Ã"],
  ["Ccedil", "Ã"],
  ["Egrave", "Ã"],
  ["Eacute", "Ã"],
  ["Ecirc", "Ã"],
  ["Euml", "Ã"],
  ["Igrave", "Ã"],
  ["Iacute", "Ã"],
  ["Icirc", "Ã"],
  ["Iuml", "Ã"],
  ["ETH", "Ã"],
  ["Ntilde", "Ã"],
  ["Ograve", "Ã"],
  ["Oacute", "Ã"],
  ["Ocirc", "Ã"],
  ["Otilde", "Ã"],
  ["Ouml", "Ã"],
  ["times", "Ã"],
  ["Oslash", "Ã"],
  ["Ugrave", "Ã"],
  ["Uacute", "Ã"],
  ["Ucirc", "Ã"],
  ["Uuml", "Ã"],
  ["Yacute", "Ã"],
  ["THORN", "Ã"],
  ["szlig", "Ã"],
  ["agrave", "Ã "],
  ["aacute", "Ã¡"],
  ["acirc", "Ã¢"],
  ["atilde", "Ã£"],
  ["auml", "Ã¤"],
  ["aring", "Ã¥"],
  ["aelig", "Ã¦"],
  ["ccedil", "Ã§"],
  ["egrave", "Ã¨"],
  ["eacute", "Ã©"],
  ["ecirc", "Ãª"],
  ["euml", "Ã«"],
  ["igrave", "Ã¬"],
  ["iacute", "Ã­"],
  ["icirc", "Ã®"],
  ["iuml", "Ã¯"],
  ["eth", "Ã°"],
  ["ntilde", "Ã±"],
  ["ograve", "Ã²"],
  ["oacute", "Ã³"],
  ["ocirc", "Ã´"],
  ["otilde", "Ãµ"],
  ["ouml", "Ã¶"],
  ["divide", "Ã·"],
  ["oslash", "Ã¸"],
  ["ugrave", "Ã¹"],
  ["uacute", "Ãº"],
  ["ucirc", "Ã»"],
  ["uuml", "Ã¼"],
  ["yacute", "Ã½"],
  ["thorn", "Ã¾"],
  ["yuml", "Ã¿"],
  ["OElig", "Å"],
  ["oelig", "Å"],
  ["Scaron", "Å "],
  ["scaron", "Å¡"],
  ["Yuml", "Å¸"],
  ["fnof", "Æ"],
  ["circ", "Ë"],
  ["tilde", "Ë"],
  ["Alpha", "Î"],
  ["Beta", "Î"],
  ["Gamma", "Î"],
  ["Delta", "Î"],
  ["Epsilon", "Î"],
  ["Zeta", "Î"],
  ["Eta", "Î"],
  ["Theta", "Î"],
  ["Iota", "Î"],
  ["Kappa", "Î"],
  ["Lambda", "Î"],
  ["Mu", "Î"],
  ["Nu", "Î"],
  ["Xi", "Î"],
  ["Omicron", "Î"],
  ["Pi", "Î "],
  ["Rho", "Î¡"],
  ["Sigma", "Î£"],
  ["Tau", "Î¤"],
  ["Upsilon", "Î¥"],
  ["Phi", "Î¦"],
  ["Chi", "Î§"],
  ["Psi", "Î¨"],
  ["Omega", "Î©"],
  ["alpha", "Î±"],
  ["beta", "Î²"],
  ["gamma", "Î³"],
  ["delta", "Î´"],
  ["epsilon", "Îµ"],
  ["zeta", "Î¶"],
  ["eta", "Î·"],
  ["theta", "Î¸"],
  ["iota", "Î¹"],
  ["kappa", "Îº"],
  ["lambda", "Î»"],
  ["mu", "Î¼"],
  ["nu", "Î½"],
  ["xi", "Î¾"],
  ["omicron", "Î¿"],
  ["pi", "Ï"],
  ["rho", "Ï"],
  ["sigmaf", "Ï"],
  ["sigma", "Ï"],
  ["tau", "Ï"],
  ["upsilon", "Ï"],
  ["phi", "Ï"],
  ["chi", "Ï"],
  ["psi", "Ï"],
  ["omega", "Ï"],
  ["thetasym", "Ï"],
  ["upsih", "Ï"],
  ["piv", "Ï"],
  ["ensp", "â"],
  ["emsp", "â"],
  ["thinsp", "â"],
  ["zwnj", "â"],
  ["zwj", "â"],
  ["lrm", "â"],
  ["rlm", "â"],
  ["ndash", "â"],
  ["mdash", "â"],
  ["lsquo", "â"],
  ["rsquo", "â"],
  ["sbquo", "â"],
  ["ldquo", "â"],
  ["rdquo", "â"],
  ["bdquo", "â"],
  ["dagger", "â "],
  ["Dagger", "â¡"],
  ["bull", "â¢"],
  ["hellip", "â¦"],
  ["permil", "â°"],
  ["prime", "â²"],
  ["Prime", "â³"],
  ["lsaquo", "â¹"],
  ["rsaquo", "âº"],
  ["oline", "â¾"],
  ["frasl", "â"],
  ["euro", "â¬"],
  ["image", "â"],
  ["weierp", "â"],
  ["real", "â"],
  ["trade", "â¢"],
  ["alefsym", "âµ"],
  ["larr", "â"],
  ["uarr", "â"],
  ["rarr", "â"],
  ["darr", "â"],
  ["harr", "â"],
  ["crarr", "âµ"],
  ["lArr", "â"],
  ["uArr", "â"],
  ["rArr", "â"],
  ["dArr", "â"],
  ["hArr", "â"],
  ["forall", "â"],
  ["part", "â"],
  ["exist", "â"],
  ["empty", "â"],
  ["nabla", "â"],
  ["isin", "â"],
  ["notin", "â"],
  ["ni", "â"],
  ["prod", "â"],
  ["sum", "â"],
  ["minus", "â"],
  ["lowast", "â"],
  ["radic", "â"],
  ["prop", "â"],
  ["infin", "â"],
  ["ang", "â "],
  ["and", "â§"],
  ["or", "â¨"],
  ["cap", "â©"],
  ["cup", "âª"],
  ["int", "â«"],
  ["there4", "â´"],
  ["sim", "â¼"],
  ["cong", "â"],
  ["asymp", "â"],
  ["ne", "â "],
  ["equiv", "â¡"],
  ["le", "â¤"],
  ["ge", "â¥"],
  ["sub", "â"],
  ["sup", "â"],
  ["nsub", "â"],
  ["sube", "â"],
  ["supe", "â"],
  ["oplus", "â"],
  ["otimes", "â"],
  ["perp", "â¥"],
  ["sdot", "â"],
  ["lceil", "â"],
  ["rceil", "â"],
  ["lfloor", "â"],
  ["rfloor", "â"],
  ["lang", "â©"],
  ["rang", "âª"],
  ["loz", "â"],
  ["spades", "â "],
  ["clubs", "â£"],
  ["hearts", "â¥"],
  ["diams", "â¦"]
]);

// node_modules/sucrase/dist/esm/util/getJSXPragmaInfo.js
function getJSXPragmaInfo(options) {
  const [base, suffix] = splitPragma(options.jsxPragma || "React.createElement");
  const [fragmentBase, fragmentSuffix] = splitPragma(options.jsxFragmentPragma || "React.Fragment");
  return { base, suffix, fragmentBase, fragmentSuffix };
}
function splitPragma(pragma) {
  let dotIndex = pragma.indexOf(".");
  if (dotIndex === -1) {
    dotIndex = pragma.length;
  }
  return [pragma.slice(0, dotIndex), pragma.slice(dotIndex)];
}

// node_modules/sucrase/dist/esm/transformers/Transformer.js
var Transformer = class {
  // Return true if anything was processed, false otherwise.
  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
};

// node_modules/sucrase/dist/esm/transformers/JSXTransformer.js
var JSXTransformer = class _JSXTransformer extends Transformer {
  // State for calculating the line number of each JSX tag in development.
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }
  // In development, variable name holding the name of the current file.
  __init3() {
    this.filenameVarName = null;
  }
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(rootTransformer, tokens, importProcessor, nameManager, options) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.nameManager = nameManager;
    this.options = options;
    _JSXTransformer.prototype.__init.call(this);
    _JSXTransformer.prototype.__init2.call(this);
    _JSXTransformer.prototype.__init3.call(this);
    _JSXTransformer.prototype.__init4.call(this);
    _JSXTransformer.prototype.__init5.call(this);
    ;
    this.jsxPragmaInfo = getJSXPragmaInfo(options);
    this.isAutomaticRuntime = options.jsxRuntime === "automatic";
    this.jsxImportSource = options.jsxImportSource || "react";
  }
  process() {
    if (this.tokens.matches1(TokenType.jsxTagStart)) {
      this.processJSXTag();
      return true;
    }
    return false;
  }
  getPrefixCode() {
    let prefix = "";
    if (this.filenameVarName) {
      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
    }
    if (this.isAutomaticRuntime) {
      if (this.importProcessor) {
        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {
          prefix += `var ${resolvedName} = require("${path}");`;
        }
      } else {
        const { createElement: createElementResolution, ...otherResolutions } = this.esmAutomaticImportNameResolutions;
        if (createElementResolution) {
          prefix += `import {createElement as ${createElementResolution}} from "${this.jsxImportSource}";`;
        }
        const importSpecifiers = Object.entries(otherResolutions).map(([name, resolvedName]) => `${name} as ${resolvedName}`).join(", ");
        if (importSpecifiers) {
          const importPath = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          prefix += `import {${importSpecifiers}} from "${importPath}";`;
        }
      }
    }
    return prefix;
  }
  processJSXTag() {
    const { jsxRole, start } = this.tokens.currentToken();
    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);
    if (this.isAutomaticRuntime && jsxRole !== JSXRole.KeyAfterPropSpread) {
      this.transformTagToJSXFunc(elementLocationCode, jsxRole);
    } else {
      this.transformTagToCreateElement(elementLocationCode);
    }
  }
  getElementLocationCode(firstTokenStart) {
    const lineNumber = this.getLineNumberForIndex(firstTokenStart);
    return `lineNumber: ${lineNumber}`;
  }
  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(index) {
    const code = this.tokens.code;
    while (this.lastIndex < index && this.lastIndex < code.length) {
      if (code[this.lastIndex] === "\n") {
        this.lastLineNumber++;
      }
      this.lastIndex++;
    }
    return this.lastLineNumber;
  }
  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(elementLocationCode, jsxRole) {
    const isStatic = jsxRole === JSXRole.StaticChildren;
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));
    let keyCode = null;
    if (this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);
      this.processAutomaticChildrenAndEndProps(jsxRole);
    } else {
      this.processTagIntro();
      this.tokens.appendCode(", {");
      keyCode = this.processProps(true);
      if (this.tokens.matches2(TokenType.slash, TokenType.jsxTagEnd)) {
        this.tokens.appendCode("}");
      } else if (this.tokens.matches1(TokenType.jsxTagEnd)) {
        this.tokens.removeToken();
        this.processAutomaticChildrenAndEndProps(jsxRole);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
      if (keyCode) {
        this.tokens.appendCode(`, ${keyCode}`);
      }
    }
    if (!this.options.production) {
      if (keyCode === null) {
        this.tokens.appendCode(", void 0");
      }
      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);
    }
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }
  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(elementLocationCode) {
    this.tokens.replaceToken(this.getCreateElementInvocationCode());
    if (this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);
      this.processChildren(true);
    } else {
      this.processTagIntro();
      this.processPropsObjectWithDevInfo(elementLocationCode);
      if (this.tokens.matches2(TokenType.slash, TokenType.jsxTagEnd)) {
      } else if (this.tokens.matches1(TokenType.jsxTagEnd)) {
        this.tokens.removeToken();
        this.processChildren(true);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
    }
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }
  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(isStatic) {
    if (this.options.production) {
      if (isStatic) {
        return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
      } else {
        return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
      }
    } else {
      return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
  }
  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedFuncInvocation("createElement", "");
    } else {
      const { jsxPragmaInfo } = this;
      const resolvedPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base : jsxPragmaInfo.base;
      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
    }
  }
  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime"
      );
    } else {
      const { jsxPragmaInfo } = this;
      const resolvedFragmentPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) || jsxPragmaInfo.fragmentBase : jsxPragmaInfo.fragmentBase;
      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
    }
  }
  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
    if (this.importProcessor) {
      return `${funcCode}.call(void 0, `;
    } else {
      return `${funcCode}(`;
    }
  }
  claimAutoImportedName(funcName, importPathSuffix) {
    if (this.importProcessor) {
      const path = this.jsxImportSource + importPathSuffix;
      if (!this.cjsAutomaticModuleNameResolutions[path]) {
        this.cjsAutomaticModuleNameResolutions[path] = this.importProcessor.getFreeIdentifierForPath(path);
      }
      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
    } else {
      if (!this.esmAutomaticImportNameResolutions[funcName]) {
        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(
          `_${funcName}`
        );
      }
      return this.esmAutomaticImportNameResolutions[funcName];
    }
  }
  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    let introEnd = this.tokens.currentIndex() + 1;
    while (this.tokens.tokens[introEnd].isType || !this.tokens.matches2AtIndex(introEnd - 1, TokenType.jsxName, TokenType.jsxName) && !this.tokens.matches2AtIndex(introEnd - 1, TokenType.greaterThan, TokenType.jsxName) && !this.tokens.matches1AtIndex(introEnd, TokenType.braceL) && !this.tokens.matches1AtIndex(introEnd, TokenType.jsxTagEnd) && !this.tokens.matches2AtIndex(introEnd, TokenType.slash, TokenType.jsxTagEnd)) {
      introEnd++;
    }
    if (introEnd === this.tokens.currentIndex() + 1) {
      const tagName = this.tokens.identifierName();
      if (startsWithLowerCase(tagName)) {
        this.tokens.replaceToken(`'${tagName}'`);
      }
    }
    while (this.tokens.currentIndex() < introEnd) {
      this.rootTransformer.processToken();
    }
  }
  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(elementLocationCode) {
    const devProps = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;
    if (!this.tokens.matches1(TokenType.jsxName) && !this.tokens.matches1(TokenType.braceL)) {
      if (devProps) {
        this.tokens.appendCode(`, {${devProps}}`);
      } else {
        this.tokens.appendCode(`, null`);
      }
      return;
    }
    this.tokens.appendCode(`, {`);
    this.processProps(false);
    if (devProps) {
      this.tokens.appendCode(` ${devProps}}`);
    } else {
      this.tokens.appendCode("}");
    }
  }
  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(extractKeyCode) {
    let keyCode = null;
    while (true) {
      if (this.tokens.matches2(TokenType.jsxName, TokenType.eq)) {
        const propName = this.tokens.identifierName();
        if (extractKeyCode && propName === "key") {
          if (keyCode !== null) {
            this.tokens.appendCode(keyCode.replace(/[^\n]/g, ""));
          }
          this.tokens.removeToken();
          this.tokens.removeToken();
          const snapshot = this.tokens.snapshot();
          this.processPropValue();
          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);
          continue;
        } else {
          this.processPropName(propName);
          this.tokens.replaceToken(": ");
          this.processPropValue();
        }
      } else if (this.tokens.matches1(TokenType.jsxName)) {
        const propName = this.tokens.identifierName();
        this.processPropName(propName);
        this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(TokenType.braceL)) {
        this.tokens.replaceToken("");
        this.rootTransformer.processBalancedCode();
        this.tokens.replaceToken("");
      } else {
        break;
      }
      this.tokens.appendCode(",");
    }
    return keyCode;
  }
  processPropName(propName) {
    if (propName.includes("-")) {
      this.tokens.replaceToken(`'${propName}'`);
    } else {
      this.tokens.copyToken();
    }
  }
  processPropValue() {
    if (this.tokens.matches1(TokenType.braceL)) {
      this.tokens.replaceToken("");
      this.rootTransformer.processBalancedCode();
      this.tokens.replaceToken("");
    } else if (this.tokens.matches1(TokenType.jsxTagStart)) {
      this.processJSXTag();
    } else {
      this.processStringPropValue();
    }
  }
  processStringPropValue() {
    const token = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXStringValueLiteral(valueCode);
    this.tokens.replaceToken(literalCode + replacementCode);
  }
  /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */
  processAutomaticChildrenAndEndProps(jsxRole) {
    if (jsxRole === JSXRole.StaticChildren) {
      this.tokens.appendCode(" children: [");
      this.processChildren(false);
      this.tokens.appendCode("]}");
    } else {
      if (jsxRole === JSXRole.OneChild) {
        this.tokens.appendCode(" children: ");
      }
      this.processChildren(false);
      this.tokens.appendCode("}");
    }
  }
  /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */
  processChildren(needsInitialComma) {
    let needsComma = needsInitialComma;
    while (true) {
      if (this.tokens.matches2(TokenType.jsxTagStart, TokenType.slash)) {
        return;
      }
      let didEmitElement = false;
      if (this.tokens.matches1(TokenType.braceL)) {
        if (this.tokens.matches2(TokenType.braceL, TokenType.braceR)) {
          this.tokens.replaceToken("");
          this.tokens.replaceToken("");
        } else {
          this.tokens.replaceToken(needsComma ? ", " : "");
          this.rootTransformer.processBalancedCode();
          this.tokens.replaceToken("");
          didEmitElement = true;
        }
      } else if (this.tokens.matches1(TokenType.jsxTagStart)) {
        this.tokens.appendCode(needsComma ? ", " : "");
        this.processJSXTag();
        didEmitElement = true;
      } else if (this.tokens.matches1(TokenType.jsxText) || this.tokens.matches1(TokenType.jsxEmptyText)) {
        didEmitElement = this.processChildTextElement(needsComma);
      } else {
        throw new Error("Unexpected token when processing JSX children.");
      }
      if (didEmitElement) {
        needsComma = true;
      }
    }
  }
  /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */
  processChildTextElement(needsComma) {
    const token = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token.start, token.end);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXTextLiteral(valueCode);
    if (literalCode === '""') {
      this.tokens.replaceToken(replacementCode);
      return false;
    } else {
      this.tokens.replaceToken(`${needsComma ? ", " : ""}${literalCode}${replacementCode}`);
      return true;
    }
  }
  getDevSource(elementLocationCode) {
    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;
  }
  getFilenameVarName() {
    if (!this.filenameVarName) {
      this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
    }
    return this.filenameVarName;
  }
};
function startsWithLowerCase(s) {
  const firstChar = s.charCodeAt(0);
  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;
}
function formatJSXTextLiteral(text2) {
  let result2 = "";
  let whitespace = "";
  let isInInitialLineWhitespace = false;
  let seenNonWhitespace = false;
  for (let i2 = 0; i2 < text2.length; i2++) {
    const c = text2[i2];
    if (c === " " || c === "	" || c === "\r") {
      if (!isInInitialLineWhitespace) {
        whitespace += c;
      }
    } else if (c === "\n") {
      whitespace = "";
      isInInitialLineWhitespace = true;
    } else {
      if (seenNonWhitespace && isInInitialLineWhitespace) {
        result2 += " ";
      }
      result2 += whitespace;
      whitespace = "";
      if (c === "&") {
        const { entity, newI } = processEntity(text2, i2 + 1);
        i2 = newI - 1;
        result2 += entity;
      } else {
        result2 += c;
      }
      seenNonWhitespace = true;
      isInInitialLineWhitespace = false;
    }
  }
  if (!isInInitialLineWhitespace) {
    result2 += whitespace;
  }
  return JSON.stringify(result2);
}
function formatJSXTextReplacement(text2) {
  let numNewlines = 0;
  let numSpaces = 0;
  for (const c of text2) {
    if (c === "\n") {
      numNewlines++;
      numSpaces = 0;
    } else if (c === " ") {
      numSpaces++;
    }
  }
  return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
}
function formatJSXStringValueLiteral(text2) {
  let result2 = "";
  for (let i2 = 0; i2 < text2.length; i2++) {
    const c = text2[i2];
    if (c === "\n") {
      if (/\s/.test(text2[i2 + 1])) {
        result2 += " ";
        while (i2 < text2.length && /\s/.test(text2[i2 + 1])) {
          i2++;
        }
      } else {
        result2 += "\n";
      }
    } else if (c === "&") {
      const { entity, newI } = processEntity(text2, i2 + 1);
      result2 += entity;
      i2 = newI - 1;
    } else {
      result2 += c;
    }
  }
  return JSON.stringify(result2);
}
function processEntity(text2, indexAfterAmpersand) {
  let str = "";
  let count2 = 0;
  let entity;
  let i2 = indexAfterAmpersand;
  if (text2[i2] === "#") {
    let radix = 10;
    i2++;
    let numStart;
    if (text2[i2] === "x") {
      radix = 16;
      i2++;
      numStart = i2;
      while (i2 < text2.length && isHexDigit(text2.charCodeAt(i2))) {
        i2++;
      }
    } else {
      numStart = i2;
      while (i2 < text2.length && isDecimalDigit(text2.charCodeAt(i2))) {
        i2++;
      }
    }
    if (text2[i2] === ";") {
      const numStr = text2.slice(numStart, i2);
      if (numStr) {
        i2++;
        entity = String.fromCodePoint(parseInt(numStr, radix));
      }
    }
  } else {
    while (i2 < text2.length && count2++ < 10) {
      const ch = text2[i2];
      i2++;
      if (ch === ";") {
        entity = xhtml_default.get(str);
        break;
      }
      str += ch;
    }
  }
  if (!entity) {
    return { entity: "&", newI: indexAfterAmpersand };
  }
  return { entity, newI: i2 };
}
function isDecimalDigit(code) {
  return code >= charCodes.digit0 && code <= charCodes.digit9;
}
function isHexDigit(code) {
  return code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF;
}

// node_modules/sucrase/dist/esm/util/getNonTypeIdentifiers.js
function getNonTypeIdentifiers(tokens, options) {
  const jsxPragmaInfo = getJSXPragmaInfo(options);
  const nonTypeIdentifiers = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < tokens.tokens.length; i2++) {
    const token = tokens.tokens[i2];
    if (token.type === TokenType.name && !token.isType && (token.identifierRole === IdentifierRole.Access || token.identifierRole === IdentifierRole.ObjectShorthand || token.identifierRole === IdentifierRole.ExportAccess) && !token.shadowsGlobal) {
      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
    }
    if (token.type === TokenType.jsxTagStart) {
      nonTypeIdentifiers.add(jsxPragmaInfo.base);
    }
    if (token.type === TokenType.jsxTagStart && i2 + 1 < tokens.tokens.length && tokens.tokens[i2 + 1].type === TokenType.jsxTagEnd) {
      nonTypeIdentifiers.add(jsxPragmaInfo.base);
      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);
    }
    if (token.type === TokenType.jsxName && token.identifierRole === IdentifierRole.Access) {
      const identifierName = tokens.identifierNameForToken(token);
      if (!startsWithLowerCase(identifierName) || tokens.tokens[i2 + 1].type === TokenType.dot) {
        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
      }
    }
  }
  return nonTypeIdentifiers;
}

// node_modules/sucrase/dist/esm/CJSImportProcessor.js
var CJSImportProcessor = class _CJSImportProcessor {
  __init() {
    this.nonTypeIdentifiers = /* @__PURE__ */ new Set();
  }
  __init2() {
    this.importInfoByPath = /* @__PURE__ */ new Map();
  }
  __init3() {
    this.importsToReplace = /* @__PURE__ */ new Map();
  }
  __init4() {
    this.identifierReplacements = /* @__PURE__ */ new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = /* @__PURE__ */ new Map();
  }
  constructor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options, isTypeScriptTransformEnabled, keepUnusedImports, helperManager) {
    ;
    this.nameManager = nameManager;
    this.tokens = tokens;
    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
    this.options = options;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.keepUnusedImports = keepUnusedImports;
    this.helperManager = helperManager;
    _CJSImportProcessor.prototype.__init.call(this);
    _CJSImportProcessor.prototype.__init2.call(this);
    _CJSImportProcessor.prototype.__init3.call(this);
    _CJSImportProcessor.prototype.__init4.call(this);
    _CJSImportProcessor.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let i2 = 0; i2 < this.tokens.tokens.length; i2++) {
      if (this.tokens.matches1AtIndex(i2, TokenType._import) && !this.tokens.matches3AtIndex(i2, TokenType._import, TokenType.name, TokenType.eq)) {
        this.preprocessImportAtIndex(i2);
      }
      if (this.tokens.matches1AtIndex(i2, TokenType._export) && !this.tokens.matches2AtIndex(i2, TokenType._export, TokenType.eq)) {
        this.preprocessExportAtIndex(i2);
      }
    }
    this.generateImportReplacements();
  }
  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({ localName }) => localName)
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }
  shouldAutomaticallyElideImportedName(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
  }
  generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport
      } = importInfo;
      if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }
      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard"
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault"
        )}(${primaryImportName});`;
      }
      for (const { importedName, localName } of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom"
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport"
        )}(${primaryImportName});`;
      }
      this.importsToReplace.set(path, requireCode);
      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const { importedName, localName } of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }
  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }
  preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];
    index++;
    if ((this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) || this.tokens.matches1AtIndex(index, TokenType._typeof)) && !this.tokens.matches1AtIndex(index + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)) {
      return;
    }
    if (this.tokens.matches1AtIndex(index, TokenType.parenL)) {
      return;
    }
    if (this.tokens.matches1AtIndex(index, TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, TokenType.comma)) {
        index++;
      }
    }
    if (this.tokens.matches1AtIndex(index, TokenType.star)) {
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }
    if (this.tokens.matches1AtIndex(index, TokenType.braceL)) {
      const result2 = this.getNamedImports(index + 1);
      index = result2.newIndex;
      for (const namedImport of result2.namedImports) {
        if (namedImport.importedName === "default") {
          defaultNames.push(namedImport.localName);
        } else {
          namedImports.push(namedImport);
        }
      }
    }
    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {
      index++;
    }
    if (!this.tokens.matches1AtIndex(index, TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.defaultNames.push(...defaultNames);
    importInfo.wildcardNames.push(...wildcardNames);
    importInfo.namedImports.push(...namedImports);
    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {
      importInfo.hasBareImport = true;
    }
  }
  preprocessExportAtIndex(index) {
    if (this.tokens.matches2AtIndex(index, TokenType._export, TokenType._var) || this.tokens.matches2AtIndex(index, TokenType._export, TokenType._let) || this.tokens.matches2AtIndex(index, TokenType._export, TokenType._const)) {
      this.preprocessVarExportAtIndex(index);
    } else if (this.tokens.matches2AtIndex(index, TokenType._export, TokenType._function) || this.tokens.matches2AtIndex(index, TokenType._export, TokenType._class)) {
      const exportName = this.tokens.identifierNameAtIndex(index + 2);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches3AtIndex(index, TokenType._export, TokenType.name, TokenType._function)) {
      const exportName = this.tokens.identifierNameAtIndex(index + 3);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches2AtIndex(index, TokenType._export, TokenType.braceL)) {
      this.preprocessNamedExportAtIndex(index);
    } else if (this.tokens.matches2AtIndex(index, TokenType._export, TokenType.star)) {
      this.preprocessExportStarAtIndex(index);
    }
  }
  preprocessVarExportAtIndex(index) {
    let depth = 0;
    for (let i2 = index + 2; ; i2++) {
      if (this.tokens.matches1AtIndex(i2, TokenType.braceL) || this.tokens.matches1AtIndex(i2, TokenType.dollarBraceL) || this.tokens.matches1AtIndex(i2, TokenType.bracketL)) {
        depth++;
      } else if (this.tokens.matches1AtIndex(i2, TokenType.braceR) || this.tokens.matches1AtIndex(i2, TokenType.bracketR)) {
        depth--;
      } else if (depth === 0 && !this.tokens.matches1AtIndex(i2, TokenType.name)) {
        break;
      } else if (this.tokens.matches1AtIndex(1, TokenType.eq)) {
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        i2 = endIndex - 1;
      } else {
        const token = this.tokens.tokens[i2];
        if (isDeclaration(token)) {
          const exportName = this.tokens.identifierNameAtIndex(i2);
          this.identifierReplacements.set(exportName, `exports.${exportName}`);
        }
      }
    }
  }
  /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */
  preprocessNamedExportAtIndex(index) {
    index += 2;
    const { newIndex, namedImports } = this.getNamedImports(index);
    index = newIndex;
    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {
      index++;
    } else {
      for (const { importedName: localName, localName: exportedName } of namedImports) {
        this.addExportBinding(localName, exportedName);
      }
      return;
    }
    if (!this.tokens.matches1AtIndex(index, TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }
  preprocessExportStarAtIndex(index) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index, TokenType._export, TokenType.star, TokenType._as)) {
      index += 3;
      exportedName = this.tokens.identifierNameAtIndex(index);
      index += 2;
    } else {
      index += 3;
    }
    if (!this.tokens.matches1AtIndex(index, TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }
  getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, TokenType.braceR)) {
        index++;
        break;
      }
      const specifierInfo = getImportExportSpecifierInfo(this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName
        });
      }
      if (this.tokens.matches2AtIndex(index, TokenType.comma, TokenType.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, TokenType.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, TokenType.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return { newIndex: index, namedImports };
  }
  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
  getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }
  addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }
  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result2 = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result2 || "";
  }
  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }
  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }
  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return /* @__PURE__ */ new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys()
    ]);
  }
};

// node_modules/sucrase/dist/esm/computeSourceMap.js
var import_gen_mapping = __toESM(require_gen_mapping_umd());
function computeSourceMap({ code: generatedCode, mappings: rawMappings }, filePath, options, source, tokens) {
  const sourceColumns = computeSourceColumns(source, tokens);
  const map2 = new import_gen_mapping.GenMapping({ file: options.compiledFilename });
  let tokenIndex = 0;
  let currentMapping = rawMappings[0];
  while (currentMapping === void 0 && tokenIndex < rawMappings.length - 1) {
    tokenIndex++;
    currentMapping = rawMappings[tokenIndex];
  }
  let line = 0;
  let lineStart = 0;
  if (currentMapping !== lineStart) {
    (0, import_gen_mapping.maybeAddSegment)(map2, line, 0, filePath, line, 0);
  }
  for (let i2 = 0; i2 < generatedCode.length; i2++) {
    if (i2 === currentMapping) {
      const genColumn = currentMapping - lineStart;
      const sourceColumn = sourceColumns[tokenIndex];
      (0, import_gen_mapping.maybeAddSegment)(map2, line, genColumn, filePath, line, sourceColumn);
      while ((currentMapping === i2 || currentMapping === void 0) && tokenIndex < rawMappings.length - 1) {
        tokenIndex++;
        currentMapping = rawMappings[tokenIndex];
      }
    }
    if (generatedCode.charCodeAt(i2) === charCodes.lineFeed) {
      line++;
      lineStart = i2 + 1;
      if (currentMapping !== lineStart) {
        (0, import_gen_mapping.maybeAddSegment)(map2, line, 0, filePath, line, 0);
      }
    }
  }
  const { sourceRoot, sourcesContent, ...sourceMap } = (0, import_gen_mapping.toEncodedMap)(map2);
  return sourceMap;
}
function computeSourceColumns(code, tokens) {
  const sourceColumns = new Array(tokens.length);
  let tokenIndex = 0;
  let currentMapping = tokens[tokenIndex].start;
  let lineStart = 0;
  for (let i2 = 0; i2 < code.length; i2++) {
    if (i2 === currentMapping) {
      sourceColumns[tokenIndex] = currentMapping - lineStart;
      tokenIndex++;
      currentMapping = tokens[tokenIndex].start;
    }
    if (code.charCodeAt(i2) === charCodes.lineFeed) {
      lineStart = i2 + 1;
    }
  }
  return sourceColumns;
}

// node_modules/sucrase/dist/esm/HelperManager.js
var HELPERS = {
  require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
  interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
  interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
  createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
  // check in the exports object and does a plain assignment, whereas Babel uses
  // defineProperty and builds an object of explicitly-exported names so that star exports can
  // always take lower precedence. For now, we do the easier TypeScript thing.
  createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
  nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
  asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
  optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
  asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
};
var HelperManager = class _HelperManager {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(nameManager) {
    ;
    this.nameManager = nameManager;
    _HelperManager.prototype.__init.call(this);
    _HelperManager.prototype.__init2.call(this);
  }
  getHelperName(baseName) {
    let helperName = this.helperNames[baseName];
    if (helperName) {
      return helperName;
    }
    helperName = this.nameManager.claimFreeName(`_${baseName}`);
    this.helperNames[baseName] = helperName;
    return helperName;
  }
  emitHelpers() {
    let resultCode = "";
    if (this.helperNames.optionalChainDelete) {
      this.getHelperName("optionalChain");
    }
    if (this.helperNames.asyncOptionalChainDelete) {
      this.getHelperName("asyncOptionalChain");
    }
    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {
      const helperName = this.helperNames[baseName];
      let helperCode = helperCodeTemplate;
      if (baseName === "optionalChainDelete") {
        helperCode = helperCode.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain);
      } else if (baseName === "asyncOptionalChainDelete") {
        helperCode = helperCode.replace(
          "ASYNC_OPTIONAL_CHAIN_NAME",
          this.helperNames.asyncOptionalChain
        );
      } else if (baseName === "require") {
        if (this.createRequireName === null) {
          this.createRequireName = this.nameManager.claimFreeName("_createRequire");
        }
        helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);
      }
      if (helperName) {
        resultCode += " ";
        resultCode += helperCode.replace(baseName, helperName).replace(/\s+/g, " ").trim();
      }
    }
    return resultCode;
  }
};

// node_modules/sucrase/dist/esm/identifyShadowedGlobals.js
function identifyShadowedGlobals(tokens, scopes, globalNames) {
  if (!hasShadowedGlobals(tokens, globalNames)) {
    return;
  }
  markShadowedGlobals(tokens, scopes, globalNames);
}
function hasShadowedGlobals(tokens, globalNames) {
  for (const token of tokens.tokens) {
    if (token.type === TokenType.name && !token.isType && isNonTopLevelDeclaration(token) && globalNames.has(tokens.identifierNameForToken(token))) {
      return true;
    }
  }
  return false;
}
function markShadowedGlobals(tokens, scopes, globalNames) {
  const scopeStack = [];
  let scopeIndex = scopes.length - 1;
  for (let i2 = tokens.tokens.length - 1; ; i2--) {
    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i2 + 1) {
      scopeStack.pop();
    }
    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i2 + 1) {
      scopeStack.push(scopes[scopeIndex]);
      scopeIndex--;
    }
    if (i2 < 0) {
      break;
    }
    const token = tokens.tokens[i2];
    const name = tokens.identifierNameForToken(token);
    if (scopeStack.length > 1 && !token.isType && token.type === TokenType.name && globalNames.has(name)) {
      if (isBlockScopedDeclaration(token)) {
        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);
      } else if (isFunctionScopedDeclaration(token)) {
        let stackIndex = scopeStack.length - 1;
        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {
          stackIndex--;
        }
        if (stackIndex < 0) {
          throw new Error("Did not find parent function scope.");
        }
        markShadowedForScope(scopeStack[stackIndex], tokens, name);
      }
    }
  }
  if (scopeStack.length > 0) {
    throw new Error("Expected empty scope stack after processing file.");
  }
}
function markShadowedForScope(scope, tokens, name) {
  for (let i2 = scope.startTokenIndex; i2 < scope.endTokenIndex; i2++) {
    const token = tokens.tokens[i2];
    if ((token.type === TokenType.name || token.type === TokenType.jsxName) && tokens.identifierNameForToken(token) === name) {
      token.shadowsGlobal = true;
    }
  }
}

// node_modules/sucrase/dist/esm/util/getIdentifierNames.js
function getIdentifierNames(code, tokens) {
  const names = [];
  for (const token of tokens) {
    if (token.type === TokenType.name) {
      names.push(code.slice(token.start, token.end));
    }
  }
  return names;
}

// node_modules/sucrase/dist/esm/NameManager.js
var NameManager = class _NameManager {
  __init() {
    this.usedNames = /* @__PURE__ */ new Set();
  }
  constructor(code, tokens) {
    ;
    _NameManager.prototype.__init.call(this);
    this.usedNames = new Set(getIdentifierNames(code, tokens));
  }
  claimFreeName(name) {
    const newName = this.findFreeName(name);
    this.usedNames.add(newName);
    return newName;
  }
  findFreeName(name) {
    if (!this.usedNames.has(name)) {
      return name;
    }
    let suffixNum = 2;
    while (this.usedNames.has(name + String(suffixNum))) {
      suffixNum++;
    }
    return name + String(suffixNum);
  }
};

// node_modules/sucrase/dist/esm/Options.js
var import_ts_interface_checker = __toESM(require_dist());

// node_modules/sucrase/dist/esm/Options-gen-types.js
var t = __toESM(require_dist());
var Transform = t.union(
  t.lit("jsx"),
  t.lit("typescript"),
  t.lit("flow"),
  t.lit("imports"),
  t.lit("react-hot-loader"),
  t.lit("jest")
);
var SourceMapOptions = t.iface([], {
  compiledFilename: "string"
});
var Options = t.iface([], {
  transforms: t.array("Transform"),
  disableESTransforms: t.opt("boolean"),
  jsxRuntime: t.opt(t.union(t.lit("classic"), t.lit("automatic"), t.lit("preserve"))),
  production: t.opt("boolean"),
  jsxImportSource: t.opt("string"),
  jsxPragma: t.opt("string"),
  jsxFragmentPragma: t.opt("string"),
  keepUnusedImports: t.opt("boolean"),
  preserveDynamicImport: t.opt("boolean"),
  injectCreateRequireForImportRequire: t.opt("boolean"),
  enableLegacyTypeScriptModuleInterop: t.opt("boolean"),
  enableLegacyBabel5ModuleInterop: t.opt("boolean"),
  sourceMapOptions: t.opt("SourceMapOptions"),
  filePath: t.opt("string")
});
var exportedTypeSuite = {
  Transform,
  SourceMapOptions,
  Options
};
var Options_gen_types_default = exportedTypeSuite;

// node_modules/sucrase/dist/esm/Options.js
var { Options: OptionsChecker } = (0, import_ts_interface_checker.createCheckers)(Options_gen_types_default);
function validateOptions(options) {
  OptionsChecker.strictCheck(options);
}

// node_modules/sucrase/dist/esm/parser/traverser/lval.js
function parseSpread() {
  next();
  parseMaybeAssign(false);
}
function parseRest(isBlockScope) {
  next();
  parseBindingAtom(isBlockScope);
}
function parseBindingIdentifier(isBlockScope) {
  parseIdentifier();
  markPriorBindingIdentifier(isBlockScope);
}
function parseImportedIdentifier() {
  parseIdentifier();
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
}
function markPriorBindingIdentifier(isBlockScope) {
  let identifierRole;
  if (state.scopeDepth === 0) {
    identifierRole = IdentifierRole.TopLevelDeclaration;
  } else if (isBlockScope) {
    identifierRole = IdentifierRole.BlockScopedDeclaration;
  } else {
    identifierRole = IdentifierRole.FunctionScopedDeclaration;
  }
  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
}
function parseBindingAtom(isBlockScope) {
  switch (state.type) {
    case TokenType._this: {
      const oldIsType = pushTypeContext(0);
      next();
      popTypeContext(oldIsType);
      return;
    }
    case TokenType._yield:
    case TokenType.name: {
      state.type = TokenType.name;
      parseBindingIdentifier(isBlockScope);
      return;
    }
    case TokenType.bracketL: {
      next();
      parseBindingList(
        TokenType.bracketR,
        isBlockScope,
        true
        /* allowEmpty */
      );
      return;
    }
    case TokenType.braceL:
      parseObj(true, isBlockScope);
      return;
    default:
      unexpected();
  }
}
function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {
  let first = true;
  let hasRemovedComma = false;
  const firstItemTokenIndex = state.tokens.length;
  while (!eat(close) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      state.tokens[state.tokens.length - 1].contextId = contextId;
      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {
        state.tokens[state.tokens.length - 1].isType = true;
        hasRemovedComma = true;
      }
    }
    if (allowEmpty && match(TokenType.comma)) {
    } else if (eat(close)) {
      break;
    } else if (match(TokenType.ellipsis)) {
      parseRest(isBlockScope);
      parseAssignableListItemTypes();
      eat(TokenType.comma);
      expect(close);
      break;
    } else {
      parseAssignableListItem(allowModifiers, isBlockScope);
    }
  }
}
function parseAssignableListItem(allowModifiers, isBlockScope) {
  if (allowModifiers) {
    tsParseModifiers([
      ContextualKeyword._public,
      ContextualKeyword._protected,
      ContextualKeyword._private,
      ContextualKeyword._readonly,
      ContextualKeyword._override
    ]);
  }
  parseMaybeDefault(isBlockScope);
  parseAssignableListItemTypes();
  parseMaybeDefault(
    isBlockScope,
    true
    /* leftAlreadyParsed */
  );
}
function parseAssignableListItemTypes() {
  if (isFlowEnabled) {
    flowParseAssignableListItemTypes();
  } else if (isTypeScriptEnabled) {
    tsParseAssignableListItemTypes();
  }
}
function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
  if (!leftAlreadyParsed) {
    parseBindingAtom(isBlockScope);
  }
  if (!eat(TokenType.eq)) {
    return;
  }
  const eqIndex = state.tokens.length - 1;
  parseMaybeAssign();
  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
}

// node_modules/sucrase/dist/esm/parser/plugins/typescript.js
function tsIsIdentifier() {
  return match(TokenType.name);
}
function isLiteralPropertyName() {
  return match(TokenType.name) || Boolean(state.type & TokenType.IS_KEYWORD) || match(TokenType.string) || match(TokenType.num) || match(TokenType.bigint) || match(TokenType.decimal);
}
function tsNextTokenCanFollowModifier() {
  const snapshot = state.snapshot();
  next();
  const canFollowModifier = (match(TokenType.bracketL) || match(TokenType.braceL) || match(TokenType.star) || match(TokenType.ellipsis) || match(TokenType.hash) || isLiteralPropertyName()) && !hasPrecedingLineBreak();
  if (canFollowModifier) {
    return true;
  } else {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
}
function tsParseModifiers(allowedModifiers) {
  while (true) {
    const modifier = tsParseModifier(allowedModifiers);
    if (modifier === null) {
      break;
    }
  }
}
function tsParseModifier(allowedModifiers) {
  if (!match(TokenType.name)) {
    return null;
  }
  const modifier = state.contextualKeyword;
  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
    switch (modifier) {
      case ContextualKeyword._readonly:
        state.tokens[state.tokens.length - 1].type = TokenType._readonly;
        break;
      case ContextualKeyword._abstract:
        state.tokens[state.tokens.length - 1].type = TokenType._abstract;
        break;
      case ContextualKeyword._static:
        state.tokens[state.tokens.length - 1].type = TokenType._static;
        break;
      case ContextualKeyword._public:
        state.tokens[state.tokens.length - 1].type = TokenType._public;
        break;
      case ContextualKeyword._private:
        state.tokens[state.tokens.length - 1].type = TokenType._private;
        break;
      case ContextualKeyword._protected:
        state.tokens[state.tokens.length - 1].type = TokenType._protected;
        break;
      case ContextualKeyword._override:
        state.tokens[state.tokens.length - 1].type = TokenType._override;
        break;
      case ContextualKeyword._declare:
        state.tokens[state.tokens.length - 1].type = TokenType._declare;
        break;
      default:
        break;
    }
    return modifier;
  }
  return null;
}
function tsParseEntityName() {
  parseIdentifier();
  while (eat(TokenType.dot)) {
    parseIdentifier();
  }
}
function tsParseTypeReference() {
  tsParseEntityName();
  if (!hasPrecedingLineBreak() && match(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseThisTypePredicate() {
  next();
  tsParseTypeAnnotation();
}
function tsParseThisTypeNode() {
  next();
}
function tsParseTypeQuery() {
  expect(TokenType._typeof);
  if (match(TokenType._import)) {
    tsParseImportType();
  } else {
    tsParseEntityName();
  }
  if (!hasPrecedingLineBreak() && match(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseImportType() {
  expect(TokenType._import);
  expect(TokenType.parenL);
  expect(TokenType.string);
  expect(TokenType.parenR);
  if (eat(TokenType.dot)) {
    tsParseEntityName();
  }
  if (match(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseTypeParameter() {
  eat(TokenType._const);
  const hadIn = eat(TokenType._in);
  const hadOut = eatContextual(ContextualKeyword._out);
  eat(TokenType._const);
  if ((hadIn || hadOut) && !match(TokenType.name)) {
    state.tokens[state.tokens.length - 1].type = TokenType.name;
  } else {
    parseIdentifier();
  }
  if (eat(TokenType._extends)) {
    tsParseType();
  }
  if (eat(TokenType.eq)) {
    tsParseType();
  }
}
function tsTryParseTypeParameters() {
  if (match(TokenType.lessThan)) {
    tsParseTypeParameters();
  }
}
function tsParseTypeParameters() {
  const oldIsType = pushTypeContext(0);
  if (match(TokenType.lessThan) || match(TokenType.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }
  while (!eat(TokenType.greaterThan) && !state.error) {
    tsParseTypeParameter();
    eat(TokenType.comma);
  }
  popTypeContext(oldIsType);
}
function tsFillSignature(returnToken) {
  const returnTokenRequired = returnToken === TokenType.arrow;
  tsTryParseTypeParameters();
  expect(TokenType.parenL);
  state.scopeDepth++;
  tsParseBindingListForSignature(
    false
    /* isBlockScope */
  );
  state.scopeDepth--;
  if (returnTokenRequired) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  } else if (match(returnToken)) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  }
}
function tsParseBindingListForSignature(isBlockScope) {
  parseBindingList(TokenType.parenR, isBlockScope);
}
function tsParseTypeMemberSemicolon() {
  if (!eat(TokenType.comma)) {
    semicolon();
  }
}
function tsParseSignatureMember() {
  tsFillSignature(TokenType.colon);
  tsParseTypeMemberSemicolon();
}
function tsIsUnambiguouslyIndexSignature() {
  const snapshot = state.snapshot();
  next();
  const isIndexSignature = eat(TokenType.name) && match(TokenType.colon);
  state.restoreFromSnapshot(snapshot);
  return isIndexSignature;
}
function tsTryParseIndexSignature() {
  if (!(match(TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {
    return false;
  }
  const oldIsType = pushTypeContext(0);
  expect(TokenType.bracketL);
  parseIdentifier();
  tsParseTypeAnnotation();
  expect(TokenType.bracketR);
  tsTryParseTypeAnnotation();
  tsParseTypeMemberSemicolon();
  popTypeContext(oldIsType);
  return true;
}
function tsParsePropertyOrMethodSignature(isReadonly) {
  eat(TokenType.question);
  if (!isReadonly && (match(TokenType.parenL) || match(TokenType.lessThan))) {
    tsFillSignature(TokenType.colon);
    tsParseTypeMemberSemicolon();
  } else {
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
  }
}
function tsParseTypeMember() {
  if (match(TokenType.parenL) || match(TokenType.lessThan)) {
    tsParseSignatureMember();
    return;
  }
  if (match(TokenType._new)) {
    next();
    if (match(TokenType.parenL) || match(TokenType.lessThan)) {
      tsParseSignatureMember();
    } else {
      tsParsePropertyOrMethodSignature(false);
    }
    return;
  }
  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);
  const found = tsTryParseIndexSignature();
  if (found) {
    return;
  }
  if ((isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) && tsNextTokenCanFollowModifier()) {
  }
  parsePropertyName(
    -1
    /* Types don't need context IDs. */
  );
  tsParsePropertyOrMethodSignature(readonly);
}
function tsParseTypeLiteral() {
  tsParseObjectTypeMembers();
}
function tsParseObjectTypeMembers() {
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    tsParseTypeMember();
  }
}
function tsLookaheadIsStartOfMappedType() {
  const snapshot = state.snapshot();
  const isStartOfMappedType = tsIsStartOfMappedType();
  state.restoreFromSnapshot(snapshot);
  return isStartOfMappedType;
}
function tsIsStartOfMappedType() {
  next();
  if (eat(TokenType.plus) || eat(TokenType.minus)) {
    return isContextual(ContextualKeyword._readonly);
  }
  if (isContextual(ContextualKeyword._readonly)) {
    next();
  }
  if (!match(TokenType.bracketL)) {
    return false;
  }
  next();
  if (!tsIsIdentifier()) {
    return false;
  }
  next();
  return match(TokenType._in);
}
function tsParseMappedTypeParameter() {
  parseIdentifier();
  expect(TokenType._in);
  tsParseType();
}
function tsParseMappedType() {
  expect(TokenType.braceL);
  if (match(TokenType.plus) || match(TokenType.minus)) {
    next();
    expectContextual(ContextualKeyword._readonly);
  } else {
    eatContextual(ContextualKeyword._readonly);
  }
  expect(TokenType.bracketL);
  tsParseMappedTypeParameter();
  if (eatContextual(ContextualKeyword._as)) {
    tsParseType();
  }
  expect(TokenType.bracketR);
  if (match(TokenType.plus) || match(TokenType.minus)) {
    next();
    expect(TokenType.question);
  } else {
    eat(TokenType.question);
  }
  tsTryParseType();
  semicolon();
  expect(TokenType.braceR);
}
function tsParseTupleType() {
  expect(TokenType.bracketL);
  while (!eat(TokenType.bracketR) && !state.error) {
    tsParseTupleElementType();
    eat(TokenType.comma);
  }
}
function tsParseTupleElementType() {
  if (eat(TokenType.ellipsis)) {
    tsParseType();
  } else {
    tsParseType();
    eat(TokenType.question);
  }
  if (eat(TokenType.colon)) {
    tsParseType();
  }
}
function tsParseParenthesizedType() {
  expect(TokenType.parenL);
  tsParseType();
  expect(TokenType.parenR);
}
function tsParseTemplateLiteralType() {
  nextTemplateToken();
  nextTemplateToken();
  while (!match(TokenType.backQuote) && !state.error) {
    expect(TokenType.dollarBraceL);
    tsParseType();
    nextTemplateToken();
    nextTemplateToken();
  }
  next();
}
var FunctionType;
(function(FunctionType2) {
  const TSFunctionType = 0;
  FunctionType2[FunctionType2["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
  const TSConstructorType = TSFunctionType + 1;
  FunctionType2[FunctionType2["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
  const TSAbstractConstructorType = TSConstructorType + 1;
  FunctionType2[FunctionType2["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
})(FunctionType || (FunctionType = {}));
function tsParseFunctionOrConstructorType(type) {
  if (type === FunctionType.TSAbstractConstructorType) {
    expectContextual(ContextualKeyword._abstract);
  }
  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {
    expect(TokenType._new);
  }
  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
  state.inDisallowConditionalTypesContext = false;
  tsFillSignature(TokenType.arrow);
  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
}
function tsParseNonArrayType() {
  switch (state.type) {
    case TokenType.name:
      tsParseTypeReference();
      return;
    case TokenType._void:
    case TokenType._null:
      next();
      return;
    case TokenType.string:
    case TokenType.num:
    case TokenType.bigint:
    case TokenType.decimal:
    case TokenType._true:
    case TokenType._false:
      parseLiteral();
      return;
    case TokenType.minus:
      next();
      parseLiteral();
      return;
    case TokenType._this: {
      tsParseThisTypeNode();
      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
        tsParseThisTypePredicate();
      }
      return;
    }
    case TokenType._typeof:
      tsParseTypeQuery();
      return;
    case TokenType._import:
      tsParseImportType();
      return;
    case TokenType.braceL:
      if (tsLookaheadIsStartOfMappedType()) {
        tsParseMappedType();
      } else {
        tsParseTypeLiteral();
      }
      return;
    case TokenType.bracketL:
      tsParseTupleType();
      return;
    case TokenType.parenL:
      tsParseParenthesizedType();
      return;
    case TokenType.backQuote:
      tsParseTemplateLiteralType();
      return;
    default:
      if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = TokenType.name;
        return;
      }
      break;
  }
  unexpected();
}
function tsParseArrayTypeOrHigher() {
  tsParseNonArrayType();
  while (!hasPrecedingLineBreak() && eat(TokenType.bracketL)) {
    if (!eat(TokenType.bracketR)) {
      tsParseType();
      expect(TokenType.bracketR);
    }
  }
}
function tsParseInferType() {
  expectContextual(ContextualKeyword._infer);
  parseIdentifier();
  if (match(TokenType._extends)) {
    const snapshot = state.snapshot();
    expect(TokenType._extends);
    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
    state.inDisallowConditionalTypesContext = true;
    tsParseType();
    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    if (state.error || !state.inDisallowConditionalTypesContext && match(TokenType.question)) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}
function tsParseTypeOperatorOrHigher() {
  if (isContextual(ContextualKeyword._keyof) || isContextual(ContextualKeyword._unique) || isContextual(ContextualKeyword._readonly)) {
    next();
    tsParseTypeOperatorOrHigher();
  } else if (isContextual(ContextualKeyword._infer)) {
    tsParseInferType();
  } else {
    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
    state.inDisallowConditionalTypesContext = false;
    tsParseArrayTypeOrHigher();
    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  }
}
function tsParseIntersectionTypeOrHigher() {
  eat(TokenType.bitwiseAND);
  tsParseTypeOperatorOrHigher();
  if (match(TokenType.bitwiseAND)) {
    while (eat(TokenType.bitwiseAND)) {
      tsParseTypeOperatorOrHigher();
    }
  }
}
function tsParseUnionTypeOrHigher() {
  eat(TokenType.bitwiseOR);
  tsParseIntersectionTypeOrHigher();
  if (match(TokenType.bitwiseOR)) {
    while (eat(TokenType.bitwiseOR)) {
      tsParseIntersectionTypeOrHigher();
    }
  }
}
function tsIsStartOfFunctionType() {
  if (match(TokenType.lessThan)) {
    return true;
  }
  return match(TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
}
function tsSkipParameterStart() {
  if (match(TokenType.name) || match(TokenType._this)) {
    next();
    return true;
  }
  if (match(TokenType.braceL) || match(TokenType.bracketL)) {
    let depth = 1;
    next();
    while (depth > 0 && !state.error) {
      if (match(TokenType.braceL) || match(TokenType.bracketL)) {
        depth++;
      } else if (match(TokenType.braceR) || match(TokenType.bracketR)) {
        depth--;
      }
      next();
    }
    return true;
  }
  return false;
}
function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
  const snapshot = state.snapshot();
  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
  state.restoreFromSnapshot(snapshot);
  return isUnambiguouslyStartOfFunctionType;
}
function tsIsUnambiguouslyStartOfFunctionType() {
  next();
  if (match(TokenType.parenR) || match(TokenType.ellipsis)) {
    return true;
  }
  if (tsSkipParameterStart()) {
    if (match(TokenType.colon) || match(TokenType.comma) || match(TokenType.question) || match(TokenType.eq)) {
      return true;
    }
    if (match(TokenType.parenR)) {
      next();
      if (match(TokenType.arrow)) {
        return true;
      }
    }
  }
  return false;
}
function tsParseTypeOrTypePredicateAnnotation(returnToken) {
  const oldIsType = pushTypeContext(0);
  expect(returnToken);
  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
  if (!finishedReturn) {
    tsParseType();
  }
  popTypeContext(oldIsType);
}
function tsTryParseTypeOrTypePredicateAnnotation() {
  if (match(TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
  }
}
function tsTryParseTypeAnnotation() {
  if (match(TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}
function tsTryParseType() {
  if (eat(TokenType.colon)) {
    tsParseType();
  }
}
function tsParseTypePredicateOrAssertsPrefix() {
  const snapshot = state.snapshot();
  if (isContextual(ContextualKeyword._asserts)) {
    next();
    if (eatContextual(ContextualKeyword._is)) {
      tsParseType();
      return true;
    } else if (tsIsIdentifier() || match(TokenType._this)) {
      next();
      if (eatContextual(ContextualKeyword._is)) {
        tsParseType();
      }
      return true;
    } else {
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (tsIsIdentifier() || match(TokenType._this)) {
    next();
    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {
      next();
      tsParseType();
      return true;
    } else {
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  }
  return false;
}
function tsParseTypeAnnotation() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.colon);
  tsParseType();
  popTypeContext(oldIsType);
}
function tsParseType() {
  tsParseNonConditionalType();
  if (state.inDisallowConditionalTypesContext || hasPrecedingLineBreak() || !eat(TokenType._extends)) {
    return;
  }
  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;
  state.inDisallowConditionalTypesContext = true;
  tsParseNonConditionalType();
  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  expect(TokenType.question);
  tsParseType();
  expect(TokenType.colon);
  tsParseType();
}
function isAbstractConstructorSignature() {
  return isContextual(ContextualKeyword._abstract) && lookaheadType() === TokenType._new;
}
function tsParseNonConditionalType() {
  if (tsIsStartOfFunctionType()) {
    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
    return;
  }
  if (match(TokenType._new)) {
    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
    return;
  } else if (isAbstractConstructorSignature()) {
    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
    return;
  }
  tsParseUnionTypeOrHigher();
}
function tsParseTypeAssertion() {
  const oldIsType = pushTypeContext(1);
  tsParseType();
  expect(TokenType.greaterThan);
  popTypeContext(oldIsType);
  parseMaybeUnary();
}
function tsTryParseJSXTypeArgument() {
  if (eat(TokenType.jsxTagStart)) {
    state.tokens[state.tokens.length - 1].type = TokenType.typeParameterStart;
    const oldIsType = pushTypeContext(1);
    while (!match(TokenType.greaterThan) && !state.error) {
      tsParseType();
      eat(TokenType.comma);
    }
    nextJSXTagToken();
    popTypeContext(oldIsType);
  }
}
function tsParseHeritageClause() {
  while (!match(TokenType.braceL) && !state.error) {
    tsParseExpressionWithTypeArguments();
    eat(TokenType.comma);
  }
}
function tsParseExpressionWithTypeArguments() {
  tsParseEntityName();
  if (match(TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}
function tsParseInterfaceDeclaration() {
  parseBindingIdentifier(false);
  tsTryParseTypeParameters();
  if (eat(TokenType._extends)) {
    tsParseHeritageClause();
  }
  tsParseObjectTypeMembers();
}
function tsParseTypeAliasDeclaration() {
  parseBindingIdentifier(false);
  tsTryParseTypeParameters();
  expect(TokenType.eq);
  tsParseType();
  semicolon();
}
function tsParseEnumMember() {
  if (match(TokenType.string)) {
    parseLiteral();
  } else {
    parseIdentifier();
  }
  if (eat(TokenType.eq)) {
    const eqIndex = state.tokens.length - 1;
    parseMaybeAssign();
    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
  }
}
function tsParseEnumDeclaration() {
  parseBindingIdentifier(false);
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    tsParseEnumMember();
    eat(TokenType.comma);
  }
}
function tsParseModuleBlock() {
  expect(TokenType.braceL);
  parseBlockBody(
    /* end */
    TokenType.braceR
  );
}
function tsParseModuleOrNamespaceDeclaration() {
  parseBindingIdentifier(false);
  if (eat(TokenType.dot)) {
    tsParseModuleOrNamespaceDeclaration();
  } else {
    tsParseModuleBlock();
  }
}
function tsParseAmbientExternalModuleDeclaration() {
  if (isContextual(ContextualKeyword._global)) {
    parseIdentifier();
  } else if (match(TokenType.string)) {
    parseExprAtom();
  } else {
    unexpected();
  }
  if (match(TokenType.braceL)) {
    tsParseModuleBlock();
  } else {
    semicolon();
  }
}
function tsParseImportEqualsDeclaration() {
  parseImportedIdentifier();
  expect(TokenType.eq);
  tsParseModuleReference();
  semicolon();
}
function tsIsExternalModuleReference() {
  return isContextual(ContextualKeyword._require) && lookaheadType() === TokenType.parenL;
}
function tsParseModuleReference() {
  if (tsIsExternalModuleReference()) {
    tsParseExternalModuleReference();
  } else {
    tsParseEntityName();
  }
}
function tsParseExternalModuleReference() {
  expectContextual(ContextualKeyword._require);
  expect(TokenType.parenL);
  if (!match(TokenType.string)) {
    unexpected();
  }
  parseLiteral();
  expect(TokenType.parenR);
}
function tsTryParseDeclare() {
  if (isLineTerminator()) {
    return false;
  }
  switch (state.type) {
    case TokenType._function: {
      const oldIsType = pushTypeContext(1);
      next();
      const functionStart = state.start;
      parseFunction(
        functionStart,
        /* isStatement */
        true
      );
      popTypeContext(oldIsType);
      return true;
    }
    case TokenType._class: {
      const oldIsType = pushTypeContext(1);
      parseClass(
        /* isStatement */
        true,
        /* optionalId */
        false
      );
      popTypeContext(oldIsType);
      return true;
    }
    case TokenType._const: {
      if (match(TokenType._const) && isLookaheadContextual(ContextualKeyword._enum)) {
        const oldIsType = pushTypeContext(1);
        expect(TokenType._const);
        expectContextual(ContextualKeyword._enum);
        state.tokens[state.tokens.length - 1].type = TokenType._enum;
        tsParseEnumDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
    }
    case TokenType._var:
    case TokenType._let: {
      const oldIsType = pushTypeContext(1);
      parseVarStatement(state.type !== TokenType._var);
      popTypeContext(oldIsType);
      return true;
    }
    case TokenType.name: {
      const oldIsType = pushTypeContext(1);
      const contextualKeyword = state.contextualKeyword;
      let matched = false;
      if (contextualKeyword === ContextualKeyword._global) {
        tsParseAmbientExternalModuleDeclaration();
        matched = true;
      } else {
        matched = tsParseDeclaration(
          contextualKeyword,
          /* isBeforeToken */
          true
        );
      }
      popTypeContext(oldIsType);
      return matched;
    }
    default:
      return false;
  }
}
function tsTryParseExportDeclaration() {
  return tsParseDeclaration(
    state.contextualKeyword,
    /* isBeforeToken */
    true
  );
}
function tsParseExpressionStatement(contextualKeyword) {
  switch (contextualKeyword) {
    case ContextualKeyword._declare: {
      const declareTokenIndex = state.tokens.length - 1;
      const matched = tsTryParseDeclare();
      if (matched) {
        state.tokens[declareTokenIndex].type = TokenType._declare;
        return true;
      }
      break;
    }
    case ContextualKeyword._global:
      if (match(TokenType.braceL)) {
        tsParseModuleBlock();
        return true;
      }
      break;
    default:
      return tsParseDeclaration(
        contextualKeyword,
        /* isBeforeToken */
        false
      );
  }
  return false;
}
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
  switch (contextualKeyword) {
    case ContextualKeyword._abstract:
      if (tsCheckLineTerminator(isBeforeToken) && match(TokenType._class)) {
        state.tokens[state.tokens.length - 1].type = TokenType._abstract;
        parseClass(
          /* isStatement */
          true,
          /* optionalId */
          false
        );
        return true;
      }
      break;
    case ContextualKeyword._enum:
      if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
        state.tokens[state.tokens.length - 1].type = TokenType._enum;
        tsParseEnumDeclaration();
        return true;
      }
      break;
    case ContextualKeyword._interface:
      if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseInterfaceDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;
    case ContextualKeyword._module:
      if (tsCheckLineTerminator(isBeforeToken)) {
        if (match(TokenType.string)) {
          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
          tsParseAmbientExternalModuleDeclaration();
          popTypeContext(oldIsType);
          return true;
        } else if (match(TokenType.name)) {
          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
          tsParseModuleOrNamespaceDeclaration();
          popTypeContext(oldIsType);
          return true;
        }
      }
      break;
    case ContextualKeyword._namespace:
      if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseModuleOrNamespaceDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;
    case ContextualKeyword._type:
      if (tsCheckLineTerminator(isBeforeToken) && match(TokenType.name)) {
        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);
        tsParseTypeAliasDeclaration();
        popTypeContext(oldIsType);
        return true;
      }
      break;
    default:
      break;
  }
  return false;
}
function tsCheckLineTerminator(isBeforeToken) {
  if (isBeforeToken) {
    next();
    return true;
  } else {
    return !isLineTerminator();
  }
}
function tsTryParseGenericAsyncArrowFunction() {
  const snapshot = state.snapshot();
  tsParseTypeParameters();
  parseFunctionParams();
  tsTryParseTypeOrTypePredicateAnnotation();
  expect(TokenType.arrow);
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  parseFunctionBody(true);
  return true;
}
function tsParseTypeArgumentsWithPossibleBitshift() {
  if (state.type === TokenType.bitShiftL) {
    state.pos -= 1;
    finishToken(TokenType.lessThan);
  }
  tsParseTypeArguments();
}
function tsParseTypeArguments() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.lessThan);
  while (!match(TokenType.greaterThan) && !state.error) {
    tsParseType();
    eat(TokenType.comma);
  }
  if (!oldIsType) {
    popTypeContext(oldIsType);
    rescan_gt();
    expect(TokenType.greaterThan);
    state.tokens[state.tokens.length - 1].isType = true;
  } else {
    expect(TokenType.greaterThan);
    popTypeContext(oldIsType);
  }
}
function tsIsDeclarationStart() {
  if (match(TokenType.name)) {
    switch (state.contextualKeyword) {
      case ContextualKeyword._abstract:
      case ContextualKeyword._declare:
      case ContextualKeyword._enum:
      case ContextualKeyword._interface:
      case ContextualKeyword._module:
      case ContextualKeyword._namespace:
      case ContextualKeyword._type:
        return true;
      default:
        break;
    }
  }
  return false;
}
function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
  if (match(TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
  }
  if (!match(TokenType.braceL) && isLineTerminator()) {
    let i2 = state.tokens.length - 1;
    while (i2 >= 0 && (state.tokens[i2].start >= functionStart || state.tokens[i2].type === TokenType._default || state.tokens[i2].type === TokenType._export)) {
      state.tokens[i2].isType = true;
      i2--;
    }
    return;
  }
  parseFunctionBody(false, funcContextId);
}
function tsParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!hasPrecedingLineBreak() && eat(TokenType.bang)) {
    state.tokens[state.tokens.length - 1].type = TokenType.nonNullAssertion;
    return;
  }
  if (match(TokenType.lessThan) || match(TokenType.bitShiftL)) {
    const snapshot = state.snapshot();
    if (!noCalls && atPossibleAsync()) {
      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
      if (asyncArrowFn) {
        return;
      }
    }
    tsParseTypeArgumentsWithPossibleBitshift();
    if (!noCalls && eat(TokenType.parenL)) {
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      parseCallExpressionArguments();
    } else if (match(TokenType.backQuote)) {
      parseTemplate();
    } else if (
      // The remaining possible case is an instantiation expression, e.g.
      // Array<number> . Check for a few cases that would disqualify it and
      // cause us to bail out.
      // a<b>>c is not (a<b>)>c, but a<(b>>c)
      state.type === TokenType.greaterThan || // a<b>c is (a<b)>c
      state.type !== TokenType.parenL && Boolean(state.type & TokenType.IS_EXPRESSION_START) && !hasPrecedingLineBreak()
    ) {
      unexpected();
    }
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  } else if (!noCalls && match(TokenType.questionDot) && lookaheadType() === TokenType.lessThan) {
    next();
    state.tokens[startTokenIndex].isOptionalChainStart = true;
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    tsParseTypeArguments();
    expect(TokenType.parenL);
    parseCallExpressionArguments();
  }
  baseParseSubscript(startTokenIndex, noCalls, stopState);
}
function tsTryParseExport() {
  if (eat(TokenType._import)) {
    if (isContextual(ContextualKeyword._type) && lookaheadType() !== TokenType.eq) {
      expectContextual(ContextualKeyword._type);
    }
    tsParseImportEqualsDeclaration();
    return true;
  } else if (eat(TokenType.eq)) {
    parseExpression();
    semicolon();
    return true;
  } else if (eatContextual(ContextualKeyword._as)) {
    expectContextual(ContextualKeyword._namespace);
    parseIdentifier();
    semicolon();
    return true;
  } else {
    if (isContextual(ContextualKeyword._type)) {
      const nextType = lookaheadType();
      if (nextType === TokenType.braceL || nextType === TokenType.star) {
        next();
      }
    }
    return false;
  }
}
function tsParseImportSpecifier() {
  parseIdentifier();
  if (match(TokenType.comma) || match(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    return;
  }
  parseIdentifier();
  if (match(TokenType.comma) || match(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    state.tokens[state.tokens.length - 2].isType = true;
    state.tokens[state.tokens.length - 1].isType = true;
    return;
  }
  parseIdentifier();
  if (match(TokenType.comma) || match(TokenType.braceR)) {
    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
    return;
  }
  parseIdentifier();
  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;
  state.tokens[state.tokens.length - 4].isType = true;
  state.tokens[state.tokens.length - 3].isType = true;
  state.tokens[state.tokens.length - 2].isType = true;
  state.tokens[state.tokens.length - 1].isType = true;
}
function tsParseExportSpecifier() {
  parseIdentifier();
  if (match(TokenType.comma) || match(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
    return;
  }
  parseIdentifier();
  if (match(TokenType.comma) || match(TokenType.braceR)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
    state.tokens[state.tokens.length - 2].isType = true;
    state.tokens[state.tokens.length - 1].isType = true;
    return;
  }
  parseIdentifier();
  if (match(TokenType.comma) || match(TokenType.braceR)) {
    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;
    return;
  }
  parseIdentifier();
  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;
  state.tokens[state.tokens.length - 4].isType = true;
  state.tokens[state.tokens.length - 3].isType = true;
  state.tokens[state.tokens.length - 2].isType = true;
  state.tokens[state.tokens.length - 1].isType = true;
}
function tsTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === TokenType._class) {
    state.type = TokenType._abstract;
    next();
    parseClass(true, true);
    return true;
  }
  if (isContextual(ContextualKeyword._interface)) {
    const oldIsType = pushTypeContext(2);
    tsParseDeclaration(ContextualKeyword._interface, true);
    popTypeContext(oldIsType);
    return true;
  }
  return false;
}
function tsTryParseStatementContent() {
  if (state.type === TokenType._const) {
    const ahead = lookaheadTypeAndKeyword();
    if (ahead.type === TokenType.name && ahead.contextualKeyword === ContextualKeyword._enum) {
      expect(TokenType._const);
      expectContextual(ContextualKeyword._enum);
      state.tokens[state.tokens.length - 1].type = TokenType._enum;
      tsParseEnumDeclaration();
      return true;
    }
  }
  return false;
}
function tsTryParseClassMemberWithIsStatic(isStatic) {
  const memberStartIndexAfterStatic = state.tokens.length;
  tsParseModifiers([
    ContextualKeyword._abstract,
    ContextualKeyword._readonly,
    ContextualKeyword._declare,
    ContextualKeyword._static,
    ContextualKeyword._override
  ]);
  const modifiersEndIndex = state.tokens.length;
  const found = tsTryParseIndexSignature();
  if (found) {
    const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;
    for (let i2 = memberStartIndex; i2 < modifiersEndIndex; i2++) {
      state.tokens[i2].isType = true;
    }
    return true;
  }
  return false;
}
function tsParseIdentifierStatement(contextualKeyword) {
  const matched = tsParseExpressionStatement(contextualKeyword);
  if (!matched) {
    semicolon();
  }
}
function tsParseExportDeclaration() {
  const isDeclare = eatContextual(ContextualKeyword._declare);
  if (isDeclare) {
    state.tokens[state.tokens.length - 1].type = TokenType._declare;
  }
  let matchedDeclaration = false;
  if (match(TokenType.name)) {
    if (isDeclare) {
      const oldIsType = pushTypeContext(2);
      matchedDeclaration = tsTryParseExportDeclaration();
      popTypeContext(oldIsType);
    } else {
      matchedDeclaration = tsTryParseExportDeclaration();
    }
  }
  if (!matchedDeclaration) {
    if (isDeclare) {
      const oldIsType = pushTypeContext(2);
      parseStatement(true);
      popTypeContext(oldIsType);
    } else {
      parseStatement(true);
    }
  }
}
function tsAfterParseClassSuper(hasSuper) {
  if (hasSuper && (match(TokenType.lessThan) || match(TokenType.bitShiftL))) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  if (eatContextual(ContextualKeyword._implements)) {
    state.tokens[state.tokens.length - 1].type = TokenType._implements;
    const oldIsType = pushTypeContext(1);
    tsParseHeritageClause();
    popTypeContext(oldIsType);
  }
}
function tsStartParseObjPropValue() {
  tsTryParseTypeParameters();
}
function tsStartParseFunctionParams() {
  tsTryParseTypeParameters();
}
function tsAfterParseVarHead() {
  const oldIsType = pushTypeContext(0);
  if (!hasPrecedingLineBreak()) {
    eat(TokenType.bang);
  }
  tsTryParseTypeAnnotation();
  popTypeContext(oldIsType);
}
function tsStartParseAsyncArrowFromCallExpression() {
  if (match(TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}
function tsParseMaybeAssign(noIn, isWithinParens) {
  if (isJSXEnabled) {
    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
  } else {
    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
  }
}
function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
  if (!match(TokenType.lessThan)) {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
  const snapshot = state.snapshot();
  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }
  state.type = TokenType.typeParameterStart;
  tsParseTypeParameters();
  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (!wasArrow) {
    unexpected();
  }
  return wasArrow;
}
function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
  if (!match(TokenType.lessThan)) {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
  const snapshot = state.snapshot();
  tsParseTypeParameters();
  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
  if (!wasArrow) {
    unexpected();
  }
  if (state.error) {
    state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }
  return baseParseMaybeAssign(noIn, isWithinParens);
}
function tsParseArrow() {
  if (match(TokenType.colon)) {
    const snapshot = state.snapshot();
    tsParseTypeOrTypePredicateAnnotation(TokenType.colon);
    if (canInsertSemicolon())
      unexpected();
    if (!match(TokenType.arrow))
      unexpected();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
  return eat(TokenType.arrow);
}
function tsParseAssignableListItemTypes() {
  const oldIsType = pushTypeContext(0);
  eat(TokenType.question);
  tsTryParseTypeAnnotation();
  popTypeContext(oldIsType);
}
function tsParseMaybeDecoratorArguments() {
  if (match(TokenType.lessThan) || match(TokenType.bitShiftL)) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }
  baseParseMaybeDecoratorArguments();
}

// node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js
function jsxReadToken() {
  let sawNewline = false;
  let sawNonWhitespace = false;
  while (true) {
    if (state.pos >= input.length) {
      unexpected("Unterminated JSX contents");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === charCodes.lessThan || ch === charCodes.leftCurlyBrace) {
      if (state.pos === state.start) {
        if (ch === charCodes.lessThan) {
          state.pos++;
          finishToken(TokenType.jsxTagStart);
          return;
        }
        getTokenFromCode(ch);
        return;
      }
      if (sawNewline && !sawNonWhitespace) {
        finishToken(TokenType.jsxEmptyText);
      } else {
        finishToken(TokenType.jsxText);
      }
      return;
    }
    if (ch === charCodes.lineFeed) {
      sawNewline = true;
    } else if (ch !== charCodes.space && ch !== charCodes.carriageReturn && ch !== charCodes.tab) {
      sawNonWhitespace = true;
    }
    state.pos++;
  }
}
function jsxReadString(quote2) {
  state.pos++;
  for (; ; ) {
    if (state.pos >= input.length) {
      unexpected("Unterminated string constant");
      return;
    }
    const ch = input.charCodeAt(state.pos);
    if (ch === quote2) {
      state.pos++;
      break;
    }
    state.pos++;
  }
  finishToken(TokenType.string);
}
function jsxReadWord() {
  let ch;
  do {
    if (state.pos > input.length) {
      unexpected("Unexpectedly reached the end of input.");
      return;
    }
    ch = input.charCodeAt(++state.pos);
  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);
  finishToken(TokenType.jsxName);
}
function jsxParseIdentifier() {
  nextJSXTagToken();
}
function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();
  if (!eat(TokenType.colon)) {
    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
    return;
  }
  jsxParseIdentifier();
}
function jsxParseElementName() {
  const firstTokenIndex = state.tokens.length;
  jsxParseNamespacedName(IdentifierRole.Access);
  let hadDot = false;
  while (match(TokenType.dot)) {
    hadDot = true;
    nextJSXTagToken();
    jsxParseIdentifier();
  }
  if (!hadDot) {
    const firstToken = state.tokens[firstTokenIndex];
    const firstChar = input.charCodeAt(firstToken.start);
    if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {
      firstToken.identifierRole = null;
    }
  }
}
function jsxParseAttributeValue() {
  switch (state.type) {
    case TokenType.braceL:
      next();
      parseExpression();
      nextJSXTagToken();
      return;
    case TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;
    case TokenType.string:
      nextJSXTagToken();
      return;
    default:
      unexpected("JSX value should be either an expression or a quoted JSX text");
  }
}
function jsxParseSpreadChild() {
  expect(TokenType.ellipsis);
  parseExpression();
}
function jsxParseOpeningElement(initialTokenIndex) {
  if (match(TokenType.jsxTagEnd)) {
    return false;
  }
  jsxParseElementName();
  if (isTypeScriptEnabled) {
    tsTryParseJSXTypeArgument();
  }
  let hasSeenPropSpread = false;
  while (!match(TokenType.slash) && !match(TokenType.jsxTagEnd) && !state.error) {
    if (eat(TokenType.braceL)) {
      hasSeenPropSpread = true;
      expect(TokenType.ellipsis);
      parseMaybeAssign();
      nextJSXTagToken();
      continue;
    }
    if (hasSeenPropSpread && state.end - state.start === 3 && input.charCodeAt(state.start) === charCodes.lowercaseK && input.charCodeAt(state.start + 1) === charCodes.lowercaseE && input.charCodeAt(state.start + 2) === charCodes.lowercaseY) {
      state.tokens[initialTokenIndex].jsxRole = JSXRole.KeyAfterPropSpread;
    }
    jsxParseNamespacedName(IdentifierRole.ObjectKey);
    if (match(TokenType.eq)) {
      nextJSXTagToken();
      jsxParseAttributeValue();
    }
  }
  const isSelfClosing = match(TokenType.slash);
  if (isSelfClosing) {
    nextJSXTagToken();
  }
  return isSelfClosing;
}
function jsxParseClosingElement() {
  if (match(TokenType.jsxTagEnd)) {
    return;
  }
  jsxParseElementName();
}
function jsxParseElementAt() {
  const initialTokenIndex = state.tokens.length - 1;
  state.tokens[initialTokenIndex].jsxRole = JSXRole.NoChildren;
  let numExplicitChildren = 0;
  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);
  if (!isSelfClosing) {
    nextJSXExprToken();
    while (true) {
      switch (state.type) {
        case TokenType.jsxTagStart:
          nextJSXTagToken();
          if (match(TokenType.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement();
            if (state.tokens[initialTokenIndex].jsxRole !== JSXRole.KeyAfterPropSpread) {
              if (numExplicitChildren === 1) {
                state.tokens[initialTokenIndex].jsxRole = JSXRole.OneChild;
              } else if (numExplicitChildren > 1) {
                state.tokens[initialTokenIndex].jsxRole = JSXRole.StaticChildren;
              }
            }
            return;
          }
          numExplicitChildren++;
          jsxParseElementAt();
          nextJSXExprToken();
          break;
        case TokenType.jsxText:
          numExplicitChildren++;
          nextJSXExprToken();
          break;
        case TokenType.jsxEmptyText:
          nextJSXExprToken();
          break;
        case TokenType.braceL:
          next();
          if (match(TokenType.ellipsis)) {
            jsxParseSpreadChild();
            nextJSXExprToken();
            numExplicitChildren += 2;
          } else {
            if (!match(TokenType.braceR)) {
              numExplicitChildren++;
              parseExpression();
            }
            nextJSXExprToken();
          }
          break;
        default:
          unexpected();
          return;
      }
    }
  }
}
function jsxParseElement() {
  nextJSXTagToken();
  jsxParseElementAt();
}
function nextJSXTagToken() {
  state.tokens.push(new Token());
  skipSpace();
  state.start = state.pos;
  const code = input.charCodeAt(state.pos);
  if (IS_IDENTIFIER_START[code]) {
    jsxReadWord();
  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {
    jsxReadString(code);
  } else {
    ++state.pos;
    switch (code) {
      case charCodes.greaterThan:
        finishToken(TokenType.jsxTagEnd);
        break;
      case charCodes.lessThan:
        finishToken(TokenType.jsxTagStart);
        break;
      case charCodes.slash:
        finishToken(TokenType.slash);
        break;
      case charCodes.equalsTo:
        finishToken(TokenType.eq);
        break;
      case charCodes.leftCurlyBrace:
        finishToken(TokenType.braceL);
        break;
      case charCodes.dot:
        finishToken(TokenType.dot);
        break;
      case charCodes.colon:
        finishToken(TokenType.colon);
        break;
      default:
        unexpected();
    }
  }
}
function nextJSXExprToken() {
  state.tokens.push(new Token());
  state.start = state.pos;
  jsxReadToken();
}

// node_modules/sucrase/dist/esm/parser/plugins/types.js
function typedParseConditional(noIn) {
  if (match(TokenType.question)) {
    const nextType = lookaheadType();
    if (nextType === TokenType.colon || nextType === TokenType.comma || nextType === TokenType.parenR) {
      return;
    }
  }
  baseParseConditional(noIn);
}
function typedParseParenItem() {
  eatTypeToken(TokenType.question);
  if (match(TokenType.colon)) {
    if (isTypeScriptEnabled) {
      tsParseTypeAnnotation();
    } else if (isFlowEnabled) {
      flowParseTypeAnnotation();
    }
  }
}

// node_modules/sucrase/dist/esm/parser/traverser/expression.js
var StopState = class {
  constructor(stop) {
    this.stop = stop;
  }
};
function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (match(TokenType.comma)) {
    while (eat(TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
}
function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (isTypeScriptEnabled) {
    return tsParseMaybeAssign(noIn, isWithinParens);
  } else if (isFlowEnabled) {
    return flowParseMaybeAssign(noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
}
function baseParseMaybeAssign(noIn, isWithinParens) {
  if (match(TokenType._yield)) {
    parseYield();
    return false;
  }
  if (match(TokenType.parenL) || match(TokenType.name) || match(TokenType._yield)) {
    state.potentialArrowAt = state.start;
  }
  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (state.type & TokenType.IS_ASSIGN) {
    next();
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
}
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}
function parseConditional(noIn) {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseConditional(noIn);
  } else {
    baseParseConditional(noIn);
  }
}
function baseParseConditional(noIn) {
  if (eat(TokenType.question)) {
    parseMaybeAssign();
    expect(TokenType.colon);
    parseMaybeAssign(noIn);
  }
}
function parseExprOps(noIn) {
  const startTokenIndex = state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (isTypeScriptEnabled && (TokenType._in & TokenType.PRECEDENCE_MASK) > minPrec && !hasPrecedingLineBreak() && (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))) {
    const oldIsType = pushTypeContext(1);
    tsParseType();
    popTypeContext(oldIsType);
    rescan_gt();
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }
  const prec = state.type & TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !match(TokenType._in))) {
    if (prec > minPrec) {
      const op = state.type;
      next();
      if (op === TokenType.nullishCoalescing) {
        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }
      const rhsStartTokenIndex = state.tokens.length;
      parseMaybeUnary();
      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === TokenType.nullishCoalescing) {
        state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}
function parseMaybeUnary() {
  if (isTypeScriptEnabled && !isJSXEnabled && eat(TokenType.lessThan)) {
    tsParseTypeAssertion();
    return false;
  }
  if (isContextual(ContextualKeyword._module) && lookaheadCharCode() === charCodes.leftCurlyBrace && !hasFollowingLineBreak()) {
    parseModuleExpression();
    return false;
  }
  if (state.type & TokenType.IS_PREFIX) {
    next();
    parseMaybeUnary();
    return false;
  }
  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {
    if (state.type === TokenType.preIncDec) {
      state.type = TokenType.postIncDec;
    }
    next();
  }
  return false;
}
function parseExprSubscripts() {
  const startTokenIndex = state.tokens.length;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startTokenIndex);
  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {
    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;
  }
  return false;
}
function parseSubscripts(startTokenIndex, noCalls = false) {
  if (isFlowEnabled) {
    flowParseSubscripts(startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}
function baseParseSubscripts(startTokenIndex, noCalls = false) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !state.error);
}
function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (isTypeScriptEnabled) {
    tsParseSubscript(startTokenIndex, noCalls, stopState);
  } else if (isFlowEnabled) {
    flowParseSubscript(startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}
function baseParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!noCalls && eat(TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    parseSubscripts(startTokenIndex, noCalls);
  } else if (match(TokenType.questionDot)) {
    state.tokens[startTokenIndex].isOptionalChainStart = true;
    if (noCalls && lookaheadType() === TokenType.parenL) {
      stopState.stop = true;
      return;
    }
    next();
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    if (eat(TokenType.bracketL)) {
      parseExpression();
      expect(TokenType.bracketR);
    } else if (eat(TokenType.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if (eat(TokenType.dot)) {
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if (eat(TokenType.bracketL)) {
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    expect(TokenType.bracketR);
  } else if (!noCalls && match(TokenType.parenL)) {
    if (atPossibleAsync()) {
      const snapshot = state.snapshot();
      const asyncStartTokenIndex = state.tokens.length;
      next();
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = getNextContextId();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      if (shouldParseAsyncArrow()) {
        state.restoreFromSnapshot(snapshot);
        stopState.stop = true;
        state.scopeDepth++;
        parseFunctionParams();
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      next();
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = getNextContextId();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
    }
  } else if (match(TokenType.backQuote)) {
    parseTemplate();
  } else {
    stopState.stop = true;
  }
}
function atPossibleAsync() {
  return state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && !canInsertSemicolon();
}
function parseCallExpressionArguments() {
  let first = true;
  while (!eat(TokenType.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(TokenType.parenR)) {
        break;
      }
    }
    parseExprListItem(false);
  }
}
function shouldParseAsyncArrow() {
  return match(TokenType.colon) || match(TokenType.arrow);
}
function parseAsyncArrowFromCallExpression(startTokenIndex) {
  if (isTypeScriptEnabled) {
    tsStartParseAsyncArrowFromCallExpression();
  } else if (isFlowEnabled) {
    flowStartParseAsyncArrowFromCallExpression();
  }
  expect(TokenType.arrow);
  parseArrowExpression(startTokenIndex);
}
function parseNoCallExpr() {
  const startTokenIndex = state.tokens.length;
  parseExprAtom();
  parseSubscripts(startTokenIndex, true);
}
function parseExprAtom() {
  if (eat(TokenType.modulo)) {
    parseIdentifier();
    return false;
  }
  if (match(TokenType.jsxText) || match(TokenType.jsxEmptyText)) {
    parseLiteral();
    return false;
  } else if (match(TokenType.lessThan) && isJSXEnabled) {
    state.type = TokenType.jsxTagStart;
    jsxParseElement();
    next();
    return false;
  }
  const canBeArrow = state.potentialArrowAt === state.start;
  switch (state.type) {
    case TokenType.slash:
    case TokenType.assign:
      retokenizeSlashAsRegex();
    case TokenType._super:
    case TokenType._this:
    case TokenType.regexp:
    case TokenType.num:
    case TokenType.bigint:
    case TokenType.decimal:
    case TokenType.string:
    case TokenType._null:
    case TokenType._true:
    case TokenType._false:
      next();
      return false;
    case TokenType._import:
      next();
      if (match(TokenType.dot)) {
        state.tokens[state.tokens.length - 1].type = TokenType.name;
        next();
        parseIdentifier();
      }
      return false;
    case TokenType.name: {
      const startTokenIndex = state.tokens.length;
      const functionStart = state.start;
      const contextualKeyword = state.contextualKeyword;
      parseIdentifier();
      if (contextualKeyword === ContextualKeyword._await) {
        parseAwait();
        return false;
      } else if (contextualKeyword === ContextualKeyword._async && match(TokenType._function) && !canInsertSemicolon()) {
        next();
        parseFunction(functionStart, false);
        return false;
      } else if (canBeArrow && contextualKeyword === ContextualKeyword._async && !canInsertSemicolon() && match(TokenType.name)) {
        state.scopeDepth++;
        parseBindingIdentifier(false);
        expect(TokenType.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      } else if (match(TokenType._do) && !canInsertSemicolon()) {
        next();
        parseBlock();
        return false;
      }
      if (canBeArrow && !canInsertSemicolon() && match(TokenType.arrow)) {
        state.scopeDepth++;
        markPriorBindingIdentifier(false);
        expect(TokenType.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      }
      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;
      return false;
    }
    case TokenType._do: {
      next();
      parseBlock();
      return false;
    }
    case TokenType.parenL: {
      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
      return wasArrow;
    }
    case TokenType.bracketL:
      next();
      parseExprList(TokenType.bracketR, true);
      return false;
    case TokenType.braceL:
      parseObj(false, false);
      return false;
    case TokenType._function:
      parseFunctionExpression();
      return false;
    case TokenType.at:
      parseDecorators();
    case TokenType._class:
      parseClass(false);
      return false;
    case TokenType._new:
      parseNew();
      return false;
    case TokenType.backQuote:
      parseTemplate();
      return false;
    case TokenType.doubleColon: {
      next();
      parseNoCallExpr();
      return false;
    }
    case TokenType.hash: {
      const code = lookaheadCharCode();
      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {
        parseMaybePrivateName();
      } else {
        next();
      }
      return false;
    }
    default:
      unexpected();
      return false;
  }
}
function parseMaybePrivateName() {
  eat(TokenType.hash);
  parseIdentifier();
}
function parseFunctionExpression() {
  const functionStart = state.start;
  parseIdentifier();
  if (eat(TokenType.dot)) {
    parseIdentifier();
  }
  parseFunction(functionStart, false);
}
function parseLiteral() {
  next();
}
function parseParenExpression() {
  expect(TokenType.parenL);
  parseExpression();
  expect(TokenType.parenR);
}
function parseParenAndDistinguishExpression(canBeArrow) {
  const snapshot = state.snapshot();
  const startTokenIndex = state.tokens.length;
  expect(TokenType.parenL);
  let first = true;
  while (!match(TokenType.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (match(TokenType.parenR)) {
        break;
      }
    }
    if (match(TokenType.ellipsis)) {
      parseRest(
        false
        /* isBlockScope */
      );
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }
  expect(TokenType.parenR);
  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      state.restoreFromSnapshot(snapshot);
      state.scopeDepth++;
      parseFunctionParams();
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (state.error) {
        state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }
  return false;
}
function shouldParseArrow() {
  return match(TokenType.colon) || !canInsertSemicolon();
}
function parseArrow() {
  if (isTypeScriptEnabled) {
    return tsParseArrow();
  } else if (isFlowEnabled) {
    return flowParseArrow();
  } else {
    return eat(TokenType.arrow);
  }
}
function parseParenItem() {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseParenItem();
  }
}
function parseNew() {
  expect(TokenType._new);
  if (eat(TokenType.dot)) {
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (isFlowEnabled) {
    flowStartParseNewArguments();
  }
  if (eat(TokenType.parenL)) {
    parseExprList(TokenType.parenR);
  }
}
function parseNewCallee() {
  parseNoCallExpr();
  eat(TokenType.questionDot);
}
function parseTemplate() {
  nextTemplateToken();
  nextTemplateToken();
  while (!match(TokenType.backQuote) && !state.error) {
    expect(TokenType.dollarBraceL);
    parseExpression();
    nextTemplateToken();
    nextTemplateToken();
  }
  next();
}
function parseObj(isPattern, isBlockScope) {
  const contextId = getNextContextId();
  let first = true;
  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;
  while (!eat(TokenType.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(TokenType.braceR)) {
        break;
      }
    }
    let isGenerator = false;
    if (match(TokenType.ellipsis)) {
      const previousIndex = state.tokens.length;
      parseSpread();
      if (isPattern) {
        if (state.tokens.length === previousIndex + 2) {
          markPriorBindingIdentifier(isBlockScope);
        }
        if (eat(TokenType.braceR)) {
          break;
        }
      }
      continue;
    }
    if (!isPattern) {
      isGenerator = eat(TokenType.star);
    }
    if (!isPattern && isContextual(ContextualKeyword._async)) {
      if (isGenerator)
        unexpected();
      parseIdentifier();
      if (match(TokenType.colon) || match(TokenType.parenL) || match(TokenType.braceR) || match(TokenType.eq) || match(TokenType.comma)) {
      } else {
        if (match(TokenType.star)) {
          next();
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }
    parseObjPropValue(isPattern, isBlockScope, contextId);
  }
  state.tokens[state.tokens.length - 1].contextId = contextId;
}
function isGetterOrSetterMethod(isPattern) {
  return !isPattern && (match(TokenType.string) || // get "string"() {}
  match(TokenType.num) || // get 1() {}
  match(TokenType.bracketL) || // get ["string"]() {}
  match(TokenType.name) || // get foo() {}
  !!(state.type & TokenType.IS_KEYWORD));
}
function parseObjectMethod(isPattern, objectContextId) {
  const functionStart = state.start;
  if (match(TokenType.parenL)) {
    if (isPattern)
      unexpected();
    parseMethod(
      functionStart,
      /* isConstructor */
      false
    );
    return true;
  }
  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(
      functionStart,
      /* isConstructor */
      false
    );
    return true;
  }
  return false;
}
function parseObjectProperty(isPattern, isBlockScope) {
  if (eat(TokenType.colon)) {
    if (isPattern) {
      parseMaybeDefault(isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }
  let identifierRole;
  if (isPattern) {
    if (state.scopeDepth === 0) {
      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = IdentifierRole.ObjectShorthand;
  }
  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;
  parseMaybeDefault(isBlockScope, true);
}
function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
  if (isTypeScriptEnabled) {
    tsStartParseObjPropValue();
  } else if (isFlowEnabled) {
    flowStartParseObjPropValue();
  }
  const wasMethod = parseObjectMethod(isPattern, objectContextId);
  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}
function parsePropertyName(objectContextId) {
  if (isFlowEnabled) {
    flowParseVariance();
  }
  if (eat(TokenType.bracketL)) {
    state.tokens[state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    expect(TokenType.bracketR);
    state.tokens[state.tokens.length - 1].contextId = objectContextId;
  } else {
    if (match(TokenType.num) || match(TokenType.string) || match(TokenType.bigint) || match(TokenType.decimal)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;
    state.tokens[state.tokens.length - 1].contextId = objectContextId;
  }
}
function parseMethod(functionStart, isConstructor) {
  const funcContextId = getNextContextId();
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  const allowModifiers = isConstructor;
  parseFunctionParams(allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(functionStart, funcContextId);
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
}
function parseArrowExpression(startTokenIndex) {
  parseFunctionBody(true);
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
}
function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
  if (isTypeScriptEnabled) {
    tsParseFunctionBodyAndFinish(functionStart, funcContextId);
  } else if (isFlowEnabled) {
    flowParseFunctionBodyAndFinish(funcContextId);
  } else {
    parseFunctionBody(false, funcContextId);
  }
}
function parseFunctionBody(allowExpression, funcContextId = 0) {
  const isExpression = allowExpression && !match(TokenType.braceL);
  if (isExpression) {
    parseMaybeAssign();
  } else {
    parseBlock(true, funcContextId);
  }
}
function parseExprList(close, allowEmpty = false) {
  let first = true;
  while (!eat(close) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(close))
        break;
    }
    parseExprListItem(allowEmpty);
  }
}
function parseExprListItem(allowEmpty) {
  if (allowEmpty && match(TokenType.comma)) {
  } else if (match(TokenType.ellipsis)) {
    parseSpread();
    parseParenItem();
  } else if (match(TokenType.question)) {
    next();
  } else {
    parseMaybeAssign(false, true);
  }
}
function parseIdentifier() {
  next();
  state.tokens[state.tokens.length - 1].type = TokenType.name;
}
function parseAwait() {
  parseMaybeUnary();
}
function parseYield() {
  next();
  if (!match(TokenType.semi) && !canInsertSemicolon()) {
    eat(TokenType.star);
    parseMaybeAssign();
  }
}
function parseModuleExpression() {
  expectContextual(ContextualKeyword._module);
  expect(TokenType.braceL);
  parseBlockBody(TokenType.braceR);
}

// node_modules/sucrase/dist/esm/parser/plugins/flow.js
function isMaybeDefaultImport(lookahead) {
  return (lookahead.type === TokenType.name || !!(lookahead.type & TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== ContextualKeyword._from;
}
function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || TokenType.colon);
  flowParseType();
  popTypeContext(oldIsType);
}
function flowParsePredicate() {
  expect(TokenType.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(TokenType.parenL)) {
    parseExpression();
    expect(TokenType.parenR);
  }
}
function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.colon);
  if (match(TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match(TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}
function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(
    /* isClass */
    true
  );
}
function flowParseDeclareFunction() {
  next();
  parseIdentifier();
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  expect(TokenType.parenL);
  flowParseFunctionTypeParams();
  expect(TokenType.parenR);
  flowParseTypeAndPredicateInitialiser();
  semicolon();
}
function flowParseDeclare() {
  if (match(TokenType._class)) {
    flowParseDeclareClass();
  } else if (match(TokenType._function)) {
    flowParseDeclareFunction();
  } else if (match(TokenType._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match(TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}
function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}
function flowParseDeclareModule() {
  if (match(TokenType.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
  expect(TokenType.braceL);
  while (!match(TokenType.braceR) && !state.error) {
    if (match(TokenType._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(TokenType.braceR);
}
function flowParseDeclareExportDeclaration() {
  expect(TokenType._export);
  if (eat(TokenType._default)) {
    if (match(TokenType._function) || match(TokenType._class)) {
      flowParseDeclare();
    } else {
      flowParseType();
      semicolon();
    }
  } else if (match(TokenType._var) || // declare export var ...
  match(TokenType._function) || // declare export function ...
  match(TokenType._class) || // declare export class ...
  isContextual(ContextualKeyword._opaque)) {
    flowParseDeclare();
  } else if (match(TokenType.star) || // declare export * from ''
  match(TokenType.braceL) || // declare export {} ...
  isContextual(ContextualKeyword._interface) || // declare export interface ...
  isContextual(ContextualKeyword._type) || // declare export type ...
  isContextual(ContextualKeyword._opaque)) {
    parseExport();
  } else {
    unexpected();
  }
}
function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}
function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}
function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}
function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}
function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  if (eat(TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(TokenType.comma));
  }
  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(TokenType.comma));
  }
  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(TokenType.comma));
  }
  flowParseObjectType(isClass, false, isClass);
}
function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}
function flowParseInterface() {
  flowParseInterfaceish();
}
function flowParseRestrictedIdentifier() {
  parseIdentifier();
}
function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  flowParseTypeInitialiser(TokenType.eq);
  semicolon();
}
function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  if (match(TokenType.colon)) {
    flowParseTypeInitialiser(TokenType.colon);
  }
  if (!declare) {
    flowParseTypeInitialiser(TokenType.eq);
  }
  semicolon();
}
function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();
  if (eat(TokenType.eq)) {
    flowParseType();
  }
}
function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  if (match(TokenType.lessThan) || match(TokenType.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }
  do {
    flowParseTypeParameter();
    if (!match(TokenType.greaterThan)) {
      expect(TokenType.comma);
    }
  } while (!match(TokenType.greaterThan) && !state.error);
  expect(TokenType.greaterThan);
  popTypeContext(oldIsType);
}
function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(TokenType.lessThan);
  while (!match(TokenType.greaterThan) && !state.error) {
    flowParseType();
    if (!match(TokenType.greaterThan)) {
      expect(TokenType.comma);
    }
  }
  expect(TokenType.greaterThan);
  popTypeContext(oldIsType);
}
function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(TokenType.comma));
  }
  flowParseObjectType(false, false, false);
}
function flowParseObjectPropertyKey() {
  if (match(TokenType.num) || match(TokenType.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}
function flowParseObjectTypeIndexer() {
  if (lookaheadType() === TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(TokenType.bracketR);
  flowParseTypeInitialiser();
}
function flowParseObjectTypeInternalSlot() {
  flowParseObjectPropertyKey();
  expect(TokenType.bracketR);
  expect(TokenType.bracketR);
  if (match(TokenType.lessThan) || match(TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(TokenType.question);
    flowParseTypeInitialiser();
  }
}
function flowParseObjectTypeMethodish() {
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }
  expect(TokenType.parenL);
  while (!match(TokenType.parenR) && !match(TokenType.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(TokenType.parenR)) {
      expect(TokenType.comma);
    }
  }
  if (eat(TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  expect(TokenType.parenR);
  flowParseTypeInitialiser();
}
function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}
function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && match(TokenType.braceBarL)) {
    expect(TokenType.braceBarL);
    endDelim = TokenType.braceBarR;
  } else {
    expect(TokenType.braceL);
    endDelim = TokenType.braceR;
  }
  while (!match(endDelim) && !state.error) {
    if (allowProto && isContextual(ContextualKeyword._proto)) {
      const lookahead = lookaheadType();
      if (lookahead !== TokenType.colon && lookahead !== TokenType.question) {
        next();
        allowStatic = false;
      }
    }
    if (allowStatic && isContextual(ContextualKeyword._static)) {
      const lookahead = lookaheadType();
      if (lookahead !== TokenType.colon && lookahead !== TokenType.question) {
        next();
      }
    }
    flowParseVariance();
    if (eat(TokenType.bracketL)) {
      if (eat(TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (match(TokenType.parenL) || match(TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {
        const lookahead = lookaheadType();
        if (lookahead === TokenType.name || lookahead === TokenType.string || lookahead === TokenType.num) {
          next();
        }
      }
      flowParseObjectTypeProperty();
    }
    flowObjectTypeSemicolon();
  }
  expect(endDelim);
}
function flowParseObjectTypeProperty() {
  if (match(TokenType.ellipsis)) {
    expect(TokenType.ellipsis);
    if (!eat(TokenType.comma)) {
      eat(TokenType.semi);
    }
    if (match(TokenType.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (match(TokenType.lessThan) || match(TokenType.parenL)) {
      flowParseObjectTypeMethodish();
    } else {
      eat(TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}
function flowObjectTypeSemicolon() {
  if (!eat(TokenType.semi) && !eat(TokenType.comma) && !match(TokenType.braceR) && !match(TokenType.braceBarR)) {
    unexpected();
  }
}
function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    parseIdentifier();
  }
  while (eat(TokenType.dot)) {
    parseIdentifier();
  }
}
function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}
function flowParseTypeofType() {
  expect(TokenType._typeof);
  flowParsePrimaryType();
}
function flowParseTupleType() {
  expect(TokenType.bracketL);
  while (state.pos < input.length && !match(TokenType.bracketR)) {
    flowParseType();
    if (match(TokenType.bracketR)) {
      break;
    }
    expect(TokenType.comma);
  }
  expect(TokenType.bracketR);
}
function flowParseFunctionTypeParam() {
  const lookahead = lookaheadType();
  if (lookahead === TokenType.colon || lookahead === TokenType.question) {
    parseIdentifier();
    eat(TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}
function flowParseFunctionTypeParams() {
  while (!match(TokenType.parenR) && !match(TokenType.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(TokenType.parenR)) {
      expect(TokenType.comma);
    }
  }
  if (eat(TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = state.noAnonFunctionType;
  switch (state.type) {
    case TokenType.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }
    case TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;
    case TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;
    case TokenType.bracketL:
      flowParseTupleType();
      return;
    case TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      expect(TokenType.parenL);
      flowParseFunctionTypeParams();
      expect(TokenType.parenR);
      expect(TokenType.arrow);
      flowParseType();
      return;
    case TokenType.parenL:
      next();
      if (!match(TokenType.parenR) && !match(TokenType.ellipsis)) {
        if (match(TokenType.name)) {
          const token = lookaheadType();
          isGroupedType = token !== TokenType.question && token !== TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }
      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;
        if (state.noAnonFunctionType || !(match(TokenType.comma) || match(TokenType.parenR) && lookaheadType() === TokenType.arrow)) {
          expect(TokenType.parenR);
          return;
        } else {
          eat(TokenType.comma);
        }
      }
      flowParseFunctionTypeParams();
      expect(TokenType.parenR);
      expect(TokenType.arrow);
      flowParseType();
      return;
    case TokenType.minus:
      next();
      parseLiteral();
      return;
    case TokenType.string:
    case TokenType.num:
    case TokenType._true:
    case TokenType._false:
    case TokenType._null:
    case TokenType._this:
    case TokenType._void:
    case TokenType.star:
      next();
      return;
    default:
      if (state.type === TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = TokenType.name;
        return;
      }
  }
  unexpected();
}
function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match(TokenType.bracketL) || match(TokenType.questionDot))) {
    eat(TokenType.questionDot);
    expect(TokenType.bracketL);
    if (eat(TokenType.bracketR)) {
    } else {
      flowParseType();
      expect(TokenType.bracketR);
    }
  }
}
function flowParsePrefixType() {
  if (eat(TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}
function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(TokenType.arrow)) {
    flowParseType();
  }
}
function flowParseIntersectionType() {
  eat(TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}
function flowParseUnionType() {
  eat(TokenType.bitwiseOR);
  flowParseIntersectionType();
  while (eat(TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}
function flowParseType() {
  flowParseUnionType();
}
function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}
function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match(TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}
function flowParseVariance() {
  if (match(TokenType.plus) || match(TokenType.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}
function flowParseFunctionBodyAndFinish(funcContextId) {
  if (match(TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }
  parseFunctionBody(false, funcContextId);
}
function flowParseSubscript(startTokenIndex, noCalls, stopState) {
  if (match(TokenType.questionDot) && lookaheadType() === TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    next();
    flowParseTypeParameterInstantiation();
    expect(TokenType.parenL);
    parseCallExpressionArguments();
    return;
  } else if (!noCalls && match(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    expect(TokenType.parenL);
    parseCallExpressionArguments();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  baseParseSubscript(startTokenIndex, noCalls, stopState);
}
function flowStartParseNewArguments() {
  if (match(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}
function flowTryParseStatement() {
  if (match(TokenType.name) && state.contextualKeyword === ContextualKeyword._interface) {
    const oldIsType = pushTypeContext(0);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
    return true;
  } else if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}
function flowTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}
function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === ContextualKeyword._declare) {
    if (match(TokenType._class) || match(TokenType.name) || match(TokenType._function) || match(TokenType._var) || match(TokenType._export)) {
      const oldIsType = pushTypeContext(1);
      flowParseDeclare();
      popTypeContext(oldIsType);
    }
  } else if (match(TokenType.name)) {
    if (contextualKeyword === ContextualKeyword._interface) {
      const oldIsType = pushTypeContext(1);
      flowParseInterface();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._type) {
      const oldIsType = pushTypeContext(1);
      flowParseTypeAlias();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._opaque) {
      const oldIsType = pushTypeContext(1);
      flowParseOpaqueType(false);
      popTypeContext(oldIsType);
    }
  }
  semicolon();
}
function flowShouldParseExportDeclaration() {
  return isContextual(ContextualKeyword._type) || isContextual(ContextualKeyword._interface) || isContextual(ContextualKeyword._opaque) || isContextual(ContextualKeyword._enum);
}
function flowShouldDisallowExportDefaultSpecifier() {
  return match(TokenType.name) && (state.contextualKeyword === ContextualKeyword._type || state.contextualKeyword === ContextualKeyword._interface || state.contextualKeyword === ContextualKeyword._opaque || state.contextualKeyword === ContextualKeyword._enum);
}
function flowParseExportDeclaration() {
  if (isContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(1);
    next();
    if (match(TokenType.braceL)) {
      parseExportSpecifiers();
      parseExportFrom();
    } else {
      flowParseTypeAlias();
    }
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._opaque)) {
    const oldIsType = pushTypeContext(1);
    next();
    flowParseOpaqueType(false);
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._interface)) {
    const oldIsType = pushTypeContext(1);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
  } else {
    parseStatement(true);
  }
}
function flowShouldParseExportStar() {
  return match(TokenType.star) || isContextual(ContextualKeyword._type) && lookaheadType() === TokenType.star;
}
function flowParseExportStar() {
  if (eatContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(2);
    baseParseExportStar();
    popTypeContext(oldIsType);
  } else {
    baseParseExportStar();
  }
}
function flowAfterParseClassSuper(hasSuper) {
  if (hasSuper && match(TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
  if (isContextual(ContextualKeyword._implements)) {
    const oldIsType = pushTypeContext(0);
    next();
    state.tokens[state.tokens.length - 1].type = TokenType._implements;
    do {
      flowParseRestrictedIdentifier();
      if (match(TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    } while (eat(TokenType.comma));
    popTypeContext(oldIsType);
  }
}
function flowStartParseObjPropValue() {
  if (match(TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
    if (!match(TokenType.parenL))
      unexpected();
  }
}
function flowParseAssignableListItemTypes() {
  const oldIsType = pushTypeContext(0);
  eat(TokenType.question);
  if (match(TokenType.colon)) {
    flowParseTypeAnnotation();
  }
  popTypeContext(oldIsType);
}
function flowStartParseImportSpecifiers() {
  if (match(TokenType._typeof) || isContextual(ContextualKeyword._type)) {
    const lh = lookaheadTypeAndKeyword();
    if (isMaybeDefaultImport(lh) || lh.type === TokenType.braceL || lh.type === TokenType.star) {
      next();
    }
  }
}
function flowParseImportSpecifier() {
  const isTypeKeyword2 = state.contextualKeyword === ContextualKeyword._type || state.type === TokenType._typeof;
  if (isTypeKeyword2) {
    next();
  } else {
    parseIdentifier();
  }
  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {
    parseIdentifier();
    if (isTypeKeyword2 && !match(TokenType.name) && !(state.type & TokenType.IS_KEYWORD)) {
    } else {
      parseIdentifier();
    }
  } else {
    if (isTypeKeyword2 && (match(TokenType.name) || !!(state.type & TokenType.IS_KEYWORD))) {
      parseIdentifier();
    }
    if (eatContextual(ContextualKeyword._as)) {
      parseIdentifier();
    }
  }
}
function flowStartParseFunctionParams() {
  if (match(TokenType.lessThan)) {
    const oldIsType = pushTypeContext(0);
    flowParseTypeParameterDeclaration();
    popTypeContext(oldIsType);
  }
}
function flowAfterParseVarHead() {
  if (match(TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}
function flowStartParseAsyncArrowFromCallExpression() {
  if (match(TokenType.colon)) {
    const oldNoAnonFunctionType = state.noAnonFunctionType;
    state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    state.noAnonFunctionType = oldNoAnonFunctionType;
  }
}
function flowParseMaybeAssign(noIn, isWithinParens) {
  if (match(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
      state.type = TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }
    const oldIsType = pushTypeContext(0);
    flowParseTypeParameterDeclaration();
    popTypeContext(oldIsType);
    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    unexpected();
  }
  return baseParseMaybeAssign(noIn, isWithinParens);
}
function flowParseArrow() {
  if (match(TokenType.colon)) {
    const oldIsType = pushTypeContext(0);
    const snapshot = state.snapshot();
    const oldNoAnonFunctionType = state.noAnonFunctionType;
    state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    state.noAnonFunctionType = oldNoAnonFunctionType;
    if (canInsertSemicolon())
      unexpected();
    if (!match(TokenType.arrow))
      unexpected();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
    popTypeContext(oldIsType);
  }
  return eat(TokenType.arrow);
}
function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && match(TokenType.lessThan)) {
    const snapshot = state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !state.error) {
      return;
    }
    state.restoreFromSnapshot(snapshot);
  }
  baseParseSubscripts(startTokenIndex, noCalls);
}
function parseAsyncArrowWithTypeParameters() {
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  parseFunctionParams();
  if (!parseArrow()) {
    return false;
  }
  parseArrowExpression(startTokenIndex);
  return true;
}
function flowParseEnumDeclaration() {
  expectContextual(ContextualKeyword._enum);
  state.tokens[state.tokens.length - 1].type = TokenType._enum;
  parseIdentifier();
  flowParseEnumBody();
}
function flowParseEnumBody() {
  if (eatContextual(ContextualKeyword._of)) {
    next();
  }
  expect(TokenType.braceL);
  flowParseEnumMembers();
  expect(TokenType.braceR);
}
function flowParseEnumMembers() {
  while (!match(TokenType.braceR) && !state.error) {
    if (eat(TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!match(TokenType.braceR)) {
      expect(TokenType.comma);
    }
  }
}
function flowParseEnumMember() {
  parseIdentifier();
  if (eat(TokenType.eq)) {
    next();
  }
}

// node_modules/sucrase/dist/esm/parser/traverser/statement.js
function parseTopLevel() {
  parseBlockBody(TokenType.eof);
  state.scopes.push(new Scope(0, state.tokens.length, true));
  if (state.scopeDepth !== 0) {
    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);
  }
  return new File(state.tokens, state.scopes);
}
function parseStatement(declaration) {
  if (isFlowEnabled) {
    if (flowTryParseStatement()) {
      return;
    }
  }
  if (match(TokenType.at)) {
    parseDecorators();
  }
  parseStatementContent(declaration);
}
function parseStatementContent(declaration) {
  if (isTypeScriptEnabled) {
    if (tsTryParseStatementContent()) {
      return;
    }
  }
  const starttype = state.type;
  switch (starttype) {
    case TokenType._break:
    case TokenType._continue:
      parseBreakContinueStatement();
      return;
    case TokenType._debugger:
      parseDebuggerStatement();
      return;
    case TokenType._do:
      parseDoStatement();
      return;
    case TokenType._for:
      parseForStatement();
      return;
    case TokenType._function:
      if (lookaheadType() === TokenType.dot)
        break;
      if (!declaration)
        unexpected();
      parseFunctionStatement();
      return;
    case TokenType._class:
      if (!declaration)
        unexpected();
      parseClass(true);
      return;
    case TokenType._if:
      parseIfStatement();
      return;
    case TokenType._return:
      parseReturnStatement();
      return;
    case TokenType._switch:
      parseSwitchStatement();
      return;
    case TokenType._throw:
      parseThrowStatement();
      return;
    case TokenType._try:
      parseTryStatement();
      return;
    case TokenType._let:
    case TokenType._const:
      if (!declaration)
        unexpected();
    case TokenType._var:
      parseVarStatement(starttype !== TokenType._var);
      return;
    case TokenType._while:
      parseWhileStatement();
      return;
    case TokenType.braceL:
      parseBlock();
      return;
    case TokenType.semi:
      parseEmptyStatement();
      return;
    case TokenType._export:
    case TokenType._import: {
      const nextType = lookaheadType();
      if (nextType === TokenType.parenL || nextType === TokenType.dot) {
        break;
      }
      next();
      if (starttype === TokenType._import) {
        parseImport();
      } else {
        parseExport();
      }
      return;
    }
    case TokenType.name:
      if (state.contextualKeyword === ContextualKeyword._async) {
        const functionStart = state.start;
        const snapshot = state.snapshot();
        next();
        if (match(TokenType._function) && !canInsertSemicolon()) {
          expect(TokenType._function);
          parseFunction(functionStart, true);
          return;
        } else {
          state.restoreFromSnapshot(snapshot);
        }
      } else if (state.contextualKeyword === ContextualKeyword._using && !hasFollowingLineBreak() && // Statements like `using[0]` and `using in foo` aren't actual using
      // declarations.
      lookaheadType() === TokenType.name) {
        parseVarStatement(true);
        return;
      } else if (startsAwaitUsing()) {
        expectContextual(ContextualKeyword._await);
        parseVarStatement(true);
        return;
      }
    default:
      break;
  }
  const initialTokensLength = state.tokens.length;
  parseExpression();
  let simpleName = null;
  if (state.tokens.length === initialTokensLength + 1) {
    const token = state.tokens[state.tokens.length - 1];
    if (token.type === TokenType.name) {
      simpleName = token.contextualKeyword;
    }
  }
  if (simpleName == null) {
    semicolon();
    return;
  }
  if (eat(TokenType.colon)) {
    parseLabeledStatement();
  } else {
    parseIdentifierStatement(simpleName);
  }
}
function startsAwaitUsing() {
  if (!isContextual(ContextualKeyword._await)) {
    return false;
  }
  const snapshot = state.snapshot();
  next();
  if (!isContextual(ContextualKeyword._using) || hasPrecedingLineBreak()) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  next();
  if (!match(TokenType.name) || hasPrecedingLineBreak()) {
    state.restoreFromSnapshot(snapshot);
    return false;
  }
  state.restoreFromSnapshot(snapshot);
  return true;
}
function parseDecorators() {
  while (match(TokenType.at)) {
    parseDecorator();
  }
}
function parseDecorator() {
  next();
  if (eat(TokenType.parenL)) {
    parseExpression();
    expect(TokenType.parenR);
  } else {
    parseIdentifier();
    while (eat(TokenType.dot)) {
      parseIdentifier();
    }
    parseMaybeDecoratorArguments();
  }
}
function parseMaybeDecoratorArguments() {
  if (isTypeScriptEnabled) {
    tsParseMaybeDecoratorArguments();
  } else {
    baseParseMaybeDecoratorArguments();
  }
}
function baseParseMaybeDecoratorArguments() {
  if (eat(TokenType.parenL)) {
    parseCallExpressionArguments();
  }
}
function parseBreakContinueStatement() {
  next();
  if (!isLineTerminator()) {
    parseIdentifier();
    semicolon();
  }
}
function parseDebuggerStatement() {
  next();
  semicolon();
}
function parseDoStatement() {
  next();
  parseStatement(false);
  expect(TokenType._while);
  parseParenExpression();
  eat(TokenType.semi);
}
function parseForStatement() {
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  parseAmbiguousForStatement();
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
  state.scopeDepth--;
}
function isUsingInLoop() {
  if (!isContextual(ContextualKeyword._using)) {
    return false;
  }
  if (isLookaheadContextual(ContextualKeyword._of)) {
    return false;
  }
  return true;
}
function parseAmbiguousForStatement() {
  next();
  let forAwait = false;
  if (isContextual(ContextualKeyword._await)) {
    forAwait = true;
    next();
  }
  expect(TokenType.parenL);
  if (match(TokenType.semi)) {
    if (forAwait) {
      unexpected();
    }
    parseFor();
    return;
  }
  const isAwaitUsing = startsAwaitUsing();
  if (isAwaitUsing || match(TokenType._var) || match(TokenType._let) || match(TokenType._const) || isUsingInLoop()) {
    if (isAwaitUsing) {
      expectContextual(ContextualKeyword._await);
    }
    next();
    parseVar(true, state.type !== TokenType._var);
    if (match(TokenType._in) || isContextual(ContextualKeyword._of)) {
      parseForIn(forAwait);
      return;
    }
    parseFor();
    return;
  }
  parseExpression(true);
  if (match(TokenType._in) || isContextual(ContextualKeyword._of)) {
    parseForIn(forAwait);
    return;
  }
  if (forAwait) {
    unexpected();
  }
  parseFor();
}
function parseFunctionStatement() {
  const functionStart = state.start;
  next();
  parseFunction(functionStart, true);
}
function parseIfStatement() {
  next();
  parseParenExpression();
  parseStatement(false);
  if (eat(TokenType._else)) {
    parseStatement(false);
  }
}
function parseReturnStatement() {
  next();
  if (!isLineTerminator()) {
    parseExpression();
    semicolon();
  }
}
function parseSwitchStatement() {
  next();
  parseParenExpression();
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  expect(TokenType.braceL);
  while (!match(TokenType.braceR) && !state.error) {
    if (match(TokenType._case) || match(TokenType._default)) {
      const isCase = match(TokenType._case);
      next();
      if (isCase) {
        parseExpression();
      }
      expect(TokenType.colon);
    } else {
      parseStatement(true);
    }
  }
  next();
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));
  state.scopeDepth--;
}
function parseThrowStatement() {
  next();
  parseExpression();
  semicolon();
}
function parseCatchClauseParam() {
  parseBindingAtom(
    true
    /* isBlockScope */
  );
  if (isTypeScriptEnabled) {
    tsTryParseTypeAnnotation();
  }
}
function parseTryStatement() {
  next();
  parseBlock();
  if (match(TokenType._catch)) {
    next();
    let catchBindingStartTokenIndex = null;
    if (match(TokenType.parenL)) {
      state.scopeDepth++;
      catchBindingStartTokenIndex = state.tokens.length;
      expect(TokenType.parenL);
      parseCatchClauseParam();
      expect(TokenType.parenR);
    }
    parseBlock();
    if (catchBindingStartTokenIndex != null) {
      const endTokenIndex = state.tokens.length;
      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));
      state.scopeDepth--;
    }
  }
  if (eat(TokenType._finally)) {
    parseBlock();
  }
}
function parseVarStatement(isBlockScope) {
  next();
  parseVar(false, isBlockScope);
  semicolon();
}
function parseWhileStatement() {
  next();
  parseParenExpression();
  parseStatement(false);
}
function parseEmptyStatement() {
  next();
}
function parseLabeledStatement() {
  parseStatement(true);
}
function parseIdentifierStatement(contextualKeyword) {
  if (isTypeScriptEnabled) {
    tsParseIdentifierStatement(contextualKeyword);
  } else if (isFlowEnabled) {
    flowParseIdentifierStatement(contextualKeyword);
  } else {
    semicolon();
  }
}
function parseBlock(isFunctionScope = false, contextId = 0) {
  const startTokenIndex = state.tokens.length;
  state.scopeDepth++;
  expect(TokenType.braceL);
  if (contextId) {
    state.tokens[state.tokens.length - 1].contextId = contextId;
  }
  parseBlockBody(TokenType.braceR);
  if (contextId) {
    state.tokens[state.tokens.length - 1].contextId = contextId;
  }
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));
  state.scopeDepth--;
}
function parseBlockBody(end) {
  while (!eat(end) && !state.error) {
    parseStatement(true);
  }
}
function parseFor() {
  expect(TokenType.semi);
  if (!match(TokenType.semi)) {
    parseExpression();
  }
  expect(TokenType.semi);
  if (!match(TokenType.parenR)) {
    parseExpression();
  }
  expect(TokenType.parenR);
  parseStatement(false);
}
function parseForIn(forAwait) {
  if (forAwait) {
    eatContextual(ContextualKeyword._of);
  } else {
    next();
  }
  parseExpression();
  expect(TokenType.parenR);
  parseStatement(false);
}
function parseVar(isFor, isBlockScope) {
  while (true) {
    parseVarHead(isBlockScope);
    if (eat(TokenType.eq)) {
      const eqIndex = state.tokens.length - 1;
      parseMaybeAssign(isFor);
      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;
    }
    if (!eat(TokenType.comma)) {
      break;
    }
  }
}
function parseVarHead(isBlockScope) {
  parseBindingAtom(isBlockScope);
  if (isTypeScriptEnabled) {
    tsAfterParseVarHead();
  } else if (isFlowEnabled) {
    flowAfterParseVarHead();
  }
}
function parseFunction(functionStart, isStatement, optionalId = false) {
  if (match(TokenType.star)) {
    next();
  }
  if (isStatement && !optionalId && !match(TokenType.name) && !match(TokenType._yield)) {
    unexpected();
  }
  let nameScopeStartTokenIndex = null;
  if (match(TokenType.name)) {
    if (!isStatement) {
      nameScopeStartTokenIndex = state.tokens.length;
      state.scopeDepth++;
    }
    parseBindingIdentifier(false);
  }
  const startTokenIndex = state.tokens.length;
  state.scopeDepth++;
  parseFunctionParams();
  parseFunctionBodyAndFinish(functionStart);
  const endTokenIndex = state.tokens.length;
  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));
  state.scopeDepth--;
  if (nameScopeStartTokenIndex !== null) {
    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));
    state.scopeDepth--;
  }
}
function parseFunctionParams(allowModifiers = false, funcContextId = 0) {
  if (isTypeScriptEnabled) {
    tsStartParseFunctionParams();
  } else if (isFlowEnabled) {
    flowStartParseFunctionParams();
  }
  expect(TokenType.parenL);
  if (funcContextId) {
    state.tokens[state.tokens.length - 1].contextId = funcContextId;
  }
  parseBindingList(
    TokenType.parenR,
    false,
    false,
    allowModifiers,
    funcContextId
  );
  if (funcContextId) {
    state.tokens[state.tokens.length - 1].contextId = funcContextId;
  }
}
function parseClass(isStatement, optionalId = false) {
  const contextId = getNextContextId();
  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;
  state.tokens[state.tokens.length - 1].isExpression = !isStatement;
  let nameScopeStartTokenIndex = null;
  if (!isStatement) {
    nameScopeStartTokenIndex = state.tokens.length;
    state.scopeDepth++;
  }
  parseClassId(isStatement, optionalId);
  parseClassSuper();
  const openBraceIndex = state.tokens.length;
  parseClassBody(contextId);
  if (state.error) {
    return;
  }
  state.tokens[openBraceIndex].contextId = contextId;
  state.tokens[state.tokens.length - 1].contextId = contextId;
  if (nameScopeStartTokenIndex !== null) {
    const endTokenIndex = state.tokens.length;
    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));
    state.scopeDepth--;
  }
}
function isClassProperty() {
  return match(TokenType.eq) || match(TokenType.semi) || match(TokenType.braceR) || match(TokenType.bang) || match(TokenType.colon);
}
function isClassMethod() {
  return match(TokenType.parenL) || match(TokenType.lessThan);
}
function parseClassBody(classContextId) {
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    if (eat(TokenType.semi)) {
      continue;
    }
    if (match(TokenType.at)) {
      parseDecorator();
      continue;
    }
    const memberStart = state.start;
    parseClassMember(memberStart, classContextId);
  }
}
function parseClassMember(memberStart, classContextId) {
  if (isTypeScriptEnabled) {
    tsParseModifiers([
      ContextualKeyword._declare,
      ContextualKeyword._public,
      ContextualKeyword._protected,
      ContextualKeyword._private,
      ContextualKeyword._override
    ]);
  }
  let isStatic = false;
  if (match(TokenType.name) && state.contextualKeyword === ContextualKeyword._static) {
    parseIdentifier();
    if (isClassMethod()) {
      parseClassMethod(
        memberStart,
        /* isConstructor */
        false
      );
      return;
    } else if (isClassProperty()) {
      parseClassProperty();
      return;
    }
    state.tokens[state.tokens.length - 1].type = TokenType._static;
    isStatic = true;
    if (match(TokenType.braceL)) {
      state.tokens[state.tokens.length - 1].contextId = classContextId;
      parseBlock();
      return;
    }
  }
  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}
function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
  if (isTypeScriptEnabled) {
    if (tsTryParseClassMemberWithIsStatic(isStatic)) {
      return;
    }
  }
  if (eat(TokenType.star)) {
    parseClassPropertyName(classContextId);
    parseClassMethod(
      memberStart,
      /* isConstructor */
      false
    );
    return;
  }
  parseClassPropertyName(classContextId);
  let isConstructor = false;
  const token = state.tokens[state.tokens.length - 1];
  if (token.contextualKeyword === ContextualKeyword._constructor) {
    isConstructor = true;
  }
  parsePostMemberNameModifiers();
  if (isClassMethod()) {
    parseClassMethod(memberStart, isConstructor);
  } else if (isClassProperty()) {
    parseClassProperty();
  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {
    state.tokens[state.tokens.length - 1].type = TokenType._async;
    const isGenerator = match(TokenType.star);
    if (isGenerator) {
      next();
    }
    parseClassPropertyName(classContextId);
    parsePostMemberNameModifiers();
    parseClassMethod(
      memberStart,
      false
      /* isConstructor */
    );
  } else if ((token.contextualKeyword === ContextualKeyword._get || token.contextualKeyword === ContextualKeyword._set) && !(isLineTerminator() && match(TokenType.star))) {
    if (token.contextualKeyword === ContextualKeyword._get) {
      state.tokens[state.tokens.length - 1].type = TokenType._get;
    } else {
      state.tokens[state.tokens.length - 1].type = TokenType._set;
    }
    parseClassPropertyName(classContextId);
    parseClassMethod(
      memberStart,
      /* isConstructor */
      false
    );
  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {
    parseClassPropertyName(classContextId);
    parseClassProperty();
  } else if (isLineTerminator()) {
    parseClassProperty();
  } else {
    unexpected();
  }
}
function parseClassMethod(functionStart, isConstructor) {
  if (isTypeScriptEnabled) {
    tsTryParseTypeParameters();
  } else if (isFlowEnabled) {
    if (match(TokenType.lessThan)) {
      flowParseTypeParameterDeclaration();
    }
  }
  parseMethod(functionStart, isConstructor);
}
function parseClassPropertyName(classContextId) {
  parsePropertyName(classContextId);
}
function parsePostMemberNameModifiers() {
  if (isTypeScriptEnabled) {
    const oldIsType = pushTypeContext(0);
    eat(TokenType.question);
    popTypeContext(oldIsType);
  }
}
function parseClassProperty() {
  if (isTypeScriptEnabled) {
    eatTypeToken(TokenType.bang);
    tsTryParseTypeAnnotation();
  } else if (isFlowEnabled) {
    if (match(TokenType.colon)) {
      flowParseTypeAnnotation();
    }
  }
  if (match(TokenType.eq)) {
    const equalsTokenIndex = state.tokens.length;
    next();
    parseMaybeAssign();
    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;
  }
  semicolon();
}
function parseClassId(isStatement, optionalId = false) {
  if (isTypeScriptEnabled && (!isStatement || optionalId) && isContextual(ContextualKeyword._implements)) {
    return;
  }
  if (match(TokenType.name)) {
    parseBindingIdentifier(true);
  }
  if (isTypeScriptEnabled) {
    tsTryParseTypeParameters();
  } else if (isFlowEnabled) {
    if (match(TokenType.lessThan)) {
      flowParseTypeParameterDeclaration();
    }
  }
}
function parseClassSuper() {
  let hasSuper = false;
  if (eat(TokenType._extends)) {
    parseExprSubscripts();
    hasSuper = true;
  } else {
    hasSuper = false;
  }
  if (isTypeScriptEnabled) {
    tsAfterParseClassSuper(hasSuper);
  } else if (isFlowEnabled) {
    flowAfterParseClassSuper(hasSuper);
  }
}
function parseExport() {
  const exportIndex = state.tokens.length - 1;
  if (isTypeScriptEnabled) {
    if (tsTryParseExport()) {
      return;
    }
  }
  if (shouldParseExportStar()) {
    parseExportStar();
  } else if (isExportDefaultSpecifier()) {
    parseIdentifier();
    if (match(TokenType.comma) && lookaheadType() === TokenType.star) {
      expect(TokenType.comma);
      expect(TokenType.star);
      expectContextual(ContextualKeyword._as);
      parseIdentifier();
    } else {
      parseExportSpecifiersMaybe();
    }
    parseExportFrom();
  } else if (eat(TokenType._default)) {
    parseExportDefaultExpression();
  } else if (shouldParseExportDeclaration()) {
    parseExportDeclaration();
  } else {
    parseExportSpecifiers();
    parseExportFrom();
  }
  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;
}
function parseExportDefaultExpression() {
  if (isTypeScriptEnabled) {
    if (tsTryParseExportDefaultExpression()) {
      return;
    }
  }
  if (isFlowEnabled) {
    if (flowTryParseExportDefaultExpression()) {
      return;
    }
  }
  const functionStart = state.start;
  if (eat(TokenType._function)) {
    parseFunction(functionStart, true, true);
  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === TokenType._function) {
    eatContextual(ContextualKeyword._async);
    eat(TokenType._function);
    parseFunction(functionStart, true, true);
  } else if (match(TokenType._class)) {
    parseClass(true, true);
  } else if (match(TokenType.at)) {
    parseDecorators();
    parseClass(true, true);
  } else {
    parseMaybeAssign();
    semicolon();
  }
}
function parseExportDeclaration() {
  if (isTypeScriptEnabled) {
    tsParseExportDeclaration();
  } else if (isFlowEnabled) {
    flowParseExportDeclaration();
  } else {
    parseStatement(true);
  }
}
function isExportDefaultSpecifier() {
  if (isTypeScriptEnabled && tsIsDeclarationStart()) {
    return false;
  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {
    return false;
  }
  if (match(TokenType.name)) {
    return state.contextualKeyword !== ContextualKeyword._async;
  }
  if (!match(TokenType._default)) {
    return false;
  }
  const _next = nextTokenStart();
  const lookahead = lookaheadTypeAndKeyword();
  const hasFrom = lookahead.type === TokenType.name && lookahead.contextualKeyword === ContextualKeyword._from;
  if (lookahead.type === TokenType.comma) {
    return true;
  }
  if (hasFrom) {
    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));
    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;
  }
  return false;
}
function parseExportSpecifiersMaybe() {
  if (eat(TokenType.comma)) {
    parseExportSpecifiers();
  }
}
function parseExportFrom() {
  if (eatContextual(ContextualKeyword._from)) {
    parseExprAtom();
    maybeParseImportAttributes();
  }
  semicolon();
}
function shouldParseExportStar() {
  if (isFlowEnabled) {
    return flowShouldParseExportStar();
  } else {
    return match(TokenType.star);
  }
}
function parseExportStar() {
  if (isFlowEnabled) {
    flowParseExportStar();
  } else {
    baseParseExportStar();
  }
}
function baseParseExportStar() {
  expect(TokenType.star);
  if (isContextual(ContextualKeyword._as)) {
    parseExportNamespace();
  } else {
    parseExportFrom();
  }
}
function parseExportNamespace() {
  next();
  state.tokens[state.tokens.length - 1].type = TokenType._as;
  parseIdentifier();
  parseExportSpecifiersMaybe();
  parseExportFrom();
}
function shouldParseExportDeclaration() {
  return isTypeScriptEnabled && tsIsDeclarationStart() || isFlowEnabled && flowShouldParseExportDeclaration() || state.type === TokenType._var || state.type === TokenType._const || state.type === TokenType._let || state.type === TokenType._function || state.type === TokenType._class || isContextual(ContextualKeyword._async) || match(TokenType.at);
}
function parseExportSpecifiers() {
  let first = true;
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(TokenType.comma);
      if (eat(TokenType.braceR)) {
        break;
      }
    }
    parseExportSpecifier();
  }
}
function parseExportSpecifier() {
  if (isTypeScriptEnabled) {
    tsParseExportSpecifier();
    return;
  }
  parseIdentifier();
  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;
  if (eatContextual(ContextualKeyword._as)) {
    parseIdentifier();
  }
}
function isImportReflection() {
  const snapshot = state.snapshot();
  expectContextual(ContextualKeyword._module);
  if (eatContextual(ContextualKeyword._from)) {
    if (isContextual(ContextualKeyword._from)) {
      state.restoreFromSnapshot(snapshot);
      return true;
    } else {
      state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (match(TokenType.comma)) {
    state.restoreFromSnapshot(snapshot);
    return false;
  } else {
    state.restoreFromSnapshot(snapshot);
    return true;
  }
}
function parseMaybeImportReflection() {
  if (isContextual(ContextualKeyword._module) && isImportReflection()) {
    next();
  }
}
function parseImport() {
  if (isTypeScriptEnabled && match(TokenType.name) && lookaheadType() === TokenType.eq) {
    tsParseImportEqualsDeclaration();
    return;
  }
  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {
    const lookahead = lookaheadTypeAndKeyword();
    if (lookahead.type === TokenType.name && lookahead.contextualKeyword !== ContextualKeyword._from) {
      expectContextual(ContextualKeyword._type);
      if (lookaheadType() === TokenType.eq) {
        tsParseImportEqualsDeclaration();
        return;
      }
    } else if (lookahead.type === TokenType.star || lookahead.type === TokenType.braceL) {
      expectContextual(ContextualKeyword._type);
    }
  }
  if (match(TokenType.string)) {
    parseExprAtom();
  } else {
    parseMaybeImportReflection();
    parseImportSpecifiers();
    expectContextual(ContextualKeyword._from);
    parseExprAtom();
  }
  maybeParseImportAttributes();
  semicolon();
}
function shouldParseDefaultImport() {
  return match(TokenType.name);
}
function parseImportSpecifierLocal() {
  parseImportedIdentifier();
}
function parseImportSpecifiers() {
  if (isFlowEnabled) {
    flowStartParseImportSpecifiers();
  }
  let first = true;
  if (shouldParseDefaultImport()) {
    parseImportSpecifierLocal();
    if (!eat(TokenType.comma))
      return;
  }
  if (match(TokenType.star)) {
    next();
    expectContextual(ContextualKeyword._as);
    parseImportSpecifierLocal();
    return;
  }
  expect(TokenType.braceL);
  while (!eat(TokenType.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      if (eat(TokenType.colon)) {
        unexpected(
          "ES2015 named imports do not destructure. Use another statement for destructuring after the import."
        );
      }
      expect(TokenType.comma);
      if (eat(TokenType.braceR)) {
        break;
      }
    }
    parseImportSpecifier();
  }
}
function parseImportSpecifier() {
  if (isTypeScriptEnabled) {
    tsParseImportSpecifier();
    return;
  }
  if (isFlowEnabled) {
    flowParseImportSpecifier();
    return;
  }
  parseImportedIdentifier();
  if (isContextual(ContextualKeyword._as)) {
    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;
    next();
    parseImportedIdentifier();
  }
}
function maybeParseImportAttributes() {
  if (match(TokenType._with) || isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak()) {
    next();
    parseObj(false, false);
  }
}

// node_modules/sucrase/dist/esm/parser/traverser/index.js
function parseFile() {
  if (state.pos === 0 && input.charCodeAt(0) === charCodes.numberSign && input.charCodeAt(1) === charCodes.exclamationMark) {
    skipLineComment(2);
  }
  nextToken();
  return parseTopLevel();
}

// node_modules/sucrase/dist/esm/parser/index.js
var File = class {
  constructor(tokens, scopes) {
    this.tokens = tokens;
    this.scopes = scopes;
  }
};
function parse(input2, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2) {
  if (isFlowEnabled2 && isTypeScriptEnabled2) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }
  initParser(input2, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2);
  const result2 = parseFile();
  if (state.error) {
    throw augmentError(state.error);
  }
  return result2;
}

// node_modules/sucrase/dist/esm/util/isAsyncOperation.js
function isAsyncOperation(tokens) {
  let index = tokens.currentIndex();
  let depth = 0;
  const startToken = tokens.currentToken();
  do {
    const token = tokens.tokens[index];
    if (token.isOptionalChainStart) {
      depth++;
    }
    if (token.isOptionalChainEnd) {
      depth--;
    }
    depth += token.numNullishCoalesceStarts;
    depth -= token.numNullishCoalesceEnds;
    if (token.contextualKeyword === ContextualKeyword._await && token.identifierRole == null && token.scopeDepth === startToken.scopeDepth) {
      return true;
    }
    index += 1;
  } while (depth > 0 && index < tokens.tokens.length);
  return false;
}

// node_modules/sucrase/dist/esm/TokenProcessor.js
var TokenProcessor = class _TokenProcessor {
  __init() {
    this.resultCode = "";
  }
  // Array mapping input token index to optional string index position in the
  // output code.
  __init2() {
    this.resultMappings = new Array(this.tokens.length);
  }
  __init3() {
    this.tokenIndex = 0;
  }
  constructor(code, tokens, isFlowEnabled2, disableESTransforms, helperManager) {
    ;
    this.code = code;
    this.tokens = tokens;
    this.isFlowEnabled = isFlowEnabled2;
    this.disableESTransforms = disableESTransforms;
    this.helperManager = helperManager;
    _TokenProcessor.prototype.__init.call(this);
    _TokenProcessor.prototype.__init2.call(this);
    _TokenProcessor.prototype.__init3.call(this);
  }
  /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */
  snapshot() {
    return {
      resultCode: this.resultCode,
      tokenIndex: this.tokenIndex
    };
  }
  restoreToSnapshot(snapshot) {
    this.resultCode = snapshot.resultCode;
    this.tokenIndex = snapshot.tokenIndex;
  }
  /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */
  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
    const result2 = this.resultCode.slice(snapshot.resultCode.length);
    this.resultCode = snapshot.resultCode;
    return result2;
  }
  reset() {
    this.resultCode = "";
    this.resultMappings = new Array(this.tokens.length);
    this.tokenIndex = 0;
  }
  matchesContextualAtIndex(index, contextualKeyword) {
    return this.matches1AtIndex(index, TokenType.name) && this.tokens[index].contextualKeyword === contextualKeyword;
  }
  identifierNameAtIndex(index) {
    return this.identifierNameForToken(this.tokens[index]);
  }
  identifierNameAtRelativeIndex(relativeIndex) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(token) {
    return this.code.slice(token.start, token.end);
  }
  rawCodeForToken(token) {
    return this.code.slice(token.start, token.end);
  }
  stringValueAtIndex(index) {
    return this.stringValueForToken(this.tokens[index]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(token) {
    return this.code.slice(token.start + 1, token.end - 1);
  }
  matches1AtIndex(index, t1) {
    return this.tokens[index].type === t1;
  }
  matches2AtIndex(index, t1, t2) {
    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
  }
  matches3AtIndex(index, t1, t2, t3) {
    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;
  }
  matches1(t1) {
    return this.tokens[this.tokenIndex].type === t1;
  }
  matches2(t1, t2) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
  }
  matches3(t1, t2, t3) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;
  }
  matches4(t1, t2, t3, t4) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;
  }
  matches5(t1, t2, t3, t4, t5) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;
  }
  matchesContextual(contextualKeyword) {
    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
  }
  matchesContextIdAndLabel(type, contextId) {
    return this.matches1(type) && this.currentToken().contextId === contextId;
  }
  previousWhitespaceAndComments() {
    let whitespaceAndComments = this.code.slice(
      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length
    );
    if (this.isFlowEnabled) {
      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
    }
    return whitespaceAndComments;
  }
  replaceToken(newCode) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(newCode) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }
  /**
   * Remove all code until the next }, accounting for balanced braces.
   */
  removeBalancedCode() {
    let braceDepth = 0;
    while (!this.isAtEnd()) {
      if (this.matches1(TokenType.braceL)) {
        braceDepth++;
      } else if (this.matches1(TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(tokenType) {
    if (this.tokens[this.tokenIndex].type !== tokenType) {
      throw new Error(`Expected token ${tokenType}`);
    }
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    );
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  copyTokenWithPrefix(prefix) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultCode += prefix;
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    );
    this.appendTokenSuffix();
    this.tokenIndex++;
  }
  appendTokenPrefix() {
    const token = this.currentToken();
    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {
      token.isAsyncOperation = isAsyncOperation(this);
    }
    if (this.disableESTransforms) {
      return;
    }
    if (token.numNullishCoalesceStarts) {
      for (let i2 = 0; i2 < token.numNullishCoalesceStarts; i2++) {
        if (token.isAsyncOperation) {
          this.resultCode += "await ";
          this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
        } else {
          this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
        }
        this.resultCode += "(";
      }
    }
    if (token.isOptionalChainStart) {
      if (token.isAsyncOperation) {
        this.resultCode += "await ";
      }
      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === TokenType._delete) {
        if (token.isAsyncOperation) {
          this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
        } else {
          this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
        }
      } else if (token.isAsyncOperation) {
        this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
      } else {
        this.resultCode += this.helperManager.getHelperName("optionalChain");
      }
      this.resultCode += "([";
    }
  }
  appendTokenSuffix() {
    const token = this.currentToken();
    if (token.isOptionalChainEnd && !this.disableESTransforms) {
      this.resultCode += "])";
    }
    if (token.numNullishCoalesceEnds && !this.disableESTransforms) {
      for (let i2 = 0; i2 < token.numNullishCoalesceEnds; i2++) {
        this.resultCode += "))";
      }
    }
  }
  appendCode(code) {
    this.resultCode += code;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const token = this.currentToken();
    return this.code.slice(token.start, token.end);
  }
  tokenAtRelativeIndex(relativeIndex) {
    return this.tokens[this.tokenIndex + relativeIndex];
  }
  currentIndex() {
    return this.tokenIndex;
  }
  /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */
  nextToken() {
    if (this.tokenIndex === this.tokens.length) {
      throw new Error("Unexpectedly reached end of input.");
    }
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length) {
      throw new Error("Tried to finish processing tokens before reaching the end.");
    }
    this.resultCode += this.previousWhitespaceAndComments();
    return { code: this.resultCode, mappings: this.resultMappings };
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
};

// node_modules/sucrase/dist/esm/util/getClassInfo.js
function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms) {
  const snapshot = tokens.snapshot();
  const headerInfo = processClassHeader(tokens);
  let constructorInitializerStatements = [];
  const instanceInitializerNames = [];
  const staticInitializerNames = [];
  let constructorInsertPos = null;
  const fields = [];
  const rangesToRemove = [];
  const classContextId = tokens.currentToken().contextId;
  if (classContextId == null) {
    throw new Error("Expected non-null class context ID on class open-brace.");
  }
  tokens.nextToken();
  while (!tokens.matchesContextIdAndLabel(TokenType.braceR, classContextId)) {
    if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {
      ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
    } else if (tokens.matches1(TokenType.semi)) {
      if (!disableESTransforms) {
        rangesToRemove.push({ start: tokens.currentIndex(), end: tokens.currentIndex() + 1 });
      }
      tokens.nextToken();
    } else if (tokens.currentToken().isType) {
      tokens.nextToken();
    } else {
      const statementStartIndex = tokens.currentIndex();
      let isStatic = false;
      let isESPrivate = false;
      let isDeclareOrAbstract = false;
      while (isAccessModifier(tokens.currentToken())) {
        if (tokens.matches1(TokenType._static)) {
          isStatic = true;
        }
        if (tokens.matches1(TokenType.hash)) {
          isESPrivate = true;
        }
        if (tokens.matches1(TokenType._declare) || tokens.matches1(TokenType._abstract)) {
          isDeclareOrAbstract = true;
        }
        tokens.nextToken();
      }
      if (isStatic && tokens.matches1(TokenType.braceL)) {
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (isESPrivate) {
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {
        ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
        continue;
      }
      const nameStartIndex = tokens.currentIndex();
      skipFieldName(tokens);
      if (tokens.matches1(TokenType.lessThan) || tokens.matches1(TokenType.parenL)) {
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      while (tokens.currentToken().isType) {
        tokens.nextToken();
      }
      if (tokens.matches1(TokenType.eq)) {
        const equalsIndex = tokens.currentIndex();
        const valueEnd = tokens.currentToken().rhsEndIndex;
        if (valueEnd == null) {
          throw new Error("Expected rhsEndIndex on class field assignment.");
        }
        tokens.nextToken();
        while (tokens.currentIndex() < valueEnd) {
          rootTransformer.processToken();
        }
        let initializerName;
        if (isStatic) {
          initializerName = nameManager.claimFreeName("__initStatic");
          staticInitializerNames.push(initializerName);
        } else {
          initializerName = nameManager.claimFreeName("__init");
          instanceInitializerNames.push(initializerName);
        }
        fields.push({
          initializerName,
          equalsIndex,
          start: nameStartIndex,
          end: tokens.currentIndex()
        });
      } else if (!disableESTransforms || isDeclareOrAbstract) {
        rangesToRemove.push({ start: statementStartIndex, end: tokens.currentIndex() });
      }
    }
  }
  tokens.restoreToSnapshot(snapshot);
  if (disableESTransforms) {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames: [],
      staticInitializerNames: [],
      constructorInsertPos,
      fields: [],
      rangesToRemove
    };
  } else {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames,
      staticInitializerNames,
      constructorInsertPos,
      fields,
      rangesToRemove
    };
  }
}
function skipToNextClassElement(tokens, classContextId) {
  tokens.nextToken();
  while (tokens.currentToken().contextId !== classContextId) {
    tokens.nextToken();
  }
  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {
    tokens.previousToken();
  }
}
function processClassHeader(tokens) {
  const classToken = tokens.currentToken();
  const contextId = classToken.contextId;
  if (contextId == null) {
    throw new Error("Expected context ID on class token.");
  }
  const isExpression = classToken.isExpression;
  if (isExpression == null) {
    throw new Error("Expected isExpression on class token.");
  }
  let className = null;
  let hasSuperclass = false;
  tokens.nextToken();
  if (tokens.matches1(TokenType.name)) {
    className = tokens.identifierName();
  }
  while (!tokens.matchesContextIdAndLabel(TokenType.braceL, contextId)) {
    if (tokens.matches1(TokenType._extends) && !tokens.currentToken().isType) {
      hasSuperclass = true;
    }
    tokens.nextToken();
  }
  return { isExpression, className, hasSuperclass };
}
function processConstructor(tokens) {
  const constructorInitializerStatements = [];
  tokens.nextToken();
  const constructorContextId = tokens.currentToken().contextId;
  if (constructorContextId == null) {
    throw new Error("Expected context ID on open-paren starting constructor params.");
  }
  while (!tokens.matchesContextIdAndLabel(TokenType.parenR, constructorContextId)) {
    if (tokens.currentToken().contextId === constructorContextId) {
      tokens.nextToken();
      if (isAccessModifier(tokens.currentToken())) {
        tokens.nextToken();
        while (isAccessModifier(tokens.currentToken())) {
          tokens.nextToken();
        }
        const token = tokens.currentToken();
        if (token.type !== TokenType.name) {
          throw new Error("Expected identifier after access modifiers in constructor arg.");
        }
        const name = tokens.identifierNameForToken(token);
        constructorInitializerStatements.push(`this.${name} = ${name}`);
      }
    } else {
      tokens.nextToken();
    }
  }
  tokens.nextToken();
  while (tokens.currentToken().isType) {
    tokens.nextToken();
  }
  let constructorInsertPos = tokens.currentIndex();
  let foundSuperCall = false;
  while (!tokens.matchesContextIdAndLabel(TokenType.braceR, constructorContextId)) {
    if (!foundSuperCall && tokens.matches2(TokenType._super, TokenType.parenL)) {
      tokens.nextToken();
      const superCallContextId = tokens.currentToken().contextId;
      if (superCallContextId == null) {
        throw new Error("Expected a context ID on the super call");
      }
      while (!tokens.matchesContextIdAndLabel(TokenType.parenR, superCallContextId)) {
        tokens.nextToken();
      }
      constructorInsertPos = tokens.currentIndex();
      foundSuperCall = true;
    }
    tokens.nextToken();
  }
  tokens.nextToken();
  return { constructorInitializerStatements, constructorInsertPos };
}
function isAccessModifier(token) {
  return [
    TokenType._async,
    TokenType._get,
    TokenType._set,
    TokenType.plus,
    TokenType.minus,
    TokenType._readonly,
    TokenType._static,
    TokenType._public,
    TokenType._private,
    TokenType._protected,
    TokenType._override,
    TokenType._abstract,
    TokenType.star,
    TokenType._declare,
    TokenType.hash
  ].includes(token.type);
}
function skipFieldName(tokens) {
  if (tokens.matches1(TokenType.bracketL)) {
    const startToken = tokens.currentToken();
    const classContextId = startToken.contextId;
    if (classContextId == null) {
      throw new Error("Expected class context ID on computed name open bracket.");
    }
    while (!tokens.matchesContextIdAndLabel(TokenType.bracketR, classContextId)) {
      tokens.nextToken();
    }
    tokens.nextToken();
  } else {
    tokens.nextToken();
  }
}

// node_modules/sucrase/dist/esm/util/elideImportEquals.js
function elideImportEquals(tokens) {
  tokens.removeInitialToken();
  tokens.removeToken();
  tokens.removeToken();
  tokens.removeToken();
  if (tokens.matches1(TokenType.parenL)) {
    tokens.removeToken();
    tokens.removeToken();
    tokens.removeToken();
  } else {
    while (tokens.matches1(TokenType.dot)) {
      tokens.removeToken();
      tokens.removeToken();
    }
  }
}

// node_modules/sucrase/dist/esm/util/getDeclarationInfo.js
var EMPTY_DECLARATION_INFO = {
  typeDeclarations: /* @__PURE__ */ new Set(),
  valueDeclarations: /* @__PURE__ */ new Set()
};
function getDeclarationInfo(tokens) {
  const typeDeclarations = /* @__PURE__ */ new Set();
  const valueDeclarations = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < tokens.tokens.length; i2++) {
    const token = tokens.tokens[i2];
    if (token.type === TokenType.name && isTopLevelDeclaration(token)) {
      if (token.isType) {
        typeDeclarations.add(tokens.identifierNameForToken(token));
      } else {
        valueDeclarations.add(tokens.identifierNameForToken(token));
      }
    }
  }
  return { typeDeclarations, valueDeclarations };
}

// node_modules/sucrase/dist/esm/util/isExportFrom.js
function isExportFrom(tokens) {
  let closeBraceIndex = tokens.currentIndex();
  while (!tokens.matches1AtIndex(closeBraceIndex, TokenType.braceR)) {
    closeBraceIndex++;
  }
  return tokens.matchesContextualAtIndex(closeBraceIndex + 1, ContextualKeyword._from) && tokens.matches1AtIndex(closeBraceIndex + 2, TokenType.string);
}

// node_modules/sucrase/dist/esm/util/removeMaybeImportAttributes.js
function removeMaybeImportAttributes(tokens) {
  if (tokens.matches2(TokenType._with, TokenType.braceL) || tokens.matches2(TokenType.name, TokenType.braceL) && tokens.matchesContextual(ContextualKeyword._assert)) {
    tokens.removeToken();
    tokens.removeToken();
    tokens.removeBalancedCode();
    tokens.removeToken();
  }
}

// node_modules/sucrase/dist/esm/util/shouldElideDefaultExport.js
function shouldElideDefaultExport(isTypeScriptTransformEnabled, keepUnusedImports, tokens, declarationInfo) {
  if (!isTypeScriptTransformEnabled || keepUnusedImports) {
    return false;
  }
  const exportToken = tokens.currentToken();
  if (exportToken.rhsEndIndex == null) {
    throw new Error("Expected non-null rhsEndIndex on export token.");
  }
  const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();
  if (numTokens !== 3 && !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, TokenType.semi))) {
    return false;
  }
  const identifierToken = tokens.tokenAtRelativeIndex(2);
  if (identifierToken.type !== TokenType.name) {
    return false;
  }
  const exportedName = tokens.identifierNameForToken(identifierToken);
  return declarationInfo.typeDeclarations.has(exportedName) && !declarationInfo.valueDeclarations.has(exportedName);
}

// node_modules/sucrase/dist/esm/transformers/CJSImportTransformer.js
var CJSImportTransformer = class _CJSImportTransformer extends Transformer {
  __init() {
    this.hadExport = false;
  }
  __init2() {
    this.hadNamedExport = false;
  }
  __init3() {
    this.hadDefaultExport = false;
  }
  constructor(rootTransformer, tokens, importProcessor, nameManager, helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, enableLegacyTypeScriptModuleInterop, isTypeScriptTransformEnabled, isFlowTransformEnabled, preserveDynamicImport, keepUnusedImports) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.nameManager = nameManager;
    this.helperManager = helperManager;
    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
    this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;
    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.isFlowTransformEnabled = isFlowTransformEnabled;
    this.preserveDynamicImport = preserveDynamicImport;
    this.keepUnusedImports = keepUnusedImports;
    _CJSImportTransformer.prototype.__init.call(this);
    _CJSImportTransformer.prototype.__init2.call(this);
    _CJSImportTransformer.prototype.__init3.call(this);
    ;
    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;
  }
  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }
  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }
  process() {
    if (this.tokens.matches3(TokenType._import, TokenType.name, TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(TokenType._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(TokenType._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(TokenType.name, TokenType.postIncDec)) {
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(TokenType.name) || this.tokens.matches1(TokenType.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(TokenType.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(TokenType.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(TokenType.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }
  processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      elideImportEquals(this.tokens);
    } else {
      this.tokens.replaceToken("const");
    }
    return true;
  }
  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
  processImport() {
    if (this.tokens.matches2(TokenType._import, TokenType.parenL)) {
      if (this.preserveDynamicImport) {
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(TokenType.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }
    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
  removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {
      this.removeRemainingImport();
      return true;
    }
    if (this.tokens.matches1(TokenType.name) || this.tokens.matches1(TokenType.star)) {
      this.removeRemainingImport();
      return false;
    }
    if (this.tokens.matches1(TokenType.string)) {
      return false;
    }
    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    while (!this.tokens.matches1(TokenType.string)) {
      if (!foundNonTypeImport && this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.comma)) {
        this.tokens.removeToken();
        if (!this.tokens.matches1(TokenType.braceR)) {
          foundAnyNamedImport = true;
        }
        if (this.tokens.matches2(TokenType.name, TokenType.comma) || this.tokens.matches2(TokenType.name, TokenType.braceR) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.comma) || this.tokens.matches4(TokenType.name, TokenType.name, TokenType.name, TokenType.braceR)) {
          foundNonTypeImport = true;
        }
      }
      this.tokens.removeToken();
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }
  removeRemainingImport() {
    while (!this.tokens.matches1(TokenType.string)) {
      this.tokens.removeToken();
    }
  }
  processIdentifier() {
    const token = this.tokens.currentToken();
    if (token.shadowsGlobal) {
      return false;
    }
    if (token.identifierRole === IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }
    if (token.identifierRole !== IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(token)
    );
    if (!replacement) {
      return false;
    }
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenR) {
      possibleOpenParenIndex++;
    }
    if (this.tokens.tokens[possibleOpenParenIndex].type === TokenType.parenL) {
      if (this.tokens.tokenAtRelativeIndex(1).type === TokenType.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._new) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        this.tokens.removeToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
      } else {
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }
  processObjectShorthand() {
    const identifier = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier}: ${replacement}`);
    return true;
  }
  processExport() {
    if (this.tokens.matches2(TokenType._export, TokenType._enum) || this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)) {
      this.hadNamedExport = true;
      return false;
    }
    if (this.tokens.matches2(TokenType._export, TokenType._default)) {
      if (this.tokens.matches3(TokenType._export, TokenType._default, TokenType._enum)) {
        this.hadDefaultExport = true;
        return false;
      }
      this.processExportDefault();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType.braceL)) {
      this.processExportBindings();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(TokenType.braceL)) {
        while (!this.tokens.matches1(TokenType.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        this.tokens.removeToken();
        if (this.tokens.matches1(TokenType._as)) {
          this.tokens.removeToken();
          this.tokens.removeToken();
        }
      }
      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    this.hadNamedExport = true;
    if (this.tokens.matches2(TokenType._export, TokenType._var) || this.tokens.matches2(TokenType._export, TokenType._let) || this.tokens.matches2(TokenType._export, TokenType._const)) {
      this.processExportVar();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType._function) || // export async function
    this.tokens.matches3(TokenType._export, TokenType.name, TokenType._function)) {
      this.processExportFunction();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType._class) || this.tokens.matches3(TokenType._export, TokenType._abstract, TokenType._class) || this.tokens.matches2(TokenType._export, TokenType.at)) {
      this.processExportClass();
      return true;
    } else if (this.tokens.matches2(TokenType._export, TokenType.star)) {
      this.processExportStar();
      return true;
    } else {
      throw new Error("Unrecognized export syntax.");
    }
  }
  processAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.isType || identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, TokenType.dot)) {
      return false;
    }
    if (index >= 2 && [TokenType._var, TokenType._let, TokenType._const].includes(this.tokens.tokens[index - 2].type)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken)
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }
  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
  processComplexAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, TokenType.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken)
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }
  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
  processPreIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index + 2, TokenType.dot) || this.tokens.matches1AtIndex(index + 2, TokenType.bracketL) || this.tokens.matches1AtIndex(index + 2, TokenType.parenL))) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }
  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
  processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, TokenType.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }
  processExportDefault() {
    let exportedRuntimeValue = true;
    if (this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) || // export default async function
    this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      ContextualKeyword._async
    )) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name) || this.tokens.matches3(TokenType._export, TokenType._default, TokenType.at)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(TokenType._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (shouldElideDefaultExport(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    )) {
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
      this.tokens.copyToken();
      this.tokens.appendCode(` = ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
    } else {
      this.tokens.replaceToken("exports.");
      this.tokens.copyToken();
      this.tokens.appendCode(" =");
    }
    if (exportedRuntimeValue) {
      this.hadDefaultExport = true;
    }
  }
  copyDecorators() {
    while (this.tokens.matches1(TokenType.at)) {
      this.tokens.copyToken();
      if (this.tokens.matches1(TokenType.parenL)) {
        this.tokens.copyExpectedToken(TokenType.parenL);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
      } else {
        this.tokens.copyExpectedToken(TokenType.name);
        while (this.tokens.matches1(TokenType.dot)) {
          this.tokens.copyExpectedToken(TokenType.dot);
          this.tokens.copyExpectedToken(TokenType.name);
        }
        if (this.tokens.matches1(TokenType.parenL)) {
          this.tokens.copyExpectedToken(TokenType.parenL);
          this.rootTransformer.processBalancedCode();
          this.tokens.copyExpectedToken(TokenType.parenR);
        }
      }
    }
  }
  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
  processExportVar() {
    if (this.isSimpleExportVar()) {
      this.processSimpleExportVar();
    } else {
      this.processComplexExportVar();
    }
  }
  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
  isSimpleExportVar() {
    let tokenIndex = this.tokens.currentIndex();
    tokenIndex++;
    tokenIndex++;
    if (!this.tokens.matches1AtIndex(tokenIndex, TokenType.name)) {
      return false;
    }
    tokenIndex++;
    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {
      tokenIndex++;
    }
    if (!this.tokens.matches1AtIndex(tokenIndex, TokenType.eq)) {
      return false;
    }
    return true;
  }
  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
  processSimpleExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.copyToken();
    const varName = this.tokens.identifierName();
    while (!this.tokens.matches1(TokenType.eq)) {
      this.rootTransformer.processToken();
    }
    const endIndex = this.tokens.currentToken().rhsEndIndex;
    if (endIndex == null) {
      throw new Error("Expected = token with an end index.");
    }
    while (this.tokens.currentIndex() < endIndex) {
      this.rootTransformer.processToken();
    }
    this.tokens.appendCode(`; exports.${varName} = ${varName}`);
  }
  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
  processComplexExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const needsParens = this.tokens.matches1(TokenType.braceL);
    if (needsParens) {
      this.tokens.appendCode("(");
    }
    let depth = 0;
    while (true) {
      if (this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.dollarBraceL) || this.tokens.matches1(TokenType.bracketL)) {
        depth++;
        this.tokens.copyToken();
      } else if (this.tokens.matches1(TokenType.braceR) || this.tokens.matches1(TokenType.bracketR)) {
        depth--;
        this.tokens.copyToken();
      } else if (depth === 0 && !this.tokens.matches1(TokenType.name) && !this.tokens.currentToken().isType) {
        break;
      } else if (this.tokens.matches1(TokenType.eq)) {
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        while (this.tokens.currentIndex() < endIndex) {
          this.rootTransformer.processToken();
        }
      } else {
        const token = this.tokens.currentToken();
        if (isDeclaration(token)) {
          const name = this.tokens.identifierName();
          let replacement = this.importProcessor.getIdentifierReplacement(name);
          if (replacement === null) {
            throw new Error(`Expected a replacement for ${name} in \`export var\` syntax.`);
          }
          if (isObjectShorthandDeclaration(token)) {
            replacement = `${name}: ${replacement}`;
          }
          this.tokens.replaceToken(replacement);
        } else {
          this.rootTransformer.processToken();
        }
      }
    }
    if (needsParens) {
      const endIndex = this.tokens.currentToken().rhsEndIndex;
      if (endIndex == null) {
        throw new Error("Expected = token with an end index.");
      }
      while (this.tokens.currentIndex() < endIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(")");
    }
  }
  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
  processExportFunction() {
    this.tokens.replaceToken("");
    const name = this.processNamedFunction();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }
  /**
   * Skip past a function with a name and return that name.
   */
  processNamedFunction() {
    if (this.tokens.matches1(TokenType._function)) {
      this.tokens.copyToken();
    } else if (this.tokens.matches2(TokenType.name, TokenType._function)) {
      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {
        throw new Error("Expected async keyword in function export.");
      }
      this.tokens.copyToken();
      this.tokens.copyToken();
    }
    if (this.tokens.matches1(TokenType.star)) {
      this.tokens.copyToken();
    }
    if (!this.tokens.matches1(TokenType.name)) {
      throw new Error("Expected identifier for exported function name.");
    }
    const name = this.tokens.identifierName();
    this.tokens.copyToken();
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
    }
    this.tokens.copyExpectedToken(TokenType.parenL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(TokenType.parenR);
    this.rootTransformer.processPossibleTypeRange();
    this.tokens.copyExpectedToken(TokenType.braceL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(TokenType.braceR);
    return name;
  }
  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
  processExportClass() {
    this.tokens.removeInitialToken();
    this.copyDecorators();
    if (this.tokens.matches1(TokenType._abstract)) {
      this.tokens.removeToken();
    }
    const name = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }
  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
  processExportBindings() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const isReExport = isExportFrom(this.tokens);
    const exportStatements = [];
    while (true) {
      if (this.tokens.matches1(TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      while (this.tokens.currentIndex() < specifierInfo.endIndex) {
        this.tokens.removeToken();
      }
      const shouldRemoveExport = specifierInfo.isType || !isReExport && this.shouldElideExportedIdentifier(specifierInfo.leftName);
      if (!shouldRemoveExport) {
        const exportedName = specifierInfo.rightName;
        if (exportedName === "default") {
          this.hadDefaultExport = true;
        } else {
          this.hadNamedExport = true;
        }
        const localName = specifierInfo.leftName;
        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
      }
      if (this.tokens.matches1(TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(TokenType.comma, TokenType.braceR)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(TokenType.comma)) {
        this.tokens.removeToken();
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
      }
    }
    if (this.tokens.matchesContextual(ContextualKeyword._from)) {
      this.tokens.removeToken();
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      removeMaybeImportAttributes(this.tokens);
    } else {
      this.tokens.appendCode(exportStatements.join(" "));
    }
    if (this.tokens.matches1(TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  processExportStar() {
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(TokenType.string)) {
      this.tokens.removeToken();
    }
    const path = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(TokenType.semi)) {
      this.tokens.removeToken();
    }
  }
  shouldElideExportedIdentifier(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(name);
  }
};

// node_modules/sucrase/dist/esm/transformers/ESMImportTransformer.js
var ESMImportTransformer = class extends Transformer {
  constructor(tokens, nameManager, helperManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, isFlowTransformEnabled, keepUnusedImports, options) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    this.helperManager = helperManager;
    this.reactHotLoaderTransformer = reactHotLoaderTransformer;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.isFlowTransformEnabled = isFlowTransformEnabled;
    this.keepUnusedImports = keepUnusedImports;
    ;
    this.nonTypeIdentifiers = isTypeScriptTransformEnabled && !keepUnusedImports ? getNonTypeIdentifiers(tokens, options) : /* @__PURE__ */ new Set();
    this.declarationInfo = isTypeScriptTransformEnabled && !keepUnusedImports ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }
  process() {
    if (this.tokens.matches3(TokenType._import, TokenType.name, TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches4(TokenType._import, TokenType.name, TokenType.name, TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      for (let i2 = 0; i2 < 7; i2++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches5(TokenType._export, TokenType._import, TokenType.name, TokenType.name, TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      for (let i2 = 0; i2 < 8; i2++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(TokenType._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(TokenType._export, TokenType._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(TokenType._export, TokenType.braceL)) {
      return this.processNamedExports();
    }
    if (this.tokens.matches2(TokenType._export, TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(TokenType.braceL)) {
        while (!this.tokens.matches1(TokenType.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        this.tokens.removeToken();
        if (this.tokens.matches1(TokenType._as)) {
          this.tokens.removeToken();
          this.tokens.removeToken();
        }
      }
      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.string)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }
  processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      this.tokens.replaceToken("const");
      this.tokens.copyToken();
      this.tokens.copyToken();
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      this.tokens.replaceToken("const");
    }
    return true;
  }
  processImport() {
    if (this.tokens.matches2(TokenType._import, TokenType.parenL)) {
      return false;
    }
    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(TokenType.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(TokenType.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }
  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
  removeImportTypeBindings() {
    this.tokens.copyExpectedToken(TokenType._import);
    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {
      return true;
    }
    if (this.tokens.matches1(TokenType.string)) {
      this.tokens.copyToken();
      return false;
    }
    if (this.tokens.matchesContextual(ContextualKeyword._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)) {
      this.tokens.copyToken();
    }
    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;
    if (this.tokens.matches1(TokenType.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(TokenType.comma)) {
          needsComma = true;
          this.tokens.removeToken();
        }
      }
    }
    if (this.tokens.matches1(TokenType.star)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        this.tokens.removeToken();
      } else {
        if (needsComma) {
          this.tokens.appendCode(",");
        }
        foundNonTypeImport = true;
        this.tokens.copyExpectedToken(TokenType.star);
        this.tokens.copyExpectedToken(TokenType.name);
        this.tokens.copyExpectedToken(TokenType.name);
      }
    } else if (this.tokens.matches1(TokenType.braceL)) {
      if (needsComma) {
        this.tokens.appendCode(",");
      }
      this.tokens.copyToken();
      while (!this.tokens.matches1(TokenType.braceR)) {
        foundAnyNamedImport = true;
        const specifierInfo = getImportExportSpecifierInfo(this.tokens);
        if (specifierInfo.isType || this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)) {
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.removeToken();
          }
          if (this.tokens.matches1(TokenType.comma)) {
            this.tokens.removeToken();
          }
        } else {
          foundNonTypeImport = true;
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.copyToken();
          }
          if (this.tokens.matches1(TokenType.comma)) {
            this.tokens.copyToken();
          }
        }
      }
      this.tokens.copyExpectedToken(TokenType.braceR);
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }
  shouldAutomaticallyElideImportedName(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
  }
  processExportDefault() {
    if (shouldElideDefaultExport(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    )) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
      return true;
    }
    const alreadyHasName = this.tokens.matches4(TokenType._export, TokenType._default, TokenType._function, TokenType.name) || // export default async function
    this.tokens.matches5(TokenType._export, TokenType._default, TokenType.name, TokenType._function, TokenType.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      ContextualKeyword._async
    ) || this.tokens.matches4(TokenType._export, TokenType._default, TokenType._class, TokenType.name) || this.tokens.matches5(TokenType._export, TokenType._default, TokenType._abstract, TokenType._class, TokenType.name);
    if (!alreadyHasName && this.reactHotLoaderTransformer) {
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; export`);
      this.tokens.copyToken();
      this.tokens.appendCode(` ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
      return true;
    }
    return false;
  }
  /**
   * Handle a statement with one of these forms:
   * export {a, type b};
   * export {c, type d} from 'foo';
   *
   * In both cases, any explicit type exports should be removed. In the first
   * case, we also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) {
      return false;
    }
    this.tokens.copyExpectedToken(TokenType._export);
    this.tokens.copyExpectedToken(TokenType.braceL);
    const isReExport = isExportFrom(this.tokens);
    let foundNonTypeExport = false;
    while (!this.tokens.matches1(TokenType.braceR)) {
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      if (specifierInfo.isType || !isReExport && this.shouldElideExportedName(specifierInfo.leftName)) {
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.removeToken();
        }
        if (this.tokens.matches1(TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeExport = true;
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.copyToken();
        }
        if (this.tokens.matches1(TokenType.comma)) {
          this.tokens.copyToken();
        }
      }
    }
    this.tokens.copyExpectedToken(TokenType.braceR);
    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {
      this.tokens.removeToken();
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
    }
    return true;
  }
  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
  shouldElideExportedName(name) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);
  }
};

// node_modules/sucrase/dist/esm/transformers/FlowTransformer.js
var FlowTransformer = class extends Transformer {
  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
  }
  process() {
    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
      return true;
    }
    if (this.tokens.matches1(TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType._enum)) {
      this.processNamedExportEnum();
      return true;
    }
    if (this.tokens.matches3(TokenType._export, TokenType._default, TokenType._enum)) {
      this.processDefaultExportEnum();
      return true;
    }
    return false;
  }
  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      this.tokens.removeInitialToken();
      const enumName = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum();
      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);
    } else {
      this.tokens.copyToken();
      this.processEnum();
    }
  }
  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const enumName = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum();
    if (this.isImportsTransformEnabled) {
      this.tokens.appendCode(` exports.default = ${enumName};`);
    } else {
      this.tokens.appendCode(` export default ${enumName};`);
    }
  }
  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    this.tokens.replaceToken("const");
    this.tokens.copyExpectedToken(TokenType.name);
    let isSymbolEnum = false;
    if (this.tokens.matchesContextual(ContextualKeyword._of)) {
      this.tokens.removeToken();
      isSymbolEnum = this.tokens.matchesContextual(ContextualKeyword._symbol);
      this.tokens.removeToken();
    }
    const hasInitializers = this.tokens.matches3(TokenType.braceL, TokenType.name, TokenType.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const isMirrored = !isSymbolEnum && !hasInitializers;
    this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? ".Mirrored([" : "({");
    while (!this.tokens.matches1(TokenType.braceR)) {
      if (this.tokens.matches1(TokenType.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(isSymbolEnum, hasInitializers);
      if (this.tokens.matches1(TokenType.comma)) {
        this.tokens.copyToken();
      }
    }
    this.tokens.replaceToken(isMirrored ? "]);" : "});");
  }
  /**
   * Process an individual enum element, producing either an array element or an
   * object element based on what type of enum this is.
   */
  processEnumElement(isSymbolEnum, hasInitializers) {
    if (isSymbolEnum) {
      const elementName = this.tokens.identifierName();
      this.tokens.copyToken();
      this.tokens.appendCode(`: Symbol("${elementName}")`);
    } else if (hasInitializers) {
      this.tokens.copyToken();
      this.tokens.replaceTokenTrimmingLeftWhitespace(":");
      this.tokens.copyToken();
    } else {
      this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
    }
  }
};

// node_modules/sucrase/dist/esm/transformers/JestHoistTransformer.js
function _optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i2 = 1;
  while (i2 < ops.length) {
    const op = ops[i2];
    const fn = ops[i2 + 1];
    i2 += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
var JEST_GLOBAL_NAME = "jest";
var HOISTED_METHODS = ["mock", "unmock", "enableAutomock", "disableAutomock"];
var JestHoistTransformer = class _JestHoistTransformer extends Transformer {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(rootTransformer, tokens, nameManager, importProcessor) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.nameManager = nameManager;
    this.importProcessor = importProcessor;
    _JestHoistTransformer.prototype.__init.call(this);
    ;
  }
  process() {
    if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(TokenType.name, TokenType.dot, TokenType.name, TokenType.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {
      if (_optionalChain([this, "access", (_) => _.importProcessor, "optionalAccess", (_2) => _2.getGlobalNames, "call", (_3) => _3(), "optionalAccess", (_4) => _4.has, "call", (_5) => _5(JEST_GLOBAL_NAME)])) {
        return false;
      }
      return this.extractHoistedCalls();
    }
    return false;
  }
  getHoistedCode() {
    if (this.hoistedFunctionNames.length > 0) {
      return this.hoistedFunctionNames.map((name) => `${name}();`).join("");
    }
    return "";
  }
  /**
   * Extracts any methods calls on the jest-object that should be hoisted.
   *
   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
   *
   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
   */
  extractHoistedCalls() {
    this.tokens.removeToken();
    let followsNonHoistedJestCall = false;
    while (this.tokens.matches3(TokenType.dot, TokenType.name, TokenType.parenL)) {
      const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      const shouldHoist = HOISTED_METHODS.includes(methodName);
      if (shouldHoist) {
        const hoistedFunctionName = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(hoistedFunctionName);
        this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
        this.tokens.appendCode(";}");
        followsNonHoistedJestCall = false;
      } else {
        if (followsNonHoistedJestCall) {
          this.tokens.copyToken();
        } else {
          this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);
        }
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(TokenType.parenR);
        followsNonHoistedJestCall = true;
      }
    }
    return true;
  }
};

// node_modules/sucrase/dist/esm/transformers/NumericSeparatorTransformer.js
var NumericSeparatorTransformer = class extends Transformer {
  constructor(tokens) {
    super();
    this.tokens = tokens;
    ;
  }
  process() {
    if (this.tokens.matches1(TokenType.num)) {
      const code = this.tokens.currentTokenCode();
      if (code.includes("_")) {
        this.tokens.replaceToken(code.replace(/_/g, ""));
        return true;
      }
    }
    return false;
  }
};

// node_modules/sucrase/dist/esm/transformers/OptionalCatchBindingTransformer.js
var OptionalCatchBindingTransformer = class extends Transformer {
  constructor(tokens, nameManager) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    ;
  }
  process() {
    if (this.tokens.matches2(TokenType._catch, TokenType.braceL)) {
      this.tokens.copyToken();
      this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`);
      return true;
    }
    return false;
  }
};

// node_modules/sucrase/dist/esm/transformers/OptionalChainingNullishTransformer.js
var OptionalChainingNullishTransformer = class extends Transformer {
  constructor(tokens, nameManager) {
    super();
    this.tokens = tokens;
    this.nameManager = nameManager;
    ;
  }
  process() {
    if (this.tokens.matches1(TokenType.nullishCoalescing)) {
      const token2 = this.tokens.currentToken();
      if (this.tokens.tokens[token2.nullishStartIndex].isAsyncOperation) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (");
      } else {
        this.tokens.replaceTokenTrimmingLeftWhitespace(", () => (");
      }
      return true;
    }
    if (this.tokens.matches1(TokenType._delete)) {
      const nextToken2 = this.tokens.tokenAtRelativeIndex(1);
      if (nextToken2.isOptionalChainStart) {
        this.tokens.removeInitialToken();
        return true;
      }
    }
    const token = this.tokens.currentToken();
    const chainStart = token.subscriptStartIndex;
    if (chainStart != null && this.tokens.tokens[chainStart].isOptionalChainStart && // Super subscripts can't be optional (since super is never null/undefined), and the syntax
    // relies on the subscript being intact, so leave this token alone.
    this.tokens.tokenAtRelativeIndex(-1).type !== TokenType._super) {
      const param = this.nameManager.claimFreeName("_");
      let arrowStartSnippet;
      if (chainStart > 0 && this.tokens.matches1AtIndex(chainStart - 1, TokenType._delete) && this.isLastSubscriptInChain()) {
        arrowStartSnippet = `${param} => delete ${param}`;
      } else {
        arrowStartSnippet = `${param} => ${param}`;
      }
      if (this.tokens.tokens[chainStart].isAsyncOperation) {
        arrowStartSnippet = `async ${arrowStartSnippet}`;
      }
      if (this.tokens.matches2(TokenType.questionDot, TokenType.parenL) || this.tokens.matches2(TokenType.questionDot, TokenType.lessThan)) {
        if (this.justSkippedSuper()) {
          this.tokens.appendCode(".bind(this)");
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);
      } else if (this.tokens.matches2(TokenType.questionDot, TokenType.bracketL)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);
      } else if (this.tokens.matches1(TokenType.questionDot)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);
      } else if (this.tokens.matches1(TokenType.dot)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);
      } else if (this.tokens.matches1(TokenType.bracketL)) {
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);
      } else if (this.tokens.matches1(TokenType.parenL)) {
        if (this.justSkippedSuper()) {
          this.tokens.appendCode(".bind(this)");
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);
      } else {
        throw new Error("Unexpected subscript operator in optional chain.");
      }
      return true;
    }
    return false;
  }
  /**
   * Determine if the current token is the last of its chain, so that we know whether it's eligible
   * to have a delete op inserted.
   *
   * We can do this by walking forward until we determine one way or another. Each
   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
   * depth goes negative) and see if any other subscript token is after us in the chain.
   */
  isLastSubscriptInChain() {
    let depth = 0;
    for (let i2 = this.tokens.currentIndex() + 1; ; i2++) {
      if (i2 >= this.tokens.tokens.length) {
        throw new Error("Reached the end of the code while finding the end of the access chain.");
      }
      if (this.tokens.tokens[i2].isOptionalChainStart) {
        depth++;
      } else if (this.tokens.tokens[i2].isOptionalChainEnd) {
        depth--;
      }
      if (depth < 0) {
        return true;
      }
      if (depth === 0 && this.tokens.tokens[i2].subscriptStartIndex != null) {
        return false;
      }
    }
  }
  /**
   * Determine if we are the open-paren in an expression like super.a()?.b.
   *
   * We can do this by walking backward to find the previous subscript. If that subscript was
   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
   * we'll need to attach the right context.
   */
  justSkippedSuper() {
    let depth = 0;
    let index = this.tokens.currentIndex() - 1;
    while (true) {
      if (index < 0) {
        throw new Error(
          "Reached the start of the code while finding the start of the access chain."
        );
      }
      if (this.tokens.tokens[index].isOptionalChainStart) {
        depth--;
      } else if (this.tokens.tokens[index].isOptionalChainEnd) {
        depth++;
      }
      if (depth < 0) {
        return false;
      }
      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {
        return this.tokens.tokens[index - 1].type === TokenType._super;
      }
      index--;
    }
  }
};

// node_modules/sucrase/dist/esm/transformers/ReactDisplayNameTransformer.js
var ReactDisplayNameTransformer = class extends Transformer {
  constructor(rootTransformer, tokens, importProcessor, options) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.importProcessor = importProcessor;
    this.options = options;
    ;
  }
  process() {
    const startIndex = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const newName = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      if (newName) {
        this.tokens.replaceToken(`(0, ${newName})`);
      } else {
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    if (this.tokens.matches3(TokenType.name, TokenType.dot, TokenType.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const newName = this.importProcessor ? this.importProcessor.getIdentifierReplacement("React") || "React" : "React";
      if (newName) {
        this.tokens.replaceToken(newName);
        this.tokens.copyToken();
        this.tokens.copyToken();
      } else {
        this.tokens.copyToken();
        this.tokens.copyToken();
        this.tokens.copyToken();
      }
      this.tryProcessCreateClassCall(startIndex);
      return true;
    }
    return false;
  }
  /**
   * This is called with the token position at the open-paren.
   */
  tryProcessCreateClassCall(startIndex) {
    const displayName = this.findDisplayName(startIndex);
    if (!displayName) {
      return;
    }
    if (this.classNeedsDisplayName()) {
      this.tokens.copyExpectedToken(TokenType.parenL);
      this.tokens.copyExpectedToken(TokenType.braceL);
      this.tokens.appendCode(`displayName: '${displayName}',`);
      this.rootTransformer.processBalancedCode();
      this.tokens.copyExpectedToken(TokenType.braceR);
      this.tokens.copyExpectedToken(TokenType.parenR);
    }
  }
  findDisplayName(startIndex) {
    if (startIndex < 2) {
      return null;
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, TokenType.name, TokenType.eq)) {
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (startIndex >= 2 && this.tokens.tokens[startIndex - 2].identifierRole === IdentifierRole.ObjectKey) {
      return this.tokens.identifierNameAtIndex(startIndex - 2);
    }
    if (this.tokens.matches2AtIndex(startIndex - 2, TokenType._export, TokenType._default)) {
      return this.getDisplayNameFromFilename();
    }
    return null;
  }
  getDisplayNameFromFilename() {
    const filePath = this.options.filePath || "unknown";
    const pathSegments = filePath.split("/");
    const filename = pathSegments[pathSegments.length - 1];
    const dotIndex = filename.lastIndexOf(".");
    const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);
    if (baseFilename === "index" && pathSegments[pathSegments.length - 2]) {
      return pathSegments[pathSegments.length - 2];
    } else {
      return baseFilename;
    }
  }
  /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */
  classNeedsDisplayName() {
    let index = this.tokens.currentIndex();
    if (!this.tokens.matches2(TokenType.parenL, TokenType.braceL)) {
      return false;
    }
    const objectStartIndex = index + 1;
    const objectContextId = this.tokens.tokens[objectStartIndex].contextId;
    if (objectContextId == null) {
      throw new Error("Expected non-null context ID on object open-brace.");
    }
    for (; index < this.tokens.tokens.length; index++) {
      const token = this.tokens.tokens[index];
      if (token.type === TokenType.braceR && token.contextId === objectContextId) {
        index++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(index) === "displayName" && this.tokens.tokens[index].identifierRole === IdentifierRole.ObjectKey && token.contextId === objectContextId) {
        return false;
      }
    }
    if (index === this.tokens.tokens.length) {
      throw new Error("Unexpected end of input when processing React class.");
    }
    return this.tokens.matches1AtIndex(index, TokenType.parenR) || this.tokens.matches2AtIndex(index, TokenType.comma, TokenType.parenR);
  }
};

// node_modules/sucrase/dist/esm/transformers/ReactHotLoaderTransformer.js
var ReactHotLoaderTransformer = class _ReactHotLoaderTransformer extends Transformer {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(tokens, filePath) {
    super();
    this.tokens = tokens;
    this.filePath = filePath;
    _ReactHotLoaderTransformer.prototype.__init.call(this);
    ;
  }
  setExtractedDefaultExportName(extractedDefaultExportName) {
    this.extractedDefaultExportName = extractedDefaultExportName;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const topLevelNames = /* @__PURE__ */ new Set();
    for (const token of this.tokens.tokens) {
      if (!token.isType && isTopLevelDeclaration(token) && token.identifierRole !== IdentifierRole.ImportDeclaration) {
        topLevelNames.add(this.tokens.identifierNameForToken(token));
      }
    }
    const namesToRegister = Array.from(topLevelNames).map((name) => ({
      variableName: name,
      uniqueLocalName: name
    }));
    if (this.extractedDefaultExportName) {
      namesToRegister.push({
        variableName: this.extractedDefaultExportName,
        uniqueLocalName: "default"
      });
    }
    return `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${namesToRegister.map(
      ({ variableName, uniqueLocalName }) => `  reactHotLoader.register(${variableName}, "${uniqueLocalName}", ${JSON.stringify(
        this.filePath || ""
      )});`
    ).join("\n")}
  leaveModule(module);
})();`;
  }
  process() {
    return false;
  }
};

// node_modules/sucrase/dist/esm/util/isIdentifier.js
var RESERVED_WORDS = /* @__PURE__ */ new Set([
  // Reserved keywords as of ECMAScript 2015
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  // Future reserved keywords
  "enum",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "await",
  // Literals that cannot be used as identifiers
  "false",
  "null",
  "true"
]);
function isIdentifier(name) {
  if (name.length === 0) {
    return false;
  }
  if (!IS_IDENTIFIER_START[name.charCodeAt(0)]) {
    return false;
  }
  for (let i2 = 1; i2 < name.length; i2++) {
    if (!IS_IDENTIFIER_CHAR[name.charCodeAt(i2)]) {
      return false;
    }
  }
  return !RESERVED_WORDS.has(name);
}

// node_modules/sucrase/dist/esm/transformers/TypeScriptTransformer.js
var TypeScriptTransformer = class extends Transformer {
  constructor(rootTransformer, tokens, isImportsTransformEnabled) {
    super();
    this.rootTransformer = rootTransformer;
    this.tokens = tokens;
    this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
  }
  process() {
    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
      return true;
    }
    if (this.tokens.matches1(TokenType._public) || this.tokens.matches1(TokenType._protected) || this.tokens.matches1(TokenType._private) || this.tokens.matches1(TokenType._abstract) || this.tokens.matches1(TokenType._readonly) || this.tokens.matches1(TokenType._override) || this.tokens.matches1(TokenType.nonNullAssertion)) {
      this.tokens.removeInitialToken();
      return true;
    }
    if (this.tokens.matches1(TokenType._enum) || this.tokens.matches2(TokenType._const, TokenType._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(TokenType._export, TokenType._enum) || this.tokens.matches3(TokenType._export, TokenType._const, TokenType._enum)) {
      this.processEnum(true);
      return true;
    }
    return false;
  }
  processEnum(isExport = false) {
    this.tokens.removeInitialToken();
    while (this.tokens.matches1(TokenType._const) || this.tokens.matches1(TokenType._enum)) {
      this.tokens.removeToken();
    }
    const enumName = this.tokens.identifierName();
    this.tokens.removeToken();
    if (isExport && !this.isImportsTransformEnabled) {
      this.tokens.appendCode("export ");
    }
    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);
    this.tokens.copyExpectedToken(TokenType.braceL);
    this.processEnumBody(enumName);
    this.tokens.copyExpectedToken(TokenType.braceR);
    if (isExport && this.isImportsTransformEnabled) {
      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);
    } else {
      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
    }
  }
  /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */
  processEnumBody(enumName) {
    let previousValueCode = null;
    while (true) {
      if (this.tokens.matches1(TokenType.braceR)) {
        break;
      }
      const { nameStringCode, variableName } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken();
      if (this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.comma) || this.tokens.matches3(TokenType.eq, TokenType.string, TokenType.braceR)) {
        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);
      } else if (this.tokens.matches1(TokenType.eq)) {
        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);
      } else {
        this.processImplicitValueEnumMember(
          enumName,
          nameStringCode,
          variableName,
          previousValueCode
        );
      }
      if (this.tokens.matches1(TokenType.comma)) {
        this.tokens.removeToken();
      }
      if (variableName != null) {
        previousValueCode = variableName;
      } else {
        previousValueCode = `${enumName}[${nameStringCode}]`;
      }
    }
  }
  /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */
  extractEnumKeyInfo(nameToken) {
    if (nameToken.type === TokenType.name) {
      const name = this.tokens.identifierNameForToken(nameToken);
      return {
        nameStringCode: `"${name}"`,
        variableName: isIdentifier(name) ? name : null
      };
    } else if (nameToken.type === TokenType.string) {
      const name = this.tokens.stringValueForToken(nameToken);
      return {
        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),
        variableName: isIdentifier(name) ? name : null
      };
    } else {
      throw new Error("Expected name or string at beginning of enum element.");
    }
  }
  /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */
  processStringLiteralEnumMember(enumName, nameStringCode, variableName) {
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      this.tokens.copyToken();
      this.tokens.copyToken();
      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);
    } else {
      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);
      this.tokens.copyToken();
      this.tokens.copyToken();
      this.tokens.appendCode(";");
    }
  }
  /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
   * auto-incrementing.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = 1 + 1
   * ->
   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
   *
   * Example 2:
   * "some key" = 1 + 1
   * ->
   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
   */
  processExplicitValueEnumMember(enumName, nameStringCode, variableName) {
    const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;
    if (rhsEndIndex == null) {
      throw new Error("Expected rhsEndIndex on enum assign.");
    }
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName}`);
      this.tokens.copyToken();
      while (this.tokens.currentIndex() < rhsEndIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(
        `; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`
      );
    } else {
      this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);
      this.tokens.copyToken();
      while (this.tokens.currentIndex() < rhsEndIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(`] = ${nameStringCode};`);
    }
  }
  /**
   * Handle an enum member with no right-hand side expression. In this case, the value is the
   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
   * reverse mapping.
   *
   * Example 1:
   * someKey2
   * ->
   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
   *
   * Example 2:
   * "some key 2"
   * ->
   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
   */
  processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode) {
    let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : "0";
    if (variableName != null) {
      this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);
      valueCode = variableName;
    }
    this.tokens.appendCode(
      `${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`
    );
  }
};

// node_modules/sucrase/dist/esm/transformers/RootTransformer.js
var RootTransformer = class _RootTransformer {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options) {
    ;
    _RootTransformer.prototype.__init.call(this);
    _RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const { tokenProcessor, importProcessor } = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);
    if (!options.disableESTransforms) {
      this.transformers.push(
        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager)
      );
      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));
      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));
    }
    if (transforms.includes("jsx")) {
      if (options.jsxRuntime !== "preserve") {
        this.transformers.push(
          new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options)
        );
      }
      this.transformers.push(
        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options)
      );
    }
    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(
        new CJSImportTransformer(
          this,
          tokenProcessor,
          importProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          enableLegacyBabel5ModuleInterop,
          Boolean(options.enableLegacyTypeScriptModuleInterop),
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.preserveDynamicImport),
          Boolean(options.keepUnusedImports)
        )
      );
    } else {
      this.transformers.push(
        new ESMImportTransformer(
          tokenProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.keepUnusedImports),
          options
        )
      );
    }
    if (transforms.includes("flow")) {
      this.transformers.push(
        new FlowTransformer(this, tokenProcessor, transforms.includes("imports"))
      );
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(
        new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports"))
      );
    }
    if (transforms.includes("jest")) {
      this.transformers.push(
        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor)
      );
    }
  }
  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    let prefix = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix += transformer.getPrefixCode();
    }
    prefix += this.helperManager.emitHelpers();
    prefix += this.generatedVariables.map((v2) => ` var ${v2};`).join("");
    for (const transformer of this.transformers) {
      prefix += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    const result2 = this.tokens.finish();
    let { code } = result2;
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return {
        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(result2.mappings, prefix.length)
      };
    } else {
      return {
        code: prefix + code + suffix,
        mappings: this.shiftMappings(result2.mappings, prefix.length)
      };
    }
  }
  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(TokenType.braceL) || this.tokens.matches1(TokenType.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(TokenType.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(TokenType.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(TokenType._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }
  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(TokenType._class, TokenType.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }
  processClass() {
    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);
    const needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }
    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context ID.");
    }
    this.tokens.copyExpectedToken(TokenType._class);
    while (!this.tokens.matchesContextIdAndLabel(TokenType.braceL, contextId)) {
      this.processToken();
    }
    this.processClassBody(classInfo, className);
    const staticInitializerStatements = classInfo.staticInitializerNames.map(
      (name) => `${className}.${name}()`
    );
    if (needsCommaExpression) {
      this.tokens.appendCode(
        `, ${staticInitializerStatements.map((s) => `${s}, `).join("")}${className})`
      );
    } else if (classInfo.staticInitializerNames.length > 0) {
      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(" ")}`);
    }
  }
  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(classInfo, className) {
    const {
      headerInfo,
      constructorInsertPos,
      constructorInitializerStatements,
      fields,
      instanceInitializerNames,
      rangesToRemove
    } = classInfo;
    let fieldIndex = 0;
    let rangeToRemoveIndex = 0;
    const classContextId = this.tokens.currentToken().contextId;
    if (classContextId == null) {
      throw new Error("Expected non-null context ID on class.");
    }
    this.tokens.copyExpectedToken(TokenType.braceL);
    if (this.isReactHotLoaderTransformEnabled) {
      this.tokens.appendCode(
        "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}"
      );
    }
    const needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;
    if (constructorInsertPos === null && needsConstructorInit) {
      const constructorInitializersCode = this.makeConstructorInitCode(
        constructorInitializerStatements,
        instanceInitializerNames,
        className
      );
      if (headerInfo.hasSuperclass) {
        const argsName = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`
        );
      } else {
        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
      }
    }
    while (!this.tokens.matchesContextIdAndLabel(TokenType.braceR, classContextId)) {
      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
        let needsCloseBrace = false;
        if (this.tokens.matches1(TokenType.bracketL)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);
        } else if (this.tokens.matches1(TokenType.string) || this.tokens.matches1(TokenType.num)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);
          needsCloseBrace = true;
        } else {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);
        }
        while (this.tokens.currentIndex() < fields[fieldIndex].end) {
          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {
            this.tokens.appendCode("]");
          }
          this.processToken();
        }
        this.tokens.appendCode("}");
        fieldIndex++;
      } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {
        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeInitialToken();
        }
        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeToken();
        }
        rangeToRemoveIndex++;
      } else if (this.tokens.currentIndex() === constructorInsertPos) {
        this.tokens.copyToken();
        if (needsConstructorInit) {
          this.tokens.appendCode(
            `;${this.makeConstructorInitCode(
              constructorInitializerStatements,
              instanceInitializerNames,
              className
            )};`
          );
        }
        this.processToken();
      } else {
        this.processToken();
      }
    }
    this.tokens.copyExpectedToken(TokenType.braceR);
  }
  makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {
    return [
      ...constructorInitializerStatements,
      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`)
    ].join(";");
  }
  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(TokenType.parenR, TokenType.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let nextNonTypeIndex = this.tokens.currentIndex() + 1;
      while (this.tokens.tokens[nextNonTypeIndex].isType) {
        nextNonTypeIndex++;
      }
      if (this.tokens.matches1AtIndex(nextNonTypeIndex, TokenType.arrow)) {
        this.tokens.removeInitialToken();
        while (this.tokens.currentIndex() < nextNonTypeIndex) {
          this.tokens.removeToken();
        }
        this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
        return true;
      }
    }
    return false;
  }
  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual(ContextualKeyword._async) && !this.tokens.matches1(TokenType._async)) {
      return false;
    }
    const nextToken2 = this.tokens.tokenAtRelativeIndex(1);
    if (nextToken2.type !== TokenType.lessThan || !nextToken2.isType) {
      return false;
    }
    let nextNonTypeIndex = this.tokens.currentIndex() + 1;
    while (this.tokens.tokens[nextNonTypeIndex].isType) {
      nextNonTypeIndex++;
    }
    if (this.tokens.matches1AtIndex(nextNonTypeIndex, TokenType.parenL)) {
      this.tokens.replaceToken("async (");
      this.tokens.removeInitialToken();
      while (this.tokens.currentIndex() < nextNonTypeIndex) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      this.processBalancedCode();
      this.processToken();
      return true;
    }
    return false;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
      return true;
    }
    return false;
  }
  shiftMappings(mappings, prefixLength) {
    for (let i2 = 0; i2 < mappings.length; i2++) {
      const mapping = mappings[i2];
      if (mapping !== void 0) {
        mappings[i2] = mapping + prefixLength;
      }
    }
    return mappings;
  }
};

// node_modules/sucrase/dist/esm/util/formatTokens.js
var import_lines_and_columns = __toESM(require_build());

// node_modules/sucrase/dist/esm/util/getTSImportedNames.js
function getTSImportedNames(tokens) {
  const importedNames = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < tokens.tokens.length; i2++) {
    if (tokens.matches1AtIndex(i2, TokenType._import) && !tokens.matches3AtIndex(i2, TokenType._import, TokenType.name, TokenType.eq)) {
      collectNamesForImport(tokens, i2, importedNames);
    }
  }
  return importedNames;
}
function collectNamesForImport(tokens, index, importedNames) {
  index++;
  if (tokens.matches1AtIndex(index, TokenType.parenL)) {
    return;
  }
  if (tokens.matches1AtIndex(index, TokenType.name)) {
    importedNames.add(tokens.identifierNameAtIndex(index));
    index++;
    if (tokens.matches1AtIndex(index, TokenType.comma)) {
      index++;
    }
  }
  if (tokens.matches1AtIndex(index, TokenType.star)) {
    index += 2;
    importedNames.add(tokens.identifierNameAtIndex(index));
    index++;
  }
  if (tokens.matches1AtIndex(index, TokenType.braceL)) {
    index++;
    collectNamesForNamedImport(tokens, index, importedNames);
  }
}
function collectNamesForNamedImport(tokens, index, importedNames) {
  while (true) {
    if (tokens.matches1AtIndex(index, TokenType.braceR)) {
      return;
    }
    const specifierInfo = getImportExportSpecifierInfo(tokens, index);
    index = specifierInfo.endIndex;
    if (!specifierInfo.isType) {
      importedNames.add(specifierInfo.rightName);
    }
    if (tokens.matches2AtIndex(index, TokenType.comma, TokenType.braceR)) {
      return;
    } else if (tokens.matches1AtIndex(index, TokenType.braceR)) {
      return;
    } else if (tokens.matches1AtIndex(index, TokenType.comma)) {
      index++;
    } else {
      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);
    }
  }
}

// node_modules/sucrase/dist/esm/index.js
function transform2(code, options) {
  validateOptions(options);
  try {
    const sucraseContext = getSucraseContext(code, options);
    const transformer = new RootTransformer(
      sucraseContext,
      options.transforms,
      Boolean(options.enableLegacyBabel5ModuleInterop),
      options
    );
    const transformerResult = transformer.transform();
    let result2 = { code: transformerResult.code };
    if (options.sourceMapOptions) {
      if (!options.filePath) {
        throw new Error("filePath must be specified when generating a source map.");
      }
      result2 = {
        ...result2,
        sourceMap: computeSourceMap(
          transformerResult,
          options.filePath,
          options.sourceMapOptions,
          code,
          sucraseContext.tokenProcessor.tokens
        )
      };
    }
    return result2;
  } catch (e) {
    if (options.filePath) {
      e.message = `Error transforming ${options.filePath}: ${e.message}`;
    }
    throw e;
  }
}
function getSucraseContext(code, options) {
  const isJSXEnabled2 = options.transforms.includes("jsx");
  const isTypeScriptEnabled2 = options.transforms.includes("typescript");
  const isFlowEnabled2 = options.transforms.includes("flow");
  const disableESTransforms = options.disableESTransforms === true;
  const file = parse(code, isJSXEnabled2, isTypeScriptEnabled2, isFlowEnabled2);
  const tokens = file.tokens;
  const scopes = file.scopes;
  const nameManager = new NameManager(code, tokens);
  const helperManager = new HelperManager(nameManager);
  const tokenProcessor = new TokenProcessor(
    code,
    tokens,
    isFlowEnabled2,
    disableESTransforms,
    helperManager
  );
  const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);
  let importProcessor = null;
  if (options.transforms.includes("imports")) {
    importProcessor = new CJSImportProcessor(
      nameManager,
      tokenProcessor,
      enableLegacyTypeScriptModuleInterop,
      options,
      options.transforms.includes("typescript"),
      Boolean(options.keepUnusedImports),
      helperManager
    );
    importProcessor.preprocessTokens();
    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());
    if (options.transforms.includes("typescript") && !options.keepUnusedImports) {
      importProcessor.pruneTypeOnlyImports();
    }
  } else if (options.transforms.includes("typescript") && !options.keepUnusedImports) {
    identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));
  }
  return { tokenProcessor, scopes, nameManager, importProcessor, helperManager };
}

// node_modules/@aliemir/react-live/dist/react-live.es.js
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LiveContext = (0, import_react2.createContext)({});
var LiveContext$1 = LiveContext;
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var opts = {
  transforms: ["typescript", "jsx", "imports"]
};
var transform3 = function(code, options) {
  if (options === void 0) {
    options = {};
  }
  return transform2(code, _objectSpread$2(_objectSpread$2({}, opts), options)).code;
};
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var errorBoundary = function errorBoundary2(Element, errorCallback) {
  return function(_Component) {
    _inheritsLoose(ErrorBoundary, _Component);
    function ErrorBoundary() {
      return _Component.apply(this, arguments) || this;
    }
    var _proto = ErrorBoundary.prototype;
    _proto.componentDidCatch = function componentDidCatch(error) {
      errorCallback(error);
    };
    _proto.render = function render() {
      return typeof Element === "function" ? import_react2.default.createElement(Element, null) : import_react2.default.isValidElement(Element) ? Element : null;
    };
    return ErrorBoundary;
  }(import_react2.Component);
};
var errorBoundary$1 = errorBoundary;
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
var evalCode = function evalCode2(code, scope) {
  var scopeKeys = Object.keys(scope);
  var scopeValues = scopeKeys.map(function(key) {
    return scope[key];
  });
  return _construct(Function, scopeKeys.concat([code])).apply(void 0, scopeValues);
};
var evalCode$1 = evalCode;
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var generateElement = function generateElement2(_ref, errorCallback) {
  var _ref$code = _ref.code, code = _ref$code === void 0 ? "" : _ref$code, _ref$scope = _ref.scope, scope = _ref$scope === void 0 ? {} : _ref$scope, _ref$opts = _ref.opts, opts2 = _ref$opts === void 0 ? {} : _ref$opts;
  var codeTrimmed = code.trim().replace(/;$/, "");
  var transformed = transform3("return (" + codeTrimmed + ")", opts2).trim();
  return errorBoundary$1(evalCode$1(transformed, _objectSpread$1({
    React: import_react2.default
  }, scope)), errorCallback);
};
var renderElementAsync = function renderElementAsync2(_ref2, resultCallback, errorCallback) {
  var _ref2$code = _ref2.code, code = _ref2$code === void 0 ? "" : _ref2$code, _ref2$scope = _ref2.scope, scope = _ref2$scope === void 0 ? {} : _ref2$scope, _ref2$opts = _ref2.opts, opts2 = _ref2$opts === void 0 ? {} : _ref2$opts;
  var render = function render2(element) {
    if (typeof element === "undefined") {
      errorCallback(new SyntaxError("`render` must be called with valid JSX."));
    } else {
      resultCallback(errorBoundary$1(element, errorCallback));
    }
  };
  if (!/render\s*\(/.test(code)) {
    return errorCallback(new SyntaxError("No-Inline evaluations must call `render`."));
  }
  evalCode$1(transform3(code, opts2), _objectSpread$1(_objectSpread$1({
    React: import_react2.default
  }, scope), {}, {
    render
  }));
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function LiveProvider(_ref) {
  var _ref$Context = _ref.Context, Context = _ref$Context === void 0 ? LiveContext$1 : _ref$Context, children = _ref.children, code = _ref.code, language = _ref.language, theme3 = _ref.theme, disabled = _ref.disabled, scope = _ref.scope, transformOptions = _ref.transformOptions, transformCode = _ref.transformCode, _ref$noInline = _ref.noInline, noInline = _ref$noInline === void 0 ? false : _ref$noInline;
  var _useState = (0, import_react2.useState)({
    error: void 0,
    element: void 0
  }), state2 = _useState[0], setState = _useState[1];
  function transpileAsync(newCode) {
    var errorCallback = function errorCallback2(error) {
      setState({
        error: error.toString(),
        element: void 0
      });
    };
    try {
      var transformResult = transformCode ? transformCode(newCode) : newCode;
      return Promise.resolve(transformResult).then(function(transformedCode) {
        var renderElement = function renderElement2(element) {
          return setState({
            error: void 0,
            element
          });
        };
        var input2 = {
          code: transformedCode,
          scope,
          opts: transformOptions
        };
        if (noInline) {
          setState({
            error: void 0,
            element: null
          });
          renderElementAsync(input2, renderElement, errorCallback);
        } else {
          renderElement(generateElement(input2, errorCallback));
        }
      })["catch"](errorCallback);
    } catch (e) {
      errorCallback(e);
      return Promise.resolve();
    }
  }
  var onError = function onError2(error) {
    return setState({
      error: error.toString()
    });
  };
  (0, import_react2.useEffect)(function() {
    transpileAsync(code)["catch"](onError);
  }, [code, scope, noInline, transformCode]);
  var onChange = function onChange2(newCode) {
    transpileAsync(newCode)["catch"](onError);
  };
  return import_react2.default.createElement(Context.Provider, {
    value: _objectSpread(_objectSpread({}, state2), {}, {
      code,
      language,
      theme: theme3,
      disabled,
      onError,
      onChange
    })
  }, children);
}
LiveProvider.defaultProps = {
  code: "",
  noInline: false,
  language: "jsx",
  disabled: false
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["Component", "Context"];
function LivePreview(_ref) {
  var Component3 = _ref.Component, _ref$Context = _ref.Context, Context = _ref$Context === void 0 ? LiveContext$1 : _ref$Context, rest2 = _objectWithoutPropertiesLoose(_ref, _excluded);
  var _useContext = (0, import_react2.useContext)(Context), Element = _useContext.element;
  return import_react2.default.createElement(Component3, rest2, Element ? import_react2.default.createElement(Element, null) : null);
}
LivePreview.defaultProps = {
  Component: "div"
};

// node_modules/@refinedev/inferencer/dist/esm/chakra-ui.js
var import_react9 = __toESM(require_react());

// node_modules/prism-react-renderer/themes/vsDark/index.js
var theme2 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [{
    types: ["prolog"],
    style: {
      color: "rgb(0, 0, 128)"
    }
  }, {
    types: ["comment"],
    style: {
      color: "rgb(106, 153, 85)"
    }
  }, {
    types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
    style: {
      color: "rgb(86, 156, 214)"
    }
  }, {
    types: ["number", "inserted"],
    style: {
      color: "rgb(181, 206, 168)"
    }
  }, {
    types: ["constant"],
    style: {
      color: "rgb(100, 102, 149)"
    }
  }, {
    types: ["attr-name", "variable"],
    style: {
      color: "rgb(156, 220, 254)"
    }
  }, {
    types: ["deleted", "string", "attr-value", "template-punctuation"],
    style: {
      color: "rgb(206, 145, 120)"
    }
  }, {
    types: ["selector"],
    style: {
      color: "rgb(215, 186, 125)"
    }
  }, {
    // Fix tag color
    types: ["tag"],
    style: {
      color: "rgb(78, 201, 176)"
    }
  }, {
    // Fix tag color for HTML
    types: ["tag"],
    languages: ["markup"],
    style: {
      color: "rgb(86, 156, 214)"
    }
  }, {
    types: ["punctuation", "operator"],
    style: {
      color: "rgb(212, 212, 212)"
    }
  }, {
    // Fix punctuation color for HTML
    types: ["punctuation"],
    languages: ["markup"],
    style: {
      color: "#808080"
    }
  }, {
    types: ["function"],
    style: {
      color: "rgb(220, 220, 170)"
    }
  }, {
    types: ["class-name"],
    style: {
      color: "rgb(78, 201, 176)"
    }
  }, {
    types: ["char"],
    style: {
      color: "rgb(209, 105, 105)"
    }
  }]
};
var vsDark_default = theme2;

// node_modules/@refinedev/inferencer/dist/esm/chakra-ui.js
var import_react10 = __toESM(require_react());
var import_react11 = __toESM(require_react());

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  return +value;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString_default(value);
        other = baseToString_default(other);
      } else {
        value = baseToNumber_default(value);
        other = baseToNumber_default(other);
      }
      result2 = operator(value, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n2, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n2 = toInteger_default(n2);
  return function() {
    if (--n2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default : function(func, data) {
  metaMap_default.set(func, data);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array2, placeholder) {
  var length = array2.length, result2 = 0;
  while (length--) {
    if (array2[length] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array2 = realNames_default[result2], length = hasOwnProperty.call(realNames_default, result2) ? array2.length : 0;
  while (length--) {
    var data = array2[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array2) {
  var index = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index < length) {
    array2[index] = source[index];
  }
  return array2;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto2 = Object.prototype;
var hasOwnProperty2 = objectProto2.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty2.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func === data[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array2, iteratee2) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (iteratee2(array2[index], index, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array2, indexes) {
  var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array2);
  while (length--) {
    var index = indexes[length];
    array2[length] = isIndex_default(index, arrLength) ? oldArray[index] : void 0;
  }
  return array2;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array2, placeholder) {
  var index = -1, length = array2.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array2[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array2[index] = PLACEHOLDER;
      result2[resIndex++] = index;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length, placeholder = getHolder_default(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length
      );
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders_default(data[3], PLACEHOLDER2) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders_default(data[5], PLACEHOLDER2) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data) {
    mergeData_default(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n2, guard) {
  n2 = guard ? void 0 : n2;
  n2 = func && n2 == null ? func.length : n2;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n2);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/_assignValue.js
var objectProto3 = Object.prototype;
var hasOwnProperty3 = objectProto3.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/assign.js
var objectProto4 = Object.prototype;
var hasOwnProperty4 = objectProto4.hasOwnProperty;
var assign = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty4.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto5 = Object.prototype;
var hasOwnProperty5 = objectProto5.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty5.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index = -1, length = paths.length, result2 = Array(length), skip = object == null;
  while (++index < length) {
    result2[index] = skip ? void 0 : get_default(object, paths[index]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/flatten.js
function flatten(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseFlatten_default(array2, 1) : [];
}
var flatten_default = flatten;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto6 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty6 = objectProto6.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function before(n2, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  n2 = toInteger_default(n2);
  return function() {
    if (--n2 > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n2 <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_castSlice.js
function castSlice(array2, start, end) {
  var length = array2.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array2 : baseSlice_default(array2, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array2, iteratee2, accumulator, initAccum) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  if (initAccum && length) {
    accumulator = array2[++index];
  }
  while (++index < length) {
    accumulator = iteratee2(accumulator, array2[index], index, array2);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã": "A",
  "Ã ": "a",
  "Ã¡": "a",
  "Ã¢": "a",
  "Ã£": "a",
  "Ã¤": "a",
  "Ã¥": "a",
  "Ã": "C",
  "Ã§": "c",
  "Ã": "D",
  "Ã°": "d",
  "Ã": "E",
  "Ã": "E",
  "Ã": "E",
  "Ã": "E",
  "Ã¨": "e",
  "Ã©": "e",
  "Ãª": "e",
  "Ã«": "e",
  "Ã": "I",
  "Ã": "I",
  "Ã": "I",
  "Ã": "I",
  "Ã¬": "i",
  "Ã­": "i",
  "Ã®": "i",
  "Ã¯": "i",
  "Ã": "N",
  "Ã±": "n",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã": "O",
  "Ã²": "o",
  "Ã³": "o",
  "Ã´": "o",
  "Ãµ": "o",
  "Ã¶": "o",
  "Ã¸": "o",
  "Ã": "U",
  "Ã": "U",
  "Ã": "U",
  "Ã": "U",
  "Ã¹": "u",
  "Ãº": "u",
  "Ã»": "u",
  "Ã¼": "u",
  "Ã": "Y",
  "Ã½": "y",
  "Ã¿": "y",
  "Ã": "Ae",
  "Ã¦": "ae",
  "Ã": "Th",
  "Ã¾": "th",
  "Ã": "ss",
  // Latin Extended-A block.
  "Ä": "A",
  "Ä": "A",
  "Ä": "A",
  "Ä": "a",
  "Ä": "a",
  "Ä": "a",
  "Ä": "C",
  "Ä": "C",
  "Ä": "C",
  "Ä": "C",
  "Ä": "c",
  "Ä": "c",
  "Ä": "c",
  "Ä": "c",
  "Ä": "D",
  "Ä": "D",
  "Ä": "d",
  "Ä": "d",
  "Ä": "E",
  "Ä": "E",
  "Ä": "E",
  "Ä": "E",
  "Ä": "E",
  "Ä": "e",
  "Ä": "e",
  "Ä": "e",
  "Ä": "e",
  "Ä": "e",
  "Ä": "G",
  "Ä": "G",
  "Ä ": "G",
  "Ä¢": "G",
  "Ä": "g",
  "Ä": "g",
  "Ä¡": "g",
  "Ä£": "g",
  "Ä¤": "H",
  "Ä¦": "H",
  "Ä¥": "h",
  "Ä§": "h",
  "Ä¨": "I",
  "Äª": "I",
  "Ä¬": "I",
  "Ä®": "I",
  "Ä°": "I",
  "Ä©": "i",
  "Ä«": "i",
  "Ä­": "i",
  "Ä¯": "i",
  "Ä±": "i",
  "Ä´": "J",
  "Äµ": "j",
  "Ä¶": "K",
  "Ä·": "k",
  "Ä¸": "k",
  "Ä¹": "L",
  "Ä»": "L",
  "Ä½": "L",
  "Ä¿": "L",
  "Å": "L",
  "Äº": "l",
  "Ä¼": "l",
  "Ä¾": "l",
  "Å": "l",
  "Å": "l",
  "Å": "N",
  "Å": "N",
  "Å": "N",
  "Å": "N",
  "Å": "n",
  "Å": "n",
  "Å": "n",
  "Å": "n",
  "Å": "O",
  "Å": "O",
  "Å": "O",
  "Å": "o",
  "Å": "o",
  "Å": "o",
  "Å": "R",
  "Å": "R",
  "Å": "R",
  "Å": "r",
  "Å": "r",
  "Å": "r",
  "Å": "S",
  "Å": "S",
  "Å": "S",
  "Å ": "S",
  "Å": "s",
  "Å": "s",
  "Å": "s",
  "Å¡": "s",
  "Å¢": "T",
  "Å¤": "T",
  "Å¦": "T",
  "Å£": "t",
  "Å¥": "t",
  "Å§": "t",
  "Å¨": "U",
  "Åª": "U",
  "Å¬": "U",
  "Å®": "U",
  "Å°": "U",
  "Å²": "U",
  "Å©": "u",
  "Å«": "u",
  "Å­": "u",
  "Å¯": "u",
  "Å±": "u",
  "Å³": "u",
  "Å´": "W",
  "Åµ": "w",
  "Å¶": "Y",
  "Å·": "y",
  "Å¸": "Y",
  "Å¹": "Z",
  "Å»": "Z",
  "Å½": "Z",
  "Åº": "z",
  "Å¼": "z",
  "Å¾": "z",
  "Ä²": "IJ",
  "Ä³": "ij",
  "Å": "Oe",
  "Å": "oe",
  "Å": "'n",
  "Å¿": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "['â]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "['â]";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index) {
  word = word.toLowerCase();
  return result2 + (index ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber_default(number);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString_default(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil = createRound_default("ceil");
var ceil_default = ceil;

// node_modules/lodash-es/chain.js
function chain(value) {
  var result2 = wrapperLodash_default(value);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number), lower, upper);
}
var clamp_default = clamp;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_initCloneArray.js
var objectProto7 = Object.prototype;
var hasOwnProperty7 = objectProto7.hasOwnProperty;
function initCloneArray(array2) {
  var length = array2.length, result2 = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty7.call(array2, "index")) {
    result2.index = array2.index;
    result2.input = array2.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer_default(object);
    case boolTag:
    case dateTag:
      return new Ctor(+object);
    case dataViewTag:
      return cloneDataView_default(object, isDeep);
    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray_default(object, isDeep);
    case mapTag:
      return new Ctor();
    case numberTag:
    case stringTag:
      return new Ctor(object);
    case regexpTag:
      return cloneRegExp_default(object);
    case setTag:
      return new Ctor();
    case symbolTag:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag2 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag2;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag2 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag2;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var objectTag2 = "[object Object]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag2] = cloneableTags[dateTag2] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag3] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag3] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result2 = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result2);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag2 || tag == argsTag || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result2, value)) : copySymbols_default(value, baseAssign_default(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array2) {
  var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array2[index];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array2 = arguments[0], index = length;
  while (index--) {
    args[index - 1] = arguments[index];
  }
  return arrayPush_default(isArray_default(array2) ? copyArray_default(array2) : [array2], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function cond(pairs) {
  var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee_default;
  pairs = !length ? [] : arrayMap_default(pairs, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT4);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index = -1;
    while (++index < length) {
      var pair = pairs[index];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (length--) {
    var key = props[length], predicate = source[key], value = object[key];
    if (value === void 0 && !(key in object) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array2, setter, iteratee2, accumulator) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    var value = array2[index];
    setter(accumulator, value, iteratee2(value), array2);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee2(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee2(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto8 = Object.prototype;
var hasOwnProperty8 = objectProto8.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty8.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto9 = Object.prototype;
var hasOwnProperty9 = objectProto9.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index < length) {
    var source = sources[index];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_default(value, objectProto9[key]) && !hasOwnProperty9.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT5);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// node_modules/lodash-es/difference.js
var difference = baseRest_default(function(array2, values2) {
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array2, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// node_modules/lodash-es/drop.js
function drop(array2, n2, guard) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  return baseSlice_default(array2, n2 < 0 ? 0 : n2, length);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array2, n2, guard) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  n2 = length - n2;
  return baseSlice_default(array2, 0, n2 < 0 ? 0 : n2);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array2, predicate, isDrop, fromRight) {
  var length = array2.length, index = fromRight ? length : -1;
  while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
  }
  return isDrop ? baseSlice_default(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice_default(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array2, iteratee2) {
  var length = array2 == null ? 0 : array2.length;
  while (length--) {
    if (iteratee2(array2[length], length, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string, target, position) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length = string.length;
  position = position === void 0 ? length : baseClamp_default(toInteger_default(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set2) {
  var index = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index] = [value, value];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag4 = "[object Map]";
var setTag4 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag4) {
      return mapToArray_default(object);
    }
    if (tag == setTag4) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array2, predicate) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (!predicate(array2[index], index, array2)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value, index, collection2) {
    result2 = !!predicate(value, index, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value) {
  return value ? baseClamp_default(toInteger_default(value), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array2, value, start, end) {
  var length = array2.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger_default(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array2[start++] = value;
  }
  return array2;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array2, value, start, end) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array2, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill_default(array2, value, start, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value, index, collection2) {
    if (predicate(value, index, collection2)) {
      result2.push(value);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default = filter;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax4 = Math.max;
function findIndex(array2, predicate, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax4(length + index, 0);
  }
  return baseFindIndex_default(array2, baseIteratee_default(predicate, 3), index);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/find.js
var find = createFind_default(findIndex_default);
var find_default = find;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value, key, collection2) {
    if (predicate(value, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax5 = Math.max;
var nativeMin4 = Math.min;
function findLastIndex(array2, predicate, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax5(length + index, 0) : nativeMin4(index, length - 1);
  }
  return baseFindIndex_default(array2, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head(array2) {
  return array2 && array2.length ? array2[0] : void 0;
}
var head_default = head;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result2[++index] = iteratee2(value, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY2 = 1 / 0;
function flattenDeep(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseFlatten_default(array2, INFINITY2) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array2, depth) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array2, depth);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor = createRound_default("floor");
var floor_default = floor;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT6);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];
      var funcName = getFuncName_default(func), data = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
      while (++index2 < length) {
        result2 = funcs[index2].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto10 = Object.prototype;
var hasOwnProperty10 = objectProto10.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty10.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue_default(result2, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber_default(value);
      other = toNumber_default(other);
    }
    return operator(value, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value, other) {
  return value >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseInRange.js
var nativeMax6 = Math.max;
var nativeMin5 = Math.min;
function baseInRange(number, start, end) {
  return number >= nativeMin5(start, end) && number < nativeMax6(start, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number = toNumber_default(number);
  return baseInRange_default(number, start, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag3 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag3;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax7 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax7(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax8 = Math.max;
function indexOf(array2, value, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax8(length + index, 0);
  }
  return baseIndexOf_default(array2, value, index);
}
var indexOf_default = indexOf;

// node_modules/lodash-es/initial.js
function initial(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseSlice_default(array2, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin6 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array2 = arrays[othIndex];
    if (othIndex && iteratee2) {
      array2 = arrayMap_default(array2, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin6(array2.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache_default(othIndex && array2) : void 0;
  }
  array2 = arrays[0];
  var index = -1, seen = caches[0];
  outer:
    while (++index < length && result2.length < maxLength) {
      var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee2(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto11 = Object.prototype;
var nativeObjectToString = objectProto11.toString;
var invert = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString.call(value);
  }
  result2[value] = key;
}, constant_default(identity_default));
var invert_default = invert;

// node_modules/lodash-es/invertBy.js
var objectProto12 = Object.prototype;
var hasOwnProperty11 = objectProto12.hasOwnProperty;
var nativeObjectToString2 = objectProto12.toString;
var invertBy = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString2.call(value);
  }
  if (hasOwnProperty11.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path, args) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  var func = object == null ? object : object[toKey_default(last_default(path))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path, args) {
  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value) {
    result2[++index] = isFunc ? apply_default(path, value, args) : baseInvoke_default(value, path, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag3 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == arrayBufferTag3;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag3 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike_default(value) && baseGetTag_default(value) == boolTag3;
}
var isBoolean_default = isBoolean;

// node_modules/lodash-es/_baseIsDate.js
var dateTag3 = "[object Date]";
function baseIsDate(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == dateTag3;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEmpty.js
var mapTag5 = "[object Map]";
var setTag5 = "[object Set]";
var objectProto13 = Object.prototype;
var hasOwnProperty12 = objectProto13.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag5 || tag == setTag5) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty12.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite(value) {
  return typeof value == "number" && nativeIsFinite2(value);
}
var isFinite_default = isFinite;

// node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag3 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag3;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isNaN.js
function isNaN2(value) {
  return isNumber_default(value) && value != +value;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable_default(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// node_modules/lodash-es/isNull.js
function isNull(value) {
  return value === null;
}
var isNull_default = isNull;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag3 = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag3;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER = 9007199254740991;
function isSafeInteger(value) {
  return isInteger_default(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag2 = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == weakMapTag2;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto = Array.prototype;
var nativeJoin = arrayProto.join;
function join(array2, separator) {
  return array2 == null ? "" : nativeJoin.call(array2, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value, key) {
  baseAssignValue_default(result2, key, value);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array2, value, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array2[index] === value) {
      return index;
    }
  }
  return index;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax9 = Math.max;
var nativeMin7 = Math.min;
function lastIndexOf(array2, value, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = index < 0 ? nativeMax9(length + index, 0) : nativeMin7(index, length - 1);
  }
  return value === value ? strictLastIndexOf_default(array2, value, index) : baseFindIndex_default(array2, baseIsNaN_default, index, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value, other) {
  return value <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, iteratee2(value, key, object2), value);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty_default(path, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array2, iteratee2, comparator) {
  var index = -1, length = array2.length;
  while (++index < length) {
    var value = array2[index], current = iteratee2(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max(array2) {
  return array2 && array2.length ? baseExtremum_default(array2, identity_default, baseGt_default) : void 0;
}
var max_default = max;

// node_modules/lodash-es/maxBy.js
function maxBy(array2, iteratee2) {
  return array2 && array2.length ? baseExtremum_default(array2, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array2, iteratee2) {
  var result2, index = -1, length = array2.length;
  while (++index < length) {
    var current = iteratee2(array2[index]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN2 = 0 / 0;
function baseMean(array2, iteratee2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseSum_default(array2, iteratee2) / length : NAN2;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean(array2) {
  return baseMean_default(array2, identity_default);
}
var mean_default = mean;

// node_modules/lodash-es/meanBy.js
function meanBy(array2, iteratee2) {
  return baseMean_default(array2, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path, args) {
  return function(object) {
    return baseInvoke_default(object, path, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path) {
    return baseInvoke_default(object, path, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min(array2) {
  return array2 && array2.length ? baseExtremum_default(array2, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// node_modules/lodash-es/minBy.js
function minBy(array2, iteratee2) {
  return array2 && array2.length ? baseExtremum_default(array2, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag6 = "[object Map]";
var setTag6 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike_default(value)) {
    return isString_default(value) ? stringToArray_default(value) : copyArray_default(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray_default(value[symIterator]());
  }
  var tag = getTag_default(value), func = tag == mapTag6 ? mapToArray_default : tag == setTag6 ? setToArray_default : values_default;
  return func(value);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array2, n2) {
  var length = array2.length;
  if (!length) {
    return;
  }
  n2 += n2 < 0 ? length : 0;
  return isIndex_default(n2, length) ? array2[n2] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array2, n2) {
  return array2 && array2.length ? baseNth_default(array2, toInteger_default(n2)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n2) {
  n2 = toInteger_default(n2);
  return baseRest_default(function(args) {
    return baseNth_default(args, n2);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value) {
  return isPlainObject_default(value) ? void 0 : value;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path) {
    path = castPath_default(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length = paths.length;
  while (length--) {
    baseUnset_default(result2, paths[length]);
  }
  return result2;
});
var omit_default = omit;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length = paths.length, result2 = {};
  while (++index < length) {
    var path = paths[index], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result2, castPath_default(path, object), value);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array2, comparer) {
  var length = array2.length;
  array2.sort(comparer);
  while (length--) {
    array2[length] = array2[length].value;
  }
  return array2;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result2 = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result2) {
      if (index >= ordersLength) {
        return result2;
      }
      var order = orders[index];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value) {
          return baseGet_default(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin8 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index = -1, length = nativeMin8(args.length, funcsLength);
    while (++index < length) {
      args[index] = transforms[index].call(this, args[index]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n2) {
  var result2 = "";
  if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
    return result2;
  }
  do {
    if (n2 % 2) {
      result2 += string;
    }
    n2 = nativeFloor(n2 / 2);
    if (n2) {
      string += string;
    }
  } while (n2);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length).join("") : result2.slice(0, length);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil2 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  if (!length || strLength >= length) {
    return string;
  }
  var mid = (length - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string + createPadding_default(nativeCeil2(mid), chars);
}
var pad_default = pad;

// node_modules/lodash-es/padEnd.js
function padEnd(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? string + createPadding_default(length - strLength, chars) : string;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string : string;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// node_modules/lodash-es/plant.js
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone2 = wrapperClone_default(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path) {
    return object == null ? void 0 : baseGet_default(object, path);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array2, value, fromIndex, comparator) {
  var index = fromIndex - 1, length = array2.length;
  while (++index < length) {
    if (comparator(array2[index], value)) {
      return index;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto2 = Array.prototype;
var splice = arrayProto2.splice;
function basePullAll(array2, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index = -1, length = values2.length, seen = array2;
  if (array2 === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array2, baseUnary_default(iteratee2));
  }
  while (++index < length) {
    var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array2) {
        splice.call(seen, fromIndex, 1);
      }
      splice.call(array2, fromIndex, 1);
    }
  }
  return array2;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array2, values2) {
  return array2 && array2.length && values2 && values2.length ? basePullAll_default(array2, values2) : array2;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array2, values2, iteratee2) {
  return array2 && array2.length && values2 && values2.length ? basePullAll_default(array2, values2, baseIteratee_default(iteratee2, 2)) : array2;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array2, values2, comparator) {
  return array2 && array2.length && values2 && values2.length ? basePullAll_default(array2, values2, void 0, comparator) : array2;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAt(array2, indexes) {
  var length = array2 ? indexes.length : 0, lastIndex = length - 1;
  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex_default(index)) {
        splice2.call(array2, index, 1);
      } else {
        baseUnset_default(array2, index);
      }
    }
  }
  return array2;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array2, indexes) {
  var length = array2 == null ? 0 : array2.length, result2 = baseAt_default(array2, indexes);
  basePullAt_default(array2, arrayMap_default(indexes, function(index) {
    return isIndex_default(index, length) ? +index : index;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin9 = Math.min;
var nativeRandom2 = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin9(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random;

// node_modules/lodash-es/_baseRange.js
var nativeCeil3 = Math.ceil;
var nativeMax10 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index = -1, length = nativeMax10(nativeCeil3((end - start) / (step || 1)), 0), result2 = Array(length);
  while (length--) {
    result2[fromRight ? length : ++index] = start;
    start += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start, end, step, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array2, iteratee2, accumulator, initAccum) {
  var length = array2 == null ? 0 : array2.length;
  if (initAccum && length) {
    accumulator = array2[--length];
  }
  while (length--) {
    accumulator = iteratee2(accumulator, array2[length], length, array2);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove(array2, predicate) {
  var result2 = [];
  if (!(array2 && array2.length)) {
    return result2;
  }
  var index = -1, indexes = [], length = array2.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index < length) {
    var value = array2[index];
    if (predicate(value, index, array2)) {
      result2.push(value);
      indexes.push(index);
    }
  }
  basePullAt_default(array2, indexes);
  return result2;
}
var remove_default = remove;

// node_modules/lodash-es/repeat.js
function repeat(string, n2, guard) {
  if (guard ? isIterateeCall_default(string, n2, guard) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger_default(n2);
  }
  return baseRepeat_default(toString_default(string), n2);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT8 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT8);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path, defaultValue) {
  path = castPath_default(path, object);
  var index = -1, length = path.length;
  if (!length) {
    length = 1;
    object = void 0;
  }
  while (++index < length) {
    var value = object == null ? void 0 : object[toKey_default(path[index])];
    if (value === void 0) {
      index = length;
      value = defaultValue;
    }
    object = isFunction_default(value) ? value.call(object) : value;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto4 = Array.prototype;
var nativeReverse = arrayProto4.reverse;
function reverse(array2) {
  return array2 == null ? array2 : nativeReverse.call(array2);
}
var reverse_default = reverse;

// node_modules/lodash-es/round.js
var round = createRound_default("round");
var round_default = round;

// node_modules/lodash-es/_arraySample.js
function arraySample(array2) {
  var length = array2.length;
  return length ? array2[baseRandom_default(0, length - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array2, size2) {
  var index = -1, length = array2.length, lastIndex = length - 1;
  size2 = size2 === void 0 ? length : size2;
  while (++index < size2) {
    var rand = baseRandom_default(index, lastIndex), value = array2[rand];
    array2[rand] = array2[index];
    array2[index] = value;
  }
  array2.length = size2;
  return array2;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array2, n2) {
  return shuffleSelf_default(copyArray_default(array2), baseClamp_default(n2, 0, array2.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n2) {
  var array2 = values_default(collection);
  return shuffleSelf_default(array2, baseClamp_default(n2, 0, array2.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n2, guard) {
  if (guard ? isIterateeCall_default(collection, n2, guard) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger_default(n2);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n2);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// node_modules/lodash-es/setWith.js
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path, value, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array2) {
  return shuffleSelf_default(copyArray_default(array2));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default = shuffle;

// node_modules/lodash-es/size.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag7 || tag == setTag7) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default = size;

// node_modules/lodash-es/slice.js
function slice(array2, start, end) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array2, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length : toInteger_default(end);
  }
  return baseSlice_default(array2, start, end);
}
var slice_default = slice;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value, index, collection2) {
    result2 = predicate(value, index, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin10 = Math.min;
function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
  var low = 0, high = array2 == null ? 0 : array2.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_default(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin10(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array2, value, retHighest) {
  var low = 0, high = array2 == null ? low : array2.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array2[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array2, value, identity_default, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array2, value) {
  return baseSortedIndex_default(array2, value);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array2, value, iteratee2) {
  return baseSortedIndexBy_default(array2, value, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array2, value) {
  var length = array2 == null ? 0 : array2.length;
  if (length) {
    var index = baseSortedIndex_default(array2, value);
    if (index < length && eq_default(array2[index], value)) {
      return index;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array2, value) {
  return baseSortedIndex_default(array2, value, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array2, value, iteratee2) {
  return baseSortedIndexBy_default(array2, value, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array2, value) {
  var length = array2 == null ? 0 : array2.length;
  if (length) {
    var index = baseSortedIndex_default(array2, value, true) - 1;
    if (eq_default(array2[index], value)) {
      return index;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array2, iteratee2) {
  var index = -1, length = array2.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
    if (!index || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array2) {
  return array2 && array2.length ? baseSortedUniq_default(array2) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array2, iteratee2) {
  return array2 && array2.length ? baseSortedUniq_default(array2, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT9 = "Expected a function";
var nativeMax11 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  start = start == null ? 0 : nativeMax11(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array2 = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array2) {
      arrayPush_default(otherArgs, array2);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith(string, target, position) {
  string = toString_default(string);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// node_modules/lodash-es/sum.js
function sum(array2) {
  return array2 && array2.length ? baseSum_default(array2, identity_default) : 0;
}
var sum_default = sum;

// node_modules/lodash-es/sumBy.js
function sumBy(array2, iteratee2) {
  return array2 && array2.length ? baseSum_default(array2, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseSlice_default(array2, 1, length) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array2, n2, guard) {
  if (!(array2 && array2.length)) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  return baseSlice_default(array2, 0, n2 < 0 ? 0 : n2);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array2, n2, guard) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  n2 = length - n2;
  return baseSlice_default(array2, n2 < 0 ? 0 : n2, length);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto14 = Object.prototype;
var hasOwnProperty13 = objectProto14.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto14[key]) && !hasOwnProperty13.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto15 = Object.prototype;
var hasOwnProperty14 = objectProto15.hasOwnProperty;
function template(string, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options, guard)) {
    options = void 0;
  }
  string = toString_default(string);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty14.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match2.length;
    return match2;
  });
  source += "';\n";
  var variable = hasOwnProperty14.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// node_modules/lodash-es/thru.js
function thru(value, interceptor) {
  return interceptor(value);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin11 = Math.min;
function times(n2, iteratee2) {
  n2 = toInteger_default(n2);
  if (n2 < 1 || n2 > MAX_SAFE_INTEGER3) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH6, length = nativeMin11(n2, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n2 -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length, iteratee2);
  while (++index < n2) {
    iteratee2(index);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value) {
  return toString_default(value).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value) {
  if (isArray_default(value)) {
    return arrayMap_default(value, toKey_default);
  }
  return isSymbol_default(value) ? [value] : copyArray_default(stringToPath_default(toString_default(value)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp_default(toInteger_default(value), -MAX_SAFE_INTEGER4, MAX_SAFE_INTEGER4) : value === 0 ? value : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value) {
  return toString_default(value).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform4(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index, object2) {
    return iteratee2(accumulator, value, index, object2);
  });
  return accumulator;
}
var transform_default = transform4;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1, length = strSymbols.length;
  while (++index < length && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart2 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart2, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length = "length" in options ? toInteger_default(options.length) : length;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match2, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match2 = separator.exec(substring)) {
        var newEnd = match2.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index = result2.lastIndexOf(separator);
    if (index > -1) {
      result2 = result2.slice(0, index);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape;

// node_modules/lodash-es/union.js
var union2 = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union2;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/uniq.js
function uniq(array2) {
  return array2 && array2.length ? baseUniq_default(array2) : [];
}
var uniq_default = uniq;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array2, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array2 && array2.length ? baseUniq_default(array2, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_default(prefix) + id;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array2, iteratee2) {
  if (!(array2 && array2.length)) {
    return [];
  }
  var result2 = unzip_default(array2);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group) {
    return apply_default(iteratee2, void 0, group);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path, updater, customizer) {
  return baseSet_default(object, path, updater(baseGet_default(object, path)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update(object, path, updater) {
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater));
}
var update_default = update;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array2, values2) {
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, values2) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value, wrapper) {
  return partial_default(castFunction_default(wrapper), value);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length ? 1 : 0));
  value.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value, this.__chain__).thru(function(array2) {
    if (length && !array2.length) {
      array2.push(void 0);
    }
    return array2;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper_default) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq_default(arrays[0]) : [];
  }
  var index = -1, result2 = Array(length);
  while (++index < length) {
    var array2 = arrays[index], othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index) {
        result2[index] = baseDifference_default(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index = -1, length = props.length, valsLength = values2.length, result2 = {};
  while (++index < length) {
    var value = index < valsLength ? values2[index] : void 0;
    assignFunc(result2, props[index], value);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default,
  find: find_default,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default,
  size: size_default,
  some: some_default,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax12 = Math.max;
var nativeMin12 = Math.min;
function getView(start, end, transforms) {
  var index = -1, length = transforms.length;
  while (++index < length) {
    var data = transforms[index], size2 = data.size;
    switch (data.type) {
      case "drop":
        start += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin12(end, start + size2);
        break;
      case "takeRight":
        start = nativeMax12(start, end - size2);
        break;
    }
  }
  return { "start": start, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin13 = Math.min;
function lazyValue() {
  var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin13(length, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length && takeCount == length) {
    return baseWrapperValue_default(array2, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length-- && resIndex < takeCount) {
      index += dir;
      var iterIndex = -1, value = array2[index];
      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto5 = Array.prototype;
var objectProto16 = Object.prototype;
var hasOwnProperty15 = objectProto16.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax13 = Math.max;
var nativeMin14 = Math.min;
var mixin2 = function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty15.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index) {
  LazyWrapper_default.prototype[methodName] = function(n2) {
    n2 = n2 === void 0 ? 1 : nativeMax13(toInteger_default(n2), 0);
    var result2 = this.__filtered__ && !index ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin14(n2, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin14(n2, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n2) {
    return this.reverse()[methodName](n2).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index) {
  var type = index + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index) {
  var takeName = "take" + (index ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index) {
  var dropName = "drop" + (index ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value) {
    return baseInvoke_default(value, path, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper_default(this);
      var result2 = func.apply(value, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto5[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray_default(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func.apply(isArray_default(value2) ? value2 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty15.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/@refinedev/inferencer/dist/esm/chakra-ui.js
var import_react12 = __toESM(require_react());
var import_react14 = __toESM(require_react());

// node_modules/@refinedev/react-table/dist/esm/index.js
var import_react3 = __toESM(require_react());

// node_modules/@tanstack/react-table/build/lib/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@tanstack/table-core/build/lib/index.mjs
function functionalUpdate(updater, input2) {
  return typeof updater === "function" ? updater(input2) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d2) {
  return d2 instanceof Function;
}
function isNumberArray(d2) {
  return Array.isArray(d2) && d2.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts2) {
  let deps = [];
  let result2;
  return () => {
    let depTime;
    if (opts2.key && opts2.debug)
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result2;
    }
    deps = newDeps;
    let resultTime;
    if (opts2.key && opts2.debug)
      resultTime = Date.now();
    result2 = fn(...newDeps);
    opts2 == null || opts2.onChange == null || opts2.onChange(result2);
    if (opts2.key && opts2.debug) {
      if (opts2 != null && opts2.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad2 = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%câ± ${pad2(resultEndTime, 5)} /${pad2(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts2 == null ? void 0 : opts2.key);
      }
    }
    return result2;
  };
}
function createColumn(table, columnDef, depth, parent2) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(".", "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result2 = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result2 = (_result = result2) == null ? void 0 : _result[key];
          if (result2 === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result2;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (true) {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent: parent2,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d2) => d2.getFlatColumns())];
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;
      }
    }),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;
      }
    })
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h) => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
var Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, {
      key: "getHeaderGroups",
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugHeaders;
      }
    });
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, {
      key: "getCenterHeaderGroups",
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugHeaders;
      }
    });
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, {
      key: "getLeftHeaderGroups",
      debug: () => {
        var _table$options$debugA3;
        return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugHeaders;
      }
    });
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, {
      key: "getRightHeaderGroups",
      debug: () => {
        var _table$options$debugA4;
        return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugHeaders;
      }
    });
    table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, {
      key: "getFooterGroups",
      debug: () => {
        var _table$options$debugA5;
        return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugHeaders;
      }
    });
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, {
      key: "getLeftFooterGroups",
      debug: () => {
        var _table$options$debugA6;
        return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugHeaders;
      }
    });
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, {
      key: "getCenterFooterGroups",
      debug: () => {
        var _table$options$debugA7;
        return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugHeaders;
      }
    });
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, {
      key: "getRightFooterGroups",
      debug: () => {
        var _table$options$debugA8;
        return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugHeaders;
      }
    });
    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, {
      key: "getFlatHeaders",
      debug: () => {
        var _table$options$debugA9;
        return (_table$options$debugA9 = table.options.debugAll) != null ? _table$options$debugA9 : table.options.debugHeaders;
      }
    });
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, {
      key: "getLeftFlatHeaders",
      debug: () => {
        var _table$options$debugA10;
        return (_table$options$debugA10 = table.options.debugAll) != null ? _table$options$debugA10 : table.options.debugHeaders;
      }
    });
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, {
      key: "getCenterFlatHeaders",
      debug: () => {
        var _table$options$debugA11;
        return (_table$options$debugA11 = table.options.debugAll) != null ? _table$options$debugA11 : table.options.debugHeaders;
      }
    });
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, {
      key: "getRightFlatHeaders",
      debug: () => {
        var _table$options$debugA12;
        return (_table$options$debugA12 = table.options.debugAll) != null ? _table$options$debugA12 : table.options.debugHeaders;
      }
    });
    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, {
      key: "getCenterLeafHeaders",
      debug: () => {
        var _table$options$debugA13;
        return (_table$options$debugA13 = table.options.debugAll) != null ? _table$options$debugA13 : table.options.debugHeaders;
      }
    });
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, {
      key: "getLeftLeafHeaders",
      debug: () => {
        var _table$options$debugA14;
        return (_table$options$debugA14 = table.options.debugAll) != null ? _table$options$debugA14 : table.options.debugHeaders;
      }
    });
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, {
      key: "getRightLeafHeaders",
      debug: () => {
        var _table$options$debugA15;
        return (_table$options$debugA15 = table.options.debugAll) != null ? _table$options$debugA15 : table.options.debugHeaders;
      }
    });
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, {
      key: "getLeafHeaders",
      debug: () => {
        var _table$options$debugA16;
        return (_table$options$debugA16 = table.options.debugAll) != null ? _table$options$debugA16 : table.options.debugHeaders;
      }
    });
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d2) => d2.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state2) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = (position) => {
      const columns = !position ? table.getVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
      const index = columns.findIndex((d2) => d2.id === column.id);
      if (index > 0) {
        const prevSiblingColumn = columns[index - 1];
        return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();
      }
      return 0;
    };
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _,
          ...rest2
        } = _ref2;
        return rest2;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum3 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum3 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum3;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = () => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return (e) => {
        if (!column || !canResize) {
          return;
        }
        e.persist == null || e.persist();
        if (isTouchStartEvent(e)) {
          if (e.touches && e.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d2) => [d2.column.id, d2.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const mouseEvents = {
          moveHandler: (e2) => onMove(e2.clientX),
          upHandler: (e2) => {
            document.removeEventListener("mousemove", mouseEvents.moveHandler);
            document.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e2.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e2) => {
            if (e2.cancelable) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            onMove(e2.touches[0].clientX);
            return false;
          },
          upHandler: (e2) => {
            var _e$touches$;
            document.removeEventListener("touchmove", touchEvents.moveHandler);
            document.removeEventListener("touchend", touchEvents.upHandler);
            if (e2.cancelable) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            onEnd((_e$touches$ = e2.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e)) {
          document.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          document.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          document.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          document.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum3, header) => {
        return sum3 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum3, header) => {
        return sum3 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum3, header) => {
        return sum3 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum3, header) => {
        return sum3 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
var passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean")
    return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {
    };
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === "touchstart";
}
var Expanding = {
  getInitialState: (state2) => {
    return {
      expanded: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued)
          return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e) => {
        e.persist == null || e.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id) => {
        const splitId = id.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest2
          } = oldExpanded;
          return rest2;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand)
          return;
        row.toggleExpanded();
      };
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _row$getValue;
  const search = filterValue.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min3, max3] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min3 && rowValue <= max3;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min3 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max3 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min3 > max3) {
    const temp = min3;
    min3 = max3;
    max3 = temp;
  }
  return [min3, max3];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
var Filters = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state2) => {
    return {
      columnFilters: [],
      globalFilter: void 0,
      // filtersProgress: 1,
      // facetProgress: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100,
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
      );
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;
      return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d2) => d2.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousfilter = old == null ? void 0 : old.find((d2) => d2.id === column.id);
        const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d2) => d2.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousfilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d2) => {
            if (d2.id === column.id) {
              return newFilterObj;
            }
            return d2;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return void 0;
      }
      return column._getFacetedMinMaxValues();
    };
  },
  createRow: (row, table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter3, _table$options$filter4;
      const {
        globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn]
      );
    };
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter2) => {
          const column = leafColumns.find((d2) => d2.id === filter2.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter2.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum2 = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum3, next2) => {
    const nextValue = next2.getValue(columnId);
    return sum3 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min2 = (columnId, _leafRows, childRows) => {
  let min3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
      min3 = value;
    }
  });
  return min3;
};
var max2 = (columnId, _leafRows, childRows) => {
  let max3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
      max3 = value;
    }
  });
  return max3;
};
var extent = (columnId, _leafRows, childRows) => {
  let min3;
  let max3;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min3 === void 0) {
        if (value >= value)
          min3 = max3 = value;
      } else {
        if (min3 > value)
          min3 = value;
        if (max3 < value)
          max3 = value;
      }
    }
  });
  return [min3, max3];
};
var mean2 = (columnId, leafRows) => {
  let count2 = 0;
  let sum3 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum3 += value;
    }
  });
  if (count2)
    return sum3 / count2;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values2 = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values2)) {
    return;
  }
  if (values2.length === 1) {
    return values2[0];
  }
  const mid = Math.floor(values2.length / 2);
  const nums = values2.sort((a, b) => a - b);
  return values2.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d2) => d2.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d2) => d2.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum: sum2,
  min: min2,
  max: max2,
  extent,
  mean: mean2,
  median,
  unique,
  uniqueCount,
  count
};
var Grouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state2) => {
    return {
      grouping: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d2) => d2 !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _ref, _ref2, _ref3, _column$columnDef$ena;
      return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup)
          return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g2) => leafColumns.find((col) => col.id === g2)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var Ordering = {
  getInitialState: (state2) => {
    return {
      columnOrder: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d2) => d2.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, {
      key: "getOrderColumnsFn"
      // debug: () => table.options.debugAll ?? table.options.debugTable,
    });
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var Pagination = {
  getInitialState: (state2) => {
    return {
      ...state2,
      pagination: {
        ...getDefaultPaginationState(),
        ...state2 == null ? void 0 : state2.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued)
          return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i2) => i2);
      }
      return pageOptions;
    }, {
      key: "getPageOptions",
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
      }
    });
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);
    };
  }
};
var getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
var getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
var Pinning = {
  getInitialState: (state2) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      rowPinning: getDefaultRowPinningState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table),
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position) => {
      const columnIds = column.getLeafColumns().map((d2) => d2.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds]
          };
        }
        if (position === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d2) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d2.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d2) => d2.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d2) => left == null ? void 0 : left.includes(d2));
      const isRight = leafColumnIds.some((d2) => right == null ? void 0 : right.includes(d2));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2) => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3) => {
        let {
          id
        } = _ref3;
        return id;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)]
          };
        }
        if (position === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref4;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d2) => top == null ? void 0 : top.includes(d2));
      const isBottom = rowIds.some((d2) => bottom == null ? void 0 : bottom.includes(d2));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _table$_getPinnedRows, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position)
        return -1;
      const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5) => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allCells.filter((d2) => !leftAndRight.includes(d2.column.id));
    }, {
      key: "row.getCenterVisibleCells",
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;
      }
    });
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, ,], (allCells, left) => {
      const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "left"
      }));
      return cells;
    }, {
      key: "row.getLeftVisibleCells",
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;
      }
    });
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "right"
      }));
      return cells;
    }, {
      key: "row.getRightVisibleCells",
      debug: () => {
        var _table$options$debugA3;
        return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugRows;
      }
    });
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, {
      key: "getLeftLeafColumns",
      debug: () => {
        var _table$options$debugA4;
        return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;
      }
    });
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, {
      key: "getRightLeafColumns",
      debug: () => {
        var _table$options$debugA5;
        return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;
      }
    });
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allColumns.filter((d2) => !leftAndRight.includes(d2.id));
    }, {
      key: "getCenterLeafColumns",
      debug: () => {
        var _table$options$debugA6;
        return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugColumns;
      }
    });
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState2;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position) => {
      var _pinningState$positio2;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);
    };
    table._getPinnedRows = (position) => memo(() => [table.getRowModel().rows, table.getState().rowPinning[position]], (visibleRows, pinnedRowIds) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d2) => ({
        ...d2,
        position
      }));
    }, {
      key: `row.get${position === "top" ? "Top" : "Bottom"}Rows`,
      debug: () => {
        var _table$options$debugA7;
        return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugRows;
      }
    })();
    table.getTopRows = () => table._getPinnedRows("top");
    table.getBottomRows = () => table._getPinnedRows("bottom");
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d2) => !topAndBottom.has(d2.id));
    }, {
      key: "row.getCenterRows",
      debug: () => {
        var _table$options$debugA8;
        return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugRows;
      }
    });
  }
};
var RowSelection = {
  getInitialState: (state2) => {
    return {
      rowSelection: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, {
      key: "getSelectedRowModel",
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
      }
    });
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugTable;
      }
    });
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA3;
        return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugTable;
      }
    });
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d2) => d2.getIsSelected() || d2.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e) => {
        table.toggleAllRowsSelected(e.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e) => {
        table.toggleAllPageRowsSelected(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts2) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts2 == null ? void 0 : opts2.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e) => {
        var _target;
        if (!canSelect)
          return;
        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length))
    return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);
  return a > b ? 1 : a < b ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === "number") {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return "";
    }
    return String(a);
  }
  if (typeof a === "string") {
    return a;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var Sorting = {
  getInitialState: (state2) => {
    return {
      sorting: [],
      ...state2
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e) => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString2 = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString2 = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString2) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d2) => d2.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d2) => d2.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d2) => {
            if (d2.id === column.id) {
              return {
                ...d2,
                desc: nextDesc
              };
            }
            return d2;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d2) => d2.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d2) => d2.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d2) => d2.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e) => {
        if (!canSort)
          return;
        e.persist == null || e.persist();
        column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
var Visibility = {
  getInitialState: (state2) => {
    return {
      columnVisibility: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _table$getState$colum, _table$getState$colum2;
      return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e) => {
        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;
      }
    });
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {
      key: "row.getVisibleCells",
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;
      }
    });
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d2) => d2.getIsVisible()).map((d2) => d2.id).join("_")], (columns) => {
        return columns.filter((d2) => d2.getIsVisible == null ? void 0 : d2.getIsVisible());
      }, {
        key,
        debug: () => {
          var _table$options$debugA3;
          return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;
        }
      });
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
var features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing];
function createTable(options) {
  var _options$initialState;
  if (options.debugAll || options.debugTable) {
    console.info("Creating Table Instance...");
  }
  let table = {
    _features: features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features: features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent2) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent2)) != null ? _table$options$getRow : `${parent2 ? [parent2.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    getRow: (id, searchAll) => {
      const row = (searchAll ? table.getCoreRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        if (true) {
          throw new Error(`getRow expected an ID, but got ${id}`);
        }
        throw new Error();
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, {
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;
      },
      key: "getDefaultColumnDef"
    }),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent2, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent2);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, {
      key: "getAllColumns",
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;
      }
    }),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, {
      key: "getAllFlatColumns",
      debug: () => {
        var _table$options$debugA3;
        return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;
      }
    }),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, {
      key: "getAllFlatColumnsById",
      debug: () => {
        var _table$options$debugA4;
        return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;
      }
    }),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, {
      key: "getAllLeafColumns",
      debug: () => {
        var _table$options$debugA5;
        return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;
      }
    }),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), {
      key: "cell.getContext",
      debug: () => table.options.debugAll
    })
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
var createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d2) => d2.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow)
          break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, {
      key: "row.getAllCells",
      debug: () => {
        var _table$options$debugA;
        return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;
      }
    }),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, {
      key: false,
      debug: () => {
        var _table$options$debugA2;
        return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;
      }
    })
  };
  for (let i2 = 0; i2 < table._features.length; i2++) {
    const feature = table._features[i2];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i2 = 0; i2 < originalRows.length; i2++) {
        const row = createRow(table, table._getRowId(originalRows[i2], i2, parentRow), originalRows[i2], i2, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i2], i2);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, {
    key: "getRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  var _table$options$maxLea;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i2 = 0; i2 < rowsToFilter2.length; i2++) {
      var _row$subRows;
      let row = rowsToFilter2[i2];
      const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  var _table$options$maxLea2;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i2 = 0; i2 < rowsToFilter2.length; i2++) {
      let row = rowsToFilter2[i2];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {
          const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFilteredRowModel() {
  return (table) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i2 = 0; i2 < rowModel.flatRows.length; i2++) {
        rowModel.flatRows[i2].columnFilters = {};
        rowModel.flatRows[i2].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d2) => {
      var _filterFn$resolveFilt;
      const column = table.getColumn(d2.id);
      if (!column) {
        return;
      }
      const filterFn = column.getFilterFn();
      if (!filterFn) {
        if (true) {
          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);
        }
        return;
      }
      resolvedColumnFilters.push({
        id: d2.id,
        filterFn,
        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d2.value)) != null ? _filterFn$resolveFilt : d2.value
      });
    });
    const filterableIds = columnFilters.map((d2) => d2.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column) => column.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column) => {
        var _globalFilterFn$resol;
        resolvedGlobalFilters.push({
          id: column.id,
          filterFn: globalFilterFn,
          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j2 = 0; j2 < rowModel.flatRows.length; j2++) {
      const row = rowModel.flatRows[j2];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i2 = 0; i2 < resolvedColumnFilters.length; i2++) {
          currentColumnFilter = resolvedColumnFilters[i2];
          const id = currentColumnFilter.id;
          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i2 = 0; i2 < resolvedGlobalFilters.length; i2++) {
          currentGlobalFilter = resolvedGlobalFilters[i2];
          const id = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i2 = 0; i2 < filterableIds.length; i2++) {
        if (row.columnFilters[filterableIds[i2]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, {
    key: "getFilteredRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      if (!column)
        return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = rows.map((row) => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i2 = 0; i2 < availableSorting.length; i2 += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i2];
          const columnInfo = columnInfoById[sortEntry.id];
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;
          if (columnInfo.sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === void 0;
            const bUndefined = bValue === void 0;
            if (aUndefined || bUndefined) {
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, {
    key: "getSortedRowModel",
    debug: () => {
      var _table$options$debugA;
      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;
    },
    onChange: () => {
      table._autoResetPageIndex();
    }
  });
}

// node_modules/@tanstack/react-table/build/lib/index.mjs
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? React2.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React2.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state2, setState] = React2.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state2,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

// node_modules/@refinedev/react-table/dist/esm/index.js
var import_react4 = __toESM(require_react());
var j = Object.defineProperty;
var i = (t2, a) => j(t2, "name", { value: a, configurable: true });
var v = i(() => {
  let t2 = (0, import_react4.useRef)(true);
  return (0, import_react4.useEffect)(() => {
    t2.current = false;
  }, []), t2.current;
}, "useIsFirstRender");
function Y({ refineCoreProps: { hasPagination: t2 = true, ...a } = {}, initialState: P = {}, ...B }) {
  var x2, y, C2;
  let m = v(), R = SC({ ...a, hasPagination: t2 }), g2 = (((x2 = a.filters) == null ? void 0 : x2.mode) || "server") === "server", b = (((y = a.sorters) == null ? void 0 : y.mode) || "server") === "server", O2 = t2 === false ? "off" : "server", E = (((C2 = a.pagination) == null ? void 0 : C2.mode) ?? O2) !== "off", { tableQueryResult: { data: l }, current: Q2, setCurrent: u, pageSize: H, setPageSize: h, sorters: w2, setSorters: z, filters: M, setFilters: U2, pageCount: I } = R, p = [];
  M.forEach((e) => {
    e.operator !== "or" && e.operator !== "and" && "field" in e && p.push(e);
  });
  let F2 = useReactTable({ data: (l == null ? void 0 : l.data) ?? [], getCoreRowModel: getCoreRowModel(), getSortedRowModel: b ? void 0 : getSortedRowModel(), getFilteredRowModel: g2 ? void 0 : getFilteredRowModel(), initialState: { pagination: { pageIndex: Q2 - 1, pageSize: H }, sorting: w2.map((e) => ({ id: e.field, desc: e.order === "desc" })), columnFilters: p.map((e) => ({ id: e.field, operator: e.operator, value: e.value })), ...P }, pageCount: I, manualPagination: true, manualSorting: b, manualFiltering: g2, ...B }), { state: L, columns: k } = F2.options, { pagination: q2, sorting: o, columnFilters: s } = L, { pageIndex: T, pageSize: c } = q2 ?? {};
  return (0, import_react3.useEffect)(() => {
    T !== void 0 && u(T + 1);
  }, [T]), (0, import_react3.useEffect)(() => {
    c !== void 0 && h(c);
  }, [c]), (0, import_react3.useEffect)(() => {
    o !== void 0 && (z(o == null ? void 0 : o.map((e) => ({ field: e.id, order: e.desc ? "desc" : "asc" }))), o.length > 0 && E && !m && u(1));
  }, [o]), (0, import_react3.useEffect)(() => {
    let e = [];
    s == null || s.map((r) => {
      var D, S;
      let n2 = r.operator ?? ((S = (D = k.find((A2) => A2.id === r.id)) == null ? void 0 : D.meta) == null ? void 0 : S.filterOperator);
      e.push({ field: r.id, operator: n2 ?? (Array.isArray(r.value) ? "in" : "eq"), value: r.value });
    });
    let f2 = p.filter((r) => !e.some((n2) => r.field === n2.field && r.operator === n2.operator));
    f2 == null || f2.map((r) => {
      e.push({ field: r.field, operator: r.operator, value: void 0 });
    }), U2(e), e.length > 0 && E && !m && u(1);
  }, [s]), { ...F2, refineCore: R };
}
i(Y, "useTable");

// node_modules/@refinedev/inferencer/dist/esm/chakra-ui.js
var Er = Object.defineProperty;
var n = (e, o) => Er(e, "name", { value: o, configurable: true });
var Mr = /(image|photo|avatar|url|logo|cover|thumbnail|icon)/i;
var we = n((e, o) => {
  let c = ["name", "label", "title", "count", "content", "username", "nickname", "login", "firstName", "lastName", "url"];
  Mr.test(e) && c.unshift("url");
  let i2 = c.find((s) => s in o && !!o[s]);
  if (i2)
    return i2 === "firstName" && "lastName" in o ? ["firstName", "lastName"] : i2;
}, "getFieldableKeys");
function Te(e, o, c) {
  if (o)
    return o;
  let i2 = c == null ? void 0 : c.find((u) => u.name === e), s = w(i2 == null ? void 0 : i2.meta, i2 == null ? void 0 : i2.options);
  return s != null && s.dataProviderName ? s.dataProviderName : "default";
}
n(Te, "pickDataProvider");
var ke = n((e) => {
  var o;
  return (o = e == null ? void 0 : e.options) == null ? void 0 : o.dataProviderName;
}, "dataProviderFromResource");
var Ae = n((e) => {
  let o = [...e].filter(Boolean).sort((c, i2) => (i2.priority || 0) - (c.priority || 0))[0];
  return o || null;
}, "pickInferredField");
var He = n((e) => {
  try {
    return import_standalone.default.format(e, { parser: "typescript", plugins: [import_parser_typescript.default], arrowParens: "always", trailingComma: "all", semi: true, tabWidth: 4, printWidth: 80 });
  } catch (o) {
    return console.warn("Formatting error in inferencer", o), e;
  }
}, "prettierFormat");
var We = n((e) => e.replace(/ {2,}/g, " ").replace(/\n{2,}/g, `
`), "prettySpaces");
var Re = /(-id|-ids|_id|_ids|Id|Ids|ID|IDs)(\[\])?$/;
var Ge = n((e, o) => {
  let c = Re.test(e), i2 = typeof o == "string" || typeof o == "number", s = Array.isArray(o) && o.every((u) => typeof u == "string" || typeof u == "number");
  return c && i2 || c && s ? { key: e, relation: true, multiple: !!s, type: "relation", priority: 1 } : false;
}, "relationInfer");
var U = n((e) => e.replace(Re, ""), "removeRelationSuffix");
var fe = n((e) => U(e).replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").replace(/-/g, " ").split(" ").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join(" "), "prettyString");
var F = n((e) => {
  let { resource: o, field: c, i18n: i2 } = e;
  if (i2) {
    let u = `translate("${o.name}.fields.${c.key}")`;
    return e.noBraces ? `${u}` : `{${u}}`;
  }
  let s = fe(c.key);
  return e.noQuotes ? s : `"${s}"`;
}, "translatePrettyString");
var q = n((e = "") => import_pluralize.default.isSingular(e) ? e : import_pluralize.default.singular(e), "toSingular");
var te = n((e = "") => import_pluralize2.default.isPlural(e) ? e : import_pluralize2.default.plural(e), "toPlural");
var Pe = n((e) => e.replace(/export\s+(const|let|var|type|interface|function|class)\s+(\w+)\s*(=|:)\s*/g, "$1 $2 = ").split(`
`).filter((s) => !s.trim().startsWith("export default")).join(`
`), "replaceExports");
var Je = /import(?:(?:(?:[ \n\t]+([^ *\n\t\{\},]+)[ \n\t]*(?:,|[ \n\t]+))?([ \n\t]*\{(?:[ \n\t]*[^ \n\t"'\{\}]+[ \n\t]*,?)+\})?[ \n\t]*)|[ \n\t]*\*[ \n\t]*as[ \n\t]+([^ \n\t\{\}]+)[ \n\t]+)from[ \n\t]*(?:['"])([^'"\n]+)(?:['"])(?:;?)/g;
var Dr = /import[ \n\t](?:['"])([^'"\n]+)(?:['"])(?:;?)/g;
var Or = /((?:\w|\s|_)*)( as )((?:\w|\s|_)*)( |,)?/g;
var Le = n((e, o = {}) => {
  let c = e.matchAll(Je), i2 = /* @__PURE__ */ new Set();
  for (let s of c) {
    let [, u, y, p, l] = s;
    if (l in o) {
      let $ = o[l];
      if (l === "react")
        continue;
      u && i2.add(`const { default: ${u} } = ${$};`), y && i2.add(`const${y.replace(Or, "$1: $3$4")} = ${$};`), p && i2.add(`const ${p} = ${$};`);
    }
  }
  return We(`
    ${Array.from(i2).join(`
`)}
    ${e.replace(Je, "").replace(Dr, "")}
    `);
}, "replaceImports");
var Ee = n((e, o) => e ? o.find((i2) => {
  let s = U(e.key);
  return i2.name === s || i2.name === (import_pluralize3.default.isPlural(s) ? s : import_pluralize3.default.plural(s)) || i2.name === (import_pluralize3.default.isSingular(s) ? s : import_pluralize3.default.singular(s));
}) : void 0, "resourceFromInferred");
var Y2 = n((e, o, c = "Inferred") => {
  let i2 = e.replace(/[^a-zA-Z0-9]/g, " "), s = import_pluralize4.default.singular(i2), y = fe(s).replace(/ /g, "") || c, p = o.charAt(0).toUpperCase() + o.slice(1);
  return /^[a-zA-Z]/.test(y) ? `${y}${p}` : `${p}${y}`;
}, "componentName");
var jr = n((e) => e ? Array.isArray(e) ? e.join("") : typeof e == "string" ? e : typeof e == "object" || typeof e == "function" ? e.toString() : typeof e == "number" ? String(e) : typeof e == "boolean" && e ? "true" : e : "", "handleExpression");
var x = n((e, ...o) => e.reduce((i2, s, u) => `${i2}${s}${jr(o[u])}`, "").trim(), "jsx");
var Me = n((e, o) => `
    ${e ?? ""}
    
    render(typeof ${o} !== "undefined" ? <${o} /> : <></>);
    `, "prepareLiveCode");
var Ne = n((e) => e == null ? void 0 : e.replace(/(\/\* hidden-start \*\/)(.|\n)*?(\/\* hidden-end \*\/)/g, ""), "removeHiddenCode");
var Ur = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var Ve = n((e) => Ur.test(e), "shouldDotAccess");
function Be(e, o, c) {
  let i2 = `${e}`;
  return o && (i2 += "?.", Ve(o) ? i2 += o : i2 += `['${o}']`), c && (i2 += "?.", Ve(c) ? i2 += c : i2 += `['${c}']`), i2;
}
n(Be, "accessorSingle");
function Kr(e, o, c) {
  return (c ?? []).map((s) => Be(e, o, s));
}
n(Kr, "accessorMultiple");
var f = n((e, o, c, i2 = ' + " " + ') => Array.isArray(c) ? i2 ? Kr(e, o, c).join(i2) : Be(e, o, c[0]) : Be(e, o, c), "accessor");
var Q = n((e, o, c) => {
  let i2 = e;
  return o && (i2 += `.${o}`), c && (Array.isArray(c) ? i2 += `.${c[0]}` : i2 += `.${c}`), i2;
}, "dotAccessor");
var ne = n((e) => {
  let o = e.reduce((i2, [s, u, y]) => (i2[u] || (i2[u] = []), i2[u].includes(s) || (y ? i2[u].push([s, true]) : i2[u].push(s)), i2), {});
  return Object.entries(o).map(([i2, s]) => {
    let u = s.find(($) => Array.isArray($) && $[1]), y = s.filter(($) => typeof $ == "string"), p = u ? `${u[0]}` : "", l = y.length ? `{ ${y.join(", ")} }` : "";
    return `import ${p}${p && l ? ", " : ""}${l} from "${i2}";`;
  });
}, "printImports");
var Qr = /^id$/i;
var Ie = n((e) => Qr.test(e), "isIDKey");
var xe = n((e) => e.relationInfer && e.relationInfer.accessor ? Array.isArray(e.relationInfer.accessor) ? `optionLabel: "${e.relationInfer.accessor[0]}",` : e.relationInfer.accessor !== "title" ? `optionLabel: "${e.relationInfer.accessor}",` : "" : "", "getOptionLabel");
var oe = n((e) => {
}, "noOp");
var A = n((e, o = "") => {
  if (Number.isInteger(Number(e)))
    return o.charAt(0).toLowerCase() + o.slice(1) + e;
  let i2 = e.replace(/^\d+/, "").replace(/[^a-zA-Z0-9]/g, "-"), s = fe(i2).replace(/ /g, "");
  return `${s.charAt(0).toLowerCase() + s.slice(1)}${o.charAt(0).toUpperCase() + o.slice(1)}`;
}, "getVariableName");
var O = n((e, o, c) => {
  if (o && c && e) {
    let i2 = e ? o[e] : {}, s = (i2 == null ? void 0 : i2[c]) ?? (i2 == null ? void 0 : i2.default);
    return s ? `meta: ${JSON.stringify(s)},` : "";
  }
  return "";
}, "getMetaProps");
var ee = n((e, o, c) => {
  if (o && c && e) {
    let i2 = e ? o[e] : {}, u = [...c, "default"].reduce((y, p) => y ?? (i2 == null ? void 0 : i2[p]), void 0);
    if (u)
      return u;
  }
}, "pickMeta");
var $e = n((e) => e === void 0 ? e : typeof e == "string" ? `"${e}"` : e, "idQuoteWrapper");
var Xe = n((e) => {
  let o = n((c, i2, s, u = o, y) => {
    let p = e.map(($) => $(c, i2, s, u, y));
    return Ae(p);
  }, "fieldInferencer");
  return o;
}, "composeInferencers");
var er = n((e) => n((c, i2, s, u, y, p) => e.reduce((l, $) => $(l, i2, s, u, y, p), c), "fieldTransformer"), "composeTransformers");
var rr = n((e, o, c, i2, s) => {
  let u = Array.isArray(o), y = Array.isArray(o) && o.every((p) => typeof p == "string" || typeof p == "number");
  if (u) {
    if (!y) {
      let l = i2(e, o[0], c, i2, s);
      return l ? { ...l, key: e, multiple: true, priority: 1 } : false;
    }
    let p = i2(e, o[0], c, i2, s) || { type: "string" };
    return { key: e, multiple: true, priority: 1, type: p == null ? void 0 : p.type };
  }
  return false;
}, "arrayInfer");
var tr = n((e, o) => typeof o == "boolean" ? { key: e, type: "boolean" } : false, "booleanInfer");
var _r = /(_at|_on|At|On|AT|ON)(\[\])?$/;
var qr = ["/", ":", "-", "."];
var or = n((e, o) => {
  let c = _r.test(e) && (0, import_dayjs.default)(o).isValid(), i2 = typeof o == "string" && (0, import_dayjs.default)(o).isValid();
  return typeof o == "string" && qr.some((u) => o.includes(u)) && (c || i2) ? { key: e, type: "date", priority: 1 } : false;
}, "dateInfer");
var Wr = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var ar = n((e, o) => typeof o == "string" && Wr.test(o) ? { key: e, type: "email", priority: 1 } : false, "emailInfer");
var Gr = /\.(gif|jpe?g|tiff?|png|webp|bmp|svg)$/i;
var sr = n((e, o) => typeof o == "string" && Gr.test(o) ? { key: e, type: "image", priority: 2 } : false, "imageInfer");
var ir = n((e, o) => typeof o > "u" || o === null ? null : false, "nullishInfer");
var cr = n((e, o) => {
  let c = typeof o == "string" && o.length > 0, i2 = !isNaN(o);
  return c && i2 || typeof o == "number" ? { key: e, type: "number" } : false;
}, "numberInfer");
var ur = /id$/i;
var pr = n((e, o, c, i2, s) => {
  let u = o !== null, y = !Array.isArray(o);
  if (u && y && typeof o == "object") {
    let l = Object.keys(o).length === 1 && ur.test(Object.keys(o)[0]), $ = Object.keys(o).some((S) => ur.test(S));
    if (l)
      return { key: e, type: "relation", relation: true, accessor: "id", priority: 1 };
    let I = we(e, o);
    if ((I ? I.length > 0 : false) && I) {
      let S = I && Array.isArray(I) ? I[0] : I, h = i2(S, o[S], o, i2, s);
      if (h) {
        let w2 = Array.isArray(I) ? I.map((m) => h.accessor ? `${m}.${Array.isArray(h.accessor) ? h.accessor[0] : h.accessor}` : m) : h.accessor ? Array.isArray(h.accessor) ? `${I}.${h.accessor[0]}` : `${I}.${h.accessor}` : I;
        return (h == null ? void 0 : h.type) === "text" && (s === "create" || s === "edit") && $ ? { key: e, type: "relation", relation: true, accessor: "id", priority: 1 } : { ...h, fieldable: true, key: e, accessor: w2, priority: 1 };
      }
    }
    return { key: e, fieldable: false, type: "object", priority: 1 };
  }
  return false;
}, "objectInfer");
var mr = n((e, o) => typeof o == "string" && o.length > 100 ? { key: e, type: "richtext", priority: 1 } : false, "richtextInfer");
var lr = n((e, o) => typeof o == "string" ? { key: e, type: "text" } : false, "textInfer");
var Zr = /^(https?|ftp):\/\/(-\.)?([^\s/?\.#-]+\.?)+(\/[^\s]*)?$/i;
var dr = n((e, o) => typeof o == "string" && Zr.test(o) ? { key: e, type: "url", priority: 1 } : false, "urlInfer");
var fr = [rr, tr, or, ar, sr, ir, cr, pr, Ge, mr, lr, dr];
var gr = n((e, o, c, i2) => e.map((u) => {
  if (!u.relation && (u.type === "text" || u.type === "richtext" || u.type === "number") && !u.canRelation) {
    let y = /^[a-z0-9-]+$/, p = n((S) => y.test(`${S}`), "isValidUUID"), l = u.key.toLowerCase() !== "id";
    return !(!u.accessor || typeof u.accessor == "string") || !l ? u : (u.multiple ? i2[u.key] : [i2[u.key]]).every((S) => p(u.accessor ? S[u.accessor] : S)) ? { ...u, canRelation: true } : u;
  }
  return u;
}), "basicToRelation");
var Yr = /(image|photo|avatar|cover|thumbnail|icon)/i;
var yr = n((e) => e.map((c) => c.type === "url" && Yr.test(c.key) ? { ...c, type: "image" } : c), "imageByKey");
var hr = n((e, o) => e.map((i2) => {
  let s = Ee(i2, o);
  return s ? { ...i2, relation: true, type: "relation", resource: s } : i2;
}), "relationByResource");
var kr = n((e, o, c, i2, s, u) => e.map((p) => {
  if (p.relation && p.type === "relation" && !p.resource) {
    let l = p.accessor ? i2[p.key][p.accessor] : i2[p.key], $ = s(p.key, l, i2, s, u);
    if ($ && $.type !== "relation")
      return { ...p, fieldable: true, relation: false, type: $.type, canRelation: true };
  }
  return p;
}), "relationToFieldable");
var Ir = [yr, hr, kr, gr];
var xr = [["react", "React", import_react8.default], ["@refinedev/core", "RefineCore", esm_exports]];
var De2 = import_react8.default.createContext({});
var Oe = n(({ fetchError: e, code: o, additionalScope: c, errorComponent: i2 }) => {
  let s = (o && Pe(Le(o, [...xr, ...c ?? []].reduce((p, [l, $, I, L]) => L ? p : { ...p, [l]: $ }, {})))) ?? "", u = import_react8.default.useMemo(() => ({ React: import_react8.default, ...import_react8.default, ...[...xr, ...c ?? []].reduce((p, [l, $, I]) => ({ ...p, [$]: I }), {}) }), [c]), y = import_react8.default.useMemo(() => n(() => {
    let { error: l } = import_react8.default.useContext(De2);
    return i2 ? import_react8.default.createElement(i2, { error: l ? `<p>An error occured while rendering the generated component.You can check the generated code from the below "Show Code" button and fix the error manually.</p>
                                    <p>If you think this is a bug, please report the issue at <a target="_blank" rel="noopener noreferrer" href="https://github.com/refinedev/refine/issues">https://github.com/refinedev/refine/issues</a></p>
                                    <p>Exception:</p>
                                    <code>${l}</code>` : typeof e == "string" ? e : e ? `<p>Something went wrong while fetching the resource data.</p>
                                    <p>To learn more about the Inferencer, please check the <a href="https://refine.dev/docs/packages/documentation/inferencer/" target="_blank">documentation</a>.</p>` : void 0 }) : null;
  }, "LiveErrorComponent"), [i2, e]);
  return import_react8.default.createElement(LiveProvider, { Context: De2, code: s, scope: u, noInline: true }, !e && import_react8.default.createElement(LivePreview, { Context: De2 }), import_react8.default.createElement(y, null));
}, "LiveComponent");
var ie = n(({ code: e, loading: o }) => {
  let c = import_react9.default.useMemo(() => He(e ?? ""), [e]), [i2, s] = import_react9.default.useState(false), [u, y] = import_react9.default.useState(false), [p, l] = import_react9.default.useState(false), [$, I] = import_react9.default.useState(false), [L, S] = import_react9.default.useState(false);
  return import_react9.default.useEffect(() => {
    if (!o) {
      let h = setTimeout(() => {
        s(true);
      }, 300);
      return () => {
        clearTimeout(h);
      };
    }
    return () => {
    };
  }, [o]), import_react9.default.useEffect(() => {
    if (typeof window < "u") {
      let h = window.matchMedia("(max-width: 449px)");
      h.matches ? l(false) : l(true);
      let w2 = n(() => {
        h.matches ? l(false) : l(true);
      }, "handleResize");
      return window.addEventListener("resize", w2), () => {
        window.removeEventListener("resize", w2);
      };
    }
    return () => {
    };
  }, []), import_react9.default.useEffect(() => {
    if (typeof window < "u") {
      let h = window.matchMedia("(max-width: 1280px)");
      h.matches ? I(true) : I(false);
      let w2 = n(() => {
        h.matches ? I(true) : I(false);
      }, "handleResize");
      return window.addEventListener("resize", w2), () => {
        window.removeEventListener("resize", w2);
      };
    }
    return () => {
    };
  }, []), c && !o ? import_react9.default.createElement(import_react9.default.Fragment, null, p && import_react9.default.createElement("div", { className: "refine-inferencer--code-viewer", style: { position: "sticky", bottom: "24px", paddingTop: "24px", left: 0, right: 0, width: "100%", zIndex: 10, display: "flex", justifyContent: "center", transition: "all 0.2s ease", opacity: i2 && !u ? 1 : 0, transform: i2 && !u ? "translateY(0)" : "translateY(100px)" } }, import_react9.default.createElement("div", { style: { width: "calc(100% - calc(64px * 2))", maxWidth: "1080px", padding: "20px", backgroundColor: "#1A1A1A", boxShadow: "0px 4px 16px -4px rgba(0, 0, 0, 0.5), 0px 8px 32px -8px rgba(0, 0, 0, 0.35)", borderRadius: "16px", display: "flex", alignItems: "center", justifyContent: "space-between", flexDirection: $ ? "column" : "row", gap: "12px" } }, import_react9.default.createElement("div", { style: { display: "flex", alignItems: "flex-start", gap: "8px" } }, import_react9.default.createElement("div", null, import_react9.default.createElement(at2, null)), import_react9.default.createElement("div", { style: { fontSize: "14px", lineHeight: "20px", color: "#ffffff" } }, import_react9.default.createElement("p", { style: { padding: 0, margin: 0 } }, "Most of the page code is auto-generated by the", " ", import_react9.default.createElement("span", { style: { textDecoration: "underline" } }, "Inferencer"), " ", "feature, based on your backend data structure."), import_react9.default.createElement("p", { style: { padding: 0, margin: 0 } }, "While this is an excellent way to experiment with refine,", " ", import_react9.default.createElement("span", { style: { fontWeight: 600 } }, "it's not intended to be used on production.")))), import_react9.default.createElement("div", null, import_react9.default.createElement("button", { onPointerEnter: () => S(true), onPointerLeave: () => S(false), onClick: () => y(true), style: { appearance: "none", border: "none", padding: "10px 16px", borderRadius: "4px", display: "flex", alignItems: "center", justifyContent: "center", background: "#0080FF", color: "#ffffff", fontSize: "14px", lineHeight: "20px", fontWeight: 600, gap: "8px", cursor: "pointer", transition: "all 0.2s ease", transform: L ? "scale(1.025)" : void 0, filter: L ? "brightness(1.1)" : void 0 } }, import_react9.default.createElement(Fr, { style: { flexShrink: 0 } }), import_react9.default.createElement("span", null, "Show the auto-generated code"))))), import_react9.default.createElement(ot, { visible: u, onClose: () => y(false), code: c })) : null;
}, "SharedCodeViewer");
var ot = n(({ visible: e, onClose: o, code: c = "" }) => {
  let i2 = import_react9.default.useRef(null), [s, u] = import_react9.default.useState(false), [y, p] = import_react9.default.useState(false), [l, $] = import_react9.default.useState(false), [I, L] = import_react9.default.useState(false);
  import_react9.default.useEffect(() => {
    if (typeof document < "u") {
      let d2 = n((a) => {
        i2.current && !i2.current.contains(a.target) && o();
      }, "onOutsideClick");
      return document.addEventListener("pointerdown", d2), () => {
        document.removeEventListener("pointerdown", d2);
      };
    }
    return () => {
    };
  }, [o]);
  let S = n(() => {
    typeof navigator < "u" && (navigator.clipboard.writeText(c), u(true), setTimeout(() => {
      u(false);
    }, 1e3));
  }, "onCopy"), h = import_react9.default.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" } }, import_react9.default.createElement("div", { style: { fontWeight: 700, fontSize: "20px", lineHeight: "32px", color: "#0D0D0D" } }, "Auto-generated code by Inferencer"), import_react9.default.createElement("button", { onClick: o, onPointerEnter: () => $(true), onPointerLeave: () => $(false), style: { flexShrink: 0, appearance: "none", border: "none", background: "none", padding: 0, margin: 0, outline: "none", borderRadius: "50px", width: "32px", height: "32px", cursor: "pointer", transition: "all 0.15s ease", transform: l ? "scale(1.05)" : void 0, filter: l ? "brightness(0.8)" : void 0 } }, import_react9.default.createElement(st, null))), w2 = import_react9.default.createElement("div", { style: { fontSize: "13px", borderRadius: "8px", flex: "1", overflow: "scroll", background: "#1E1E1E" } }, import_react9.default.createElement(dist_default, { ...defaultProps, theme: vsDark_default, code: c, language: "tsx" }, ({ className: d2, style: a, tokens: b, getLineProps: H, getTokenProps: T }) => import_react9.default.createElement("pre", { className: d2, style: { ...a, padding: "14px 14px 14px 14px", margin: "0", width: "100%", boxSizing: "border-box" } }, b.map((z, K) => import_react9.default.createElement("div", { key: K, ...H({ line: z, key: K }) }, z.map((r, k) => import_react9.default.createElement("span", { key: k, ...T({ token: r, key: k }) })))))));
  return import_react9.default.createElement("div", { className: "refine-inferencer--code-viewer-modal", style: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 9999, backgroundColor: "rgba(0, 0, 0, 0.5)", transition: "all 0.2s ease", opacity: e ? 1 : 0, pointerEvents: e ? "all" : "none", display: "flex", justifyContent: "center", alignItems: "center" } }, import_react9.default.createElement("div", { ref: i2, style: { transform: e ? "scale(1) translateY(0px)" : "scale(0) translateY(-200px)", transition: "all 0.25s cubic-bezier(.35,1.29,.81,1.08)", transitionDelay: "0.25", width: "calc(100% - calc(32px * 2))", height: "calc(100% - calc(32px * 2))", backgroundColor: "#fff", maxWidth: "640px", maxHeight: "720px", borderRadius: "8px", padding: "16px" } }, import_react9.default.createElement("div", { style: { display: "flex", flexDirection: "column", height: "100%", width: "100%", gap: "16px" } }, h, w2, import_react9.default.createElement("div", { style: { display: "flex", justifyContent: "flex-start", alignItems: "flex-end", gap: "16px" } }, import_react9.default.createElement("button", { onPointerEnter: () => p(true), onPointerLeave: () => p(false), onClick: S, style: { appearance: "none", height: "40px", border: "none", padding: "10px 16px", borderRadius: "4px", display: "flex", alignItems: "center", justifyContent: "center", background: "#0080FF", color: "#ffffff", fontSize: "14px", lineHeight: "20px", fontWeight: 600, gap: "8px", cursor: "pointer", position: "relative", overflow: "hidden", transition: "filter 0.2s ease", transform: y ? "scale(1.025)" : "scale(1)", filter: y ? "brightness(1.1)" : void 0 } }, import_react9.default.createElement($r, { style: { flexShrink: 0, marginTop: "-2px", marginBottom: "-2px" } }), import_react9.default.createElement("span", null, "Copy Generated Code"), import_react9.default.createElement("div", { style: { position: "absolute", width: "100%", height: "100%", top: 0, left: 0, display: "flex", alignItems: "center", justifyContent: "center", background: "#0080FF", transition: "all 0.2s ease", transform: s ? "translateY(0)" : "translateY(40px)" } }, import_react9.default.createElement($r, { style: { flexShrink: 0, marginTop: "-2px", marginBottom: "-2px" } }), import_react9.default.createElement("span", null, "Copied!"))), import_react9.default.createElement("a", { onPointerEnter: () => L(true), onPointerLeave: () => L(false), href: "https://refine.dev/docs/packages/documentation/inferencer", target: "_blank", rel: "noreferrer", style: { appearance: "none", textDecoration: "none", border: "none", padding: "10px 16px", borderRadius: "4px", display: "flex", alignItems: "center", justifyContent: "center", background: "rgba(0, 128, 255, 0.1)", color: "#0080FF", fontSize: "14px", lineHeight: "20px", fontWeight: 600, gap: "8px", cursor: "pointer", transition: "all 0.2s ease", transform: I ? "scale(1.025)" : void 0, filter: I ? "brightness(1.1)" : void 0 } }, import_react9.default.createElement(Fr, { style: { flexShrink: 0 } }), import_react9.default.createElement("span", null, "Learn more about inferencer"))))));
}, "CodeModal");
var at2 = n((e) => import_react9.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, fill: "none", ...e }, import_react9.default.createElement("path", { fill: "#0080FF", fillRule: "evenodd", d: "M10 20C4.477 20 0 15.523 0 10S4.477 0 10 0s10 4.477 10 10-4.477 10-10 10Zm0-15a1.25 1.25 0 1 0 0 2.5A1.25 1.25 0 0 0 10 5Zm0 10c.69 0 1.25-.56 1.25-1.25V10a1.25 1.25 0 1 0-2.5 0v3.75c0 .69.56 1.25 1.25 1.25Z", clipRule: "evenodd" })), "InfoIcon");
var Fr = n((e) => import_react9.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...e }, import_react9.default.createElement("path", { fill: "currentColor", d: "M5 2a1 1 0 0 1 0 2H4v8h8v-1a1 1 0 1 1 2 0v1a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h1Z" }), import_react9.default.createElement("path", { fill: "currentColor", d: "M9 2a1 1 0 0 0 0 2h1.586L6.293 8.293a1 1 0 0 0 1.414 1.414L12 5.414V7a1 1 0 1 0 2 0V3a1 1 0 0 0-1-1H9Z" })), "OpenIcon");
var st = n((e) => import_react9.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 32, height: 32, fill: "none", ...e }, import_react9.default.createElement("path", { fill: "#A6A6A6", fillRule: "evenodd", d: "M16 32C7.163 32 0 24.837 0 16S7.163 0 16 0s16 7.163 16 16-7.163 16-16 16Zm-2.586-21.414a2 2 0 1 0-2.828 2.828L13.172 16l-2.586 2.586a2 2 0 1 0 2.828 2.828L16 18.828l2.586 2.586a2 2 0 1 0 2.828-2.828L18.828 16l2.586-2.586a2 2 0 1 0-2.828-2.828L16 13.172l-2.586-2.586Z", clipRule: "evenodd" })), "CloseIcon");
var $r = n((e) => import_react9.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, viewBox: "0 0 24 24", fill: "none", ...e }, import_react9.default.createElement("path", { fill: "currentColor", fillRule: "evenodd", d: "M8 5a3 3 0 0 0 3 3h2a3 3 0 0 0 3-3h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h1Zm0 7a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm1 3a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2H9Z", clipRule: "evenodd" }), import_react9.default.createElement("path", { fill: "currentColor", d: "M13 4a1 1 0 1 1 0 2h-2a1 1 0 1 1 0-2h2Z" })), "ClipboardIcon");
var br = n((e, o, c, i2) => {
  let { resource: s, id: u, resources: y } = N(o), p = c ?? u, l = re(), [$, I] = import_react10.default.useState(void 0), [L, S] = import_react10.default.useState(void 0), [h, w2] = import_react10.default.useState(void 0), [m, d2] = import_react10.default.useState(true), [a, b] = import_react10.default.useState(false), H = import_react10.default.useCallback(async (T) => {
    var r;
    let z = ke(s) ?? Te(s == null ? void 0 : s.name, void 0, y), K = l(z);
    b(true), I(void 0);
    try {
      if ((e === "list" || e === "create") && s) {
        let k = await K.getList({ resource: s == null ? void 0 : s.name, meta: ee((s == null ? void 0 : s.identifier) ?? (s == null ? void 0 : s.name), i2, ["getList"]) }), E = (r = k.data) == null ? void 0 : r[0];
        E || I(`<p>No records/data found for resource "${s == null ? void 0 : s.name}".</p>
                            <p>Please check your data provider and resource.</p>
                            <p>For more info, please check the <a href="https://refine.dev/docs/packages/documentation/inferencer/" target="_blank">documentation</a>.</p>`), S(E), w2(k.data), setTimeout(() => {
          b(false);
        }, 500);
      }
      if ((e === "edit" || e === "show") && T && s) {
        let E = (await K.getOne({ resource: s == null ? void 0 : s.name, id: T, meta: ee((s == null ? void 0 : s.identifier) ?? (s == null ? void 0 : s.name), i2, ["getOne"]) })).data;
        E || I(`<p>No records/data found for resource "${s == null ? void 0 : s.name}".</p>
                            <p>Please check your data provider and resource.</p>
                            <p>For more info, please check the <a href="https://refine.dev/docs/packages/documentation/inferencer/" target="_blank">documentation</a>.</p>`), S(E), setTimeout(() => {
          b(false);
        }, 500);
      }
    } catch (k) {
      console.warn("An error occured while fetching the resource data. Please check the error message below:", k), I(`<p>Something went wrong while fetching the resource data.</p>
                    <p>Please check your data provider and API for resource "${s == null ? void 0 : s.name}".</p>
                    <p>For more info, please check the <a href="https://refine.dev/docs/packages/documentation/inferencer/" target="_blank">documentation</a>.</p>`), setTimeout(() => {
        b(false);
      }, 500);
    }
  }, [e, l, s, y]);
  return import_react10.default.useEffect(() => {
    d2(false), !a && !L && H(p);
  }, [H, p]), { data: L, datas: h, loading: a, initial: m, error: $ };
}, "useInferFetch");
var Cr = n(({ record: e, fields: o, infer: c, meta: i2 }) => {
  let s = re(), [u, y] = import_react11.default.useState([]), [p, l] = import_react11.default.useState(true), [$, I] = import_react11.default.useState(false), L = import_react11.default.useCallback(async (S) => {
    console.groupCollapsed("@refinedev/inferencer is trying to detect relations");
    let h = [];
    I(true);
    try {
      let w2 = S.map(async (d2) => {
        var a, b, H, T, z;
        if (d2 && (d2.relation || d2.canRelation) && e) {
          if (d2.relationInfer)
            return d2;
          let K = ke(d2.resource), r = s(K), k = d2.multiple, E = Array.isArray(d2.accessor) ? void 0 : d2.multiple ? e[d2.key].map((M) => d2.accessor ? get_default(M, d2.accessor) : M)[0] : d2.accessor ? get_default(e[d2.key], d2.accessor) : e[d2.key];
          if (E && d2.resource)
            try {
              let M = {};
              if (k && r.getMany) {
                let { data: v2 } = await r.getMany({ resource: d2.resource.name, ids: [E], meta: ee(((a = d2.resource) == null ? void 0 : a.identifier) ?? ((b = d2.resource) == null ? void 0 : b.name), i2, ["getMany"]) });
                M = v2 == null ? void 0 : v2[0];
              } else {
                let { data: v2 } = await r.getOne({ resource: d2.resource.name, id: E, meta: ee(((H = d2.resource) == null ? void 0 : H.identifier) ?? ((T = d2.resource) == null ? void 0 : T.name), i2, k ? ["getMany", "getOne"] : ["getOne"]) });
                M = v2;
              }
              h.push({ status: "success", resource: d2.resource.name, field: d2.key });
              let t2 = c("__", M, {}, c);
              return { ...d2, relationInfer: t2 };
            } catch {
              return h.push({ status: "error", resource: d2.resource.name, field: d2.key }), { ...d2, relationInfer: null };
            }
          if (E) {
            let M, t2;
            try {
              let P = {};
              if (k && r.getMany) {
                let { data: C2 } = await ((z = r.getMany) == null ? void 0 : z.call(r, { resource: te(U(d2.key)), ids: [E], meta: ee(te(U(d2.key)), i2, ["getMany"]) }));
                P = C2 == null ? void 0 : C2[0];
              } else {
                let { data: C2 } = await r.getOne({ resource: te(U(d2.key)), id: E, meta: ee(te(U(d2.key)), i2, k ? ["getMany", "getOne"] : ["getOne"]) });
                P = C2;
              }
              h.push({ status: "success", resource: te(U(d2.key)), field: d2.key }), M = P, t2 = true;
            } catch {
              h.push({ status: "error", resource: te(U(d2.key)), field: d2.key });
              let C2 = {};
              try {
                if (k && r.getMany) {
                  let { data: B } = await r.getMany({ resource: q(U(d2.key)), meta: ee(q(U(d2.key)), i2, ["getMany"]), ids: [E] });
                  C2 = B == null ? void 0 : B[0];
                } else {
                  let { data: B } = await r.getOne({ resource: q(U(d2.key)), meta: ee(q(U(d2.key)), i2, k ? ["getMany", "getOne"] : ["getOne"]), id: E });
                  C2 = B;
                }
                h.push({ status: "success", resource: q(U(d2.key)), field: d2.key }), M = C2, t2 = false;
              } catch {
                return h.push({ status: "error", resource: q(U(d2.key)), field: d2.key }), { ...d2, relationInfer: null };
              }
            }
            let v2 = c("__", M, {}, c), R = U(d2.key);
            return { ...d2, relation: true, type: "relation", resource: { name: t2 ? te(R) : q(R) }, fieldable: false, canRelation: void 0, relationInfer: v2 };
          }
          return { ...d2, relationInfer: null };
        }
        return d2;
      }), m = await Promise.all(w2);
      y(m.filter((d2) => d2)), setTimeout(() => {
        I(false);
      }, 500);
    } catch {
      setTimeout(() => {
        I(false);
      }, 500);
    }
    setTimeout(() => {
      console.log(`Tried to detect relations with ${h.length} attempts and succeeded with ${h.filter((w2) => w2.status === "success").length} attempts.`), console.groupEnd(), console.info("@refinedev/inferencer may send multiple requests to your API for nonexistent resources when trying to detect relations. To learn more about how the inferencer works, visit https://s.refine.dev/how-inferencer-works");
    }, 500);
  }, [s, e]);
  return import_react11.default.useEffect(() => {
    l(false), !$ && o && o.length > 0 && u.length === 0 && L(o);
  }, [L, $, o, L]), { fields: u, loading: $, initial: p };
}, "useRelationFetch");
var ce = n(({ type: e, additionalScope: o = [], customElements: c = [], fieldTransformers: i2 = [], renderer: s, loadingComponent: u, errorComponent: y, codeViewerComponent: p }) => {
  let l = Xe([...fr, ...c]), $ = er([...Ir, ...i2]), I = n(({ resourceName: S, fieldTransformer: h, hideCodeViewerInProduction: w2, meta: m, id: d2 }) => {
    var _e, qe;
    let { resource: a, resources: b } = N(S), { i18nProvider: H } = (0, import_react7.useContext)(Ke), { resource: T } = N(), { data: z, datas: K, loading: r, initial: k, error: E } = br(e, S ?? (a == null ? void 0 : a.name), d2, m), M = n((N2, V, W) => {
      let G2 = l(N2, V, W, l, e);
      if (G2 && a) {
        let Z = $([G2], b, a, W, l, e), j2 = h ? Z.flatMap((D) => {
          let _ = h(D);
          return _ ? [_] : [];
        }) : Z;
        return j2 == null ? void 0 : j2[0];
      }
    }, "inferSingleField"), t2 = n((N2) => Object.keys(N2).map((W) => {
      let G2 = N2[W];
      return M(W, G2, N2);
    }).filter(Boolean), "inferSingleRecord"), v2 = n((N2) => {
      let V = N2.map((D) => t2(D)), W = N2.flatMap((D) => Object.keys(D)).filter((D, _, ye) => ye.indexOf(D) === _), G2 = {}, Z = W.map((D) => {
        let _ = V.map((ae) => ae.find((re2) => re2.key === D));
        return _.reduce((ae, re2, ve) => {
          if (!re2)
            return ae;
          let he = _.filter((se) => (se == null ? void 0 : se.key) === re2.key && (se == null ? void 0 : se.type) === re2.type).length;
          return he > ae.count ? (G2[D] = N2[ve][D], { count: he, field: re2 }) : ae;
        }, { count: 0, field: void 0 }).field;
      });
      return { commonRecord: G2, inferredFields: Z };
    }, "inferMultipleRecords"), [R, P] = import_react7.default.useMemo(() => {
      if (K && (e === "list" || e === "create")) {
        let N2 = v2(K);
        return [N2.inferredFields, N2.commonRecord];
      }
      if (z) {
        let N2 = Object.keys(z).map((V) => {
          let W = z[V];
          return l(V, W, z, l, e);
        }).filter(Boolean);
        if (a) {
          let V = $(N2, b, a, z, l, e);
          return [h ? V.flatMap((G2) => {
            let Z = h(G2);
            return Z ? [Z] : [];
          }) : V, z];
        }
        return [[], z];
      }
      return [[], void 0];
    }, [z, K, b, a, h]), { fields: C2, loading: B } = Cr({ record: P, fields: R, infer: l, meta: m }), le = import_react7.default.useMemo(() => {
      let N2 = [];
      return C2.forEach((V, W, G2) => {
        if (V.resource) {
          if (N2.findIndex((j2) => {
            var D, _;
            return ((D = j2.resource) == null ? void 0 : D.name) === ((_ = V.resource) == null ? void 0 : _.name);
          }) > -1)
            return;
          let Z = G2.filter((j2, D) => {
            var _, ye, ae, re2, ve, he;
            if (D !== W) {
              let se = V.resource, Pr = j2.resource, Lr = ((_ = j2.resource) == null ? void 0 : _.identifier) || ((ye = V.resource) == null ? void 0 : ye.identifier) ? ((ae = j2.resource) == null ? void 0 : ae.identifier) === ((re2 = V.resource) == null ? void 0 : re2.identifier) : ((ve = j2.resource) == null ? void 0 : ve.name) === ((he = V.resource) == null ? void 0 : he.name);
              return se && Pr && Lr;
            } else
              return false;
          });
          if (Z.length > 0)
            if (e === "create" || e === "edit") {
              let j2;
              [V, ...Z].find((D) => {
                D.fieldable !== true && j2 === void 0 && (j2 = D);
              }), j2 ? N2.push(j2) : N2.push(V);
            } else {
              let j2;
              [V, ...Z].find((D) => {
                D.fieldable !== false && j2 === void 0 && (j2 = D);
              }), j2 ? N2.push(j2) : N2.push(V);
            }
          else
            N2.push(V);
        } else
          N2.push(V);
      }), N2;
    }, [C2, e]), ge = import_react7.default.useMemo(() => !r && !B && !k && a ? s({ resource: a, resources: b, fields: le, infer: l, meta: m, isCustomPage: a.name !== (T == null ? void 0 : T.name), id: d2, i18n: !!H }) : "", [a, b, le, r, B]), Rr = w2;
    return import_react7.default.createElement(import_react7.default.Fragment, null, u && (r || B) && import_react7.default.createElement(u, null), !r && !B && import_react7.default.createElement(import_react7.default.Fragment, null, import_react7.default.createElement(Oe, { fetchError: !r && E ? E : !r && !k && !z, code: Me(ge, Y2(((_e = a == null ? void 0 : a.meta) == null ? void 0 : _e.label) ?? ((qe = a == null ? void 0 : a.options) == null ? void 0 : qe.label) ?? (a == null ? void 0 : a.label) ?? (a == null ? void 0 : a.name) ?? "Resource", e)), errorComponent: y, additionalScope: o }), typeof p < "u" && !Rr ? import_react7.default.createElement(p, { code: Ne(ge), loading: r || B }) : null));
  }, "Inferencer");
  return n(({ name: S, resource: h, fieldTransformer: w2, meta: m, hideCodeViewerInProduction: d2, id: a }) => {
    let { resource: b } = N(h ?? S), H = `${(b == null ? void 0 : b.identifier) ?? (b == null ? void 0 : b.name)}-${e}-${a}`;
    return import_react7.default.createElement(I, { hideCodeViewerInProduction: d2, fieldTransformer: w2, resourceName: h ?? S, meta: m ?? {}, key: H, id: a });
  }, "InferencerComponent");
}, "createInferencer");
var ue = n(({ error: e }) => e ? import_react12.default.createElement(Center, { style: { minHeight: 300 } }, import_react12.default.createElement(Alert, { status: "error", variant: "subtle", flexDirection: "column", alignItems: "center", justifyContent: "center", textAlign: "center", height: "200px", maxWidth: "700px" }, import_react12.default.createElement(AlertIcon, { boxSize: "40px", mr: 0 }), import_react12.default.createElement(AlertDescription, { mt: 4, maxWidth: "sm" }, import_react12.default.createElement("div", { dangerouslySetInnerHTML: { __html: e ?? "" } })))) : null, "ErrorComponent");
var pe = n(() => import_react14.default.createElement(Box, { position: "relative", bg: "chakra-body-bg", minH: 120 }, import_react14.default.createElement(Spinner, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)" })), "LoadingComponent");
var wr = n(({ resource: e, fields: o, meta: c, isCustomPage: i2, id: s, i18n: u }) => {
  let y = Y2(e.label ?? e.name, "show"), p = "record", l = [["useShow", "@refinedev/core"], ["IResourceComponentsProps", "@refinedev/core"], ["Show", "@refinedev/chakra-ui"], ["Heading", "@chakra-ui/react"]];
  u && l.push(["useTranslate", "@refinedev/core"]);
  let I = o.filter((r) => (r == null ? void 0 : r.relation) && !(r != null && r.fieldable) && (r == null ? void 0 : r.resource)).filter(Boolean).map((r) => {
    var k, E, M, t2;
    if (r != null && r.relation && !r.fieldable && r.resource) {
      if (r.multiple) {
        l.push(["useMany", "@refinedev/core"]);
        let v2 = f(p, r.key);
        return r.accessor && (v2 = `${f(p, r.key)}?.map((item: any) => ${f("item", void 0, r.accessor)})`), `
                const { data: ${A(r.key, "Data")}, isLoading: ${A(r.key, "IsLoading")} } =
                useMany({
                    resource: "${r.resource.name}",
                    ids: ${v2} || [],
                    queryOptions: {
                        enabled: !!${p} && !!${v2}?.length,
                    },
                    ${O(((k = r == null ? void 0 : r.resource) == null ? void 0 : k.identifier) ?? ((E = r == null ? void 0 : r.resource) == null ? void 0 : E.name), c, "getMany")}
                });
                `;
      }
      return l.push(["useOne", "@refinedev/core"]), `
                const { data: ${A(r.key, "Data")}, isLoading: ${A(r.key, "IsLoading")} } =
                useOne({
                    resource: "${r.resource.name}",
                    id: ${f(p, r.key, r.accessor, false)} || "",
                    queryOptions: {
                        enabled: !!${p},
                    },
                    ${O(((M = r == null ? void 0 : r.resource) == null ? void 0 : M.identifier) ?? ((t2 = r == null ? void 0 : r.resource) == null ? void 0 : t2.name), c, "getOne")}
                });
            `;
    }
  }).filter(Boolean), L = n((r) => {
    if (r.relation && r.resource) {
      let k = A(r.key, "Data"), E = A(r.key, "IsLoading");
      if (r.multiple) {
        let M = f(p, r.key) + "?.length";
        return l.push(["TagField", "@refinedev/chakra-ui"], ["HStack", "@chakra-ui/react"]), x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                {${E} && ${M} ? <>Loading...</> : (
                    <>
                    ${(() => {
          var t2;
          if (r.relationInfer)
            if ((t2 = r.relationInfer) != null && t2.accessor) {
              if (Array.isArray(r.relationInfer.accessor))
                return "Not Handled.";
              {
                let v2 = A(r.key), R = f(v2, void 0, r.relationInfer.accessor);
                return `{record?.${r.key}?.length ? <HStack spacing="12px">{${k}?.data?.map((${v2}: any) => <TagField key={${R}} value={${R}} />)}</HStack> : <></>}`;
              }
            } else
              return "Not Handled.";
          else
            return "not-handled - relation with multiple but no resource";
        })()}
                    </>
                )}
                `;
      }
      return r.fieldable ? x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <TextField value={${f(p, r.key, r.accessor)}} />
                ` : x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                {${E} ? <>Loading...</> : (
                    <>
                    ${(() => {
        var M;
        return r.relationInfer ? (M = r.relationInfer) != null && M.accessor ? Array.isArray(r.relationInfer.accessor) ? `{${f(`${k}?.data`, void 0, r.relationInfer.accessor, ' + " " + ')}}` : `{${k}?.data?.${r.relationInfer.accessor}}` : `{${k}?.data}` : `{${k}?.data?.id}`;
      })()}
                    </>
                )}
                
                `;
    }
  }, "renderRelationFields"), S = n((r) => {
    if (r.type === "text") {
      if (l.push(["TagField", "@refinedev/chakra-ui"], ["TextField", "@refinedev/chakra-ui"], ["HStack", "@chakra-ui/react"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <HStack spacing="12px">
                {${f(p, r.key)}?.map((item: any) => (
                    <TagField value={${k}} key={${k}} />
                ))}
                </HStack>
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <TextField value={${f(p, r.key, r.accessor)}} />
            `;
    }
  }, "textFields"), h = n((r) => {
    if (r.type === "image") {
      if (l.push(["Image", "@chakra-ui/react"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                {${f(p, r.key)}?.map((item: any) => (
                    <Image sx={{ maxWidth: 200 }} src={${k}} key={${k}} />
                ))}
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <Image sx={{ maxWidth: 200 }} src={${f(p, r.key, r.accessor, " + ")}} />
                `;
    }
  }, "imageFields"), w2 = n((r) => {
    if (r.type === "email") {
      if (l.push(["TagField", "@refinedev/chakra-ui"], ["EmailField", "@refinedev/chakra-ui"], ["HStack", "@chakra-ui/react"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <HStack spacing="12px">
                {${f(p, r.key)}?.map((item: any) => (
                    <TagField value={${k}} key={${k}} />
                ))}
                </HStack>
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <EmailField value={${f(p, r.key, r.accessor, " + ")}} />
            `;
    }
  }, "emailFields"), m = n((r) => {
    if (r.type === "url") {
      if (l.push(["TagField", "@refinedev/chakra-ui"], ["UrlField", "@refinedev/chakra-ui"], ["HStack", "@chakra-ui/react"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <HStack spacing="12px">
                {${f(p, r.key)}?.map((item: any) => (
                    <TagField value={${k}} key={${k}} />
                ))}
                </HStack>
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <UrlField value={${f(p, r.key, r.accessor, " + ")}} />
            `;
    }
  }, "urlFields"), d2 = n((r) => {
    if (r.type === "boolean") {
      if (l.push(["TagField", "@refinedev/chakra-ui"], ["BooleanField", "@refinedev/chakra-ui"], ["HStack", "@chakra-ui/react"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <HStack spacing="12px">
                {${f(p, r.key)}?.map((item: any) => (
                    <TagField value={${k}} key={${k}} />
                ))}
                </HStack>
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <BooleanField value={${f(p, r.key, r.accessor, " && ")}} />
            `;
    }
  }, "booleanFields"), a = n((r) => {
    if (r.type === "date") {
      if (l.push(["DateField", "@refinedev/chakra-ui"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                {${f(p, r.key)}?.map((item: any) => (
                    <DateField value={${k}} key={${k}} />
                ))}
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <DateField value={${f(p, r.key, r.accessor, " + ' ' + ")}} />
            `;
    }
  }, "dateFields"), b = n((r) => {
    if (r.type === "richtext")
      return l.push(["MarkdownField", "@refinedev/chakra-ui"]), x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <MarkdownField value={${f(p, r.key, r.accessor, ' + " " + ')}} />
            `;
  }, "richtextFields"), H = n((r) => {
    if (r.type === "number") {
      if (l.push(["NumberField", "@refinedev/chakra-ui"], ["TagField", "@refinedev/chakra-ui"], ["HStack", "@chakra-ui/react"]), r.multiple) {
        let k = f("item", void 0, r.accessor);
        return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <HStack spacing="12px">
                {${f(p, r.key)}?.map((item: any) => (
                    <TagField value={${k}} key={${k}} />
                ))}
                </HStack>
            `;
      }
      return x`
                <Heading as="h5" size="sm" mt={4}>${F({ resource: e, field: r, i18n: u, noQuotes: true })}</Heading>
                <NumberField value={${f(p, r.key, r.accessor, ' + " " + ')} ?? ""} />
            `;
    }
  }, "numberFields"), T = n((r) => {
    if (r)
      return x`
                ${r}
            `;
  }, "wrapper"), z = o.map((r) => {
    switch (r == null ? void 0 : r.type) {
      case "text":
        return T(S(r));
      case "number":
        return T(H(r));
      case "richtext":
        return T(b(r));
      case "email":
        return T(w2(r));
      case "image":
        return T(h(r));
      case "date":
        return T(a(r));
      case "boolean":
        return T(d2(r));
      case "url":
        return T(m(r));
      case "relation":
        return T(L(r));
      default:
        return;
    }
  });
  oe(l);
  let K = u && "const translate = useTranslate();";
  return x`
    ${ne(l)}
    
    export const ${y}: React.FC<IResourceComponentsProps> = () => {
        ${K}
        const { queryResult } = useShow(${i2 ? `{ 
                    resource: "${e.name}", 
                    id: ${$e(s)},
                    ${O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getOne")}
                }` : O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getOne") ? `{ ${O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getOne")} }` : ""});
        const { data, isLoading } = queryResult;

        const ${p} = data?.data;
    
        ${I}

        return (
            <Show isLoading={isLoading}>
                ${z.join("")}
            </Show>
        );
    };
    `;
}, "renderer");
var je = ce({ type: "show", additionalScope: [["@refinedev/chakra-ui", "RefineChakraUI", { Show: zm, TagField: Oc, TextField: Nc, EmailField: Yc, UrlField: Vt, BooleanField: Rc, DateField: ig, MarkdownField: kg, NumberField: Bg }], ["@chakra-ui/react", "ChakraUI", { Heading, HStack, Image }]], codeViewerComponent: ie, loadingComponent: pe, errorComponent: ue, renderer: wr });
var me = n((e) => Array.isArray(e.accessor) || e.multiple ? `accessorKey: "${e.key}"` : e.accessor ? `accessorKey: "${Q(e.key, void 0, e.accessor)}"` : `accessorKey: "${e.key}"`, "getAccessorKey");
var Tr2 = n(({ resource: e, fields: o, meta: c, isCustomPage: i2, i18n: s }) => {
  let u = Y2(e.label ?? e.name, "list"), y = "tableData?.data", p = [["IResourceComponentsProps", "@refinedev/core"], ["useTable", "@refinedev/react-table"], ["ColumnDef", "@tanstack/react-table"], ["flexRender", "@tanstack/react-table"], ["List", "@refinedev/chakra-ui"], ["TableContainer", "@chakra-ui/react"], ["Table", "@chakra-ui/react"], ["Thead", "@chakra-ui/react"], ["Tr", "@chakra-ui/react"], ["Th", "@chakra-ui/react"], ["Tbody", "@chakra-ui/react"], ["Td", "@chakra-ui/react"], ["HStack", "@chakra-ui/react"], ["Button", "@chakra-ui/react"], ["IconButton", "@chakra-ui/react"], ["usePagination", "@refinedev/chakra-ui"], ["Box", "@chakra-ui/react"], ["IconChevronRight", "@tabler/icons"], ["IconChevronLeft", "@tabler/icons"]];
  s && p.push(["useTranslate", "@refinedev/core"]);
  let l = o.filter((t2) => (t2 == null ? void 0 : t2.relation) && !(t2 != null && t2.fieldable) && (t2 == null ? void 0 : t2.resource)), $ = l.filter(Boolean).map((t2) => {
    var v2, R;
    if (t2 != null && t2.relation && !t2.fieldable && t2.resource) {
      p.push(["GetManyResponse", "@refinedev/core"]), p.push(["useMany", "@refinedev/core"]);
      let P = "";
      return t2.multiple ? P = `[].concat(...(${y}?.map((item) => ${f("item", t2.key, t2.accessor, false)}) ?? []))` : P = `${y}?.map((item) => ${f("item", t2.key, t2.accessor, false)}) ?? []`, `
                const { data: ${A(t2.key, "Data")} } =
                useMany({
                    resource: "${t2.resource.name}",
                    ids: ${P},
                    queryOptions: {
                        enabled: !!${y},
                    },
                    ${O(((v2 = t2 == null ? void 0 : t2.resource) == null ? void 0 : v2.identifier) ?? ((R = t2 == null ? void 0 : t2.resource) == null ? void 0 : R.name), c, "getMany")}
                });
                `;
    }
  }).filter(Boolean), I = l == null ? void 0 : l.map((t2) => {
    if (t2 && t2.resource)
      return A(t2.key, "Data");
  }).filter(Boolean), L = n((t2) => {
    var v2;
    if (t2.relation && t2.resource) {
      let R = `${A(t2.key, "Data")}?.data`;
      if (Array.isArray(t2.accessor))
        return;
      let P = `id: "${t2.key}"`, C2 = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, B = me(t2), le = "";
      if (t2.multiple) {
        p.push(["TagField", "@refinedev/chakra-ui"]);
        let ge = "item";
        t2 != null && t2.relationInfer && (ge = f("item", void 0, t2.relationInfer.accessor)), le = `cell: function render({ getValue, table }) {
                    const meta = table.options.meta as {
                        ${A(t2.key, "Data")}: GetManyResponse;
                    };

                    const ${A(t2.key, "")} = getValue<any[]>()?.map((item) => {
                        return meta.${A(t2.key, "Data")}?.data?.find(
                            (resourceItems) => resourceItems.id === ${f("item", void 0, t2.accessor)}
                        );
                    })


                    return (
                        <HStack>
                            {${A(t2.key, "")}?.map((item, index) => (
                                <TagField key={index} value={${ge}} />
                            ))}
                        </HStack>
                    )
                }
            `;
      } else
        t2 != null && t2.relationInfer ? le = `cell: function render({ getValue, table }) {
                        const meta = table.options.meta as {
                            ${A(t2.key, "Data")}: GetManyResponse;
                        };

                        const ${A(t2.key, "")} = meta.${R}?.find(
                            (item) => item.id == getValue<any>(),
                        );

                        return ${f(A(t2.key), void 0, (v2 = t2 == null ? void 0 : t2.relationInfer) == null ? void 0 : v2.accessor)} ?? "Loading...";
                    },` : le = "";
      return `
                {
                    ${P},
                    ${C2},
                    ${B},
                    ${le}
                }
            `;
    }
  }, "renderRelationFields"), S = n((t2) => {
    if (t2.type === "image") {
      p.push(["Image", "@chakra-ui/react"]);
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = x`
                cell: function render({ getValue }) {
                    ${t2 != null && t2.accessor ? "try {" : ""}
                        return <Image sx={{ maxWidth: "100px" }} src={${f("getValue<any>()", void 0, Array.isArray(t2.accessor) ? t2.accessor : void 0, " + ")}} />
                    ${t2 != null && t2.accessor ? " } catch (error) { return null; }" : ""}
                }
            `;
      if (t2.multiple) {
        let B = f("item", void 0, t2.accessor, " + ");
        C2 = `
                    cell: function render({ getValue }) {
                        ${t2 != null && t2.accessor ? "try {" : ""}
                            return (
                                <HStack>
                                    {getValue<any[]>()?.map((item, index) => (
                                        <Image src={${B}} key={index} sx={{ height: "50px", maxWidth: "100px" }} />
                                    ))}
                                </HStack>
                            )
                        ${t2 != null && t2.accessor ? " } catch (error) { return null; }" : ""}
                    }
                `;
      }
      return `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "imageFields"), h = n((t2) => {
    if (t2.type === "email") {
      p.push(["EmailField", "@refinedev/chakra-ui"]);
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = x`
                cell: function render({ getValue }) {
                    return <EmailField value={${f("getValue<any>()", void 0, Array.isArray(t2.accessor) ? t2.accessor : void 0, ' + " " + ')}} />
                }
            `;
      return t2.multiple && (p.push(["TagField", "@refinedev/chakra-ui"]), C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <HStack>
                                {getValue<any[]>()?.map((item, index) => (
                                    <TagField value={${f("item", void 0, t2.accessor, " + ")}} key={index} />
                                ))}
                            </HStack>
                        )
                    }
                `), `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "emailFields"), w2 = n((t2) => {
    if (t2.type === "url") {
      p.push(["UrlField", "@refinedev/chakra-ui"]);
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = x`
                cell: function render({ getValue }) {
                    return <UrlField value={${f("getValue<any>()", void 0, Array.isArray(t2.accessor) ? t2.accessor : void 0, " + ")}} />
                }
            `;
      return t2.multiple && (p.push(["TagField", "@refinedev/chakra-ui"]), C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <HStack>
                                {getValue<any[]>()?.map((item, index) => (
                                    <TagField value={${f("item", void 0, t2.accessor, " + ")}} key={index} />
                                ))}
                            </HStack>
                        )
                    }
                `), `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "urlFields"), m = n((t2) => {
    if ((t2 == null ? void 0 : t2.type) === "boolean") {
      p.push(["BooleanField", "@refinedev/chakra-ui"]);
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = x`
                cell: function render({ getValue }) {
                    return <BooleanField value={${f("getValue<any>()", void 0, Array.isArray(t2.accessor) ? t2.accessor : void 0, " + ")}} />
                }
            `;
      return t2.multiple && (C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <HStack>
                                {getValue<any[]>()?.map((item, index) => (
                                    <BooleanField value={${f("item", void 0, t2.accessor, " + ")}} key={index} />
                                ))}
                            </HStack>
                        )
                    }
                `), `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "booleanFields"), d2 = n((t2) => {
    if (t2.type === "date") {
      p.push(["DateField", "@refinedev/chakra-ui"]);
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = x`
                cell: function render({ getValue }) {
                    return <DateField value={${f("getValue<any>()", void 0, Array.isArray(t2.accessor) ? t2.accessor : void 0, ' + " " + ')}} />
                }
            `;
      return t2.multiple && (C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <HStack>
                                {getValue<any[]>()?.map((item, index) => (
                                    <DateField value={${f("item", void 0, t2.accessor, " + ")}} key={index} />
                                ))}
                            </HStack>
                        )
                    }
                `), `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "dateFields"), a = n((t2) => {
    if ((t2 == null ? void 0 : t2.type) === "richtext") {
      p.push(["MarkdownField", "@refinedev/chakra-ui"]);
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = x`
                cell: function render({ getValue }) {
                    return <MarkdownField value={(${f("getValue<string>()", void 0, Array.isArray(t2.accessor) ? t2.accessor : void 0)})?.slice(0, 80) + "..." } />
                }
            `;
      return t2.multiple && (C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <HStack>
                                {getValue<string[]>()?.map((item, index) => (
                                    <MarkdownField value={${f("item", void 0, t2.accessor, " + ")}} key={index} />
                                ))}
                            </HStack>
                        )
                    }
                `), `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "richtextFields"), b = n((t2) => {
    if (t2 && (t2.type === "text" || t2.type === "number")) {
      let v2 = `id: "${t2.key}"`, R = me(t2), P = `header: ${F({ resource: e, field: t2, i18n: s, noBraces: true })}`, C2 = "";
      return t2.multiple && (p.push(["TagField", "@refinedev/chakra-ui"]), C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <HStack>
                                {getValue<any[]>()?.map((item, index) => (
                                    <TagField value={${f("item", void 0, t2.accessor, ' + " " + ')}} key={index} />
                                ))}
                            </HStack>
                        )
                    }
                `), !t2.multiple && Array.isArray(t2.accessor) && (C2 = `
                    cell: function render({ getValue }) {
                        return (
                            <>{${f("getValue<any>()", t2.key, t2.accessor)}}</>
                        );
                    }
                `), `
                {
                    ${v2},
                    ${R},
                    ${P},
                    ${C2}
                }
            `;
    }
  }, "basicFields"), { canEdit: H, canShow: T, canDelete: z, meta: K } = e ?? {}, r = z || (K == null ? void 0 : K.canDelete);
  H && p.push(["EditButton", "@refinedev/chakra-ui"]), T && p.push(["ShowButton", "@refinedev/chakra-ui"]), r && p.push(["DeleteButton", "@refinedev/chakra-ui"]);
  let k = H || T || r ? x`
    {
        id: "actions",
        accessorKey: "id",
        header: "Actions",
        cell: function render({ getValue }) {
            return (
                <HStack>
                ${T ? x`
                    <ShowButton
                        hideText
                        recordItemId={getValue() as string}
                    />
                    ` : ""}
                    ${H ? x`
                    <EditButton
                        hideText
                        recordItemId={getValue() as string}
                    />
                    ` : ""}
                    ${r ? x`
                    <DeleteButton
                        hideText
                        recordItemId={getValue() as string}
                    />
                    ` : ""}
                </HStack>
            );
        },
    },
        ` : "", E = o.map((t2) => {
    switch (t2 == null ? void 0 : t2.type) {
      case "text":
      case "number":
        return b(t2);
      case "richtext":
        return a(t2);
      case "email":
        return h(t2);
      case "image":
        return S(t2);
      case "date":
        return d2(t2);
      case "boolean":
        return m(t2);
      case "url":
        return w2(t2);
      case "relation":
        return L(t2);
      default:
        return;
    }
  });
  oe(p);
  let M = s && "const translate = useTranslate();";
  return x`
    import React from "react";
    ${ne(p)}
    
    export const ${u}: React.FC<IResourceComponentsProps> = () => {
        ${M}
        const columns = React.useMemo<ColumnDef<any>[]>(() => [
            ${[...E, k].filter(Boolean).join(",")}
        ], [${s ? "translate" : ""}]);

        const {
            getHeaderGroups,
            getRowModel,
            setOptions,
            refineCore: {
                setCurrent,
                pageCount,
                current,
                tableQueryResult: { data: tableData },
            },
        } = useTable({
            columns,
            ${i2 ? `
            refineCoreProps: {
                resource: "${e.name}",
                ${O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getList")}
            }
            ` : O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getList") ? `refineCoreProps: { ${O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getList")} },` : ""}
            
        });

        ${$}

        setOptions((prev) => ({
            ...prev,
            meta: {
                ...prev.meta,
                ${I.join(", ")}
            },
        }));

        return (
            <List>
                <TableContainer whiteSpace="pre-line">
                    <Table variant="simple">
                        <Thead>
                            {getHeaderGroups().map((headerGroup) => (
                                <Tr key={headerGroup.id}>
                                    {headerGroup.headers.map((header) => (
                                        <Th key={header.id}>
                                            {!header.isPlaceholder && (
                                                flexRender(
                                                    header.column.columnDef
                                                        .header,
                                                    header.getContext(),
                                                )
                                            )}
                                        </Th>
                                    ))}
                                </Tr>
                            ))}
                        </Thead>
                        <Tbody>
                            {getRowModel().rows.map((row) => (
                                <Tr key={row.id}>
                                    {row.getVisibleCells().map((cell) => (
                                        <Td key={cell.id}>
                                            {flexRender(
                                                cell.column.columnDef.cell,
                                                cell.getContext(),
                                            )}
                                        </Td>
                                    ))}
                                </Tr>
                            ))}
                        </Tbody>
                    </Table>
                </TableContainer>
                <Pagination
                    current={current}
                    pageCount={pageCount}
                    setCurrent={setCurrent}
                />
            </List>   
        );
    };

    type PaginationProps = {
        current: number;
        pageCount: number;
        setCurrent: (page: number) => void;
    };

    const Pagination: React.FC<PaginationProps> = ({
        current,
        pageCount,
        setCurrent,
    }) => {
        const pagination = usePagination({
            current,
            pageCount,
        });
    
        return (
            <Box display="flex" justifyContent="flex-end">
                <HStack my="3" spacing="1">
                    {pagination?.prev && (
                        <IconButton
                            aria-label="previous page"
                            onClick={() => setCurrent(current - 1)}
                            disabled={!pagination?.prev}
                            variant="outline"
                        >
                            <IconChevronLeft size="18" />
                        </IconButton>
                    )}
    
                    {pagination?.items.map((page) => {
                        if (typeof page === "string")
                            return <span key={page}>...</span>;
    
                        return (
                            <Button
                                key={page}
                                onClick={() => setCurrent(page)}
                                variant={page === current ? "solid" : "outline"}
                            >
                                {page}
                            </Button>
                        );
                    })}
                    {pagination?.next && (
                        <IconButton
                            aria-label="next page"
                            onClick={() => setCurrent(current + 1)}
                            variant="outline"
                        >
                            <IconChevronRight size="18" />
                        </IconButton>
                    )}
                </HStack>
            </Box>
        );
    };
    `;
}, "renderer");
var Ue = ce({ type: "list", additionalScope: [["@refinedev/chakra-ui", "RefineChakraUI", { List: Bm, usePagination: hp, TagField: Oc, EmailField: Yc, UrlField: Vt, BooleanField: Rc, DateField: ig, MarkdownField: kg, EditButton: fo, ShowButton: La, DeleteButton: De }], ["@refinedev/react-table", "RefineReactTable", { useTable: Y }], ["@tabler/icons", "TablerIcons", { IconChevronRight: zq, IconChevronLeft: xq }], ["@chakra-ui/react", "ChakraUI", { TableContainer, Table, Thead, Tr, Th, Tbody, Td, HStack, Button, IconButton, Box, Image }], ["@tanstack/react-table", "TanstackReactTable", { flexRender }]], codeViewerComponent: ie, loadingComponent: pe, errorComponent: ue, renderer: Tr2 });
var Ar = n(({ resource: e, fields: o, meta: c, isCustomPage: i2, i18n: s }) => {
  let u = Y2(e.label ?? e.name, "create"), y = [["IResourceComponentsProps", "@refinedev/core"], ["Create", "@refinedev/chakra-ui"], ["FormControl", "@chakra-ui/react"], ["FormLabel", "@chakra-ui/react"], ["FormErrorMessage", "@chakra-ui/react"], ["useForm", "@refinedev/react-hook-form"]];
  s && y.push(["useTranslate", "@refinedev/core"]);
  let l = o.filter((m) => (m == null ? void 0 : m.relation) && !(m != null && m.fieldable) && (m == null ? void 0 : m.resource)).filter(Boolean).map((m) => {
    var d2, a;
    if (m != null && m.relation && !m.fieldable && m.resource)
      return y.push(["useSelect", "@refinedev/core"]), `
                const { options: ${A(m.key, "Options")} } =
                useSelect({
                    resource: "${m.resource.name}",
                    ${xe(m)}
                    ${O(((d2 = m == null ? void 0 : m.resource) == null ? void 0 : d2.identifier) ?? ((a = m == null ? void 0 : m.resource) == null ? void 0 : a.name), c, "getList")}
                });
            `;
  }).filter(Boolean), $ = n((m) => {
    if (m.relation && m.resource) {
      y.push(["useSelect", "@refinedev/core"]), y.push(["Select", "@chakra-ui/react"]);
      let d2 = A(m.key, "Options");
      return x`
            <FormControl mb="3" isInvalid={!!errors?.${Q(m.key, void 0)}}>
                <FormLabel>${F({ resource: e, field: m, i18n: s, noQuotes: true })}</FormLabel>
                <Select
                    placeholder="Select ${q(m.resource.name)}"
                    {...register("${Q(m.key, void 0, m.accessor)}", {
                        required: "This field is required",
                    })}
                >
                    {${d2}?.map((option) => (
                        <option value={option.value} key={option.value}>
                            {option.label}
                        </option>
                    ))}
                </Select>
                <FormErrorMessage>
                    {${f("(errors as any)", m.key, m.accessor, false)}?.message as string}
                </FormErrorMessage>
            </FormControl>
            `;
    }
  }, "renderRelationFields"), I = n((m) => {
    if (m.type === "text" || m.type === "url" || m.type === "email" || m.type === "number" || m.type === "date" || m.type === "richtext")
      return Ie(m.key) || (y.push(["Input", "@chakra-ui/react"]), m.multiple) ? void 0 : x`
                <FormControl mb="3" isInvalid={!!${f("(errors as any)", m.key, m.accessor, false)}}>
                    <FormLabel>${F({ resource: e, field: m, i18n: s, noQuotes: true })}</FormLabel>
                    <Input
                        ${m.type !== "date" && m.type !== "richtext" ? `type="${m.type}"` : ""}
                        {...register("${Q(m.key, void 0, m.accessor)}", {
                            required: "This field is required",
                            ${m.type === "number" ? "valueAsNumber: true," : ""}
                        })}
                    />
                    <FormErrorMessage>
                        {${f("(errors as any)", m.key, m.accessor, false)}?.message as string}
                    </FormErrorMessage>
                </FormControl>
            `;
  }, "basicInputFields"), L = n((m) => {
    if (m.type === "boolean")
      return y.push(["Checkbox", "@chakra-ui/react"]), m.multiple ? void 0 : x`
                <FormControl mb="3" isInvalid={!!${f("errors", m.key, m.accessor, false)}}>
                    <FormLabel>${F({ resource: e, field: m, i18n: s, noQuotes: true })}</FormLabel>
                    <Checkbox
                        {...register("${Q(m.key, void 0, m.accessor)}", {
                            required: "This field is required",
                        })}
                    />
                    <FormErrorMessage>
                        {${f("errors", m.key, m.accessor, false)}?.message as string}
                    </FormErrorMessage>
                </FormControl>
               
            `;
  }, "booleanFields"), S = n((m) => {
    if (m.type === "date")
      return `
                {/* 
                    DatePicker component is not included in "@refinedev/chakra-ui" package.
                    To use a <DatePicker> component, you can examine the following links:
                    
                    - https://github.com/aboveyunhai/chakra-dayzed-datepicker
                    - https://github.com/wojtekmaj/react-date-picker
                */}
                ${I(m) ?? ""}
                `;
  }, "dateFields"), h = o.map((m) => {
    switch (m == null ? void 0 : m.type) {
      case "text":
      case "number":
      case "email":
      case "url":
      case "richtext":
        return I(m);
      case "date":
        return S(m);
      case "boolean":
        return L(m);
      case "relation":
        return $(m);
      default:
        return;
    }
  });
  oe(y);
  let w2 = s && "const translate = useTranslate();";
  return x`
    ${ne(y)}
    
    export const ${u}: React.FC<IResourceComponentsProps> = () => {
        ${w2}
        const {
            refineCore: { formLoading },
            saveButtonProps,
            register,
            formState: { errors },
        } = useForm(
            ${i2 ? `
            { 
                refineCoreProps: {
                    resource: "${e.name}",
                    action: "create",
                    ${O(e.identifier ?? e.name, c, "getOne")}
                }
            }` : O(e.identifier ?? e.name, c, "getOne") ? `{
                        refineCoreProps: { ${O(e.identifier ?? e.name, c, "getOne")} }
                        }` : ""}
        );
    
        ${l}

        return (
            <Create isLoading={formLoading} saveButtonProps={saveButtonProps}>
                ${h.join("")}
            </Create>
        );
    };
    `;
}, "renderer");
var Ke2 = ce({ type: "create", additionalScope: [["@refinedev/chakra-ui", "RefineChakraUI", { Create: tf }], ["@refinedev/react-hook-form", "RefineReactHookForm", { useForm: C }], ["@chakra-ui/react", "ChakraUI", { FormControl, FormLabel, FormErrorMessage, Select, Input, Checkbox }]], codeViewerComponent: ie, loadingComponent: pe, errorComponent: ue, renderer: Ar });
var Hr = n(({ resource: e, fields: o, meta: c, isCustomPage: i2, id: s, i18n: u }) => {
  let y = Y2(e.label ?? e.name, "edit"), p = A(e.label ?? e.name, "Data"), l = [["React", "react", true], ["IResourceComponentsProps", "@refinedev/core"], ["Edit", "@refinedev/chakra-ui"], ["FormControl", "@chakra-ui/react"], ["FormLabel", "@chakra-ui/react"], ["FormErrorMessage", "@chakra-ui/react"], ["useForm", "@refinedev/react-hook-form"]];
  u && l.push(["useTranslate", "@refinedev/core"]);
  let I = o.filter((a) => (a == null ? void 0 : a.relation) && !(a != null && a.fieldable) && (a == null ? void 0 : a.resource)).filter(Boolean).map((a) => {
    var b, H;
    if (a != null && a.relation && !a.fieldable && a.resource) {
      l.push(["useSelect", "@refinedev/core"]);
      let T = f(p, a.key, a.accessor, false);
      return a.multiple && a.accessor && (T = `${f(p, a.key)}?.map((item: any) => ${f("item", void 0, a.accessor)})`), `
                const { options: ${A(a.key, "Options")} } =
                useSelect({
                    resource: "${a.resource.name}",
                    defaultValue: ${T},
                    ${xe(a)}
                    ${O(((b = a == null ? void 0 : a.resource) == null ? void 0 : b.identifier) ?? ((H = a == null ? void 0 : a.resource) == null ? void 0 : H.name), c, "getList")}
                });

                React.useEffect(() => {
                    setValue("${Q(a.key, void 0, a.accessor)}", ${p}?.${a.key}?.id);
                }, [${A(a.key, "Options")}]);
            `;
    }
  }).filter(Boolean), L = n((a) => {
    if (a.relation && a.resource) {
      l.push(["useSelect", "@refinedev/core"]), l.push(["Select", "@chakra-ui/react"]);
      let b = A(a.key, "Options");
      return x`
            <FormControl mb="3" isInvalid={!!errors?.${Q(a.key, void 0)}}>
                <FormLabel>${F({ resource: e, field: a, i18n: u, noQuotes: true })}</FormLabel>
                <Select
                    placeholder="Select ${q(a.resource.name)}"
                    {...register("${Q(a.key, void 0, a.accessor)}", {
                        required: "This field is required",
                    })}
                >
                    {${b}?.map((option) => (
                        <option value={option.value} key={option.value}>
                            {option.label}
                        </option>
                    ))}
                </Select>
                <FormErrorMessage>
                    {${f("(errors as any)", a.key, a.accessor, false)}?.message as string}
                </FormErrorMessage>
            </FormControl>
            `;
    }
  }, "renderRelationFields"), S = n((a) => {
    if (a.type === "text" || a.type === "url" || a.type === "email" || a.type === "number" || a.type === "date" || a.type === "richtext") {
      if (l.push(["Input", "@chakra-ui/react"]), a.multiple) {
        let b = Q(a.key, "${index}", a.accessor), H = f(f("(errors as any)", a.key, void 0, false) + "?.[index]", void 0, a.accessor);
        return `
                    <>
                        {${f(p, a.key)}?.map((item: any, index: number) => (
                            <FormControl key={index} mb="3" isInvalid={!!${H}}>
                                <FormLabel>${F({ resource: e, field: a, i18n: u, noQuotes: true })}</FormLabel>
                                <Input
                                    {...register(\`${b}\`, {
                                        required: "This field is required",
                                        ${a.type === "number" ? "valueAsNumber: true," : ""}
                                    })}
                                />
                                <FormErrorMessage>
                                    {${f(H, "message")} as string}
                                </FormErrorMessage>
                            </FormControl>
                        ))}
                    </>
                `;
      }
      return x`
                <FormControl mb="3" isInvalid={!!${f("(errors as any)", a.key, a.accessor, false)}}>
                    <FormLabel>${F({ resource: e, field: a, i18n: u, noQuotes: true })}</FormLabel>
                    <Input
                        ${Ie(a.key) ? "disabled" : ""}
                        ${a.type !== "date" && a.type !== "richtext" ? `type="${a.type}"` : ""}
                        {...register("${Q(a.key, void 0, a.accessor)}", {
                            required: "This field is required",
                            ${a.type === "number" ? "valueAsNumber: true," : ""}
                        })}
                    />
                    <FormErrorMessage>
                        {${f("(errors as any)", a.key, a.accessor, false)}?.message as string}
                    </FormErrorMessage>
                </FormControl>
            `;
    }
  }, "basicInputFields"), h = n((a) => {
    if (a.type === "boolean") {
      if (l.push(["Checkbox", "@chakra-ui/react"]), a.multiple) {
        let b = Q(a.key, void 0, a.accessor), H = f("(errors as any)", a.key, void 0, false) + "?.[index]";
        return `
                    <>
                        {${f(p, a.key)}?.map((item: any, index: number) => (
                            <FormControl key={index} mb="3" isInvalid={!!${H}}>
                                <FormLabel>${F({ resource: e, field: a, i18n: u, noQuotes: true })}</FormLabel>
                                <Checkbox
                                    {...register(\`${b}.\${index}\`, {
                                        required: "This field is required",
                                    })}
                                />
                                <FormErrorMessage>
                                    {${H}?.message as string}
                                </FormErrorMessage>
                            </FormControl>
                        ))}
                    </>
                `;
      }
      return x`
                <FormControl mb="3" isInvalid={!!${f("errors", a.key, a.accessor, false)}}>
                    <FormLabel>${F({ resource: e, field: a, i18n: u, noQuotes: true })}</FormLabel>
                    <Checkbox
                        {...register("${Q(a.key, void 0, a.accessor)}", {
                            required: "This field is required",
                        })}
                    />
                    <FormErrorMessage>
                        {${f("errors", a.key, a.accessor, false)}?.message as string}
                    </FormErrorMessage>
                </FormControl>
               
            `;
    }
  }, "booleanFields"), w2 = n((a) => {
    if (a.type === "date")
      return `
                {/* 
                    DatePicker component is not included in "@refinedev/chakra-ui" package.
                    To use a <DatePicker> component, you can examine the following links:
                    
                    - https://github.com/aboveyunhai/chakra-dayzed-datepicker
                    - https://github.com/wojtekmaj/react-date-picker
                */}
                ${S(a)}
                `;
  }, "dateFields"), m = o.map((a) => {
    switch (a == null ? void 0 : a.type) {
      case "text":
      case "number":
      case "email":
      case "url":
      case "richtext":
        return S(a);
      case "date":
        return w2(a);
      case "boolean":
        return h(a);
      case "relation":
        return L(a);
      default:
        return;
    }
  });
  oe(l);
  let d2 = u && "const translate = useTranslate();";
  return x`
    ${ne(l)}
    
    export const ${y}: React.FC<IResourceComponentsProps> = () => {
        ${d2}
        const {
            refineCore: { formLoading, queryResult },
            saveButtonProps,
            register,
            setValue,
            formState: { errors },
        } = useForm(
            ${i2 ? `
            { 
                refineCoreProps: {
                    resource: "${e.name}",
                    id: ${$e(s)},
                    action: "edit",
                    ${O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getOne")}
                }
            }` : O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getOne") ? `{ refineCoreProps: { ${O((e == null ? void 0 : e.identifier) ?? (e == null ? void 0 : e.name), c, "getOne")} }
                        }` : ""}
        );
    
        const ${p} = queryResult?.data?.data;
    
        ${I}

        return (
            <Edit isLoading={formLoading} saveButtonProps={saveButtonProps}>
                ${m.join("")}
            </Edit>
        );
    };
    `;
}, "renderer");
var Qe = ce({ type: "edit", additionalScope: [["@refinedev/chakra-ui", "RefineChakraUI", { Edit: Gm }], ["@refinedev/react-hook-form", "RefineReactHookForm", { useForm: C }], ["@chakra-ui/react", "ChakraUI", { FormControl, FormLabel, FormErrorMessage, Select, Input, Checkbox }]], codeViewerComponent: ie, loadingComponent: pe, errorComponent: ue, renderer: Hr });
var Yi = n(({ action: e, id: o, ...c }) => {
  let { action: i2, id: s } = N();
  switch (e ?? i2) {
    case "show":
      return import_react5.default.createElement(je, { ...c, id: o ?? s });
    case "create":
      return import_react5.default.createElement(Ke2, { ...c, id: o ?? s });
    case "edit":
      return import_react5.default.createElement(Qe, { ...c, id: o ?? s });
    default:
      return import_react5.default.createElement(Ue, { ...c, id: o ?? s });
  }
}, "ChakraUIInferencer");
export {
  Ke2 as ChakraUICreateInferencer,
  Ar as ChakraUICreateRenderer,
  Qe as ChakraUIEditInferencer,
  Hr as ChakraUIEditRenderer,
  Yi as ChakraUIInferencer,
  Ue as ChakraUIListInferencer,
  Tr2 as ChakraUIListRenderer,
  je as ChakraUIShowInferencer,
  wr as ChakraUIShowRenderer
};
/*! Bundled license information:

prism-react-renderer/prism/index.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

lodash-es/lodash.default.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@tanstack/table-core/build/lib/index.mjs:
  (**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-table/build/lib/index.mjs:
  (**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=@refinedev_inferencer_chakra-ui.js.map
